{"ast":null,"code":"/**\n * @license Angular v14.0.3\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\nimport { getDebugNode as getDebugNode$1, RendererFactory2 as RendererFactory2$1, ɵstringify, ɵReflectionCapabilities, Directive, Component, Pipe, NgModule, ɵgetInjectableDef, resolveForwardRef as resolveForwardRef$1, ɵNG_COMP_DEF, ɵRender3NgModuleRef, ApplicationInitStatus, LOCALE_ID as LOCALE_ID$1, ɵDEFAULT_LOCALE_ID, ɵsetLocaleId, ɵRender3ComponentFactory, ɵcompileComponent, ɵNG_DIR_DEF, ɵcompileDirective, ɵNG_PIPE_DEF, ɵcompilePipe, ɵNG_MOD_DEF, ɵtransitiveScopesFor, ɵpatchComponentDefWithScope, ɵNG_INJ_DEF, ɵcompileNgModuleDefs, NgZone, Compiler, COMPILER_OPTIONS, ɵNgModuleFactory, ModuleWithComponentFactories, InjectionToken as InjectionToken$1, Injector as Injector$1, InjectFlags as InjectFlags$1, ɵsetAllowDuplicateNgModuleIdsForTest, ɵresetCompiledComponents, ɵsetUnknownElementStrictMode as ɵsetUnknownElementStrictMode$1, ɵsetUnknownPropertyStrictMode as ɵsetUnknownPropertyStrictMode$1, ɵgetUnknownElementStrictMode as ɵgetUnknownElementStrictMode$1, ɵgetUnknownPropertyStrictMode as ɵgetUnknownPropertyStrictMode$1, ɵflushModuleScopingQueueAsMuchAsPossible } from '@angular/core';\nimport { __awaiter } from 'tslib';\nimport { ResourceLoader } from '@angular/compiler';\nimport { Subject, Subscription } from 'rxjs';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Wraps a test function in an asynchronous test zone. The test will automatically\n * complete when all asynchronous calls within this zone are done. Can be used\n * to wrap an {@link inject} call.\n *\n * Example:\n *\n * ```\n * it('...', waitForAsync(inject([AClass], (object) => {\n *   object.doSomething.then(() => {\n *     expect(...);\n *   })\n * });\n * ```\n *\n * @publicApi\n */\n\nfunction waitForAsync(fn) {\n  const _Zone = typeof Zone !== 'undefined' ? Zone : null;\n\n  if (!_Zone) {\n    return function () {\n      return Promise.reject('Zone is needed for the waitForAsync() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js');\n    };\n  }\n\n  const asyncTest = _Zone && _Zone[_Zone.__symbol__('asyncTest')];\n\n  if (typeof asyncTest === 'function') {\n    return asyncTest(fn);\n  }\n\n  return function () {\n    return Promise.reject('zone-testing.js is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/testing');\n  };\n}\n/**\n * @deprecated use `waitForAsync()`, (expected removal in v12)\n * @see {@link waitForAsync}\n * @publicApi\n * */\n\n\nfunction async(fn) {\n  return waitForAsync(fn);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Fixture for debugging and testing a component.\n *\n * @publicApi\n */\n\n\nclass ComponentFixture {\n  constructor(componentRef, ngZone, _autoDetect) {\n    this.componentRef = componentRef;\n    this.ngZone = ngZone;\n    this._autoDetect = _autoDetect;\n    this._isStable = true;\n    this._isDestroyed = false;\n    this._resolve = null;\n    this._promise = null;\n    this._onUnstableSubscription = null;\n    this._onStableSubscription = null;\n    this._onMicrotaskEmptySubscription = null;\n    this._onErrorSubscription = null;\n    this.changeDetectorRef = componentRef.changeDetectorRef;\n    this.elementRef = componentRef.location;\n    this.debugElement = getDebugNode$1(this.elementRef.nativeElement);\n    this.componentInstance = componentRef.instance;\n    this.nativeElement = this.elementRef.nativeElement;\n    this.componentRef = componentRef;\n    this.ngZone = ngZone;\n\n    if (ngZone) {\n      // Create subscriptions outside the NgZone so that the callbacks run oustide\n      // of NgZone.\n      ngZone.runOutsideAngular(() => {\n        this._onUnstableSubscription = ngZone.onUnstable.subscribe({\n          next: () => {\n            this._isStable = false;\n          }\n        });\n        this._onMicrotaskEmptySubscription = ngZone.onMicrotaskEmpty.subscribe({\n          next: () => {\n            if (this._autoDetect) {\n              // Do a change detection run with checkNoChanges set to true to check\n              // there are no changes on the second run.\n              this.detectChanges(true);\n            }\n          }\n        });\n        this._onStableSubscription = ngZone.onStable.subscribe({\n          next: () => {\n            this._isStable = true; // Check whether there is a pending whenStable() completer to resolve.\n\n            if (this._promise !== null) {\n              // If so check whether there are no pending macrotasks before resolving.\n              // Do this check in the next tick so that ngZone gets a chance to update the state of\n              // pending macrotasks.\n              scheduleMicroTask(() => {\n                if (!ngZone.hasPendingMacrotasks) {\n                  if (this._promise !== null) {\n                    this._resolve(true);\n\n                    this._resolve = null;\n                    this._promise = null;\n                  }\n                }\n              });\n            }\n          }\n        });\n        this._onErrorSubscription = ngZone.onError.subscribe({\n          next: error => {\n            throw error;\n          }\n        });\n      });\n    }\n  }\n\n  _tick(checkNoChanges) {\n    this.changeDetectorRef.detectChanges();\n\n    if (checkNoChanges) {\n      this.checkNoChanges();\n    }\n  }\n  /**\n   * Trigger a change detection cycle for the component.\n   */\n\n\n  detectChanges(checkNoChanges = true) {\n    if (this.ngZone != null) {\n      // Run the change detection inside the NgZone so that any async tasks as part of the change\n      // detection are captured by the zone and can be waited for in isStable.\n      this.ngZone.run(() => {\n        this._tick(checkNoChanges);\n      });\n    } else {\n      // Running without zone. Just do the change detection.\n      this._tick(checkNoChanges);\n    }\n  }\n  /**\n   * Do a change detection run to make sure there were no changes.\n   */\n\n\n  checkNoChanges() {\n    this.changeDetectorRef.checkNoChanges();\n  }\n  /**\n   * Set whether the fixture should autodetect changes.\n   *\n   * Also runs detectChanges once so that any existing change is detected.\n   */\n\n\n  autoDetectChanges(autoDetect = true) {\n    if (this.ngZone == null) {\n      throw new Error('Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set');\n    }\n\n    this._autoDetect = autoDetect;\n    this.detectChanges();\n  }\n  /**\n   * Return whether the fixture is currently stable or has async tasks that have not been completed\n   * yet.\n   */\n\n\n  isStable() {\n    return this._isStable && !this.ngZone.hasPendingMacrotasks;\n  }\n  /**\n   * Get a promise that resolves when the fixture is stable.\n   *\n   * This can be used to resume testing after events have triggered asynchronous activity or\n   * asynchronous change detection.\n   */\n\n\n  whenStable() {\n    if (this.isStable()) {\n      return Promise.resolve(false);\n    } else if (this._promise !== null) {\n      return this._promise;\n    } else {\n      this._promise = new Promise(res => {\n        this._resolve = res;\n      });\n      return this._promise;\n    }\n  }\n\n  _getRenderer() {\n    if (this._renderer === undefined) {\n      this._renderer = this.componentRef.injector.get(RendererFactory2$1, null);\n    }\n\n    return this._renderer;\n  }\n  /**\n   * Get a promise that resolves when the ui state is stable following animations.\n   */\n\n\n  whenRenderingDone() {\n    const renderer = this._getRenderer();\n\n    if (renderer && renderer.whenRenderingDone) {\n      return renderer.whenRenderingDone();\n    }\n\n    return this.whenStable();\n  }\n  /**\n   * Trigger component destruction.\n   */\n\n\n  destroy() {\n    if (!this._isDestroyed) {\n      this.componentRef.destroy();\n\n      if (this._onUnstableSubscription != null) {\n        this._onUnstableSubscription.unsubscribe();\n\n        this._onUnstableSubscription = null;\n      }\n\n      if (this._onStableSubscription != null) {\n        this._onStableSubscription.unsubscribe();\n\n        this._onStableSubscription = null;\n      }\n\n      if (this._onMicrotaskEmptySubscription != null) {\n        this._onMicrotaskEmptySubscription.unsubscribe();\n\n        this._onMicrotaskEmptySubscription = null;\n      }\n\n      if (this._onErrorSubscription != null) {\n        this._onErrorSubscription.unsubscribe();\n\n        this._onErrorSubscription = null;\n      }\n\n      this._isDestroyed = true;\n    }\n  }\n\n}\n\nfunction scheduleMicroTask(fn) {\n  Zone.current.scheduleMicroTask('scheduleMicrotask', fn);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nconst _Zone = typeof Zone !== 'undefined' ? Zone : null;\n\nconst fakeAsyncTestModule = _Zone && _Zone[_Zone.__symbol__('fakeAsyncTest')];\n\nconst fakeAsyncTestModuleNotLoadedErrorMessage = `zone-testing.js is needed for the fakeAsync() test helper but could not be found.\n        Please make sure that your environment includes zone.js/testing`;\n/**\n * Clears out the shared fake async zone for a test.\n * To be called in a global `beforeEach`.\n *\n * @publicApi\n */\n\nfunction resetFakeAsyncZone() {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.resetFakeAsyncZone();\n  }\n\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Wraps a function to be executed in the `fakeAsync` zone:\n * - Microtasks are manually executed by calling `flushMicrotasks()`.\n * - Timers are synchronous; `tick()` simulates the asynchronous passage of time.\n *\n * If there are any pending timers at the end of the function, an exception is thrown.\n *\n * Can be used to wrap `inject()` calls.\n *\n * @param fn The function that you want to wrap in the `fakeAysnc` zone.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n *\n * @returns The function wrapped to be executed in the `fakeAsync` zone.\n * Any arguments passed when calling this returned function will be passed through to the `fn`\n * function in the parameters when it is called.\n *\n * @publicApi\n */\n\n\nfunction fakeAsync(fn) {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.fakeAsync(fn);\n  }\n\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the `fakeAsync` zone.\n *\n * The microtasks queue is drained at the very start of this function and after any timer callback\n * has been executed.\n *\n * @param millis The number of milliseconds to advance the virtual timer.\n * @param tickOptions The options to pass to the `tick()` function.\n *\n * @usageNotes\n *\n * The `tick()` option is a flag called `processNewMacroTasksSynchronously`,\n * which determines whether or not to invoke new macroTasks.\n *\n * If you provide a `tickOptions` object, but do not specify a\n * `processNewMacroTasksSynchronously` property (`tick(100, {})`),\n * then `processNewMacroTasksSynchronously` defaults to true.\n *\n * If you omit the `tickOptions` parameter (`tick(100))`), then\n * `tickOptions` defaults to `{processNewMacroTasksSynchronously: true}`.\n *\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * The following example includes a nested timeout (new macroTask), and\n * the `tickOptions` parameter is allowed to default. In this case,\n * `processNewMacroTasksSynchronously` defaults to true, and the nested\n * function is executed on each tick.\n *\n * ```\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick();\n *   expect(nestedTimeoutInvoked).toBe(true);\n * }));\n * ```\n *\n * In the following case, `processNewMacroTasksSynchronously` is explicitly\n * set to false, so the nested timeout function is not invoked.\n *\n * ```\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick(0, {processNewMacroTasksSynchronously: false});\n *   expect(nestedTimeoutInvoked).toBe(false);\n * }));\n * ```\n *\n *\n * @publicApi\n */\n\n\nfunction tick$1(millis = 0, tickOptions = {\n  processNewMacroTasksSynchronously: true\n}) {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.tick(millis, tickOptions);\n  }\n\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Flushes any pending microtasks and simulates the asynchronous passage of time for the timers in\n * the `fakeAsync` zone by\n * draining the macrotask queue until it is empty.\n *\n * @param maxTurns The maximum number of times the scheduler attempts to clear its queue before\n *     throwing an error.\n * @returns The simulated time elapsed, in milliseconds.\n *\n * @publicApi\n */\n\n\nfunction flush(maxTurns) {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.flush(maxTurns);\n  }\n\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Discard all remaining periodic tasks.\n *\n * @publicApi\n */\n\n\nfunction discardPeriodicTasks() {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.discardPeriodicTasks();\n  }\n\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Flush any pending microtasks.\n *\n * @publicApi\n */\n\n\nfunction flushMicrotasks() {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.flushMicrotasks();\n  }\n\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Used to resolve resource URLs on `@Component` when used with JIT compilation.\n *\n * Example:\n * ```\n * @Component({\n *   selector: 'my-comp',\n *   templateUrl: 'my-comp.html', // This requires asynchronous resolution\n * })\n * class MyComponent{\n * }\n *\n * // Calling `renderComponent` will fail because `renderComponent` is a synchronous process\n * // and `MyComponent`'s `@Component.templateUrl` needs to be resolved asynchronously.\n *\n * // Calling `resolveComponentResources()` will resolve `@Component.templateUrl` into\n * // `@Component.template`, which allows `renderComponent` to proceed in a synchronous manner.\n *\n * // Use browser's `fetch()` function as the default resource resolution strategy.\n * resolveComponentResources(fetch).then(() => {\n *   // After resolution all URLs have been converted into `template` strings.\n *   renderComponent(MyComponent);\n * });\n *\n * ```\n *\n * NOTE: In AOT the resolution happens during compilation, and so there should be no need\n * to call this method outside JIT mode.\n *\n * @param resourceResolver a function which is responsible for returning a `Promise` to the\n * contents of the resolved URL. Browser's `fetch()` method is a good default implementation.\n */\n\n\nfunction resolveComponentResources(resourceResolver) {\n  // Store all promises which are fetching the resources.\n  const componentResolved = []; // Cache so that we don't fetch the same resource more than once.\n\n  const urlMap = new Map();\n\n  function cachedResourceResolve(url) {\n    let promise = urlMap.get(url);\n\n    if (!promise) {\n      const resp = resourceResolver(url);\n      urlMap.set(url, promise = resp.then(unwrapResponse));\n    }\n\n    return promise;\n  }\n\n  componentResourceResolutionQueue.forEach((component, type) => {\n    const promises = [];\n\n    if (component.templateUrl) {\n      promises.push(cachedResourceResolve(component.templateUrl).then(template => {\n        component.template = template;\n      }));\n    }\n\n    const styleUrls = component.styleUrls;\n    const styles = component.styles || (component.styles = []);\n    const styleOffset = component.styles.length;\n    styleUrls && styleUrls.forEach((styleUrl, index) => {\n      styles.push(''); // pre-allocate array.\n\n      promises.push(cachedResourceResolve(styleUrl).then(style => {\n        styles[styleOffset + index] = style;\n        styleUrls.splice(styleUrls.indexOf(styleUrl), 1);\n\n        if (styleUrls.length == 0) {\n          component.styleUrls = undefined;\n        }\n      }));\n    });\n    const fullyResolved = Promise.all(promises).then(() => componentDefResolved(type));\n    componentResolved.push(fullyResolved);\n  });\n  clearResolutionOfComponentResourcesQueue();\n  return Promise.all(componentResolved).then(() => undefined);\n}\n\nlet componentResourceResolutionQueue = new Map(); // Track when existing ɵcmp for a Type is waiting on resources.\n\nconst componentDefPendingResolution = new Set();\n\nfunction maybeQueueResolutionOfComponentResources(type, metadata) {\n  if (componentNeedsResolution(metadata)) {\n    componentResourceResolutionQueue.set(type, metadata);\n    componentDefPendingResolution.add(type);\n  }\n}\n\nfunction isComponentDefPendingResolution(type) {\n  return componentDefPendingResolution.has(type);\n}\n\nfunction componentNeedsResolution(component) {\n  return !!(component.templateUrl && !component.hasOwnProperty('template') || component.styleUrls && component.styleUrls.length);\n}\n\nfunction clearResolutionOfComponentResourcesQueue() {\n  const old = componentResourceResolutionQueue;\n  componentResourceResolutionQueue = new Map();\n  return old;\n}\n\nfunction restoreComponentResolutionQueue(queue) {\n  componentDefPendingResolution.clear();\n  queue.forEach((_, type) => componentDefPendingResolution.add(type));\n  componentResourceResolutionQueue = queue;\n}\n\nfunction isComponentResourceResolutionQueueEmpty() {\n  return componentResourceResolutionQueue.size === 0;\n}\n\nfunction unwrapResponse(response) {\n  return typeof response == 'string' ? response : response.text();\n}\n\nfunction componentDefResolved(type) {\n  componentDefPendingResolution.delete(type);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Always use __globalThis if available, which is the spec-defined global variable across all\n// environments, then fallback to __global first, because in Node tests both __global and\n// __window may be defined and _global should be __global in that case. Note: Typeof/Instanceof\n// checks are considered side-effects in Terser. We explicitly mark this as side-effect free:\n// https://github.com/terser/terser/issues/250.\n\n\nconst _global$1 = /* @__PURE__ */(() => typeof globalThis !== 'undefined' && globalThis || typeof global !== 'undefined' && global || typeof window !== 'undefined' && window || typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope && self)();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar FactoryTarget;\n\n(function (FactoryTarget) {\n  FactoryTarget[FactoryTarget[\"Directive\"] = 0] = \"Directive\";\n  FactoryTarget[FactoryTarget[\"Component\"] = 1] = \"Component\";\n  FactoryTarget[FactoryTarget[\"Injectable\"] = 2] = \"Injectable\";\n  FactoryTarget[FactoryTarget[\"Pipe\"] = 3] = \"Pipe\";\n  FactoryTarget[FactoryTarget[\"NgModule\"] = 4] = \"NgModule\";\n})(FactoryTarget || (FactoryTarget = {}));\n\nvar R3TemplateDependencyKind;\n\n(function (R3TemplateDependencyKind) {\n  R3TemplateDependencyKind[R3TemplateDependencyKind[\"Directive\"] = 0] = \"Directive\";\n  R3TemplateDependencyKind[R3TemplateDependencyKind[\"Pipe\"] = 1] = \"Pipe\";\n  R3TemplateDependencyKind[R3TemplateDependencyKind[\"NgModule\"] = 2] = \"NgModule\";\n})(R3TemplateDependencyKind || (R3TemplateDependencyKind = {}));\n\nvar ViewEncapsulation$1;\n\n(function (ViewEncapsulation) {\n  ViewEncapsulation[ViewEncapsulation[\"Emulated\"] = 0] = \"Emulated\"; // Historically the 1 value was for `Native` encapsulation which has been removed as of v11.\n\n  ViewEncapsulation[ViewEncapsulation[\"None\"] = 2] = \"None\";\n  ViewEncapsulation[ViewEncapsulation[\"ShadowDom\"] = 3] = \"ShadowDom\";\n})(ViewEncapsulation$1 || (ViewEncapsulation$1 = {}));\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction getCompilerFacade(request) {\n  const globalNg = _global$1['ng'];\n\n  if (globalNg && globalNg.ɵcompilerFacade) {\n    return globalNg.ɵcompilerFacade;\n  }\n\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    // Log the type as an error so that a developer can easily navigate to the type from the\n    // console.\n    console.error(`JIT compilation failed for ${request.kind}`, request.type);\n    let message = `The ${request.kind} '${request.type.name}' needs to be compiled using the JIT compiler, but '@angular/compiler' is not available.\\n\\n`;\n\n    if (request.usage === 1\n    /* JitCompilerUsage.PartialDeclaration */\n    ) {\n      message += `The ${request.kind} is part of a library that has been partially compiled.\\n`;\n      message += `However, the Angular Linker has not processed the library such that JIT compilation is used as fallback.\\n`;\n      message += '\\n';\n      message += `Ideally, the library is processed using the Angular Linker to become fully AOT compiled.\\n`;\n    } else {\n      message += `JIT compilation is discouraged for production use-cases! Consider using AOT mode instead.\\n`;\n    }\n\n    message += `Alternatively, the JIT compiler should be loaded by bootstrapping using '@angular/platform-browser-dynamic' or '@angular/platform-server',\\n`;\n    message += `or manually provide the compiler with 'import \"@angular/compiler\";' before bootstrapping.`;\n    throw new Error(message);\n  } else {\n    throw new Error('JIT compiler unavailable');\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction getClosureSafeProperty(objWithPropertyToExtract) {\n  for (let key in objWithPropertyToExtract) {\n    if (objWithPropertyToExtract[key] === getClosureSafeProperty) {\n      return key;\n    }\n  }\n\n  throw Error('Could not find renamed property on target object.');\n}\n/**\n * Sets properties on a target object from a source object, but only if\n * the property doesn't already exist on the target object.\n * @param target The target to set properties on\n * @param source The source of the property keys and values to set\n */\n\n\nfunction fillProperties(target, source) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction stringify(token) {\n  if (typeof token === 'string') {\n    return token;\n  }\n\n  if (Array.isArray(token)) {\n    return '[' + token.map(stringify).join(', ') + ']';\n  }\n\n  if (token == null) {\n    return '' + token;\n  }\n\n  if (token.overriddenName) {\n    return `${token.overriddenName}`;\n  }\n\n  if (token.name) {\n    return `${token.name}`;\n  }\n\n  const res = token.toString();\n\n  if (res == null) {\n    return '' + res;\n  }\n\n  const newLineIndex = res.indexOf('\\n');\n  return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n}\n/**\n * Concatenates two strings with separator, allocating new strings only when necessary.\n *\n * @param before before string.\n * @param separator separator string.\n * @param after after string.\n * @returns concatenated string.\n */\n\n\nfunction concatStringsWithSpace(before, after) {\n  return before == null || before === '' ? after === null ? '' : after : after == null || after === '' ? before : before + ' ' + after;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nconst __forward_ref__ = getClosureSafeProperty({\n  __forward_ref__: getClosureSafeProperty\n});\n/**\n * Allows to refer to references which are not yet defined.\n *\n * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of\n * DI is declared, but not yet defined. It is also used when the `token` which we use when creating\n * a query is not yet defined.\n *\n * @usageNotes\n * ### Example\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}\n * @publicApi\n */\n\n\nfunction forwardRef(forwardRefFn) {\n  forwardRefFn.__forward_ref__ = forwardRef;\n\n  forwardRefFn.toString = function () {\n    return stringify(this());\n  };\n\n  return forwardRefFn;\n}\n/**\n * Lazily retrieves the reference value from a forwardRef.\n *\n * Acts as the identity function when given a non-forward-ref value.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}\n *\n * @see `forwardRef`\n * @publicApi\n */\n\n\nfunction resolveForwardRef(type) {\n  return isForwardRef(type) ? type() : type;\n}\n/** Checks whether a function is wrapped by a `forwardRef`. */\n\n\nfunction isForwardRef(fn) {\n  return typeof fn === 'function' && fn.hasOwnProperty(__forward_ref__) && fn.__forward_ref__ === forwardRef;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Construct an injectable definition which defines how a token will be constructed by the DI\n * system, and in which injectors (if any) it will be available.\n *\n * This should be assigned to a static `ɵprov` field on a type, which will then be an\n * `InjectableType`.\n *\n * Options:\n * * `providedIn` determines which injectors will include the injectable, by either associating it\n *   with an `@NgModule` or other `InjectorType`, or by specifying that this injectable should be\n *   provided in the `'root'` injector, which will be the application-level injector in most apps.\n * * `factory` gives the zero argument function which will create an instance of the injectable.\n *   The factory can call `inject` to access the `Injector` and request injection of dependencies.\n *\n * @codeGenApi\n * @publicApi This instruction has been emitted by ViewEngine for some time and is deployed to npm.\n */\n\n\nfunction ɵɵdefineInjectable(opts) {\n  return {\n    token: opts.token,\n    providedIn: opts.providedIn || null,\n    factory: opts.factory,\n    value: undefined\n  };\n}\n/**\n * @deprecated in v8, delete after v10. This API should be used only by generated code, and that\n * code should now use ɵɵdefineInjectable instead.\n * @publicApi\n */\n\n\nconst defineInjectable = ɵɵdefineInjectable;\n/**\n * Construct an `InjectorDef` which configures an injector.\n *\n * This should be assigned to a static injector def (`ɵinj`) field on a type, which will then be an\n * `InjectorType`.\n *\n * Options:\n *\n * * `providers`: an optional array of providers to add to the injector. Each provider must\n *   either have a factory or point to a type which has a `ɵprov` static property (the\n *   type must be an `InjectableType`).\n * * `imports`: an optional array of imports of other `InjectorType`s or `InjectorTypeWithModule`s\n *   whose providers will also be added to the injector. Locally provided types will override\n *   providers from imports.\n *\n * @codeGenApi\n */\n\nfunction ɵɵdefineInjector(options) {\n  return {\n    providers: options.providers || [],\n    imports: options.imports || []\n  };\n}\n/**\n * Read the injectable def (`ɵprov`) for `type` in a way which is immune to accidentally reading\n * inherited value.\n *\n * @param type A type which may have its own (non-inherited) `ɵprov`.\n */\n\n\nfunction getInjectableDef(type) {\n  return getOwnDefinition(type, NG_PROV_DEF) || getOwnDefinition(type, NG_INJECTABLE_DEF);\n}\n/**\n * Return definition only if it is defined directly on `type` and is not inherited from a base\n * class of `type`.\n */\n\n\nfunction getOwnDefinition(type, field) {\n  return type.hasOwnProperty(field) ? type[field] : null;\n}\n/**\n * Read the injectable def (`ɵprov`) for `type` or read the `ɵprov` from one of its ancestors.\n *\n * @param type A type which may have `ɵprov`, via inheritance.\n *\n * @deprecated Will be removed in a future version of Angular, where an error will occur in the\n *     scenario if we find the `ɵprov` on an ancestor only.\n */\n\n\nfunction getInheritedInjectableDef(type) {\n  const def = type && (type[NG_PROV_DEF] || type[NG_INJECTABLE_DEF]);\n\n  if (def) {\n    const typeName = getTypeName(type); // TODO(FW-1307): Re-add ngDevMode when closure can handle it\n    // ngDevMode &&\n\n    console.warn(`DEPRECATED: DI is instantiating a token \"${typeName}\" that inherits its @Injectable decorator but does not provide one itself.\\n` + `This will become an error in a future version of Angular. Please add @Injectable() to the \"${typeName}\" class.`);\n    return def;\n  } else {\n    return null;\n  }\n}\n/** Gets the name of a type, accounting for some cross-browser differences. */\n\n\nfunction getTypeName(type) {\n  // `Function.prototype.name` behaves differently between IE and other browsers. In most browsers\n  // it'll always return the name of the function itself, no matter how many other functions it\n  // inherits from. On IE the function doesn't have its own `name` property, but it takes it from\n  // the lowest level in the prototype chain. E.g. if we have `class Foo extends Parent` most\n  // browsers will evaluate `Foo.name` to `Foo` while IE will return `Parent`. We work around\n  // the issue by converting the function to a string and parsing its name out that way via a regex.\n  if (type.hasOwnProperty('name')) {\n    return type.name;\n  }\n\n  const match = ('' + type).match(/^function\\s*([^\\s(]+)/);\n  return match === null ? '' : match[1];\n}\n/**\n * Read the injector def type in a way which is immune to accidentally reading inherited value.\n *\n * @param type type which may have an injector def (`ɵinj`)\n */\n\n\nfunction getInjectorDef(type) {\n  return type && (type.hasOwnProperty(NG_INJ_DEF) || type.hasOwnProperty(NG_INJECTOR_DEF)) ? type[NG_INJ_DEF] : null;\n}\n\nconst NG_PROV_DEF = getClosureSafeProperty({\n  ɵprov: getClosureSafeProperty\n});\nconst NG_INJ_DEF = getClosureSafeProperty({\n  ɵinj: getClosureSafeProperty\n}); // We need to keep these around so we can read off old defs if new defs are unavailable\n\nconst NG_INJECTABLE_DEF = getClosureSafeProperty({\n  ngInjectableDef: getClosureSafeProperty\n});\nconst NG_INJECTOR_DEF = getClosureSafeProperty({\n  ngInjectorDef: getClosureSafeProperty\n});\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @description\n *\n * Represents a type that a Component or other object is instances of.\n *\n * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is represented by\n * the `MyCustomComponent` constructor function.\n *\n * @publicApi\n */\n\nconst Type = Function;\n\nfunction isType(v) {\n  return typeof v === 'function';\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction assertNumber(actual, msg) {\n  if (!(typeof actual === 'number')) {\n    throwError(msg, typeof actual, 'number', '===');\n  }\n}\n\nfunction assertNumberInRange(actual, minInclusive, maxInclusive) {\n  assertNumber(actual, 'Expected a number');\n  assertLessThanOrEqual(actual, maxInclusive, 'Expected number to be less than or equal to');\n  assertGreaterThanOrEqual(actual, minInclusive, 'Expected number to be greater than or equal to');\n}\n\nfunction assertString(actual, msg) {\n  if (!(typeof actual === 'string')) {\n    throwError(msg, actual === null ? 'null' : typeof actual, 'string', '===');\n  }\n}\n\nfunction assertFunction(actual, msg) {\n  if (!(typeof actual === 'function')) {\n    throwError(msg, actual === null ? 'null' : typeof actual, 'function', '===');\n  }\n}\n\nfunction assertEqual(actual, expected, msg) {\n  if (!(actual == expected)) {\n    throwError(msg, actual, expected, '==');\n  }\n}\n\nfunction assertNotEqual(actual, expected, msg) {\n  if (!(actual != expected)) {\n    throwError(msg, actual, expected, '!=');\n  }\n}\n\nfunction assertSame(actual, expected, msg) {\n  if (!(actual === expected)) {\n    throwError(msg, actual, expected, '===');\n  }\n}\n\nfunction assertNotSame(actual, expected, msg) {\n  if (!(actual !== expected)) {\n    throwError(msg, actual, expected, '!==');\n  }\n}\n\nfunction assertLessThan(actual, expected, msg) {\n  if (!(actual < expected)) {\n    throwError(msg, actual, expected, '<');\n  }\n}\n\nfunction assertLessThanOrEqual(actual, expected, msg) {\n  if (!(actual <= expected)) {\n    throwError(msg, actual, expected, '<=');\n  }\n}\n\nfunction assertGreaterThan(actual, expected, msg) {\n  if (!(actual > expected)) {\n    throwError(msg, actual, expected, '>');\n  }\n}\n\nfunction assertGreaterThanOrEqual(actual, expected, msg) {\n  if (!(actual >= expected)) {\n    throwError(msg, actual, expected, '>=');\n  }\n}\n\nfunction assertNotDefined(actual, msg) {\n  if (actual != null) {\n    throwError(msg, actual, null, '==');\n  }\n}\n\nfunction assertDefined(actual, msg) {\n  if (actual == null) {\n    throwError(msg, actual, null, '!=');\n  }\n}\n\nfunction throwError(msg, actual, expected, comparison) {\n  throw new Error(`ASSERTION ERROR: ${msg}` + (comparison == null ? '' : ` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`));\n}\n\nfunction assertDomNode(node) {\n  // If we're in a worker, `Node` will not be defined.\n  if (!(typeof Node !== 'undefined' && node instanceof Node) && !(typeof node === 'object' && node != null && node.constructor.name === 'WebWorkerRenderNode')) {\n    throwError(`The provided value must be an instance of a DOM Node but got ${stringify(node)}`);\n  }\n}\n\nfunction assertIndexInRange(arr, index) {\n  assertDefined(arr, 'Array must be defined.');\n  const maxLen = arr.length;\n\n  if (index < 0 || index >= maxLen) {\n    throwError(`Index expected to be less than ${maxLen} but got ${index}`);\n  }\n}\n\nfunction assertOneOf(value, ...validValues) {\n  if (validValues.indexOf(value) !== -1) return true;\n  throwError(`Expected value to be one of ${JSON.stringify(validValues)} but was ${JSON.stringify(value)}.`);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Equivalent to ES6 spread, add each item to an array.\n *\n * @param items The items to add\n * @param arr The array to which you want to add the items\n */\n\n\nfunction addAllToArray(items, arr) {\n  for (let i = 0; i < items.length; i++) {\n    arr.push(items[i]);\n  }\n}\n/**\n * Determines if the contents of two arrays is identical\n *\n * @param a first array\n * @param b second array\n * @param identityAccessor Optional function for extracting stable object identity from a value in\n *     the array.\n */\n\n\nfunction arrayEquals(a, b, identityAccessor) {\n  if (a.length !== b.length) return false;\n\n  for (let i = 0; i < a.length; i++) {\n    let valueA = a[i];\n    let valueB = b[i];\n\n    if (identityAccessor) {\n      valueA = identityAccessor(valueA);\n      valueB = identityAccessor(valueB);\n    }\n\n    if (valueB !== valueA) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Flattens an array.\n */\n\n\nfunction flatten$1(list, dst) {\n  if (dst === undefined) dst = list;\n\n  for (let i = 0; i < list.length; i++) {\n    let item = list[i];\n\n    if (Array.isArray(item)) {\n      // we need to inline it.\n      if (dst === list) {\n        // Our assumption that the list was already flat was wrong and\n        // we need to clone flat since we need to write to it.\n        dst = list.slice(0, i);\n      }\n\n      flatten$1(item, dst);\n    } else if (dst !== list) {\n      dst.push(item);\n    }\n  }\n\n  return dst;\n}\n\nfunction deepForEach(input, fn) {\n  input.forEach(value => Array.isArray(value) ? deepForEach(value, fn) : fn(value));\n}\n\nfunction addToArray(arr, index, value) {\n  // perf: array.push is faster than array.splice!\n  if (index >= arr.length) {\n    arr.push(value);\n  } else {\n    arr.splice(index, 0, value);\n  }\n}\n\nfunction removeFromArray(arr, index) {\n  // perf: array.pop is faster than array.splice!\n  if (index >= arr.length - 1) {\n    return arr.pop();\n  } else {\n    return arr.splice(index, 1)[0];\n  }\n}\n\nfunction newArray(size, value) {\n  const list = [];\n\n  for (let i = 0; i < size; i++) {\n    list.push(value);\n  }\n\n  return list;\n}\n/**\n * Remove item from array (Same as `Array.splice()` but faster.)\n *\n * `Array.splice()` is not as fast because it has to allocate an array for the elements which were\n * removed. This causes memory pressure and slows down code when most of the time we don't\n * care about the deleted items array.\n *\n * https://jsperf.com/fast-array-splice (About 20x faster)\n *\n * @param array Array to splice\n * @param index Index of element in array to remove.\n * @param count Number of items to remove.\n */\n\n\nfunction arraySplice(array, index, count) {\n  const length = array.length - count;\n\n  while (index < length) {\n    array[index] = array[index + count];\n    index++;\n  }\n\n  while (count--) {\n    array.pop(); // shrink the array\n  }\n}\n/**\n * Same as `Array.splice(index, 0, value)` but faster.\n *\n * `Array.splice()` is not fast because it has to allocate an array for the elements which were\n * removed. This causes memory pressure and slows down code when most of the time we don't\n * care about the deleted items array.\n *\n * @param array Array to splice.\n * @param index Index in array where the `value` should be added.\n * @param value Value to add to array.\n */\n\n\nfunction arrayInsert(array, index, value) {\n  ngDevMode && assertLessThanOrEqual(index, array.length, 'Can\\'t insert past array end.');\n  let end = array.length;\n\n  while (end > index) {\n    const previousEnd = end - 1;\n    array[end] = array[previousEnd];\n    end = previousEnd;\n  }\n\n  array[index] = value;\n}\n/**\n * Same as `Array.splice2(index, 0, value1, value2)` but faster.\n *\n * `Array.splice()` is not fast because it has to allocate an array for the elements which were\n * removed. This causes memory pressure and slows down code when most of the time we don't\n * care about the deleted items array.\n *\n * @param array Array to splice.\n * @param index Index in array where the `value` should be added.\n * @param value1 Value to add to array.\n * @param value2 Value to add to array.\n */\n\n\nfunction arrayInsert2(array, index, value1, value2) {\n  ngDevMode && assertLessThanOrEqual(index, array.length, 'Can\\'t insert past array end.');\n  let end = array.length;\n\n  if (end == index) {\n    // inserting at the end.\n    array.push(value1, value2);\n  } else if (end === 1) {\n    // corner case when we have less items in array than we have items to insert.\n    array.push(value2, array[0]);\n    array[0] = value1;\n  } else {\n    end--;\n    array.push(array[end - 1], array[end]);\n\n    while (end > index) {\n      const previousEnd = end - 2;\n      array[end] = array[previousEnd];\n      end--;\n    }\n\n    array[index] = value1;\n    array[index + 1] = value2;\n  }\n}\n/**\n * Insert a `value` into an `array` so that the array remains sorted.\n *\n * NOTE:\n * - Duplicates are not allowed, and are ignored.\n * - This uses binary search algorithm for fast inserts.\n *\n * @param array A sorted array to insert into.\n * @param value The value to insert.\n * @returns index of the inserted value.\n */\n\n\nfunction arrayInsertSorted(array, value) {\n  let index = arrayIndexOfSorted(array, value);\n\n  if (index < 0) {\n    // if we did not find it insert it.\n    index = ~index;\n    arrayInsert(array, index, value);\n  }\n\n  return index;\n}\n/**\n * Remove `value` from a sorted `array`.\n *\n * NOTE:\n * - This uses binary search algorithm for fast removals.\n *\n * @param array A sorted array to remove from.\n * @param value The value to remove.\n * @returns index of the removed value.\n *   - positive index if value found and removed.\n *   - negative index if value not found. (`~index` to get the value where it should have been\n *     inserted)\n */\n\n\nfunction arrayRemoveSorted(array, value) {\n  const index = arrayIndexOfSorted(array, value);\n\n  if (index >= 0) {\n    arraySplice(array, index, 1);\n  }\n\n  return index;\n}\n/**\n * Get an index of an `value` in a sorted `array`.\n *\n * NOTE:\n * - This uses binary search algorithm for fast removals.\n *\n * @param array A sorted array to binary search.\n * @param value The value to look for.\n * @returns index of the value.\n *   - positive index if value found.\n *   - negative index if value not found. (`~index` to get the value where it should have been\n *     located)\n */\n\n\nfunction arrayIndexOfSorted(array, value) {\n  return _arrayIndexOfSorted(array, value, 0);\n}\n/**\n * Set a `value` for a `key`.\n *\n * @param keyValueArray to modify.\n * @param key The key to locate or create.\n * @param value The value to set for a `key`.\n * @returns index (always even) of where the value vas set.\n */\n\n\nfunction keyValueArraySet(keyValueArray, key, value) {\n  let index = keyValueArrayIndexOf(keyValueArray, key);\n\n  if (index >= 0) {\n    // if we found it set it.\n    keyValueArray[index | 1] = value;\n  } else {\n    index = ~index;\n    arrayInsert2(keyValueArray, index, key, value);\n  }\n\n  return index;\n}\n/**\n * Retrieve a `value` for a `key` (on `undefined` if not found.)\n *\n * @param keyValueArray to search.\n * @param key The key to locate.\n * @return The `value` stored at the `key` location or `undefined if not found.\n */\n\n\nfunction keyValueArrayGet(keyValueArray, key) {\n  const index = keyValueArrayIndexOf(keyValueArray, key);\n\n  if (index >= 0) {\n    // if we found it retrieve it.\n    return keyValueArray[index | 1];\n  }\n\n  return undefined;\n}\n/**\n * Retrieve a `key` index value in the array or `-1` if not found.\n *\n * @param keyValueArray to search.\n * @param key The key to locate.\n * @returns index of where the key is (or should have been.)\n *   - positive (even) index if key found.\n *   - negative index if key not found. (`~index` (even) to get the index where it should have\n *     been inserted.)\n */\n\n\nfunction keyValueArrayIndexOf(keyValueArray, key) {\n  return _arrayIndexOfSorted(keyValueArray, key, 1);\n}\n/**\n * Delete a `key` (and `value`) from the `KeyValueArray`.\n *\n * @param keyValueArray to modify.\n * @param key The key to locate or delete (if exist).\n * @returns index of where the key was (or should have been.)\n *   - positive (even) index if key found and deleted.\n *   - negative index if key not found. (`~index` (even) to get the index where it should have\n *     been.)\n */\n\n\nfunction keyValueArrayDelete(keyValueArray, key) {\n  const index = keyValueArrayIndexOf(keyValueArray, key);\n\n  if (index >= 0) {\n    // if we found it remove it.\n    arraySplice(keyValueArray, index, 2);\n  }\n\n  return index;\n}\n/**\n * INTERNAL: Get an index of an `value` in a sorted `array` by grouping search by `shift`.\n *\n * NOTE:\n * - This uses binary search algorithm for fast removals.\n *\n * @param array A sorted array to binary search.\n * @param value The value to look for.\n * @param shift grouping shift.\n *   - `0` means look at every location\n *   - `1` means only look at every other (even) location (the odd locations are to be ignored as\n *         they are values.)\n * @returns index of the value.\n *   - positive index if value found.\n *   - negative index if value not found. (`~index` to get the value where it should have been\n * inserted)\n */\n\n\nfunction _arrayIndexOfSorted(array, value, shift) {\n  ngDevMode && assertEqual(Array.isArray(array), true, 'Expecting an array');\n  let start = 0;\n  let end = array.length >> shift;\n\n  while (end !== start) {\n    const middle = start + (end - start >> 1); // find the middle.\n\n    const current = array[middle << shift];\n\n    if (value === current) {\n      return middle << shift;\n    } else if (current > value) {\n      end = middle;\n    } else {\n      start = middle + 1; // We already searched middle so make it non-inclusive by adding 1\n    }\n  }\n\n  return ~(end << shift);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Convince closure compiler that the wrapped function has no side-effects.\n *\n * Closure compiler always assumes that `toString` has no side-effects. We use this quirk to\n * allow us to execute a function but have closure compiler mark the call as no-side-effects.\n * It is important that the return value for the `noSideEffects` function be assigned\n * to something which is retained otherwise the call to `noSideEffects` will be removed by closure\n * compiler.\n */\n\n\nfunction noSideEffects(fn) {\n  return {\n    toString: fn\n  }.toString();\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nconst ANNOTATIONS = '__annotations__';\nconst PARAMETERS = '__parameters__';\nconst PROP_METADATA = '__prop__metadata__';\n/**\n * @suppress {globalThis}\n */\n\nfunction makeDecorator(name, props, parentClass, additionalProcessing, typeFn) {\n  return noSideEffects(() => {\n    const metaCtor = makeMetadataCtor(props);\n\n    function DecoratorFactory(...args) {\n      if (this instanceof DecoratorFactory) {\n        metaCtor.call(this, ...args);\n        return this;\n      }\n\n      const annotationInstance = new DecoratorFactory(...args);\n      return function TypeDecorator(cls) {\n        if (typeFn) typeFn(cls, ...args); // Use of Object.defineProperty is important since it creates non-enumerable property which\n        // prevents the property is copied during subclassing.\n\n        const annotations = cls.hasOwnProperty(ANNOTATIONS) ? cls[ANNOTATIONS] : Object.defineProperty(cls, ANNOTATIONS, {\n          value: []\n        })[ANNOTATIONS];\n        annotations.push(annotationInstance);\n        if (additionalProcessing) additionalProcessing(cls);\n        return cls;\n      };\n    }\n\n    if (parentClass) {\n      DecoratorFactory.prototype = Object.create(parentClass.prototype);\n    }\n\n    DecoratorFactory.prototype.ngMetadataName = name;\n    DecoratorFactory.annotationCls = DecoratorFactory;\n    return DecoratorFactory;\n  });\n}\n\nfunction makeMetadataCtor(props) {\n  return function ctor(...args) {\n    if (props) {\n      const values = props(...args);\n\n      for (const propName in values) {\n        this[propName] = values[propName];\n      }\n    }\n  };\n}\n\nfunction makeParamDecorator(name, props, parentClass) {\n  return noSideEffects(() => {\n    const metaCtor = makeMetadataCtor(props);\n\n    function ParamDecoratorFactory(...args) {\n      if (this instanceof ParamDecoratorFactory) {\n        metaCtor.apply(this, args);\n        return this;\n      }\n\n      const annotationInstance = new ParamDecoratorFactory(...args);\n      ParamDecorator.annotation = annotationInstance;\n      return ParamDecorator;\n\n      function ParamDecorator(cls, unusedKey, index) {\n        // Use of Object.defineProperty is important since it creates non-enumerable property which\n        // prevents the property is copied during subclassing.\n        const parameters = cls.hasOwnProperty(PARAMETERS) ? cls[PARAMETERS] : Object.defineProperty(cls, PARAMETERS, {\n          value: []\n        })[PARAMETERS]; // there might be gaps if some in between parameters do not have annotations.\n        // we pad with nulls.\n\n        while (parameters.length <= index) {\n          parameters.push(null);\n        }\n\n        (parameters[index] = parameters[index] || []).push(annotationInstance);\n        return cls;\n      }\n    }\n\n    if (parentClass) {\n      ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);\n    }\n\n    ParamDecoratorFactory.prototype.ngMetadataName = name;\n    ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;\n    return ParamDecoratorFactory;\n  });\n}\n\nfunction makePropDecorator(name, props, parentClass, additionalProcessing) {\n  return noSideEffects(() => {\n    const metaCtor = makeMetadataCtor(props);\n\n    function PropDecoratorFactory(...args) {\n      if (this instanceof PropDecoratorFactory) {\n        metaCtor.apply(this, args);\n        return this;\n      }\n\n      const decoratorInstance = new PropDecoratorFactory(...args);\n\n      function PropDecorator(target, name) {\n        const constructor = target.constructor; // Use of Object.defineProperty is important because it creates a non-enumerable property\n        // which prevents the property from being copied during subclassing.\n\n        const meta = constructor.hasOwnProperty(PROP_METADATA) ? constructor[PROP_METADATA] : Object.defineProperty(constructor, PROP_METADATA, {\n          value: {}\n        })[PROP_METADATA];\n        meta[name] = meta.hasOwnProperty(name) && meta[name] || [];\n        meta[name].unshift(decoratorInstance);\n        if (additionalProcessing) additionalProcessing(target, name, ...args);\n      }\n\n      return PropDecorator;\n    }\n\n    if (parentClass) {\n      PropDecoratorFactory.prototype = Object.create(parentClass.prototype);\n    }\n\n    PropDecoratorFactory.prototype.ngMetadataName = name;\n    PropDecoratorFactory.annotationCls = PropDecoratorFactory;\n    return PropDecoratorFactory;\n  });\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/*\n * #########################\n * Attention: These Regular expressions have to hold even if the code is minified!\n * ##########################\n */\n\n/**\n * Regular expression that detects pass-through constructors for ES5 output. This Regex\n * intends to capture the common delegation pattern emitted by TypeScript and Babel. Also\n * it intends to capture the pattern where existing constructors have been downleveled from\n * ES2015 to ES5 using TypeScript w/ downlevel iteration. e.g.\n *\n * ```\n *   function MyClass() {\n *     var _this = _super.apply(this, arguments) || this;\n * ```\n *\n * downleveled to ES5 with `downlevelIteration` for TypeScript < 4.2:\n * ```\n *   function MyClass() {\n *     var _this = _super.apply(this, __spread(arguments)) || this;\n * ```\n *\n * or downleveled to ES5 with `downlevelIteration` for TypeScript >= 4.2:\n * ```\n *   function MyClass() {\n *     var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;\n * ```\n *\n * More details can be found in: https://github.com/angular/angular/issues/38453.\n */\n\n\nconst ES5_DELEGATE_CTOR = /^function\\s+\\S+\\(\\)\\s*{[\\s\\S]+\\.apply\\(this,\\s*(arguments|(?:[^()]+\\(\\[\\],)?[^()]+\\(arguments\\).*)\\)/;\n/** Regular expression that detects ES2015 classes which extend from other classes. */\n\nconst ES2015_INHERITED_CLASS = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{/;\n/**\n * Regular expression that detects ES2015 classes which extend from other classes and\n * have an explicit constructor defined.\n */\n\nconst ES2015_INHERITED_CLASS_WITH_CTOR = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{[\\s\\S]*constructor\\s*\\(/;\n/**\n * Regular expression that detects ES2015 classes which extend from other classes\n * and inherit a constructor.\n */\n\nconst ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{[\\s\\S]*constructor\\s*\\(\\)\\s*{[^}]*super\\(\\.\\.\\.arguments\\)/;\n/**\n * Determine whether a stringified type is a class which delegates its constructor\n * to its parent.\n *\n * This is not trivial since compiled code can actually contain a constructor function\n * even if the original source code did not. For instance, when the child class contains\n * an initialized instance property.\n */\n\nfunction isDelegateCtor(typeStr) {\n  return ES5_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS.test(typeStr) && !ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr);\n}\n\nclass ReflectionCapabilities {\n  constructor(reflect) {\n    this._reflect = reflect || _global$1['Reflect'];\n  }\n\n  factory(t) {\n    return (...args) => new t(...args);\n  }\n  /** @internal */\n\n\n  _zipTypesAndAnnotations(paramTypes, paramAnnotations) {\n    let result;\n\n    if (typeof paramTypes === 'undefined') {\n      result = newArray(paramAnnotations.length);\n    } else {\n      result = newArray(paramTypes.length);\n    }\n\n    for (let i = 0; i < result.length; i++) {\n      // TS outputs Object for parameters without types, while Traceur omits\n      // the annotations. For now we preserve the Traceur behavior to aid\n      // migration, but this can be revisited.\n      if (typeof paramTypes === 'undefined') {\n        result[i] = [];\n      } else if (paramTypes[i] && paramTypes[i] != Object) {\n        result[i] = [paramTypes[i]];\n      } else {\n        result[i] = [];\n      }\n\n      if (paramAnnotations && paramAnnotations[i] != null) {\n        result[i] = result[i].concat(paramAnnotations[i]);\n      }\n    }\n\n    return result;\n  }\n\n  _ownParameters(type, parentCtor) {\n    const typeStr = type.toString(); // If we have no decorators, we only have function.length as metadata.\n    // In that case, to detect whether a child class declared an own constructor or not,\n    // we need to look inside of that constructor to check whether it is\n    // just calling the parent.\n    // This also helps to work around for https://github.com/Microsoft/TypeScript/issues/12439\n    // that sets 'design:paramtypes' to []\n    // if a class inherits from another class but has no ctor declared itself.\n\n    if (isDelegateCtor(typeStr)) {\n      return null;\n    } // Prefer the direct API.\n\n\n    if (type.parameters && type.parameters !== parentCtor.parameters) {\n      return type.parameters;\n    } // API of tsickle for lowering decorators to properties on the class.\n\n\n    const tsickleCtorParams = type.ctorParameters;\n\n    if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {\n      // Newer tsickle uses a function closure\n      // Retain the non-function case for compatibility with older tsickle\n      const ctorParameters = typeof tsickleCtorParams === 'function' ? tsickleCtorParams() : tsickleCtorParams;\n      const paramTypes = ctorParameters.map(ctorParam => ctorParam && ctorParam.type);\n      const paramAnnotations = ctorParameters.map(ctorParam => ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));\n      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n    } // API for metadata created by invoking the decorators.\n\n\n    const paramAnnotations = type.hasOwnProperty(PARAMETERS) && type[PARAMETERS];\n\n    const paramTypes = this._reflect && this._reflect.getOwnMetadata && this._reflect.getOwnMetadata('design:paramtypes', type);\n\n    if (paramTypes || paramAnnotations) {\n      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n    } // If a class has no decorators, at least create metadata\n    // based on function.length.\n    // Note: We know that this is a real constructor as we checked\n    // the content of the constructor above.\n\n\n    return newArray(type.length);\n  }\n\n  parameters(type) {\n    // Note: only report metadata if we have at least one class decorator\n    // to stay in sync with the static reflector.\n    if (!isType(type)) {\n      return [];\n    }\n\n    const parentCtor = getParentCtor(type);\n\n    let parameters = this._ownParameters(type, parentCtor);\n\n    if (!parameters && parentCtor !== Object) {\n      parameters = this.parameters(parentCtor);\n    }\n\n    return parameters || [];\n  }\n\n  _ownAnnotations(typeOrFunc, parentCtor) {\n    // Prefer the direct API.\n    if (typeOrFunc.annotations && typeOrFunc.annotations !== parentCtor.annotations) {\n      let annotations = typeOrFunc.annotations;\n\n      if (typeof annotations === 'function' && annotations.annotations) {\n        annotations = annotations.annotations;\n      }\n\n      return annotations;\n    } // API of tsickle for lowering decorators to properties on the class.\n\n\n    if (typeOrFunc.decorators && typeOrFunc.decorators !== parentCtor.decorators) {\n      return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);\n    } // API for metadata created by invoking the decorators.\n\n\n    if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {\n      return typeOrFunc[ANNOTATIONS];\n    }\n\n    return null;\n  }\n\n  annotations(typeOrFunc) {\n    if (!isType(typeOrFunc)) {\n      return [];\n    }\n\n    const parentCtor = getParentCtor(typeOrFunc);\n    const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];\n    const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];\n    return parentAnnotations.concat(ownAnnotations);\n  }\n\n  _ownPropMetadata(typeOrFunc, parentCtor) {\n    // Prefer the direct API.\n    if (typeOrFunc.propMetadata && typeOrFunc.propMetadata !== parentCtor.propMetadata) {\n      let propMetadata = typeOrFunc.propMetadata;\n\n      if (typeof propMetadata === 'function' && propMetadata.propMetadata) {\n        propMetadata = propMetadata.propMetadata;\n      }\n\n      return propMetadata;\n    } // API of tsickle for lowering decorators to properties on the class.\n\n\n    if (typeOrFunc.propDecorators && typeOrFunc.propDecorators !== parentCtor.propDecorators) {\n      const propDecorators = typeOrFunc.propDecorators;\n      const propMetadata = {};\n      Object.keys(propDecorators).forEach(prop => {\n        propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);\n      });\n      return propMetadata;\n    } // API for metadata created by invoking the decorators.\n\n\n    if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {\n      return typeOrFunc[PROP_METADATA];\n    }\n\n    return null;\n  }\n\n  propMetadata(typeOrFunc) {\n    if (!isType(typeOrFunc)) {\n      return {};\n    }\n\n    const parentCtor = getParentCtor(typeOrFunc);\n    const propMetadata = {};\n\n    if (parentCtor !== Object) {\n      const parentPropMetadata = this.propMetadata(parentCtor);\n      Object.keys(parentPropMetadata).forEach(propName => {\n        propMetadata[propName] = parentPropMetadata[propName];\n      });\n    }\n\n    const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);\n\n    if (ownPropMetadata) {\n      Object.keys(ownPropMetadata).forEach(propName => {\n        const decorators = [];\n\n        if (propMetadata.hasOwnProperty(propName)) {\n          decorators.push(...propMetadata[propName]);\n        }\n\n        decorators.push(...ownPropMetadata[propName]);\n        propMetadata[propName] = decorators;\n      });\n    }\n\n    return propMetadata;\n  }\n\n  ownPropMetadata(typeOrFunc) {\n    if (!isType(typeOrFunc)) {\n      return {};\n    }\n\n    return this._ownPropMetadata(typeOrFunc, getParentCtor(typeOrFunc)) || {};\n  }\n\n  hasLifecycleHook(type, lcProperty) {\n    return type instanceof Type && lcProperty in type.prototype;\n  }\n\n}\n\nfunction convertTsickleDecoratorIntoMetadata(decoratorInvocations) {\n  if (!decoratorInvocations) {\n    return [];\n  }\n\n  return decoratorInvocations.map(decoratorInvocation => {\n    const decoratorType = decoratorInvocation.type;\n    const annotationCls = decoratorType.annotationCls;\n    const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];\n    return new annotationCls(...annotationArgs);\n  });\n}\n\nfunction getParentCtor(ctor) {\n  const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;\n  const parentCtor = parentProto ? parentProto.constructor : null; // Note: We always use `Object` as the null value\n  // to simplify checking later on.\n\n  return parentCtor || Object;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction ngDevModeResetPerfCounters() {\n  const locationString = typeof location !== 'undefined' ? location.toString() : '';\n  const newCounters = {\n    namedConstructors: locationString.indexOf('ngDevMode=namedConstructors') != -1,\n    firstCreatePass: 0,\n    tNode: 0,\n    tView: 0,\n    rendererCreateTextNode: 0,\n    rendererSetText: 0,\n    rendererCreateElement: 0,\n    rendererAddEventListener: 0,\n    rendererSetAttribute: 0,\n    rendererRemoveAttribute: 0,\n    rendererSetProperty: 0,\n    rendererSetClassName: 0,\n    rendererAddClass: 0,\n    rendererRemoveClass: 0,\n    rendererSetStyle: 0,\n    rendererRemoveStyle: 0,\n    rendererDestroy: 0,\n    rendererDestroyNode: 0,\n    rendererMoveNode: 0,\n    rendererRemoveNode: 0,\n    rendererAppendChild: 0,\n    rendererInsertBefore: 0,\n    rendererCreateComment: 0\n  }; // Make sure to refer to ngDevMode as ['ngDevMode'] for closure.\n\n  const allowNgDevModeTrue = locationString.indexOf('ngDevMode=false') === -1;\n  _global$1['ngDevMode'] = allowNgDevModeTrue && newCounters;\n  return newCounters;\n}\n/**\n * This function checks to see if the `ngDevMode` has been set. If yes,\n * then we honor it, otherwise we default to dev mode with additional checks.\n *\n * The idea is that unless we are doing production build where we explicitly\n * set `ngDevMode == false` we should be helping the developer by providing\n * as much early warning and errors as possible.\n *\n * `ɵɵdefineComponent` is guaranteed to have been called before any component template functions\n * (and thus Ivy instructions), so a single initialization there is sufficient to ensure ngDevMode\n * is defined for the entire instruction set.\n *\n * When checking `ngDevMode` on toplevel, always init it before referencing it\n * (e.g. `((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode())`), otherwise you can\n *  get a `ReferenceError` like in https://github.com/angular/angular/issues/31595.\n *\n * Details on possible values for `ngDevMode` can be found on its docstring.\n *\n * NOTE:\n * - changes to the `ngDevMode` name must be synced with `compiler-cli/src/tooling.ts`.\n */\n\n\nfunction initNgDevMode() {\n  // The below checks are to ensure that calling `initNgDevMode` multiple times does not\n  // reset the counters.\n  // If the `ngDevMode` is not an object, then it means we have not created the perf counters\n  // yet.\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    if (typeof ngDevMode !== 'object') {\n      ngDevModeResetPerfCounters();\n    }\n\n    return typeof ngDevMode !== 'undefined' && !!ngDevMode;\n  }\n\n  return false;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Base URL for the error details page.\n *\n * Keep the files below in full sync:\n *  - packages/compiler-cli/src/ngtsc/diagnostics/src/error_details_base_url.ts\n *  - packages/core/src/error_details_base_url.ts\n */\n\n\nconst ERROR_DETAILS_PAGE_BASE_URL = 'https://angular.io/errors';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Class that represents a runtime error.\n * Formats and outputs the error message in a consistent way.\n *\n * Example:\n * ```\n *  throw new RuntimeError(\n *    RuntimeErrorCode.INJECTOR_ALREADY_DESTROYED,\n *    ngDevMode && 'Injector has already been destroyed.');\n * ```\n *\n * Note: the `message` argument contains a descriptive error message as a string in development\n * mode (when the `ngDevMode` is defined). In production mode (after tree-shaking pass), the\n * `message` argument becomes `false`, thus we account for it in the typings and the runtime logic.\n */\n\nclass RuntimeError extends Error {\n  constructor(code, message) {\n    super(formatRuntimeError(code, message));\n    this.code = code;\n  }\n\n}\n/**\n * Called to format a runtime error.\n * See additional info on the `message` argument type in the `RuntimeError` class description.\n */\n\n\nfunction formatRuntimeError(code, message) {\n  // Error code might be a negative number, which is a special marker that instructs the logic to\n  // generate a link to the error details page on angular.io.\n  const fullCode = `NG0${Math.abs(code)}`;\n  let errorMessage = `${fullCode}${message ? ': ' + message.trim() : ''}`;\n\n  if (ngDevMode && code < 0) {\n    const addPeriodSeparator = !errorMessage.match(/[.,;!?]$/);\n    const separator = addPeriodSeparator ? '.' : '';\n    errorMessage = `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;\n  }\n\n  return errorMessage;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Used for stringify render output in Ivy.\n * Important! This function is very performance-sensitive and we should\n * be extra careful not to introduce megamorphic reads in it.\n * Check `core/test/render3/perf/render_stringify` for benchmarks and alternate implementations.\n */\n\n\nfunction renderStringify(value) {\n  if (typeof value === 'string') return value;\n  if (value == null) return ''; // Use `String` so that it invokes the `toString` method of the value. Note that this\n  // appears to be faster than calling `value.toString` (see `render_stringify` benchmark).\n\n  return String(value);\n}\n/**\n * Used to stringify a value so that it can be displayed in an error message.\n * Important! This function contains a megamorphic read and should only be\n * used for error messages.\n */\n\n\nfunction stringifyForError(value) {\n  if (typeof value === 'function') return value.name || value.toString();\n\n  if (typeof value === 'object' && value != null && typeof value.type === 'function') {\n    return value.type.name || value.type.toString();\n  }\n\n  return renderStringify(value);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Called when directives inject each other (creating a circular dependency) */\n\n\nfunction throwCyclicDependencyError(token, path) {\n  const depPath = path ? `. Dependency path: ${path.join(' > ')} > ${token}` : '';\n  throw new RuntimeError(-200\n  /* RuntimeErrorCode.CYCLIC_DI_DEPENDENCY */\n  , `Circular dependency in DI detected for ${token}${depPath}`);\n}\n\nfunction throwMixedMultiProviderError() {\n  throw new Error(`Cannot mix multi providers and regular providers`);\n}\n\nfunction throwInvalidProviderError(ngModuleType, providers, provider) {\n  if (ngModuleType && providers) {\n    const providerDetail = providers.map(v => v == provider ? '?' + provider + '?' : '...');\n    throw new Error(`Invalid provider for the NgModule '${stringify(ngModuleType)}' - only instances of Provider and Type are allowed, got: [${providerDetail.join(', ')}]`);\n  } else if (provider.ɵproviders) {\n    throw new RuntimeError(207\n    /* RuntimeErrorCode.PROVIDER_IN_WRONG_CONTEXT */\n    , `Invalid providers from 'importProvidersFrom' present in a non-environment injector. 'importProvidersFrom' can't be used for component providers.`);\n  } else {\n    throw new Error('Invalid provider');\n  }\n}\n/** Throws an error when a token is not found in DI. */\n\n\nfunction throwProviderNotFoundError(token, injectorName) {\n  const injectorDetails = injectorName ? ` in ${injectorName}` : '';\n  throw new RuntimeError(-201\n  /* RuntimeErrorCode.PROVIDER_NOT_FOUND */\n  , ngDevMode && `No provider for ${stringifyForError(token)} found${injectorDetails}`);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Injection flags for DI.\n *\n * @publicApi\n */\n\n\nvar InjectFlags;\n\n(function (InjectFlags) {\n  // TODO(alxhub): make this 'const' (and remove `InternalInjectFlags` enum) when ngc no longer\n  // writes exports of it into ngfactory files.\n\n  /** Check self and check parent injector if needed */\n  InjectFlags[InjectFlags[\"Default\"] = 0] = \"Default\";\n  /**\n   * Specifies that an injector should retrieve a dependency from any injector until reaching the\n   * host element of the current component. (Only used with Element Injector)\n   */\n\n  InjectFlags[InjectFlags[\"Host\"] = 1] = \"Host\";\n  /** Don't ascend to ancestors of the node requesting injection. */\n\n  InjectFlags[InjectFlags[\"Self\"] = 2] = \"Self\";\n  /** Skip the node that is requesting injection. */\n\n  InjectFlags[InjectFlags[\"SkipSelf\"] = 4] = \"SkipSelf\";\n  /** Inject `defaultValue` instead if token not found. */\n\n  InjectFlags[InjectFlags[\"Optional\"] = 8] = \"Optional\";\n})(InjectFlags || (InjectFlags = {}));\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Current implementation of inject.\n *\n * By default, it is `injectInjectorOnly`, which makes it `Injector`-only aware. It can be changed\n * to `directiveInject`, which brings in the `NodeInjector` system of ivy. It is designed this\n * way for two reasons:\n *  1. `Injector` should not depend on ivy logic.\n *  2. To maintain tree shake-ability we don't want to bring in unnecessary code.\n */\n\n\nlet _injectImplementation;\n\nfunction getInjectImplementation() {\n  return _injectImplementation;\n}\n/**\n * Sets the current inject implementation.\n */\n\n\nfunction setInjectImplementation(impl) {\n  const previous = _injectImplementation;\n  _injectImplementation = impl;\n  return previous;\n}\n/**\n * Injects `root` tokens in limp mode.\n *\n * If no injector exists, we can still inject tree-shakable providers which have `providedIn` set to\n * `\"root\"`. This is known as the limp mode injection. In such case the value is stored in the\n * injectable definition.\n */\n\n\nfunction injectRootLimpMode(token, notFoundValue, flags) {\n  const injectableDef = getInjectableDef(token);\n\n  if (injectableDef && injectableDef.providedIn == 'root') {\n    return injectableDef.value === undefined ? injectableDef.value = injectableDef.factory() : injectableDef.value;\n  }\n\n  if (flags & InjectFlags.Optional) return null;\n  if (notFoundValue !== undefined) return notFoundValue;\n  throwProviderNotFoundError(stringify(token), 'Injector');\n}\n/**\n * Assert that `_injectImplementation` is not `fn`.\n *\n * This is useful, to prevent infinite recursion.\n *\n * @param fn Function which it should not equal to\n */\n\n\nfunction assertInjectImplementationNotEqual(fn) {\n  ngDevMode && assertNotEqual(_injectImplementation, fn, 'Calling ɵɵinject would cause infinite recursion');\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nconst _THROW_IF_NOT_FOUND = {};\nconst THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n/*\n * Name of a property (that we patch onto DI decorator), which is used as an annotation of which\n * InjectFlag this decorator represents. This allows to avoid direct references to the DI decorators\n * in the code, thus making them tree-shakable.\n */\n\nconst DI_DECORATOR_FLAG = '__NG_DI_FLAG__';\nconst NG_TEMP_TOKEN_PATH = 'ngTempTokenPath';\nconst NG_TOKEN_PATH = 'ngTokenPath';\nconst NEW_LINE = /\\n/gm;\nconst NO_NEW_LINE = 'ɵ';\nconst SOURCE = '__source';\n/**\n * Current injector value used by `inject`.\n * - `undefined`: it is an error to call `inject`\n * - `null`: `inject` can be called but there is no injector (limp-mode).\n * - Injector instance: Use the injector for resolution.\n */\n\nlet _currentInjector = undefined;\n\nfunction setCurrentInjector(injector) {\n  const former = _currentInjector;\n  _currentInjector = injector;\n  return former;\n}\n\nfunction injectInjectorOnly(token, flags = InjectFlags.Default) {\n  if (_currentInjector === undefined) {\n    throw new RuntimeError(-203\n    /* RuntimeErrorCode.MISSING_INJECTION_CONTEXT */\n    , ngDevMode && `inject() must be called from an injection context (a constructor, a factory function or a field initializer)`);\n  } else if (_currentInjector === null) {\n    return injectRootLimpMode(token, undefined, flags);\n  } else {\n    return _currentInjector.get(token, flags & InjectFlags.Optional ? null : undefined, flags);\n  }\n}\n\nfunction ɵɵinject(token, flags = InjectFlags.Default) {\n  return (getInjectImplementation() || injectInjectorOnly)(resolveForwardRef(token), flags);\n}\n/**\n * Throws an error indicating that a factory function could not be generated by the compiler for a\n * particular class.\n *\n * This instruction allows the actual error message to be optimized away when ngDevMode is turned\n * off, saving bytes of generated code while still providing a good experience in dev mode.\n *\n * The name of the class is not mentioned here, but will be in the generated factory function name\n * and thus in the stack trace.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵinvalidFactoryDep(index) {\n  const msg = ngDevMode ? `This constructor is not compatible with Angular Dependency Injection because its dependency at index ${index} of the parameter list is invalid.\nThis can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.\n\nPlease check that 1) the type for the parameter at index ${index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.` : 'invalid';\n  throw new Error(msg);\n}\n/**\n * Injects a token from the currently active injector.\n * `inject` is only supported during instantiation of a dependency by the DI system. It can be used\n * during:\n * - Construction (via the `constructor`) of a class being instantiated by the DI system, such\n * as an `@Injectable` or `@Component`.\n * - In the initializer for fields of such classes.\n * - In the factory function specified for `useFactory` of a `Provider` or an `@Injectable`.\n * - In the `factory` function specified for an `InjectionToken`.\n *\n * @param token A token that represents a dependency that should be injected.\n * @param flags Optional flags that control how injection is executed.\n * The flags correspond to injection strategies that can be specified with\n * parameter decorators `@Host`, `@Self`, `@SkipSef`, and `@Optional`.\n * @returns the injected value if operation is successful, `null` otherwise.\n * @throws if called outside of a supported context.\n *\n * @usageNotes\n * In practice the `inject()` calls are allowed in a constructor, a constructor parameter and a\n * field initializer:\n *\n * ```typescript\n * @Injectable({providedIn: 'root'})\n * export class Car {\n *   radio: Radio|undefined;\n *   // OK: field initializer\n *   spareTyre = inject(Tyre);\n *\n *   constructor() {\n *     // OK: constructor body\n *     this.radio = inject(Radio);\n *   }\n * }\n * ```\n *\n * It is also legal to call `inject` from a provider's factory:\n *\n * ```typescript\n * providers: [\n *   {provide: Car, useFactory: () => {\n *     // OK: a class factory\n *     const engine = inject(Engine);\n *     return new Car(engine);\n *   }}\n * ]\n * ```\n *\n * Calls to the `inject()` function outside of the class creation context will result in error. Most\n * notably, calls to `inject()` are disallowed after a class instance was created, in methods\n * (including lifecycle hooks):\n *\n * ```typescript\n * @Component({ ... })\n * export class CarComponent {\n *   ngOnInit() {\n *     // ERROR: too late, the component instance was already created\n *     const engine = inject(Engine);\n *     engine.start();\n *   }\n * }\n * ```\n *\n * @publicApi\n */\n\n\nfunction inject$1(token, flags = InjectFlags.Default) {\n  return ɵɵinject(token, flags);\n}\n\nfunction injectArgs(types) {\n  const args = [];\n\n  for (let i = 0; i < types.length; i++) {\n    const arg = resolveForwardRef(types[i]);\n\n    if (Array.isArray(arg)) {\n      if (arg.length === 0) {\n        throw new RuntimeError(900\n        /* RuntimeErrorCode.INVALID_DIFFER_INPUT */\n        , ngDevMode && 'Arguments array must have arguments.');\n      }\n\n      let type = undefined;\n      let flags = InjectFlags.Default;\n\n      for (let j = 0; j < arg.length; j++) {\n        const meta = arg[j];\n        const flag = getInjectFlag(meta);\n\n        if (typeof flag === 'number') {\n          // Special case when we handle @Inject decorator.\n          if (flag === -1\n          /* DecoratorFlags.Inject */\n          ) {\n            type = meta.token;\n          } else {\n            flags |= flag;\n          }\n        } else {\n          type = meta;\n        }\n      }\n\n      args.push(ɵɵinject(type, flags));\n    } else {\n      args.push(ɵɵinject(arg));\n    }\n  }\n\n  return args;\n}\n/**\n * Attaches a given InjectFlag to a given decorator using monkey-patching.\n * Since DI decorators can be used in providers `deps` array (when provider is configured using\n * `useFactory`) without initialization (e.g. `Host`) and as an instance (e.g. `new Host()`), we\n * attach the flag to make it available both as a static property and as a field on decorator\n * instance.\n *\n * @param decorator Provided DI decorator.\n * @param flag InjectFlag that should be applied.\n */\n\n\nfunction attachInjectFlag(decorator, flag) {\n  decorator[DI_DECORATOR_FLAG] = flag;\n  decorator.prototype[DI_DECORATOR_FLAG] = flag;\n  return decorator;\n}\n/**\n * Reads monkey-patched property that contains InjectFlag attached to a decorator.\n *\n * @param token Token that may contain monkey-patched DI flags property.\n */\n\n\nfunction getInjectFlag(token) {\n  return token[DI_DECORATOR_FLAG];\n}\n\nfunction catchInjectorError(e, token, injectorErrorName, source) {\n  const tokenPath = e[NG_TEMP_TOKEN_PATH];\n\n  if (token[SOURCE]) {\n    tokenPath.unshift(token[SOURCE]);\n  }\n\n  e.message = formatError('\\n' + e.message, tokenPath, injectorErrorName, source);\n  e[NG_TOKEN_PATH] = tokenPath;\n  e[NG_TEMP_TOKEN_PATH] = null;\n  throw e;\n}\n\nfunction formatError(text, obj, injectorErrorName, source = null) {\n  text = text && text.charAt(0) === '\\n' && text.charAt(1) == NO_NEW_LINE ? text.slice(2) : text;\n  let context = stringify(obj);\n\n  if (Array.isArray(obj)) {\n    context = obj.map(stringify).join(' -> ');\n  } else if (typeof obj === 'object') {\n    let parts = [];\n\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        let value = obj[key];\n        parts.push(key + ':' + (typeof value === 'string' ? JSON.stringify(value) : stringify(value)));\n      }\n    }\n\n    context = `{${parts.join(', ')}}`;\n  }\n\n  return `${injectorErrorName}${source ? '(' + source + ')' : ''}[${context}]: ${text.replace(NEW_LINE, '\\n  ')}`;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Inject decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\n\n\nconst Inject = attachInjectFlag( // Disable tslint because `DecoratorFlags` is a const enum which gets inlined.\n// tslint:disable-next-line: no-toplevel-property-access\nmakeParamDecorator('Inject', token => ({\n  token\n})), -1\n/* DecoratorFlags.Inject */\n);\n/**\n * Optional decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\n\nconst Optional = // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n// tslint:disable-next-line: no-toplevel-property-access\nattachInjectFlag(makeParamDecorator('Optional'), 8\n/* InternalInjectFlags.Optional */\n);\n/**\n * Self decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\n\nconst Self = // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n// tslint:disable-next-line: no-toplevel-property-access\nattachInjectFlag(makeParamDecorator('Self'), 2\n/* InternalInjectFlags.Self */\n);\n/**\n * `SkipSelf` decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\n\nconst SkipSelf = // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n// tslint:disable-next-line: no-toplevel-property-access\nattachInjectFlag(makeParamDecorator('SkipSelf'), 4\n/* InternalInjectFlags.SkipSelf */\n);\n/**\n * Host decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\n\nconst Host = // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n// tslint:disable-next-line: no-toplevel-property-access\nattachInjectFlag(makeParamDecorator('Host'), 1\n/* InternalInjectFlags.Host */\n);\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * The strategy that the default change detector uses to detect changes.\n * When set, takes effect the next time change detection is triggered.\n *\n * @see {@link ChangeDetectorRef#usage-notes Change detection usage}\n *\n * @publicApi\n */\n\nvar ChangeDetectionStrategy;\n\n(function (ChangeDetectionStrategy) {\n  /**\n   * Use the `CheckOnce` strategy, meaning that automatic change detection is deactivated\n   * until reactivated by setting the strategy to `Default` (`CheckAlways`).\n   * Change detection can still be explicitly invoked.\n   * This strategy applies to all child directives and cannot be overridden.\n   */\n  ChangeDetectionStrategy[ChangeDetectionStrategy[\"OnPush\"] = 0] = \"OnPush\";\n  /**\n   * Use the default `CheckAlways` strategy, in which change detection is automatic until\n   * explicitly deactivated.\n   */\n\n  ChangeDetectionStrategy[ChangeDetectionStrategy[\"Default\"] = 1] = \"Default\";\n})(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));\n/**\n * Defines the possible states of the default change detector.\n * @see `ChangeDetectorRef`\n */\n\n\nvar ChangeDetectorStatus;\n\n(function (ChangeDetectorStatus) {\n  /**\n   * A state in which, after calling `detectChanges()`, the change detector\n   * state becomes `Checked`, and must be explicitly invoked or reactivated.\n   */\n  ChangeDetectorStatus[ChangeDetectorStatus[\"CheckOnce\"] = 0] = \"CheckOnce\";\n  /**\n   * A state in which change detection is skipped until the change detector mode\n   * becomes `CheckOnce`.\n   */\n\n  ChangeDetectorStatus[ChangeDetectorStatus[\"Checked\"] = 1] = \"Checked\";\n  /**\n   * A state in which change detection continues automatically until explicitly\n   * deactivated.\n   */\n\n  ChangeDetectorStatus[ChangeDetectorStatus[\"CheckAlways\"] = 2] = \"CheckAlways\";\n  /**\n   * A state in which a change detector sub tree is not a part of the main tree and\n   * should be skipped.\n   */\n\n  ChangeDetectorStatus[ChangeDetectorStatus[\"Detached\"] = 3] = \"Detached\";\n  /**\n   * Indicates that the change detector encountered an error checking a binding\n   * or calling a directive lifecycle method and is now in an inconsistent state. Change\n   * detectors in this state do not detect changes.\n   */\n\n  ChangeDetectorStatus[ChangeDetectorStatus[\"Errored\"] = 4] = \"Errored\";\n  /**\n   * Indicates that the change detector has been destroyed.\n   */\n\n  ChangeDetectorStatus[ChangeDetectorStatus[\"Destroyed\"] = 5] = \"Destroyed\";\n})(ChangeDetectorStatus || (ChangeDetectorStatus = {}));\n/**\n * Reports whether a given strategy is currently the default for change detection.\n * @param changeDetectionStrategy The strategy to check.\n * @returns True if the given strategy is the current default, false otherwise.\n * @see `ChangeDetectorStatus`\n * @see `ChangeDetectorRef`\n */\n\n\nfunction isDefaultChangeDetectionStrategy(changeDetectionStrategy) {\n  return changeDetectionStrategy == null || changeDetectionStrategy === ChangeDetectionStrategy.Default;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Defines the CSS styles encapsulation policies for the {@link Component} decorator's\n * `encapsulation` option.\n *\n * See {@link Component#encapsulation encapsulation}.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/ts/metadata/encapsulation.ts region='longform'}\n *\n * @publicApi\n */\n\n\nvar ViewEncapsulation;\n\n(function (ViewEncapsulation) {\n  // TODO: consider making `ViewEncapsulation` a `const enum` instead. See\n  // https://github.com/angular/angular/issues/44119 for additional information.\n\n  /**\n   * Emulates a native Shadow DOM encapsulation behavior by adding a specific attribute to the\n   * component's host element and applying the same attribute to all the CSS selectors provided\n   * via {@link Component#styles styles} or {@link Component#styleUrls styleUrls}.\n   *\n   * This is the default option.\n   */\n  ViewEncapsulation[ViewEncapsulation[\"Emulated\"] = 0] = \"Emulated\"; // Historically the 1 value was for `Native` encapsulation which has been removed as of v11.\n\n  /**\n   * Doesn't provide any sort of CSS style encapsulation, meaning that all the styles provided\n   * via {@link Component#styles styles} or {@link Component#styleUrls styleUrls} are applicable\n   * to any HTML element of the application regardless of their host Component.\n   */\n\n  ViewEncapsulation[ViewEncapsulation[\"None\"] = 2] = \"None\";\n  /**\n   * Uses the browser's native Shadow DOM API to encapsulate CSS styles, meaning that it creates\n   * a ShadowRoot for the component's host element which is then used to encapsulate\n   * all the Component's styling.\n   */\n\n  ViewEncapsulation[ViewEncapsulation[\"ShadowDom\"] = 3] = \"ShadowDom\";\n})(ViewEncapsulation || (ViewEncapsulation = {}));\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * This file contains reuseable \"empty\" symbols that can be used as default return values\n * in different parts of the rendering code. Because the same symbols are returned, this\n * allows for identity checks against these values to be consistently used by the framework\n * code.\n */\n\n\nconst EMPTY_OBJ = {};\nconst EMPTY_ARRAY = []; // freezing the values prevents any code from accidentally inserting new values in\n\nif ((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode()) {\n  // These property accesses can be ignored because ngDevMode will be set to false\n  // when optimizing code and the whole if statement will be dropped.\n  // tslint:disable-next-line:no-toplevel-property-access\n  Object.freeze(EMPTY_OBJ); // tslint:disable-next-line:no-toplevel-property-access\n\n  Object.freeze(EMPTY_ARRAY);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nconst NG_COMP_DEF = getClosureSafeProperty({\n  ɵcmp: getClosureSafeProperty\n});\nconst NG_DIR_DEF = getClosureSafeProperty({\n  ɵdir: getClosureSafeProperty\n});\nconst NG_PIPE_DEF = getClosureSafeProperty({\n  ɵpipe: getClosureSafeProperty\n});\nconst NG_MOD_DEF = getClosureSafeProperty({\n  ɵmod: getClosureSafeProperty\n});\nconst NG_FACTORY_DEF = getClosureSafeProperty({\n  ɵfac: getClosureSafeProperty\n});\n/**\n * If a directive is diPublic, bloomAdd sets a property on the type with this constant as\n * the key and the directive's unique ID as the value. This allows us to map directives to their\n * bloom filter bit for DI.\n */\n// TODO(misko): This is wrong. The NG_ELEMENT_ID should never be minified.\n\nconst NG_ELEMENT_ID = getClosureSafeProperty({\n  __NG_ELEMENT_ID__: getClosureSafeProperty\n});\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Counter used to generate unique IDs for component definitions. */\n\nlet componentDefCount = 0;\n/**\n * Create a component definition object.\n *\n *\n * # Example\n * ```\n * class MyDirective {\n *   // Generated by Angular Template Compiler\n *   // [Symbol] syntax will not be supported by TypeScript until v2.7\n *   static ɵcmp = defineComponent({\n *     ...\n *   });\n * }\n * ```\n * @codeGenApi\n */\n\nfunction ɵɵdefineComponent(componentDefinition) {\n  return noSideEffects(() => {\n    // Initialize ngDevMode. This must be the first statement in ɵɵdefineComponent.\n    // See the `initNgDevMode` docstring for more information.\n    (typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode();\n    const type = componentDefinition.type;\n    const standalone = componentDefinition.standalone === true;\n    const declaredInputs = {};\n    const def = {\n      type: type,\n      providersResolver: null,\n      decls: componentDefinition.decls,\n      vars: componentDefinition.vars,\n      factory: null,\n      template: componentDefinition.template || null,\n      consts: componentDefinition.consts || null,\n      ngContentSelectors: componentDefinition.ngContentSelectors,\n      hostBindings: componentDefinition.hostBindings || null,\n      hostVars: componentDefinition.hostVars || 0,\n      hostAttrs: componentDefinition.hostAttrs || null,\n      contentQueries: componentDefinition.contentQueries || null,\n      declaredInputs: declaredInputs,\n      inputs: null,\n      outputs: null,\n      exportAs: componentDefinition.exportAs || null,\n      onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,\n      directiveDefs: null,\n      pipeDefs: null,\n      standalone,\n      dependencies: standalone && componentDefinition.dependencies || null,\n      getStandaloneInjector: null,\n      selectors: componentDefinition.selectors || EMPTY_ARRAY,\n      viewQuery: componentDefinition.viewQuery || null,\n      features: componentDefinition.features || null,\n      data: componentDefinition.data || {},\n      encapsulation: componentDefinition.encapsulation || ViewEncapsulation.Emulated,\n      id: `c${componentDefCount++}`,\n      styles: componentDefinition.styles || EMPTY_ARRAY,\n      _: null,\n      setInput: null,\n      schemas: componentDefinition.schemas || null,\n      tView: null\n    };\n    const dependencies = componentDefinition.dependencies;\n    const feature = componentDefinition.features;\n    def.inputs = invertObject(componentDefinition.inputs, declaredInputs), def.outputs = invertObject(componentDefinition.outputs), feature && feature.forEach(fn => fn(def));\n    def.directiveDefs = dependencies ? () => (typeof dependencies === 'function' ? dependencies() : dependencies).map(extractDirectiveDef).filter(nonNull) : null;\n    def.pipeDefs = dependencies ? () => (typeof dependencies === 'function' ? dependencies() : dependencies).map(getPipeDef$1).filter(nonNull) : null;\n    return def;\n  });\n}\n/**\n * Generated next to NgModules to monkey-patch directive and pipe references onto a component's\n * definition, when generating a direct reference in the component file would otherwise create an\n * import cycle.\n *\n * See [this explanation](https://hackmd.io/Odw80D0pR6yfsOjg_7XCJg?view) for more details.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵsetComponentScope(type, directives, pipes) {\n  const def = type.ɵcmp;\n\n  def.directiveDefs = () => (typeof directives === 'function' ? directives() : directives).map(extractDirectiveDef);\n\n  def.pipeDefs = () => (typeof pipes === 'function' ? pipes() : pipes).map(getPipeDef$1);\n}\n\nfunction extractDirectiveDef(type) {\n  return getComponentDef$1(type) || getDirectiveDef(type);\n}\n\nfunction nonNull(value) {\n  return value !== null;\n}\n\nconst autoRegisterModuleById = {};\n/**\n * @codeGenApi\n */\n\nfunction ɵɵdefineNgModule(def) {\n  return noSideEffects(() => {\n    const res = {\n      type: def.type,\n      bootstrap: def.bootstrap || EMPTY_ARRAY,\n      declarations: def.declarations || EMPTY_ARRAY,\n      imports: def.imports || EMPTY_ARRAY,\n      exports: def.exports || EMPTY_ARRAY,\n      transitiveCompileScopes: null,\n      schemas: def.schemas || null,\n      id: def.id || null\n    };\n\n    if (def.id != null) {\n      autoRegisterModuleById[def.id] = def.type;\n    }\n\n    return res;\n  });\n}\n/**\n * Adds the module metadata that is necessary to compute the module's transitive scope to an\n * existing module definition.\n *\n * Scope metadata of modules is not used in production builds, so calls to this function can be\n * marked pure to tree-shake it from the bundle, allowing for all referenced declarations\n * to become eligible for tree-shaking as well.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵsetNgModuleScope(type, scope) {\n  return noSideEffects(() => {\n    const ngModuleDef = getNgModuleDef(type, true);\n    ngModuleDef.declarations = scope.declarations || EMPTY_ARRAY;\n    ngModuleDef.imports = scope.imports || EMPTY_ARRAY;\n    ngModuleDef.exports = scope.exports || EMPTY_ARRAY;\n  });\n}\n/**\n * Inverts an inputs or outputs lookup such that the keys, which were the\n * minified keys, are part of the values, and the values are parsed so that\n * the publicName of the property is the new key\n *\n * e.g. for\n *\n * ```\n * class Comp {\n *   @Input()\n *   propName1: string;\n *\n *   @Input('publicName2')\n *   declaredPropName2: number;\n * }\n * ```\n *\n * will be serialized as\n *\n * ```\n * {\n *   propName1: 'propName1',\n *   declaredPropName2: ['publicName2', 'declaredPropName2'],\n * }\n * ```\n *\n * which is than translated by the minifier as:\n *\n * ```\n * {\n *   minifiedPropName1: 'propName1',\n *   minifiedPropName2: ['publicName2', 'declaredPropName2'],\n * }\n * ```\n *\n * becomes: (public name => minifiedName)\n *\n * ```\n * {\n *  'propName1': 'minifiedPropName1',\n *  'publicName2': 'minifiedPropName2',\n * }\n * ```\n *\n * Optionally the function can take `secondary` which will result in: (public name => declared name)\n *\n * ```\n * {\n *  'propName1': 'propName1',\n *  'publicName2': 'declaredPropName2',\n * }\n * ```\n *\n\n */\n\n\nfunction invertObject(obj, secondary) {\n  if (obj == null) return EMPTY_OBJ;\n  const newLookup = {};\n\n  for (const minifiedKey in obj) {\n    if (obj.hasOwnProperty(minifiedKey)) {\n      let publicName = obj[minifiedKey];\n      let declaredName = publicName;\n\n      if (Array.isArray(publicName)) {\n        declaredName = publicName[1];\n        publicName = publicName[0];\n      }\n\n      newLookup[publicName] = minifiedKey;\n\n      if (secondary) {\n        secondary[publicName] = declaredName;\n      }\n    }\n  }\n\n  return newLookup;\n}\n/**\n * Create a directive definition object.\n *\n * # Example\n * ```ts\n * class MyDirective {\n *   // Generated by Angular Template Compiler\n *   // [Symbol] syntax will not be supported by TypeScript until v2.7\n *   static ɵdir = ɵɵdefineDirective({\n *     ...\n *   });\n * }\n * ```\n *\n * @codeGenApi\n */\n\n\nconst ɵɵdefineDirective = ɵɵdefineComponent;\n/**\n * Create a pipe definition object.\n *\n * # Example\n * ```\n * class MyPipe implements PipeTransform {\n *   // Generated by Angular Template Compiler\n *   static ɵpipe = definePipe({\n *     ...\n *   });\n * }\n * ```\n * @param pipeDef Pipe definition generated by the compiler\n *\n * @codeGenApi\n */\n\nfunction ɵɵdefinePipe(pipeDef) {\n  return {\n    type: pipeDef.type,\n    name: pipeDef.name,\n    factory: null,\n    pure: pipeDef.pure !== false,\n    standalone: pipeDef.standalone === true,\n    onDestroy: pipeDef.type.prototype.ngOnDestroy || null\n  };\n}\n/**\n * The following getter methods retrieve the definition from the type. Currently the retrieval\n * honors inheritance, but in the future we may change the rule to require that definitions are\n * explicit. This would require some sort of migration strategy.\n */\n\n\nfunction getComponentDef$1(type) {\n  return type[NG_COMP_DEF] || null;\n}\n\nfunction getDirectiveDef(type) {\n  return type[NG_DIR_DEF] || null;\n}\n\nfunction getPipeDef$1(type) {\n  return type[NG_PIPE_DEF] || null;\n}\n\nfunction getNgModuleDef(type, throwNotFound) {\n  const ngModuleDef = type[NG_MOD_DEF] || null;\n\n  if (!ngModuleDef && throwNotFound === true) {\n    throw new Error(`Type ${stringify(type)} does not have 'ɵmod' property.`);\n  }\n\n  return ngModuleDef;\n}\n/**\n * Special location which allows easy identification of type. If we have an array which was\n * retrieved from the `LView` and that array has `true` at `TYPE` location, we know it is\n * `LContainer`.\n */\n\n\nconst TYPE = 1;\n/**\n * Below are constants for LContainer indices to help us look up LContainer members\n * without having to remember the specific indices.\n * Uglify will inline these when minifying so there shouldn't be a cost.\n */\n\n/**\n * Flag to signify that this `LContainer` may have transplanted views which need to be change\n * detected. (see: `LView[DECLARATION_COMPONENT_VIEW])`.\n *\n * This flag, once set, is never unset for the `LContainer`. This means that when unset we can skip\n * a lot of work in `refreshEmbeddedViews`. But when set we still need to verify\n * that the `MOVED_VIEWS` are transplanted and on-push.\n */\n\nconst HAS_TRANSPLANTED_VIEWS = 2; // PARENT, NEXT, TRANSPLANTED_VIEWS_TO_REFRESH are indices 3, 4, and 5\n// As we already have these constants in LView, we don't need to re-create them.\n// T_HOST is index 6\n// We already have this constants in LView, we don't need to re-create it.\n\nconst NATIVE = 7;\nconst VIEW_REFS = 8;\nconst MOVED_VIEWS = 9;\n/**\n * Size of LContainer's header. Represents the index after which all views in the\n * container will be inserted. We need to keep a record of current views so we know\n * which views are already in the DOM (and don't need to be re-added) and so we can\n * remove views from the DOM when they are no longer required.\n */\n\nconst CONTAINER_HEADER_OFFSET = 10; // Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\n\nconst unusedValueExportToPlacateAjd$8 = 1;\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Below are constants for LView indices to help us look up LView members\n// without having to remember the specific indices.\n// Uglify will inline these when minifying so there shouldn't be a cost.\n\nconst HOST = 0;\nconst TVIEW = 1;\nconst FLAGS = 2;\nconst PARENT = 3;\nconst NEXT = 4;\nconst TRANSPLANTED_VIEWS_TO_REFRESH = 5;\nconst T_HOST = 6;\nconst CLEANUP = 7;\nconst CONTEXT = 8;\nconst INJECTOR$1 = 9;\nconst RENDERER_FACTORY = 10;\nconst RENDERER = 11;\nconst SANITIZER = 12;\nconst CHILD_HEAD = 13;\nconst CHILD_TAIL = 14; // FIXME(misko): Investigate if the three declarations aren't all same thing.\n\nconst DECLARATION_VIEW = 15;\nconst DECLARATION_COMPONENT_VIEW = 16;\nconst DECLARATION_LCONTAINER = 17;\nconst PREORDER_HOOK_FLAGS = 18;\nconst QUERIES = 19;\nconst ID = 20;\nconst EMBEDDED_VIEW_INJECTOR = 21;\n/**\n * Size of LView's header. Necessary to adjust for it when setting slots.\n *\n * IMPORTANT: `HEADER_OFFSET` should only be referred to the in the `ɵɵ*` instructions to translate\n * instruction index into `LView` index. All other indexes should be in the `LView` index space and\n * there should be no need to refer to `HEADER_OFFSET` anywhere else.\n */\n\nconst HEADER_OFFSET = 22;\n/**\n * Converts `TViewType` into human readable text.\n * Make sure this matches with `TViewType`\n */\n\nconst TViewTypeAsString = ['Root', 'Component', 'Embedded' // 2\n]; // Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\n\nconst unusedValueExportToPlacateAjd$7 = 1;\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * True if `value` is `LView`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\n\nfunction isLView(value) {\n  return Array.isArray(value) && typeof value[TYPE] === 'object';\n}\n/**\n * True if `value` is `LContainer`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\n\n\nfunction isLContainer(value) {\n  return Array.isArray(value) && value[TYPE] === true;\n}\n\nfunction isContentQueryHost(tNode) {\n  return (tNode.flags & 8\n  /* TNodeFlags.hasContentQuery */\n  ) !== 0;\n}\n\nfunction isComponentHost(tNode) {\n  return (tNode.flags & 2\n  /* TNodeFlags.isComponentHost */\n  ) === 2\n  /* TNodeFlags.isComponentHost */\n  ;\n}\n\nfunction isDirectiveHost(tNode) {\n  return (tNode.flags & 1\n  /* TNodeFlags.isDirectiveHost */\n  ) === 1\n  /* TNodeFlags.isDirectiveHost */\n  ;\n}\n\nfunction isComponentDef(def) {\n  return def.template !== null;\n}\n\nfunction isRootView(target) {\n  return (target[FLAGS] & 256\n  /* LViewFlags.IsRoot */\n  ) !== 0;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// [Assert functions do not constraint type when they are guarded by a truthy\n// expression.](https://github.com/microsoft/TypeScript/issues/37295)\n\n\nfunction assertTNodeForLView(tNode, lView) {\n  assertTNodeForTView(tNode, lView[TVIEW]);\n}\n\nfunction assertTNodeForTView(tNode, tView) {\n  assertTNode(tNode);\n  tNode.hasOwnProperty('tView_') && assertEqual(tNode.tView_, tView, 'This TNode does not belong to this TView.');\n}\n\nfunction assertTNode(tNode) {\n  assertDefined(tNode, 'TNode must be defined');\n\n  if (!(tNode && typeof tNode === 'object' && tNode.hasOwnProperty('directiveStylingLast'))) {\n    throwError('Not of type TNode, got: ' + tNode);\n  }\n}\n\nfunction assertTIcu(tIcu) {\n  assertDefined(tIcu, 'Expected TIcu to be defined');\n\n  if (!(typeof tIcu.currentCaseLViewIndex === 'number')) {\n    throwError('Object is not of TIcu type.');\n  }\n}\n\nfunction assertComponentType(actual, msg = 'Type passed in is not ComponentType, it does not have \\'ɵcmp\\' property.') {\n  if (!getComponentDef$1(actual)) {\n    throwError(msg);\n  }\n}\n\nfunction assertNgModuleType(actual, msg = 'Type passed in is not NgModuleType, it does not have \\'ɵmod\\' property.') {\n  if (!getNgModuleDef(actual)) {\n    throwError(msg);\n  }\n}\n\nfunction assertCurrentTNodeIsParent(isParent) {\n  assertEqual(isParent, true, 'currentTNode should be a parent');\n}\n\nfunction assertHasParent(tNode) {\n  assertDefined(tNode, 'currentTNode should exist!');\n  assertDefined(tNode.parent, 'currentTNode should have a parent');\n}\n\nfunction assertDataNext(lView, index, arr) {\n  if (arr == null) arr = lView;\n  assertEqual(arr.length, index, `index ${index} expected to be at the end of arr (length ${arr.length})`);\n}\n\nfunction assertLContainer(value) {\n  assertDefined(value, 'LContainer must be defined');\n  assertEqual(isLContainer(value), true, 'Expecting LContainer');\n}\n\nfunction assertLViewOrUndefined(value) {\n  value && assertEqual(isLView(value), true, 'Expecting LView or undefined or null');\n}\n\nfunction assertLView(value) {\n  assertDefined(value, 'LView must be defined');\n  assertEqual(isLView(value), true, 'Expecting LView');\n}\n\nfunction assertFirstCreatePass(tView, errMessage) {\n  assertEqual(tView.firstCreatePass, true, errMessage || 'Should only be called in first create pass.');\n}\n\nfunction assertFirstUpdatePass(tView, errMessage) {\n  assertEqual(tView.firstUpdatePass, true, errMessage || 'Should only be called in first update pass.');\n}\n/**\n * This is a basic sanity check that an object is probably a directive def. DirectiveDef is\n * an interface, so we can't do a direct instanceof check.\n */\n\n\nfunction assertDirectiveDef(obj) {\n  if (obj.type === undefined || obj.selectors == undefined || obj.inputs === undefined) {\n    throwError(`Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);\n  }\n}\n\nfunction assertIndexInDeclRange(lView, index) {\n  const tView = lView[1];\n  assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index);\n}\n\nfunction assertIndexInVarsRange(lView, index) {\n  const tView = lView[1];\n  assertBetween(tView.bindingStartIndex, tView.expandoStartIndex, index);\n}\n\nfunction assertIndexInExpandoRange(lView, index) {\n  const tView = lView[1];\n  assertBetween(tView.expandoStartIndex, lView.length, index);\n}\n\nfunction assertBetween(lower, upper, index) {\n  if (!(lower <= index && index < upper)) {\n    throwError(`Index out of range (expecting ${lower} <= ${index} < ${upper})`);\n  }\n}\n\nfunction assertProjectionSlots(lView, errMessage) {\n  assertDefined(lView[DECLARATION_COMPONENT_VIEW], 'Component views should exist.');\n  assertDefined(lView[DECLARATION_COMPONENT_VIEW][T_HOST].projection, errMessage || 'Components with projection nodes (<ng-content>) must have projection slots defined.');\n}\n\nfunction assertParentView(lView, errMessage) {\n  assertDefined(lView, errMessage || 'Component views should always have a parent view (component\\'s host view)');\n}\n/**\n * This is a basic sanity check that the `injectorIndex` seems to point to what looks like a\n * NodeInjector data structure.\n *\n * @param lView `LView` which should be checked.\n * @param injectorIndex index into the `LView` where the `NodeInjector` is expected.\n */\n\n\nfunction assertNodeInjector(lView, injectorIndex) {\n  assertIndexInExpandoRange(lView, injectorIndex);\n  assertIndexInExpandoRange(lView, injectorIndex + 8\n  /* NodeInjectorOffset.PARENT */\n  );\n  assertNumber(lView[injectorIndex + 0], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 1], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 2], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 3], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 4], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 5], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 6], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 7], 'injectorIndex should point to a bloom filter');\n  assertNumber(lView[injectorIndex + 8\n  /* NodeInjectorOffset.PARENT */\n  ], 'injectorIndex should point to parent injector');\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction getFactoryDef(type, throwNotFound) {\n  const hasFactoryDef = type.hasOwnProperty(NG_FACTORY_DEF);\n\n  if (!hasFactoryDef && throwNotFound === true && ngDevMode) {\n    throw new Error(`Type ${stringify(type)} does not have 'ɵfac' property.`);\n  }\n\n  return hasFactoryDef ? type[NG_FACTORY_DEF] : null;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Represents a basic change from a previous to a new value for a single\n * property on a directive instance. Passed as a value in a\n * {@link SimpleChanges} object to the `ngOnChanges` hook.\n *\n * @see `OnChanges`\n *\n * @publicApi\n */\n\n\nclass SimpleChange {\n  constructor(previousValue, currentValue, firstChange) {\n    this.previousValue = previousValue;\n    this.currentValue = currentValue;\n    this.firstChange = firstChange;\n  }\n  /**\n   * Check whether the new value is the first value assigned.\n   */\n\n\n  isFirstChange() {\n    return this.firstChange;\n  }\n\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * The NgOnChangesFeature decorates a component with support for the ngOnChanges\n * lifecycle hook, so it should be included in any component that implements\n * that hook.\n *\n * If the component or directive uses inheritance, the NgOnChangesFeature MUST\n * be included as a feature AFTER {@link InheritDefinitionFeature}, otherwise\n * inherited properties will not be propagated to the ngOnChanges lifecycle\n * hook.\n *\n * Example usage:\n *\n * ```\n * static ɵcmp = defineComponent({\n *   ...\n *   inputs: {name: 'publicName'},\n *   features: [NgOnChangesFeature]\n * });\n * ```\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵNgOnChangesFeature() {\n  return NgOnChangesFeatureImpl;\n}\n\nfunction NgOnChangesFeatureImpl(definition) {\n  if (definition.type.prototype.ngOnChanges) {\n    definition.setInput = ngOnChangesSetInput;\n  }\n\n  return rememberChangeHistoryAndInvokeOnChangesHook;\n} // This option ensures that the ngOnChanges lifecycle hook will be inherited\n// from superclasses (in InheritDefinitionFeature).\n\n/** @nocollapse */\n// tslint:disable-next-line:no-toplevel-property-access\n\n\nɵɵNgOnChangesFeature.ngInherit = true;\n/**\n * This is a synthetic lifecycle hook which gets inserted into `TView.preOrderHooks` to simulate\n * `ngOnChanges`.\n *\n * The hook reads the `NgSimpleChangesStore` data from the component instance and if changes are\n * found it invokes `ngOnChanges` on the component instance.\n *\n * @param this Component instance. Because this function gets inserted into `TView.preOrderHooks`,\n *     it is guaranteed to be called with component instance.\n */\n\nfunction rememberChangeHistoryAndInvokeOnChangesHook() {\n  const simpleChangesStore = getSimpleChangesStore(this);\n  const current = simpleChangesStore === null || simpleChangesStore === void 0 ? void 0 : simpleChangesStore.current;\n\n  if (current) {\n    const previous = simpleChangesStore.previous;\n\n    if (previous === EMPTY_OBJ) {\n      simpleChangesStore.previous = current;\n    } else {\n      // New changes are copied to the previous store, so that we don't lose history for inputs\n      // which were not changed this time\n      for (let key in current) {\n        previous[key] = current[key];\n      }\n    }\n\n    simpleChangesStore.current = null;\n    this.ngOnChanges(current);\n  }\n}\n\nfunction ngOnChangesSetInput(instance, value, publicName, privateName) {\n  const simpleChangesStore = getSimpleChangesStore(instance) || setSimpleChangesStore(instance, {\n    previous: EMPTY_OBJ,\n    current: null\n  });\n  const current = simpleChangesStore.current || (simpleChangesStore.current = {});\n  const previous = simpleChangesStore.previous;\n  const declaredName = this.declaredInputs[publicName];\n  const previousChange = previous[declaredName];\n  current[declaredName] = new SimpleChange(previousChange && previousChange.currentValue, value, previous === EMPTY_OBJ);\n  instance[privateName] = value;\n}\n\nconst SIMPLE_CHANGES_STORE = '__ngSimpleChanges__';\n\nfunction getSimpleChangesStore(instance) {\n  return instance[SIMPLE_CHANGES_STORE] || null;\n}\n\nfunction setSimpleChangesStore(instance, store) {\n  return instance[SIMPLE_CHANGES_STORE] = store;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nlet profilerCallback = null;\n/**\n * Sets the callback function which will be invoked before and after performing certain actions at\n * runtime (for example, before and after running change detection).\n *\n * Warning: this function is *INTERNAL* and should not be relied upon in application's code.\n * The contract of the function might be changed in any release and/or the function can be removed\n * completely.\n *\n * @param profiler function provided by the caller or null value to disable profiling.\n */\n\nconst setProfiler = profiler => {\n  profilerCallback = profiler;\n};\n/**\n * Profiler function which wraps user code executed by the runtime.\n *\n * @param event ProfilerEvent corresponding to the execution context\n * @param instance component instance\n * @param hookOrListener lifecycle hook function or output listener. The value depends on the\n *  execution context\n * @returns\n */\n\n\nconst profiler = function (event, instance, hookOrListener) {\n  if (profilerCallback != null\n  /* both `null` and `undefined` */\n  ) {\n    profilerCallback(event, instance, hookOrListener);\n  }\n};\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nconst SVG_NAMESPACE = 'svg';\nconst SVG_NAMESPACE_URI = 'http://www.w3.org/2000/svg';\nconst MATH_ML_NAMESPACE = 'math';\nconst MATH_ML_NAMESPACE_URI = 'http://www.w3.org/1998/MathML/';\n\nfunction getNamespaceUri(namespace) {\n  const name = namespace.toLowerCase();\n  return name === SVG_NAMESPACE ? SVG_NAMESPACE_URI : name === MATH_ML_NAMESPACE ? MATH_ML_NAMESPACE_URI : null;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Most of the use of `document` in Angular is from within the DI system so it is possible to simply\n * inject the `DOCUMENT` token and are done.\n *\n * Ivy is special because it does not rely upon the DI and must get hold of the document some other\n * way.\n *\n * The solution is to define `getDocument()` and `setDocument()` top-level functions for ivy.\n * Wherever ivy needs the global document, it calls `getDocument()` instead.\n *\n * When running ivy outside of a browser environment, it is necessary to call `setDocument()` to\n * tell ivy what the global `document` is.\n *\n * Angular does this for us in each of the standard platforms (`Browser`, `Server`, and `WebWorker`)\n * by calling `setDocument()` when providing the `DOCUMENT` token.\n */\n\n\nlet DOCUMENT = undefined;\n/**\n * Tell ivy what the `document` is for this platform.\n *\n * It is only necessary to call this if the current platform is not a browser.\n *\n * @param document The object representing the global `document` in this environment.\n */\n\nfunction setDocument(document) {\n  DOCUMENT = document;\n}\n/**\n * Access the object that represents the `document` for this platform.\n *\n * Ivy calls this whenever it needs to access the `document` object.\n * For example to create the renderer or to do sanitization.\n */\n\n\nfunction getDocument() {\n  if (DOCUMENT !== undefined) {\n    return DOCUMENT;\n  } else if (typeof document !== 'undefined') {\n    return document;\n  } // No \"document\" can be found. This should only happen if we are running ivy outside Angular and\n  // the current platform is not a browser. Since this is not a supported scenario at the moment\n  // this should not happen in Angular apps.\n  // Once we support running ivy outside of Angular we will need to publish `setDocument()` as a\n  // public API. Meanwhile we just return `undefined` and let the application fail.\n\n\n  return undefined;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// TODO: cleanup once the code is merged in angular/angular\n\n\nvar RendererStyleFlags3;\n\n(function (RendererStyleFlags3) {\n  RendererStyleFlags3[RendererStyleFlags3[\"Important\"] = 1] = \"Important\";\n  RendererStyleFlags3[RendererStyleFlags3[\"DashCase\"] = 2] = \"DashCase\";\n})(RendererStyleFlags3 || (RendererStyleFlags3 = {}));\n/** Returns whether the `renderer` is a `ProceduralRenderer3` */\n\n\nfunction isProceduralRenderer(renderer) {\n  return !!renderer.listen;\n}\n\nconst domRendererFactory3 = {\n  createRenderer: (hostElement, rendererType) => {\n    return getDocument();\n  }\n}; // Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\n\nconst unusedValueExportToPlacateAjd$6 = 1;\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * For efficiency reasons we often put several different data types (`RNode`, `LView`, `LContainer`)\n * in same location in `LView`. This is because we don't want to pre-allocate space for it\n * because the storage is sparse. This file contains utilities for dealing with such data types.\n *\n * How do we know what is stored at a given location in `LView`.\n * - `Array.isArray(value) === false` => `RNode` (The normal storage value)\n * - `Array.isArray(value) === true` => then the `value[0]` represents the wrapped value.\n *   - `typeof value[TYPE] === 'object'` => `LView`\n *      - This happens when we have a component at a given location\n *   - `typeof value[TYPE] === true` => `LContainer`\n *      - This happens when we have `LContainer` binding at a given location.\n *\n *\n * NOTE: it is assumed that `Array.isArray` and `typeof` operations are very efficient.\n */\n\n/**\n * Returns `RNode`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\n\nfunction unwrapRNode(value) {\n  while (Array.isArray(value)) {\n    value = value[HOST];\n  }\n\n  return value;\n}\n/**\n * Returns `LView` or `null` if not found.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\n\n\nfunction unwrapLView(value) {\n  while (Array.isArray(value)) {\n    // This check is same as `isLView()` but we don't call at as we don't want to call\n    // `Array.isArray()` twice and give JITer more work for inlining.\n    if (typeof value[TYPE] === 'object') return value;\n    value = value[HOST];\n  }\n\n  return null;\n}\n/**\n * Returns `LContainer` or `null` if not found.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\n\n\nfunction unwrapLContainer(value) {\n  while (Array.isArray(value)) {\n    // This check is same as `isLContainer()` but we don't call at as we don't want to call\n    // `Array.isArray()` twice and give JITer more work for inlining.\n    if (value[TYPE] === true) return value;\n    value = value[HOST];\n  }\n\n  return null;\n}\n/**\n * Retrieves an element value from the provided `viewData`, by unwrapping\n * from any containers, component views, or style contexts.\n */\n\n\nfunction getNativeByIndex(index, lView) {\n  ngDevMode && assertIndexInRange(lView, index);\n  ngDevMode && assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Expected to be past HEADER_OFFSET');\n  return unwrapRNode(lView[index]);\n}\n/**\n * Retrieve an `RNode` for a given `TNode` and `LView`.\n *\n * This function guarantees in dev mode to retrieve a non-null `RNode`.\n *\n * @param tNode\n * @param lView\n */\n\n\nfunction getNativeByTNode(tNode, lView) {\n  ngDevMode && assertTNodeForLView(tNode, lView);\n  ngDevMode && assertIndexInRange(lView, tNode.index);\n  const node = unwrapRNode(lView[tNode.index]);\n  ngDevMode && !isProceduralRenderer(lView[RENDERER]) && assertDomNode(node);\n  return node;\n}\n/**\n * Retrieve an `RNode` or `null` for a given `TNode` and `LView`.\n *\n * Some `TNode`s don't have associated `RNode`s. For example `Projection`\n *\n * @param tNode\n * @param lView\n */\n\n\nfunction getNativeByTNodeOrNull(tNode, lView) {\n  const index = tNode === null ? -1 : tNode.index;\n\n  if (index !== -1) {\n    ngDevMode && assertTNodeForLView(tNode, lView);\n    const node = unwrapRNode(lView[index]);\n    ngDevMode && node !== null && !isProceduralRenderer(lView[RENDERER]) && assertDomNode(node);\n    return node;\n  }\n\n  return null;\n} // fixme(misko): The return Type should be `TNode|null`\n\n\nfunction getTNode(tView, index) {\n  ngDevMode && assertGreaterThan(index, -1, 'wrong index for TNode');\n  ngDevMode && assertLessThan(index, tView.data.length, 'wrong index for TNode');\n  const tNode = tView.data[index];\n  ngDevMode && tNode !== null && assertTNode(tNode);\n  return tNode;\n}\n/** Retrieves a value from any `LView` or `TData`. */\n\n\nfunction load(view, index) {\n  ngDevMode && assertIndexInRange(view, index);\n  return view[index];\n}\n\nfunction getComponentLViewByIndex(nodeIndex, hostView) {\n  // Could be an LView or an LContainer. If LContainer, unwrap to find LView.\n  ngDevMode && assertIndexInRange(hostView, nodeIndex);\n  const slotValue = hostView[nodeIndex];\n  const lView = isLView(slotValue) ? slotValue : slotValue[HOST];\n  return lView;\n}\n/** Checks whether a given view is in creation mode */\n\n\nfunction isCreationMode(view) {\n  return (view[FLAGS] & 4\n  /* LViewFlags.CreationMode */\n  ) === 4\n  /* LViewFlags.CreationMode */\n  ;\n}\n/**\n * Returns a boolean for whether the view is attached to the change detection tree.\n *\n * Note: This determines whether a view should be checked, not whether it's inserted\n * into a container. For that, you'll want `viewAttachedToContainer` below.\n */\n\n\nfunction viewAttachedToChangeDetector(view) {\n  return (view[FLAGS] & 64\n  /* LViewFlags.Attached */\n  ) === 64\n  /* LViewFlags.Attached */\n  ;\n}\n/** Returns a boolean for whether the view is attached to a container. */\n\n\nfunction viewAttachedToContainer(view) {\n  return isLContainer(view[PARENT]);\n}\n\nfunction getConstant(consts, index) {\n  if (index === null || index === undefined) return null;\n  ngDevMode && assertIndexInRange(consts, index);\n  return consts[index];\n}\n/**\n * Resets the pre-order hook flags of the view.\n * @param lView the LView on which the flags are reset\n */\n\n\nfunction resetPreOrderHookFlags(lView) {\n  lView[PREORDER_HOOK_FLAGS] = 0;\n}\n/**\n * Updates the `TRANSPLANTED_VIEWS_TO_REFRESH` counter on the `LContainer` as well as the parents\n * whose\n *  1. counter goes from 0 to 1, indicating that there is a new child that has a view to refresh\n *  or\n *  2. counter goes from 1 to 0, indicating there are no more descendant views to refresh\n */\n\n\nfunction updateTransplantedViewCount(lContainer, amount) {\n  lContainer[TRANSPLANTED_VIEWS_TO_REFRESH] += amount;\n  let viewOrContainer = lContainer;\n  let parent = lContainer[PARENT];\n\n  while (parent !== null && (amount === 1 && viewOrContainer[TRANSPLANTED_VIEWS_TO_REFRESH] === 1 || amount === -1 && viewOrContainer[TRANSPLANTED_VIEWS_TO_REFRESH] === 0)) {\n    parent[TRANSPLANTED_VIEWS_TO_REFRESH] += amount;\n    viewOrContainer = parent;\n    parent = parent[PARENT];\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nconst instructionState = {\n  lFrame: createLFrame(null),\n  bindingsEnabled: true\n};\n/**\n * In this mode, any changes in bindings will throw an ExpressionChangedAfterChecked error.\n *\n * Necessary to support ChangeDetectorRef.checkNoChanges().\n *\n * The `checkNoChanges` function is invoked only in ngDevMode=true and verifies that no unintended\n * changes exist in the change detector or its children.\n */\n\nlet _isInCheckNoChangesMode = false;\n/**\n * Returns true if the instruction state stack is empty.\n *\n * Intended to be called from tests only (tree shaken otherwise).\n */\n\nfunction specOnlyIsInstructionStateEmpty() {\n  return instructionState.lFrame.parent === null;\n}\n\nfunction getElementDepthCount() {\n  return instructionState.lFrame.elementDepthCount;\n}\n\nfunction increaseElementDepthCount() {\n  instructionState.lFrame.elementDepthCount++;\n}\n\nfunction decreaseElementDepthCount() {\n  instructionState.lFrame.elementDepthCount--;\n}\n\nfunction getBindingsEnabled() {\n  return instructionState.bindingsEnabled;\n}\n/**\n * Enables directive matching on elements.\n *\n *  * Example:\n * ```\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- ɵɵdisableBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- ɵɵenableBindings() -->\n * </div>\n * ```\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵenableBindings() {\n  instructionState.bindingsEnabled = true;\n}\n/**\n * Disables directive matching on element.\n *\n *  * Example:\n * ```\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- ɵɵdisableBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- ɵɵenableBindings() -->\n * </div>\n * ```\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵdisableBindings() {\n  instructionState.bindingsEnabled = false;\n}\n/**\n * Return the current `LView`.\n */\n\n\nfunction getLView() {\n  return instructionState.lFrame.lView;\n}\n/**\n * Return the current `TView`.\n */\n\n\nfunction getTView() {\n  return instructionState.lFrame.tView;\n}\n/**\n * Restores `contextViewData` to the given OpaqueViewState instance.\n *\n * Used in conjunction with the getCurrentView() instruction to save a snapshot\n * of the current view and restore it when listeners are invoked. This allows\n * walking the declaration view tree in listeners to get vars from parent views.\n *\n * @param viewToRestore The OpaqueViewState instance to restore.\n * @returns Context of the restored OpaqueViewState instance.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵrestoreView(viewToRestore) {\n  instructionState.lFrame.contextLView = viewToRestore;\n  return viewToRestore[CONTEXT];\n}\n/**\n * Clears the view set in `ɵɵrestoreView` from memory. Returns the passed in\n * value so that it can be used as a return value of an instruction.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵresetView(value) {\n  instructionState.lFrame.contextLView = null;\n  return value;\n}\n\nfunction getCurrentTNode() {\n  let currentTNode = getCurrentTNodePlaceholderOk();\n\n  while (currentTNode !== null && currentTNode.type === 64\n  /* TNodeType.Placeholder */\n  ) {\n    currentTNode = currentTNode.parent;\n  }\n\n  return currentTNode;\n}\n\nfunction getCurrentTNodePlaceholderOk() {\n  return instructionState.lFrame.currentTNode;\n}\n\nfunction getCurrentParentTNode() {\n  const lFrame = instructionState.lFrame;\n  const currentTNode = lFrame.currentTNode;\n  return lFrame.isParent ? currentTNode : currentTNode.parent;\n}\n\nfunction setCurrentTNode(tNode, isParent) {\n  ngDevMode && tNode && assertTNodeForTView(tNode, instructionState.lFrame.tView);\n  const lFrame = instructionState.lFrame;\n  lFrame.currentTNode = tNode;\n  lFrame.isParent = isParent;\n}\n\nfunction isCurrentTNodeParent() {\n  return instructionState.lFrame.isParent;\n}\n\nfunction setCurrentTNodeAsNotParent() {\n  instructionState.lFrame.isParent = false;\n}\n\nfunction setCurrentTNodeAsParent() {\n  instructionState.lFrame.isParent = true;\n}\n\nfunction getContextLView() {\n  const contextLView = instructionState.lFrame.contextLView;\n  ngDevMode && assertDefined(contextLView, 'contextLView must be defined.');\n  return contextLView;\n}\n\nfunction isInCheckNoChangesMode() {\n  !ngDevMode && throwError('Must never be called in production mode');\n  return _isInCheckNoChangesMode;\n}\n\nfunction setIsInCheckNoChangesMode(mode) {\n  !ngDevMode && throwError('Must never be called in production mode');\n  _isInCheckNoChangesMode = mode;\n} // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n\n\nfunction getBindingRoot() {\n  const lFrame = instructionState.lFrame;\n  let index = lFrame.bindingRootIndex;\n\n  if (index === -1) {\n    index = lFrame.bindingRootIndex = lFrame.tView.bindingStartIndex;\n  }\n\n  return index;\n}\n\nfunction getBindingIndex() {\n  return instructionState.lFrame.bindingIndex;\n}\n\nfunction setBindingIndex(value) {\n  return instructionState.lFrame.bindingIndex = value;\n}\n\nfunction nextBindingIndex() {\n  return instructionState.lFrame.bindingIndex++;\n}\n\nfunction incrementBindingIndex(count) {\n  const lFrame = instructionState.lFrame;\n  const index = lFrame.bindingIndex;\n  lFrame.bindingIndex = lFrame.bindingIndex + count;\n  return index;\n}\n\nfunction isInI18nBlock() {\n  return instructionState.lFrame.inI18n;\n}\n\nfunction setInI18nBlock(isInI18nBlock) {\n  instructionState.lFrame.inI18n = isInI18nBlock;\n}\n/**\n * Set a new binding root index so that host template functions can execute.\n *\n * Bindings inside the host template are 0 index. But because we don't know ahead of time\n * how many host bindings we have we can't pre-compute them. For this reason they are all\n * 0 index and we just shift the root so that they match next available location in the LView.\n *\n * @param bindingRootIndex Root index for `hostBindings`\n * @param currentDirectiveIndex `TData[currentDirectiveIndex]` will point to the current directive\n *        whose `hostBindings` are being processed.\n */\n\n\nfunction setBindingRootForHostBindings(bindingRootIndex, currentDirectiveIndex) {\n  const lFrame = instructionState.lFrame;\n  lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex;\n  setCurrentDirectiveIndex(currentDirectiveIndex);\n}\n/**\n * When host binding is executing this points to the directive index.\n * `TView.data[getCurrentDirectiveIndex()]` is `DirectiveDef`\n * `LView[getCurrentDirectiveIndex()]` is directive instance.\n */\n\n\nfunction getCurrentDirectiveIndex() {\n  return instructionState.lFrame.currentDirectiveIndex;\n}\n/**\n * Sets an index of a directive whose `hostBindings` are being processed.\n *\n * @param currentDirectiveIndex `TData` index where current directive instance can be found.\n */\n\n\nfunction setCurrentDirectiveIndex(currentDirectiveIndex) {\n  instructionState.lFrame.currentDirectiveIndex = currentDirectiveIndex;\n}\n/**\n * Retrieve the current `DirectiveDef` which is active when `hostBindings` instruction is being\n * executed.\n *\n * @param tData Current `TData` where the `DirectiveDef` will be looked up at.\n */\n\n\nfunction getCurrentDirectiveDef(tData) {\n  const currentDirectiveIndex = instructionState.lFrame.currentDirectiveIndex;\n  return currentDirectiveIndex === -1 ? null : tData[currentDirectiveIndex];\n}\n\nfunction getCurrentQueryIndex() {\n  return instructionState.lFrame.currentQueryIndex;\n}\n\nfunction setCurrentQueryIndex(value) {\n  instructionState.lFrame.currentQueryIndex = value;\n}\n/**\n * Returns a `TNode` of the location where the current `LView` is declared at.\n *\n * @param lView an `LView` that we want to find parent `TNode` for.\n */\n\n\nfunction getDeclarationTNode(lView) {\n  const tView = lView[TVIEW]; // Return the declaration parent for embedded views\n\n  if (tView.type === 2\n  /* TViewType.Embedded */\n  ) {\n    ngDevMode && assertDefined(tView.declTNode, 'Embedded TNodes should have declaration parents.');\n    return tView.declTNode;\n  } // Components don't have `TView.declTNode` because each instance of component could be\n  // inserted in different location, hence `TView.declTNode` is meaningless.\n  // Falling back to `T_HOST` in case we cross component boundary.\n\n\n  if (tView.type === 1\n  /* TViewType.Component */\n  ) {\n    return lView[T_HOST];\n  } // Remaining TNode type is `TViewType.Root` which doesn't have a parent TNode.\n\n\n  return null;\n}\n/**\n * This is a light weight version of the `enterView` which is needed by the DI system.\n *\n * @param lView `LView` location of the DI context.\n * @param tNode `TNode` for DI context\n * @param flags DI context flags. if `SkipSelf` flag is set than we walk up the declaration\n *     tree from `tNode`  until we find parent declared `TElementNode`.\n * @returns `true` if we have successfully entered DI associated with `tNode` (or with declared\n *     `TNode` if `flags` has  `SkipSelf`). Failing to enter DI implies that no associated\n *     `NodeInjector` can be found and we should instead use `ModuleInjector`.\n *     - If `true` than this call must be fallowed by `leaveDI`\n *     - If `false` than this call failed and we should NOT call `leaveDI`\n */\n\n\nfunction enterDI(lView, tNode, flags) {\n  ngDevMode && assertLViewOrUndefined(lView);\n\n  if (flags & InjectFlags.SkipSelf) {\n    ngDevMode && assertTNodeForTView(tNode, lView[TVIEW]);\n    let parentTNode = tNode;\n    let parentLView = lView;\n\n    while (true) {\n      ngDevMode && assertDefined(parentTNode, 'Parent TNode should be defined');\n      parentTNode = parentTNode.parent;\n\n      if (parentTNode === null && !(flags & InjectFlags.Host)) {\n        parentTNode = getDeclarationTNode(parentLView);\n        if (parentTNode === null) break; // In this case, a parent exists and is definitely an element. So it will definitely\n        // have an existing lView as the declaration view, which is why we can assume it's defined.\n\n        ngDevMode && assertDefined(parentLView, 'Parent LView should be defined');\n        parentLView = parentLView[DECLARATION_VIEW]; // In Ivy there are Comment nodes that correspond to ngIf and NgFor embedded directives\n        // We want to skip those and look only at Elements and ElementContainers to ensure\n        // we're looking at true parent nodes, and not content or other types.\n\n        if (parentTNode.type & (2\n        /* TNodeType.Element */\n        | 8\n        /* TNodeType.ElementContainer */\n        )) {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n\n    if (parentTNode === null) {\n      // If we failed to find a parent TNode this means that we should use module injector.\n      return false;\n    } else {\n      tNode = parentTNode;\n      lView = parentLView;\n    }\n  }\n\n  ngDevMode && assertTNodeForLView(tNode, lView);\n  const lFrame = instructionState.lFrame = allocLFrame();\n  lFrame.currentTNode = tNode;\n  lFrame.lView = lView;\n  return true;\n}\n/**\n * Swap the current lView with a new lView.\n *\n * For performance reasons we store the lView in the top level of the module.\n * This way we minimize the number of properties to read. Whenever a new view\n * is entered we have to store the lView for later, and when the view is\n * exited the state has to be restored\n *\n * @param newView New lView to become active\n * @returns the previously active lView;\n */\n\n\nfunction enterView(newView) {\n  ngDevMode && assertNotEqual(newView[0], newView[1], '????');\n  ngDevMode && assertLViewOrUndefined(newView);\n  const newLFrame = allocLFrame();\n\n  if (ngDevMode) {\n    assertEqual(newLFrame.isParent, true, 'Expected clean LFrame');\n    assertEqual(newLFrame.lView, null, 'Expected clean LFrame');\n    assertEqual(newLFrame.tView, null, 'Expected clean LFrame');\n    assertEqual(newLFrame.selectedIndex, -1, 'Expected clean LFrame');\n    assertEqual(newLFrame.elementDepthCount, 0, 'Expected clean LFrame');\n    assertEqual(newLFrame.currentDirectiveIndex, -1, 'Expected clean LFrame');\n    assertEqual(newLFrame.currentNamespace, null, 'Expected clean LFrame');\n    assertEqual(newLFrame.bindingRootIndex, -1, 'Expected clean LFrame');\n    assertEqual(newLFrame.currentQueryIndex, 0, 'Expected clean LFrame');\n  }\n\n  const tView = newView[TVIEW];\n  instructionState.lFrame = newLFrame;\n  ngDevMode && tView.firstChild && assertTNodeForTView(tView.firstChild, tView);\n  newLFrame.currentTNode = tView.firstChild;\n  newLFrame.lView = newView;\n  newLFrame.tView = tView;\n  newLFrame.contextLView = newView;\n  newLFrame.bindingIndex = tView.bindingStartIndex;\n  newLFrame.inI18n = false;\n}\n/**\n * Allocates next free LFrame. This function tries to reuse the `LFrame`s to lower memory pressure.\n */\n\n\nfunction allocLFrame() {\n  const currentLFrame = instructionState.lFrame;\n  const childLFrame = currentLFrame === null ? null : currentLFrame.child;\n  const newLFrame = childLFrame === null ? createLFrame(currentLFrame) : childLFrame;\n  return newLFrame;\n}\n\nfunction createLFrame(parent) {\n  const lFrame = {\n    currentTNode: null,\n    isParent: true,\n    lView: null,\n    tView: null,\n    selectedIndex: -1,\n    contextLView: null,\n    elementDepthCount: 0,\n    currentNamespace: null,\n    currentDirectiveIndex: -1,\n    bindingRootIndex: -1,\n    bindingIndex: -1,\n    currentQueryIndex: 0,\n    parent: parent,\n    child: null,\n    inI18n: false\n  };\n  parent !== null && (parent.child = lFrame); // link the new LFrame for reuse.\n\n  return lFrame;\n}\n/**\n * A lightweight version of leave which is used with DI.\n *\n * This function only resets `currentTNode` and `LView` as those are the only properties\n * used with DI (`enterDI()`).\n *\n * NOTE: This function is reexported as `leaveDI`. However `leaveDI` has return type of `void` where\n * as `leaveViewLight` has `LFrame`. This is so that `leaveViewLight` can be used in `leaveView`.\n */\n\n\nfunction leaveViewLight() {\n  const oldLFrame = instructionState.lFrame;\n  instructionState.lFrame = oldLFrame.parent;\n  oldLFrame.currentTNode = null;\n  oldLFrame.lView = null;\n  return oldLFrame;\n}\n/**\n * This is a lightweight version of the `leaveView` which is needed by the DI system.\n *\n * NOTE: this function is an alias so that we can change the type of the function to have `void`\n * return type.\n */\n\n\nconst leaveDI = leaveViewLight;\n/**\n * Leave the current `LView`\n *\n * This pops the `LFrame` with the associated `LView` from the stack.\n *\n * IMPORTANT: We must zero out the `LFrame` values here otherwise they will be retained. This is\n * because for performance reasons we don't release `LFrame` but rather keep it for next use.\n */\n\nfunction leaveView() {\n  const oldLFrame = leaveViewLight();\n  oldLFrame.isParent = true;\n  oldLFrame.tView = null;\n  oldLFrame.selectedIndex = -1;\n  oldLFrame.contextLView = null;\n  oldLFrame.elementDepthCount = 0;\n  oldLFrame.currentDirectiveIndex = -1;\n  oldLFrame.currentNamespace = null;\n  oldLFrame.bindingRootIndex = -1;\n  oldLFrame.bindingIndex = -1;\n  oldLFrame.currentQueryIndex = 0;\n}\n\nfunction nextContextImpl(level) {\n  const contextLView = instructionState.lFrame.contextLView = walkUpViews(level, instructionState.lFrame.contextLView);\n  return contextLView[CONTEXT];\n}\n\nfunction walkUpViews(nestingLevel, currentView) {\n  while (nestingLevel > 0) {\n    ngDevMode && assertDefined(currentView[DECLARATION_VIEW], 'Declaration view should be defined if nesting level is greater than 0.');\n    currentView = currentView[DECLARATION_VIEW];\n    nestingLevel--;\n  }\n\n  return currentView;\n}\n/**\n * Gets the currently selected element index.\n *\n * Used with {@link property} instruction (and more in the future) to identify the index in the\n * current `LView` to act on.\n */\n\n\nfunction getSelectedIndex() {\n  return instructionState.lFrame.selectedIndex;\n}\n/**\n * Sets the most recent index passed to {@link select}\n *\n * Used with {@link property} instruction (and more in the future) to identify the index in the\n * current `LView` to act on.\n *\n * (Note that if an \"exit function\" was set earlier (via `setElementExitFn()`) then that will be\n * run if and when the provided `index` value is different from the current selected index value.)\n */\n\n\nfunction setSelectedIndex(index) {\n  ngDevMode && index !== -1 && assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Index must be past HEADER_OFFSET (or -1).');\n  ngDevMode && assertLessThan(index, instructionState.lFrame.lView.length, 'Can\\'t set index passed end of LView');\n  instructionState.lFrame.selectedIndex = index;\n}\n/**\n * Gets the `tNode` that represents currently selected element.\n */\n\n\nfunction getSelectedTNode() {\n  const lFrame = instructionState.lFrame;\n  return getTNode(lFrame.tView, lFrame.selectedIndex);\n}\n/**\n * Sets the namespace used to create elements to `'http://www.w3.org/2000/svg'` in global state.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵnamespaceSVG() {\n  instructionState.lFrame.currentNamespace = SVG_NAMESPACE;\n}\n/**\n * Sets the namespace used to create elements to `'http://www.w3.org/1998/MathML/'` in global state.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵnamespaceMathML() {\n  instructionState.lFrame.currentNamespace = MATH_ML_NAMESPACE;\n}\n/**\n * Sets the namespace used to create elements to `null`, which forces element creation to use\n * `createElement` rather than `createElementNS`.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵnamespaceHTML() {\n  namespaceHTMLInternal();\n}\n/**\n * Sets the namespace used to create elements to `null`, which forces element creation to use\n * `createElement` rather than `createElementNS`.\n */\n\n\nfunction namespaceHTMLInternal() {\n  instructionState.lFrame.currentNamespace = null;\n}\n\nfunction getNamespace$1() {\n  return instructionState.lFrame.currentNamespace;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Adds all directive lifecycle hooks from the given `DirectiveDef` to the given `TView`.\n *\n * Must be run *only* on the first template pass.\n *\n * Sets up the pre-order hooks on the provided `tView`,\n * see {@link HookData} for details about the data structure.\n *\n * @param directiveIndex The index of the directive in LView\n * @param directiveDef The definition containing the hooks to setup in tView\n * @param tView The current TView\n */\n\n\nfunction registerPreOrderHooks(directiveIndex, directiveDef, tView) {\n  ngDevMode && assertFirstCreatePass(tView);\n  const {\n    ngOnChanges,\n    ngOnInit,\n    ngDoCheck\n  } = directiveDef.type.prototype;\n\n  if (ngOnChanges) {\n    const wrappedOnChanges = NgOnChangesFeatureImpl(directiveDef);\n    (tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, wrappedOnChanges);\n    (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(directiveIndex, wrappedOnChanges);\n  }\n\n  if (ngOnInit) {\n    (tView.preOrderHooks || (tView.preOrderHooks = [])).push(0 - directiveIndex, ngOnInit);\n  }\n\n  if (ngDoCheck) {\n    (tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, ngDoCheck);\n    (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(directiveIndex, ngDoCheck);\n  }\n}\n/**\n *\n * Loops through the directives on the provided `tNode` and queues hooks to be\n * run that are not initialization hooks.\n *\n * Should be executed during `elementEnd()` and similar to\n * preserve hook execution order. Content, view, and destroy hooks for projected\n * components and directives must be called *before* their hosts.\n *\n * Sets up the content, view, and destroy hooks on the provided `tView`,\n * see {@link HookData} for details about the data structure.\n *\n * NOTE: This does not set up `onChanges`, `onInit` or `doCheck`, those are set up\n * separately at `elementStart`.\n *\n * @param tView The current TView\n * @param tNode The TNode whose directives are to be searched for hooks to queue\n */\n\n\nfunction registerPostOrderHooks(tView, tNode) {\n  ngDevMode && assertFirstCreatePass(tView); // It's necessary to loop through the directives at elementEnd() (rather than processing in\n  // directiveCreate) so we can preserve the current hook order. Content, view, and destroy\n  // hooks for projected components and directives must be called *before* their hosts.\n\n  for (let i = tNode.directiveStart, end = tNode.directiveEnd; i < end; i++) {\n    const directiveDef = tView.data[i];\n    ngDevMode && assertDefined(directiveDef, 'Expecting DirectiveDef');\n    const lifecycleHooks = directiveDef.type.prototype;\n    const {\n      ngAfterContentInit,\n      ngAfterContentChecked,\n      ngAfterViewInit,\n      ngAfterViewChecked,\n      ngOnDestroy\n    } = lifecycleHooks;\n\n    if (ngAfterContentInit) {\n      (tView.contentHooks || (tView.contentHooks = [])).push(-i, ngAfterContentInit);\n    }\n\n    if (ngAfterContentChecked) {\n      (tView.contentHooks || (tView.contentHooks = [])).push(i, ngAfterContentChecked);\n      (tView.contentCheckHooks || (tView.contentCheckHooks = [])).push(i, ngAfterContentChecked);\n    }\n\n    if (ngAfterViewInit) {\n      (tView.viewHooks || (tView.viewHooks = [])).push(-i, ngAfterViewInit);\n    }\n\n    if (ngAfterViewChecked) {\n      (tView.viewHooks || (tView.viewHooks = [])).push(i, ngAfterViewChecked);\n      (tView.viewCheckHooks || (tView.viewCheckHooks = [])).push(i, ngAfterViewChecked);\n    }\n\n    if (ngOnDestroy != null) {\n      (tView.destroyHooks || (tView.destroyHooks = [])).push(i, ngOnDestroy);\n    }\n  }\n}\n/**\n * Executing hooks requires complex logic as we need to deal with 2 constraints.\n *\n * 1. Init hooks (ngOnInit, ngAfterContentInit, ngAfterViewInit) must all be executed once and only\n * once, across many change detection cycles. This must be true even if some hooks throw, or if\n * some recursively trigger a change detection cycle.\n * To solve that, it is required to track the state of the execution of these init hooks.\n * This is done by storing and maintaining flags in the view: the {@link InitPhaseState},\n * and the index within that phase. They can be seen as a cursor in the following structure:\n * [[onInit1, onInit2], [afterContentInit1], [afterViewInit1, afterViewInit2, afterViewInit3]]\n * They are are stored as flags in LView[FLAGS].\n *\n * 2. Pre-order hooks can be executed in batches, because of the select instruction.\n * To be able to pause and resume their execution, we also need some state about the hook's array\n * that is being processed:\n * - the index of the next hook to be executed\n * - the number of init hooks already found in the processed part of the  array\n * They are are stored as flags in LView[PREORDER_HOOK_FLAGS].\n */\n\n/**\n * Executes pre-order check hooks ( OnChanges, DoChanges) given a view where all the init hooks were\n * executed once. This is a light version of executeInitAndCheckPreOrderHooks where we can skip read\n * / write of the init-hooks related flags.\n * @param lView The LView where hooks are defined\n * @param hooks Hooks to be run\n * @param nodeIndex 3 cases depending on the value:\n * - undefined: all hooks from the array should be executed (post-order case)\n * - null: execute hooks only from the saved index until the end of the array (pre-order case, when\n * flushing the remaining hooks)\n * - number: execute hooks only from the saved index until that node index exclusive (pre-order\n * case, when executing select(number))\n */\n\n\nfunction executeCheckHooks(lView, hooks, nodeIndex) {\n  callHooks(lView, hooks, 3\n  /* InitPhaseState.InitPhaseCompleted */\n  , nodeIndex);\n}\n/**\n * Executes post-order init and check hooks (one of AfterContentInit, AfterContentChecked,\n * AfterViewInit, AfterViewChecked) given a view where there are pending init hooks to be executed.\n * @param lView The LView where hooks are defined\n * @param hooks Hooks to be run\n * @param initPhase A phase for which hooks should be run\n * @param nodeIndex 3 cases depending on the value:\n * - undefined: all hooks from the array should be executed (post-order case)\n * - null: execute hooks only from the saved index until the end of the array (pre-order case, when\n * flushing the remaining hooks)\n * - number: execute hooks only from the saved index until that node index exclusive (pre-order\n * case, when executing select(number))\n */\n\n\nfunction executeInitAndCheckHooks(lView, hooks, initPhase, nodeIndex) {\n  ngDevMode && assertNotEqual(initPhase, 3\n  /* InitPhaseState.InitPhaseCompleted */\n  , 'Init pre-order hooks should not be called more than once');\n\n  if ((lView[FLAGS] & 3\n  /* LViewFlags.InitPhaseStateMask */\n  ) === initPhase) {\n    callHooks(lView, hooks, initPhase, nodeIndex);\n  }\n}\n\nfunction incrementInitPhaseFlags(lView, initPhase) {\n  ngDevMode && assertNotEqual(initPhase, 3\n  /* InitPhaseState.InitPhaseCompleted */\n  , 'Init hooks phase should not be incremented after all init hooks have been run.');\n  let flags = lView[FLAGS];\n\n  if ((flags & 3\n  /* LViewFlags.InitPhaseStateMask */\n  ) === initPhase) {\n    flags &= 2047\n    /* LViewFlags.IndexWithinInitPhaseReset */\n    ;\n    flags += 1\n    /* LViewFlags.InitPhaseStateIncrementer */\n    ;\n    lView[FLAGS] = flags;\n  }\n}\n/**\n * Calls lifecycle hooks with their contexts, skipping init hooks if it's not\n * the first LView pass\n *\n * @param currentView The current view\n * @param arr The array in which the hooks are found\n * @param initPhaseState the current state of the init phase\n * @param currentNodeIndex 3 cases depending on the value:\n * - undefined: all hooks from the array should be executed (post-order case)\n * - null: execute hooks only from the saved index until the end of the array (pre-order case, when\n * flushing the remaining hooks)\n * - number: execute hooks only from the saved index until that node index exclusive (pre-order\n * case, when executing select(number))\n */\n\n\nfunction callHooks(currentView, arr, initPhase, currentNodeIndex) {\n  ngDevMode && assertEqual(isInCheckNoChangesMode(), false, 'Hooks should never be run when in check no changes mode.');\n  const startIndex = currentNodeIndex !== undefined ? currentView[PREORDER_HOOK_FLAGS] & 65535\n  /* PreOrderHookFlags.IndexOfTheNextPreOrderHookMaskMask */\n  : 0;\n  const nodeIndexLimit = currentNodeIndex != null ? currentNodeIndex : -1;\n  const max = arr.length - 1; // Stop the loop at length - 1, because we look for the hook at i + 1\n\n  let lastNodeIndexFound = 0;\n\n  for (let i = startIndex; i < max; i++) {\n    const hook = arr[i + 1];\n\n    if (typeof hook === 'number') {\n      lastNodeIndexFound = arr[i];\n\n      if (currentNodeIndex != null && lastNodeIndexFound >= currentNodeIndex) {\n        break;\n      }\n    } else {\n      const isInitHook = arr[i] < 0;\n      if (isInitHook) currentView[PREORDER_HOOK_FLAGS] += 65536\n      /* PreOrderHookFlags.NumberOfInitHooksCalledIncrementer */\n      ;\n\n      if (lastNodeIndexFound < nodeIndexLimit || nodeIndexLimit == -1) {\n        callHook(currentView, initPhase, arr, i);\n        currentView[PREORDER_HOOK_FLAGS] = (currentView[PREORDER_HOOK_FLAGS] & 4294901760\n        /* PreOrderHookFlags.NumberOfInitHooksCalledMask */\n        ) + i + 2;\n      }\n\n      i++;\n    }\n  }\n}\n/**\n * Execute one hook against the current `LView`.\n *\n * @param currentView The current view\n * @param initPhaseState the current state of the init phase\n * @param arr The array in which the hooks are found\n * @param i The current index within the hook data array\n */\n\n\nfunction callHook(currentView, initPhase, arr, i) {\n  const isInitHook = arr[i] < 0;\n  const hook = arr[i + 1];\n  const directiveIndex = isInitHook ? -arr[i] : arr[i];\n  const directive = currentView[directiveIndex];\n\n  if (isInitHook) {\n    const indexWithintInitPhase = currentView[FLAGS] >> 11\n    /* LViewFlags.IndexWithinInitPhaseShift */\n    ; // The init phase state must be always checked here as it may have been recursively updated.\n\n    if (indexWithintInitPhase < currentView[PREORDER_HOOK_FLAGS] >> 16\n    /* PreOrderHookFlags.NumberOfInitHooksCalledShift */\n    && (currentView[FLAGS] & 3\n    /* LViewFlags.InitPhaseStateMask */\n    ) === initPhase) {\n      currentView[FLAGS] += 2048\n      /* LViewFlags.IndexWithinInitPhaseIncrementer */\n      ;\n      profiler(4\n      /* ProfilerEvent.LifecycleHookStart */\n      , directive, hook);\n\n      try {\n        hook.call(directive);\n      } finally {\n        profiler(5\n        /* ProfilerEvent.LifecycleHookEnd */\n        , directive, hook);\n      }\n    }\n  } else {\n    profiler(4\n    /* ProfilerEvent.LifecycleHookStart */\n    , directive, hook);\n\n    try {\n      hook.call(directive);\n    } finally {\n      profiler(5\n      /* ProfilerEvent.LifecycleHookEnd */\n      , directive, hook);\n    }\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nconst NO_PARENT_INJECTOR = -1;\n/**\n * Each injector is saved in 9 contiguous slots in `LView` and 9 contiguous slots in\n * `TView.data`. This allows us to store information about the current node's tokens (which\n * can be shared in `TView`) as well as the tokens of its ancestor nodes (which cannot be\n * shared, so they live in `LView`).\n *\n * Each of these slots (aside from the last slot) contains a bloom filter. This bloom filter\n * determines whether a directive is available on the associated node or not. This prevents us\n * from searching the directives array at this level unless it's probable the directive is in it.\n *\n * See: https://en.wikipedia.org/wiki/Bloom_filter for more about bloom filters.\n *\n * Because all injectors have been flattened into `LView` and `TViewData`, they cannot typed\n * using interfaces as they were previously. The start index of each `LInjector` and `TInjector`\n * will differ based on where it is flattened into the main array, so it's not possible to know\n * the indices ahead of time and save their types here. The interfaces are still included here\n * for documentation purposes.\n *\n * export interface LInjector extends Array<any> {\n *\n *    // Cumulative bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)\n *    [0]: number;\n *\n *    // Cumulative bloom for directive IDs 32-63\n *    [1]: number;\n *\n *    // Cumulative bloom for directive IDs 64-95\n *    [2]: number;\n *\n *    // Cumulative bloom for directive IDs 96-127\n *    [3]: number;\n *\n *    // Cumulative bloom for directive IDs 128-159\n *    [4]: number;\n *\n *    // Cumulative bloom for directive IDs 160 - 191\n *    [5]: number;\n *\n *    // Cumulative bloom for directive IDs 192 - 223\n *    [6]: number;\n *\n *    // Cumulative bloom for directive IDs 224 - 255\n *    [7]: number;\n *\n *    // We need to store a reference to the injector's parent so DI can keep looking up\n *    // the injector tree until it finds the dependency it's looking for.\n *    [PARENT_INJECTOR]: number;\n * }\n *\n * export interface TInjector extends Array<any> {\n *\n *    // Shared node bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)\n *    [0]: number;\n *\n *    // Shared node bloom for directive IDs 32-63\n *    [1]: number;\n *\n *    // Shared node bloom for directive IDs 64-95\n *    [2]: number;\n *\n *    // Shared node bloom for directive IDs 96-127\n *    [3]: number;\n *\n *    // Shared node bloom for directive IDs 128-159\n *    [4]: number;\n *\n *    // Shared node bloom for directive IDs 160 - 191\n *    [5]: number;\n *\n *    // Shared node bloom for directive IDs 192 - 223\n *    [6]: number;\n *\n *    // Shared node bloom for directive IDs 224 - 255\n *    [7]: number;\n *\n *    // Necessary to find directive indices for a particular node.\n *    [TNODE]: TElementNode|TElementContainerNode|TContainerNode;\n *  }\n */\n\n/**\n * Factory for creating instances of injectors in the NodeInjector.\n *\n * This factory is complicated by the fact that it can resolve `multi` factories as well.\n *\n * NOTE: Some of the fields are optional which means that this class has two hidden classes.\n * - One without `multi` support (most common)\n * - One with `multi` values, (rare).\n *\n * Since VMs can cache up to 4 inline hidden classes this is OK.\n *\n * - Single factory: Only `resolving` and `factory` is defined.\n * - `providers` factory: `componentProviders` is a number and `index = -1`.\n * - `viewProviders` factory: `componentProviders` is a number and `index` points to `providers`.\n */\n\nclass NodeInjectorFactory {\n  constructor(\n  /**\n   * Factory to invoke in order to create a new instance.\n   */\n  factory,\n  /**\n   * Set to `true` if the token is declared in `viewProviders` (or if it is component).\n   */\n  isViewProvider, injectImplementation) {\n    this.factory = factory;\n    /**\n     * Marker set to true during factory invocation to see if we get into recursive loop.\n     * Recursive loop causes an error to be displayed.\n     */\n\n    this.resolving = false;\n    ngDevMode && assertDefined(factory, 'Factory not specified');\n    ngDevMode && assertEqual(typeof factory, 'function', 'Expected factory function.');\n    this.canSeeViewProviders = isViewProvider;\n    this.injectImpl = injectImplementation;\n  }\n\n}\n\nfunction isFactory(obj) {\n  return obj instanceof NodeInjectorFactory;\n} // Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\n\n\nconst unusedValueExportToPlacateAjd$5 = 1;\n/**\n * Converts `TNodeType` into human readable text.\n * Make sure this matches with `TNodeType`\n */\n\nfunction toTNodeTypeAsString(tNodeType) {\n  let text = '';\n  tNodeType & 1\n  /* TNodeType.Text */\n  && (text += '|Text');\n  tNodeType & 2\n  /* TNodeType.Element */\n  && (text += '|Element');\n  tNodeType & 4\n  /* TNodeType.Container */\n  && (text += '|Container');\n  tNodeType & 8\n  /* TNodeType.ElementContainer */\n  && (text += '|ElementContainer');\n  tNodeType & 16\n  /* TNodeType.Projection */\n  && (text += '|Projection');\n  tNodeType & 32\n  /* TNodeType.Icu */\n  && (text += '|IcuContainer');\n  tNodeType & 64\n  /* TNodeType.Placeholder */\n  && (text += '|Placeholder');\n  return text.length > 0 ? text.substring(1) : text;\n} // Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\n\n\nconst unusedValueExportToPlacateAjd$4 = 1;\n/**\n * Returns `true` if the `TNode` has a directive which has `@Input()` for `class` binding.\n *\n * ```\n * <div my-dir [class]=\"exp\"></div>\n * ```\n * and\n * ```\n * @Directive({\n * })\n * class MyDirective {\n *   @Input()\n *   class: string;\n * }\n * ```\n *\n * In the above case it is necessary to write the reconciled styling information into the\n * directive's input.\n *\n * @param tNode\n */\n\nfunction hasClassInput(tNode) {\n  return (tNode.flags & 16\n  /* TNodeFlags.hasClassInput */\n  ) !== 0;\n}\n/**\n * Returns `true` if the `TNode` has a directive which has `@Input()` for `style` binding.\n *\n * ```\n * <div my-dir [style]=\"exp\"></div>\n * ```\n * and\n * ```\n * @Directive({\n * })\n * class MyDirective {\n *   @Input()\n *   class: string;\n * }\n * ```\n *\n * In the above case it is necessary to write the reconciled styling information into the\n * directive's input.\n *\n * @param tNode\n */\n\n\nfunction hasStyleInput(tNode) {\n  return (tNode.flags & 32\n  /* TNodeFlags.hasStyleInput */\n  ) !== 0;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction assertTNodeType(tNode, expectedTypes, message) {\n  assertDefined(tNode, 'should be called with a TNode');\n\n  if ((tNode.type & expectedTypes) === 0) {\n    throwError(message || `Expected [${toTNodeTypeAsString(expectedTypes)}] but got ${toTNodeTypeAsString(tNode.type)}.`);\n  }\n}\n\nfunction assertPureTNodeType(type) {\n  if (!(type === 2\n  /* TNodeType.Element */\n  || //\n  type === 1\n  /* TNodeType.Text */\n  || //\n  type === 4\n  /* TNodeType.Container */\n  || //\n  type === 8\n  /* TNodeType.ElementContainer */\n  || //\n  type === 32\n  /* TNodeType.Icu */\n  || //\n  type === 16\n  /* TNodeType.Projection */\n  || //\n  type === 64\n  /* TNodeType.Placeholder */\n  )) {\n    throwError(`Expected TNodeType to have only a single type selected, but got ${toTNodeTypeAsString(type)}.`);\n  }\n}\n/**\n * Assigns all attribute values to the provided element via the inferred renderer.\n *\n * This function accepts two forms of attribute entries:\n *\n * default: (key, value):\n *  attrs = [key1, value1, key2, value2]\n *\n * namespaced: (NAMESPACE_MARKER, uri, name, value)\n *  attrs = [NAMESPACE_MARKER, uri, name, value, NAMESPACE_MARKER, uri, name, value]\n *\n * The `attrs` array can contain a mix of both the default and namespaced entries.\n * The \"default\" values are set without a marker, but if the function comes across\n * a marker value then it will attempt to set a namespaced value. If the marker is\n * not of a namespaced value then the function will quit and return the index value\n * where it stopped during the iteration of the attrs array.\n *\n * See [AttributeMarker] to understand what the namespace marker value is.\n *\n * Note that this instruction does not support assigning style and class values to\n * an element. See `elementStart` and `elementHostAttrs` to learn how styling values\n * are applied to an element.\n * @param renderer The renderer to be used\n * @param native The element that the attributes will be assigned to\n * @param attrs The attribute array of values that will be assigned to the element\n * @returns the index value that was last accessed in the attributes array\n */\n\n\nfunction setUpAttributes(renderer, native, attrs) {\n  const isProc = isProceduralRenderer(renderer);\n  let i = 0;\n\n  while (i < attrs.length) {\n    const value = attrs[i];\n\n    if (typeof value === 'number') {\n      // only namespaces are supported. Other value types (such as style/class\n      // entries) are not supported in this function.\n      if (value !== 0\n      /* AttributeMarker.NamespaceURI */\n      ) {\n        break;\n      } // we just landed on the marker value ... therefore\n      // we should skip to the next entry\n\n\n      i++;\n      const namespaceURI = attrs[i++];\n      const attrName = attrs[i++];\n      const attrVal = attrs[i++];\n      ngDevMode && ngDevMode.rendererSetAttribute++;\n      isProc ? renderer.setAttribute(native, attrName, attrVal, namespaceURI) : native.setAttributeNS(namespaceURI, attrName, attrVal);\n    } else {\n      // attrName is string;\n      const attrName = value;\n      const attrVal = attrs[++i]; // Standard attributes\n\n      ngDevMode && ngDevMode.rendererSetAttribute++;\n\n      if (isAnimationProp(attrName)) {\n        if (isProc) {\n          renderer.setProperty(native, attrName, attrVal);\n        }\n      } else {\n        isProc ? renderer.setAttribute(native, attrName, attrVal) : native.setAttribute(attrName, attrVal);\n      }\n\n      i++;\n    }\n  } // another piece of code may iterate over the same attributes array. Therefore\n  // it may be helpful to return the exact spot where the attributes array exited\n  // whether by running into an unsupported marker or if all the static values were\n  // iterated over.\n\n\n  return i;\n}\n/**\n * Test whether the given value is a marker that indicates that the following\n * attribute values in a `TAttributes` array are only the names of attributes,\n * and not name-value pairs.\n * @param marker The attribute marker to test.\n * @returns true if the marker is a \"name-only\" marker (e.g. `Bindings`, `Template` or `I18n`).\n */\n\n\nfunction isNameOnlyAttributeMarker(marker) {\n  return marker === 3\n  /* AttributeMarker.Bindings */\n  || marker === 4\n  /* AttributeMarker.Template */\n  || marker === 6\n  /* AttributeMarker.I18n */\n  ;\n}\n\nfunction isAnimationProp(name) {\n  // Perf note: accessing charCodeAt to check for the first character of a string is faster as\n  // compared to accessing a character at index 0 (ex. name[0]). The main reason for this is that\n  // charCodeAt doesn't allocate memory to return a substring.\n  return name.charCodeAt(0) === 64\n  /* CharCode.AT_SIGN */\n  ;\n}\n/**\n * Merges `src` `TAttributes` into `dst` `TAttributes` removing any duplicates in the process.\n *\n * This merge function keeps the order of attrs same.\n *\n * @param dst Location of where the merged `TAttributes` should end up.\n * @param src `TAttributes` which should be appended to `dst`\n */\n\n\nfunction mergeHostAttrs(dst, src) {\n  if (src === null || src.length === 0) {// do nothing\n  } else if (dst === null || dst.length === 0) {\n    // We have source, but dst is empty, just make a copy.\n    dst = src.slice();\n  } else {\n    let srcMarker = -1\n    /* AttributeMarker.ImplicitAttributes */\n    ;\n\n    for (let i = 0; i < src.length; i++) {\n      const item = src[i];\n\n      if (typeof item === 'number') {\n        srcMarker = item;\n      } else {\n        if (srcMarker === 0\n        /* AttributeMarker.NamespaceURI */\n        ) {// Case where we need to consume `key1`, `key2`, `value` items.\n        } else if (srcMarker === -1\n        /* AttributeMarker.ImplicitAttributes */\n        || srcMarker === 2\n        /* AttributeMarker.Styles */\n        ) {\n          // Case where we have to consume `key1` and `value` only.\n          mergeHostAttribute(dst, srcMarker, item, null, src[++i]);\n        } else {\n          // Case where we have to consume `key1` only.\n          mergeHostAttribute(dst, srcMarker, item, null, null);\n        }\n      }\n    }\n  }\n\n  return dst;\n}\n/**\n * Append `key`/`value` to existing `TAttributes` taking region marker and duplicates into account.\n *\n * @param dst `TAttributes` to append to.\n * @param marker Region where the `key`/`value` should be added.\n * @param key1 Key to add to `TAttributes`\n * @param key2 Key to add to `TAttributes` (in case of `AttributeMarker.NamespaceURI`)\n * @param value Value to add or to overwrite to `TAttributes` Only used if `marker` is not Class.\n */\n\n\nfunction mergeHostAttribute(dst, marker, key1, key2, value) {\n  let i = 0; // Assume that new markers will be inserted at the end.\n\n  let markerInsertPosition = dst.length; // scan until correct type.\n\n  if (marker === -1\n  /* AttributeMarker.ImplicitAttributes */\n  ) {\n    markerInsertPosition = -1;\n  } else {\n    while (i < dst.length) {\n      const dstValue = dst[i++];\n\n      if (typeof dstValue === 'number') {\n        if (dstValue === marker) {\n          markerInsertPosition = -1;\n          break;\n        } else if (dstValue > marker) {\n          // We need to save this as we want the markers to be inserted in specific order.\n          markerInsertPosition = i - 1;\n          break;\n        }\n      }\n    }\n  } // search until you find place of insertion\n\n\n  while (i < dst.length) {\n    const item = dst[i];\n\n    if (typeof item === 'number') {\n      // since `i` started as the index after the marker, we did not find it if we are at the next\n      // marker\n      break;\n    } else if (item === key1) {\n      // We already have same token\n      if (key2 === null) {\n        if (value !== null) {\n          dst[i + 1] = value;\n        }\n\n        return;\n      } else if (key2 === dst[i + 1]) {\n        dst[i + 2] = value;\n        return;\n      }\n    } // Increment counter.\n\n\n    i++;\n    if (key2 !== null) i++;\n    if (value !== null) i++;\n  } // insert at location.\n\n\n  if (markerInsertPosition !== -1) {\n    dst.splice(markerInsertPosition, 0, marker);\n    i = markerInsertPosition + 1;\n  }\n\n  dst.splice(i++, 0, key1);\n\n  if (key2 !== null) {\n    dst.splice(i++, 0, key2);\n  }\n\n  if (value !== null) {\n    dst.splice(i++, 0, value);\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/// Parent Injector Utils ///////////////////////////////////////////////////////////////\n\n\nfunction hasParentInjector(parentLocation) {\n  return parentLocation !== NO_PARENT_INJECTOR;\n}\n\nfunction getParentInjectorIndex(parentLocation) {\n  ngDevMode && assertNumber(parentLocation, 'Number expected');\n  ngDevMode && assertNotEqual(parentLocation, -1, 'Not a valid state.');\n  const parentInjectorIndex = parentLocation & 32767\n  /* RelativeInjectorLocationFlags.InjectorIndexMask */\n  ;\n  ngDevMode && assertGreaterThan(parentInjectorIndex, HEADER_OFFSET, 'Parent injector must be pointing past HEADER_OFFSET.');\n  return parentLocation & 32767\n  /* RelativeInjectorLocationFlags.InjectorIndexMask */\n  ;\n}\n\nfunction getParentInjectorViewOffset(parentLocation) {\n  return parentLocation >> 16\n  /* RelativeInjectorLocationFlags.ViewOffsetShift */\n  ;\n}\n/**\n * Unwraps a parent injector location number to find the view offset from the current injector,\n * then walks up the declaration view tree until the view is found that contains the parent\n * injector.\n *\n * @param location The location of the parent injector, which contains the view offset\n * @param startView The LView instance from which to start walking up the view tree\n * @returns The LView instance that contains the parent injector\n */\n\n\nfunction getParentInjectorView(location, startView) {\n  let viewOffset = getParentInjectorViewOffset(location);\n  let parentView = startView; // For most cases, the parent injector can be found on the host node (e.g. for component\n  // or container), but we must keep the loop here to support the rarer case of deeply nested\n  // <ng-template> tags or inline views, where the parent injector might live many views\n  // above the child injector.\n\n  while (viewOffset > 0) {\n    parentView = parentView[DECLARATION_VIEW];\n    viewOffset--;\n  }\n\n  return parentView;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Defines if the call to `inject` should include `viewProviders` in its resolution.\n *\n * This is set to true when we try to instantiate a component. This value is reset in\n * `getNodeInjectable` to a value which matches the declaration location of the token about to be\n * instantiated. This is done so that if we are injecting a token which was declared outside of\n * `viewProviders` we don't accidentally pull `viewProviders` in.\n *\n * Example:\n *\n * ```\n * @Injectable()\n * class MyService {\n *   constructor(public value: String) {}\n * }\n *\n * @Component({\n *   providers: [\n *     MyService,\n *     {provide: String, value: 'providers' }\n *   ]\n *   viewProviders: [\n *     {provide: String, value: 'viewProviders'}\n *   ]\n * })\n * class MyComponent {\n *   constructor(myService: MyService, value: String) {\n *     // We expect that Component can see into `viewProviders`.\n *     expect(value).toEqual('viewProviders');\n *     // `MyService` was not declared in `viewProviders` hence it can't see it.\n *     expect(myService.value).toEqual('providers');\n *   }\n * }\n *\n * ```\n */\n\n\nlet includeViewProviders = true;\n\nfunction setIncludeViewProviders(v) {\n  const oldValue = includeViewProviders;\n  includeViewProviders = v;\n  return oldValue;\n}\n/**\n * The number of slots in each bloom filter (used by DI). The larger this number, the fewer\n * directives that will share slots, and thus, the fewer false positives when checking for\n * the existence of a directive.\n */\n\n\nconst BLOOM_SIZE = 256;\nconst BLOOM_MASK = BLOOM_SIZE - 1;\n/**\n * The number of bits that is represented by a single bloom bucket. JS bit operations are 32 bits,\n * so each bucket represents 32 distinct tokens which accounts for log2(32) = 5 bits of a bloom hash\n * number.\n */\n\nconst BLOOM_BUCKET_BITS = 5;\n/** Counter used to generate unique IDs for directives. */\n\nlet nextNgElementId = 0;\n/** Value used when something wasn't found by an injector. */\n\nconst NOT_FOUND = {};\n/**\n * Registers this directive as present in its node's injector by flipping the directive's\n * corresponding bit in the injector's bloom filter.\n *\n * @param injectorIndex The index of the node injector where this token should be registered\n * @param tView The TView for the injector's bloom filters\n * @param type The directive token to register\n */\n\nfunction bloomAdd(injectorIndex, tView, type) {\n  ngDevMode && assertEqual(tView.firstCreatePass, true, 'expected firstCreatePass to be true');\n  let id;\n\n  if (typeof type === 'string') {\n    id = type.charCodeAt(0) || 0;\n  } else if (type.hasOwnProperty(NG_ELEMENT_ID)) {\n    id = type[NG_ELEMENT_ID];\n  } // Set a unique ID on the directive type, so if something tries to inject the directive,\n  // we can easily retrieve the ID and hash it into the bloom bit that should be checked.\n\n\n  if (id == null) {\n    id = type[NG_ELEMENT_ID] = nextNgElementId++;\n  } // We only have BLOOM_SIZE (256) slots in our bloom filter (8 buckets * 32 bits each),\n  // so all unique IDs must be modulo-ed into a number from 0 - 255 to fit into the filter.\n\n\n  const bloomHash = id & BLOOM_MASK; // Create a mask that targets the specific bit associated with the directive.\n  // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n  // to bit positions 0 - 31 in a 32 bit integer.\n\n  const mask = 1 << bloomHash; // Each bloom bucket in `tData` represents `BLOOM_BUCKET_BITS` number of bits of `bloomHash`.\n  // Any bits in `bloomHash` beyond `BLOOM_BUCKET_BITS` indicate the bucket offset that the mask\n  // should be written to.\n\n  tView.data[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)] |= mask;\n}\n/**\n * Creates (or gets an existing) injector for a given element or container.\n *\n * @param tNode for which an injector should be retrieved / created.\n * @param lView View where the node is stored\n * @returns Node injector\n */\n\n\nfunction getOrCreateNodeInjectorForNode(tNode, lView) {\n  const existingInjectorIndex = getInjectorIndex(tNode, lView);\n\n  if (existingInjectorIndex !== -1) {\n    return existingInjectorIndex;\n  }\n\n  const tView = lView[TVIEW];\n\n  if (tView.firstCreatePass) {\n    tNode.injectorIndex = lView.length;\n    insertBloom(tView.data, tNode); // foundation for node bloom\n\n    insertBloom(lView, null); // foundation for cumulative bloom\n\n    insertBloom(tView.blueprint, null);\n  }\n\n  const parentLoc = getParentInjectorLocation(tNode, lView);\n  const injectorIndex = tNode.injectorIndex; // If a parent injector can't be found, its location is set to -1.\n  // In that case, we don't need to set up a cumulative bloom\n\n  if (hasParentInjector(parentLoc)) {\n    const parentIndex = getParentInjectorIndex(parentLoc);\n    const parentLView = getParentInjectorView(parentLoc, lView);\n    const parentData = parentLView[TVIEW].data; // Creates a cumulative bloom filter that merges the parent's bloom filter\n    // and its own cumulative bloom (which contains tokens for all ancestors)\n\n    for (let i = 0; i < 8\n    /* NodeInjectorOffset.BLOOM_SIZE */\n    ; i++) {\n      lView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];\n    }\n  }\n\n  lView[injectorIndex + 8\n  /* NodeInjectorOffset.PARENT */\n  ] = parentLoc;\n  return injectorIndex;\n}\n\nfunction insertBloom(arr, footer) {\n  arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);\n}\n\nfunction getInjectorIndex(tNode, lView) {\n  if (tNode.injectorIndex === -1 || // If the injector index is the same as its parent's injector index, then the index has been\n  // copied down from the parent node. No injector has been created yet on this node.\n  tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex || // After the first template pass, the injector index might exist but the parent values\n  // might not have been calculated yet for this instance\n  lView[tNode.injectorIndex + 8\n  /* NodeInjectorOffset.PARENT */\n  ] === null) {\n    return -1;\n  } else {\n    ngDevMode && assertIndexInRange(lView, tNode.injectorIndex);\n    return tNode.injectorIndex;\n  }\n}\n/**\n * Finds the index of the parent injector, with a view offset if applicable. Used to set the\n * parent injector initially.\n *\n * @returns Returns a number that is the combination of the number of LViews that we have to go up\n * to find the LView containing the parent inject AND the index of the injector within that LView.\n */\n\n\nfunction getParentInjectorLocation(tNode, lView) {\n  if (tNode.parent && tNode.parent.injectorIndex !== -1) {\n    // If we have a parent `TNode` and there is an injector associated with it we are done, because\n    // the parent injector is within the current `LView`.\n    return tNode.parent.injectorIndex; // ViewOffset is 0\n  } // When parent injector location is computed it may be outside of the current view. (ie it could\n  // be pointing to a declared parent location). This variable stores number of declaration parents\n  // we need to walk up in order to find the parent injector location.\n\n\n  let declarationViewOffset = 0;\n  let parentTNode = null;\n  let lViewCursor = lView; // The parent injector is not in the current `LView`. We will have to walk the declared parent\n  // `LView` hierarchy and look for it. If we walk of the top, that means that there is no parent\n  // `NodeInjector`.\n\n  while (lViewCursor !== null) {\n    parentTNode = getTNodeFromLView(lViewCursor);\n\n    if (parentTNode === null) {\n      // If we have no parent, than we are done.\n      return NO_PARENT_INJECTOR;\n    }\n\n    ngDevMode && parentTNode && assertTNodeForLView(parentTNode, lViewCursor[DECLARATION_VIEW]); // Every iteration of the loop requires that we go to the declared parent.\n\n    declarationViewOffset++;\n    lViewCursor = lViewCursor[DECLARATION_VIEW];\n\n    if (parentTNode.injectorIndex !== -1) {\n      // We found a NodeInjector which points to something.\n      return parentTNode.injectorIndex | declarationViewOffset << 16\n      /* RelativeInjectorLocationFlags.ViewOffsetShift */\n      ;\n    }\n  }\n\n  return NO_PARENT_INJECTOR;\n}\n/**\n * Makes a type or an injection token public to the DI system by adding it to an\n * injector's bloom filter.\n *\n * @param di The node injector in which a directive will be added\n * @param token The type or the injection token to be made public\n */\n\n\nfunction diPublicInInjector(injectorIndex, tView, token) {\n  bloomAdd(injectorIndex, tView, token);\n}\n/**\n * Inject static attribute value into directive constructor.\n *\n * This method is used with `factory` functions which are generated as part of\n * `defineDirective` or `defineComponent`. The method retrieves the static value\n * of an attribute. (Dynamic attributes are not supported since they are not resolved\n *  at the time of injection and can change over time.)\n *\n * # Example\n * Given:\n * ```\n * @Component(...)\n * class MyComponent {\n *   constructor(@Attribute('title') title: string) { ... }\n * }\n * ```\n * When instantiated with\n * ```\n * <my-component title=\"Hello\"></my-component>\n * ```\n *\n * Then factory method generated is:\n * ```\n * MyComponent.ɵcmp = defineComponent({\n *   factory: () => new MyComponent(injectAttribute('title'))\n *   ...\n * })\n * ```\n *\n * @publicApi\n */\n\n\nfunction injectAttributeImpl(tNode, attrNameToInject) {\n  ngDevMode && assertTNodeType(tNode, 12\n  /* TNodeType.AnyContainer */\n  | 3\n  /* TNodeType.AnyRNode */\n  );\n  ngDevMode && assertDefined(tNode, 'expecting tNode');\n\n  if (attrNameToInject === 'class') {\n    return tNode.classes;\n  }\n\n  if (attrNameToInject === 'style') {\n    return tNode.styles;\n  }\n\n  const attrs = tNode.attrs;\n\n  if (attrs) {\n    const attrsLength = attrs.length;\n    let i = 0;\n\n    while (i < attrsLength) {\n      const value = attrs[i]; // If we hit a `Bindings` or `Template` marker then we are done.\n\n      if (isNameOnlyAttributeMarker(value)) break; // Skip namespaced attributes\n\n      if (value === 0\n      /* AttributeMarker.NamespaceURI */\n      ) {\n        // we skip the next two values\n        // as namespaced attributes looks like\n        // [..., AttributeMarker.NamespaceURI, 'http://someuri.com/test', 'test:exist',\n        // 'existValue', ...]\n        i = i + 2;\n      } else if (typeof value === 'number') {\n        // Skip to the first value of the marked attribute.\n        i++;\n\n        while (i < attrsLength && typeof attrs[i] === 'string') {\n          i++;\n        }\n      } else if (value === attrNameToInject) {\n        return attrs[i + 1];\n      } else {\n        i = i + 2;\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction notFoundValueOrThrow(notFoundValue, token, flags) {\n  if (flags & InjectFlags.Optional) {\n    return notFoundValue;\n  } else {\n    throwProviderNotFoundError(token, 'NodeInjector');\n  }\n}\n/**\n * Returns the value associated to the given token from the ModuleInjector or throws exception\n *\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`\n * @returns the value from the injector or throws an exception\n */\n\n\nfunction lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue) {\n  if (flags & InjectFlags.Optional && notFoundValue === undefined) {\n    // This must be set or the NullInjector will throw for optional deps\n    notFoundValue = null;\n  }\n\n  if ((flags & (InjectFlags.Self | InjectFlags.Host)) === 0) {\n    const moduleInjector = lView[INJECTOR$1]; // switch to `injectInjectorOnly` implementation for module injector, since module injector\n    // should not have access to Component/Directive DI scope (that may happen through\n    // `directiveInject` implementation)\n\n    const previousInjectImplementation = setInjectImplementation(undefined);\n\n    try {\n      if (moduleInjector) {\n        return moduleInjector.get(token, notFoundValue, flags & InjectFlags.Optional);\n      } else {\n        return injectRootLimpMode(token, notFoundValue, flags & InjectFlags.Optional);\n      }\n    } finally {\n      setInjectImplementation(previousInjectImplementation);\n    }\n  }\n\n  return notFoundValueOrThrow(notFoundValue, token, flags);\n}\n/**\n * Returns the value associated to the given token from the NodeInjectors => ModuleInjector.\n *\n * Look for the injector providing the token by walking up the node injector tree and then\n * the module injector tree.\n *\n * This function patches `token` with `__NG_ELEMENT_ID__` which contains the id for the bloom\n * filter. `-1` is reserved for injecting `Injector` (implemented by `NodeInjector`)\n *\n * @param tNode The Node where the search for the injector should start\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`\n * @returns the value from the injector, `null` when not found, or `notFoundValue` if provided\n */\n\n\nfunction getOrCreateInjectable(tNode, lView, token, flags = InjectFlags.Default, notFoundValue) {\n  if (tNode !== null) {\n    // If the view or any of its ancestors have an embedded\n    // view injector, we have to look it up there first.\n    if (lView[FLAGS] & 1024\n    /* LViewFlags.HasEmbeddedViewInjector */\n    ) {\n      const embeddedInjectorValue = lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, NOT_FOUND);\n\n      if (embeddedInjectorValue !== NOT_FOUND) {\n        return embeddedInjectorValue;\n      }\n    } // Otherwise try the node injector.\n\n\n    const value = lookupTokenUsingNodeInjector(tNode, lView, token, flags, NOT_FOUND);\n\n    if (value !== NOT_FOUND) {\n      return value;\n    }\n  } // Finally, fall back to the module injector.\n\n\n  return lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);\n}\n/**\n * Returns the value associated to the given token from the node injector.\n *\n * @param tNode The Node where the search for the injector should start\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`\n * @returns the value from the injector, `null` when not found, or `notFoundValue` if provided\n */\n\n\nfunction lookupTokenUsingNodeInjector(tNode, lView, token, flags, notFoundValue) {\n  const bloomHash = bloomHashBitOrFactory(token); // If the ID stored here is a function, this is a special object like ElementRef or TemplateRef\n  // so just call the factory function to create it.\n\n  if (typeof bloomHash === 'function') {\n    if (!enterDI(lView, tNode, flags)) {\n      // Failed to enter DI, try module injector instead. If a token is injected with the @Host\n      // flag, the module injector is not searched for that token in Ivy.\n      return flags & InjectFlags.Host ? notFoundValueOrThrow(notFoundValue, token, flags) : lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);\n    }\n\n    try {\n      const value = bloomHash(flags);\n\n      if (value == null && !(flags & InjectFlags.Optional)) {\n        throwProviderNotFoundError(token);\n      } else {\n        return value;\n      }\n    } finally {\n      leaveDI();\n    }\n  } else if (typeof bloomHash === 'number') {\n    // A reference to the previous injector TView that was found while climbing the element\n    // injector tree. This is used to know if viewProviders can be accessed on the current\n    // injector.\n    let previousTView = null;\n    let injectorIndex = getInjectorIndex(tNode, lView);\n    let parentLocation = NO_PARENT_INJECTOR;\n    let hostTElementNode = flags & InjectFlags.Host ? lView[DECLARATION_COMPONENT_VIEW][T_HOST] : null; // If we should skip this injector, or if there is no injector on this node, start by\n    // searching the parent injector.\n\n    if (injectorIndex === -1 || flags & InjectFlags.SkipSelf) {\n      parentLocation = injectorIndex === -1 ? getParentInjectorLocation(tNode, lView) : lView[injectorIndex + 8\n      /* NodeInjectorOffset.PARENT */\n      ];\n\n      if (parentLocation === NO_PARENT_INJECTOR || !shouldSearchParent(flags, false)) {\n        injectorIndex = -1;\n      } else {\n        previousTView = lView[TVIEW];\n        injectorIndex = getParentInjectorIndex(parentLocation);\n        lView = getParentInjectorView(parentLocation, lView);\n      }\n    } // Traverse up the injector tree until we find a potential match or until we know there\n    // *isn't* a match.\n\n\n    while (injectorIndex !== -1) {\n      ngDevMode && assertNodeInjector(lView, injectorIndex); // Check the current injector. If it matches, see if it contains token.\n\n      const tView = lView[TVIEW];\n      ngDevMode && assertTNodeForLView(tView.data[injectorIndex + 8\n      /* NodeInjectorOffset.TNODE */\n      ], lView);\n\n      if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {\n        // At this point, we have an injector which *may* contain the token, so we step through\n        // the providers and directives associated with the injector's corresponding node to get\n        // the instance.\n        const instance = searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode);\n\n        if (instance !== NOT_FOUND) {\n          return instance;\n        }\n      }\n\n      parentLocation = lView[injectorIndex + 8\n      /* NodeInjectorOffset.PARENT */\n      ];\n\n      if (parentLocation !== NO_PARENT_INJECTOR && shouldSearchParent(flags, lView[TVIEW].data[injectorIndex + 8\n      /* NodeInjectorOffset.TNODE */\n      ] === hostTElementNode) && bloomHasToken(bloomHash, injectorIndex, lView)) {\n        // The def wasn't found anywhere on this node, so it was a false positive.\n        // Traverse up the tree and continue searching.\n        previousTView = tView;\n        injectorIndex = getParentInjectorIndex(parentLocation);\n        lView = getParentInjectorView(parentLocation, lView);\n      } else {\n        // If we should not search parent OR If the ancestor bloom filter value does not have the\n        // bit corresponding to the directive we can give up on traversing up to find the specific\n        // injector.\n        injectorIndex = -1;\n      }\n    }\n  }\n\n  return notFoundValue;\n}\n\nfunction searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode) {\n  const currentTView = lView[TVIEW];\n  const tNode = currentTView.data[injectorIndex + 8\n  /* NodeInjectorOffset.TNODE */\n  ]; // First, we need to determine if view providers can be accessed by the starting element.\n  // There are two possibilities\n\n  const canAccessViewProviders = previousTView == null ? // 1) This is the first invocation `previousTView == null` which means that we are at the\n  // `TNode` of where injector is starting to look. In such a case the only time we are allowed\n  // to look into the ViewProviders is if:\n  // - we are on a component\n  // - AND the injector set `includeViewProviders` to true (implying that the token can see\n  // ViewProviders because it is the Component or a Service which itself was declared in\n  // ViewProviders)\n  isComponentHost(tNode) && includeViewProviders : // 2) `previousTView != null` which means that we are now walking across the parent nodes.\n  // In such a case we are only allowed to look into the ViewProviders if:\n  // - We just crossed from child View to Parent View `previousTView != currentTView`\n  // - AND the parent TNode is an Element.\n  // This means that we just came from the Component's View and therefore are allowed to see\n  // into the ViewProviders.\n  previousTView != currentTView && (tNode.type & 3\n  /* TNodeType.AnyRNode */\n  ) !== 0; // This special case happens when there is a @host on the inject and when we are searching\n  // on the host element node.\n\n  const isHostSpecialCase = flags & InjectFlags.Host && hostTElementNode === tNode;\n  const injectableIdx = locateDirectiveOrProvider(tNode, currentTView, token, canAccessViewProviders, isHostSpecialCase);\n\n  if (injectableIdx !== null) {\n    return getNodeInjectable(lView, currentTView, injectableIdx, tNode);\n  } else {\n    return NOT_FOUND;\n  }\n}\n/**\n * Searches for the given token among the node's directives and providers.\n *\n * @param tNode TNode on which directives are present.\n * @param tView The tView we are currently processing\n * @param token Provider token or type of a directive to look for.\n * @param canAccessViewProviders Whether view providers should be considered.\n * @param isHostSpecialCase Whether the host special case applies.\n * @returns Index of a found directive or provider, or null when none found.\n */\n\n\nfunction locateDirectiveOrProvider(tNode, tView, token, canAccessViewProviders, isHostSpecialCase) {\n  const nodeProviderIndexes = tNode.providerIndexes;\n  const tInjectables = tView.data;\n  const injectablesStart = nodeProviderIndexes & 1048575\n  /* TNodeProviderIndexes.ProvidersStartIndexMask */\n  ;\n  const directivesStart = tNode.directiveStart;\n  const directiveEnd = tNode.directiveEnd;\n  const cptViewProvidersCount = nodeProviderIndexes >> 20\n  /* TNodeProviderIndexes.CptViewProvidersCountShift */\n  ;\n  const startingIndex = canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount; // When the host special case applies, only the viewProviders and the component are visible\n\n  const endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;\n\n  for (let i = startingIndex; i < endIndex; i++) {\n    const providerTokenOrDef = tInjectables[i];\n\n    if (i < directivesStart && token === providerTokenOrDef || i >= directivesStart && providerTokenOrDef.type === token) {\n      return i;\n    }\n  }\n\n  if (isHostSpecialCase) {\n    const dirDef = tInjectables[directivesStart];\n\n    if (dirDef && isComponentDef(dirDef) && dirDef.type === token) {\n      return directivesStart;\n    }\n  }\n\n  return null;\n}\n/**\n * Retrieve or instantiate the injectable from the `LView` at particular `index`.\n *\n * This function checks to see if the value has already been instantiated and if so returns the\n * cached `injectable`. Otherwise if it detects that the value is still a factory it\n * instantiates the `injectable` and caches the value.\n */\n\n\nfunction getNodeInjectable(lView, tView, index, tNode) {\n  let value = lView[index];\n  const tData = tView.data;\n\n  if (isFactory(value)) {\n    const factory = value;\n\n    if (factory.resolving) {\n      throwCyclicDependencyError(stringifyForError(tData[index]));\n    }\n\n    const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);\n    factory.resolving = true;\n    const previousInjectImplementation = factory.injectImpl ? setInjectImplementation(factory.injectImpl) : null;\n    const success = enterDI(lView, tNode, InjectFlags.Default);\n    ngDevMode && assertEqual(success, true, 'Because flags do not contain \\`SkipSelf\\' we expect this to always succeed.');\n\n    try {\n      value = lView[index] = factory.factory(undefined, tData, lView, tNode); // This code path is hit for both directives and providers.\n      // For perf reasons, we want to avoid searching for hooks on providers.\n      // It does no harm to try (the hooks just won't exist), but the extra\n      // checks are unnecessary and this is a hot path. So we check to see\n      // if the index of the dependency is in the directive range for this\n      // tNode. If it's not, we know it's a provider and skip hook registration.\n\n      if (tView.firstCreatePass && index >= tNode.directiveStart) {\n        ngDevMode && assertDirectiveDef(tData[index]);\n        registerPreOrderHooks(index, tData[index], tView);\n      }\n    } finally {\n      previousInjectImplementation !== null && setInjectImplementation(previousInjectImplementation);\n      setIncludeViewProviders(previousIncludeViewProviders);\n      factory.resolving = false;\n      leaveDI();\n    }\n  }\n\n  return value;\n}\n/**\n * Returns the bit in an injector's bloom filter that should be used to determine whether or not\n * the directive might be provided by the injector.\n *\n * When a directive is public, it is added to the bloom filter and given a unique ID that can be\n * retrieved on the Type. When the directive isn't public or the token is not a directive `null`\n * is returned as the node injector can not possibly provide that token.\n *\n * @param token the injection token\n * @returns the matching bit to check in the bloom filter or `null` if the token is not known.\n *   When the returned value is negative then it represents special values such as `Injector`.\n */\n\n\nfunction bloomHashBitOrFactory(token) {\n  ngDevMode && assertDefined(token, 'token must be defined');\n\n  if (typeof token === 'string') {\n    return token.charCodeAt(0) || 0;\n  }\n\n  const tokenId = // First check with `hasOwnProperty` so we don't get an inherited ID.\n  token.hasOwnProperty(NG_ELEMENT_ID) ? token[NG_ELEMENT_ID] : undefined; // Negative token IDs are used for special objects such as `Injector`\n\n  if (typeof tokenId === 'number') {\n    if (tokenId >= 0) {\n      return tokenId & BLOOM_MASK;\n    } else {\n      ngDevMode && assertEqual(tokenId, -1\n      /* InjectorMarkers.Injector */\n      , 'Expecting to get Special Injector Id');\n      return createNodeInjector;\n    }\n  } else {\n    return tokenId;\n  }\n}\n\nfunction bloomHasToken(bloomHash, injectorIndex, injectorView) {\n  // Create a mask that targets the specific bit associated with the directive we're looking for.\n  // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n  // to bit positions 0 - 31 in a 32 bit integer.\n  const mask = 1 << bloomHash; // Each bloom bucket in `injectorView` represents `BLOOM_BUCKET_BITS` number of bits of\n  // `bloomHash`. Any bits in `bloomHash` beyond `BLOOM_BUCKET_BITS` indicate the bucket offset\n  // that should be used.\n\n  const value = injectorView[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)]; // If the bloom filter value has the bit corresponding to the directive's bloomBit flipped on,\n  // this injector is a potential match.\n\n  return !!(value & mask);\n}\n/** Returns true if flags prevent parent injector from being searched for tokens */\n\n\nfunction shouldSearchParent(flags, isFirstHostTNode) {\n  return !(flags & InjectFlags.Self) && !(flags & InjectFlags.Host && isFirstHostTNode);\n}\n\nclass NodeInjector {\n  constructor(_tNode, _lView) {\n    this._tNode = _tNode;\n    this._lView = _lView;\n  }\n\n  get(token, notFoundValue, flags) {\n    return getOrCreateInjectable(this._tNode, this._lView, token, flags, notFoundValue);\n  }\n\n}\n/** Creates a `NodeInjector` for the current node. */\n\n\nfunction createNodeInjector() {\n  return new NodeInjector(getCurrentTNode(), getLView());\n}\n/**\n * @codeGenApi\n */\n\n\nfunction ɵɵgetInheritedFactory(type) {\n  return noSideEffects(() => {\n    const ownConstructor = type.prototype.constructor;\n    const ownFactory = ownConstructor[NG_FACTORY_DEF] || getFactoryOf(ownConstructor);\n    const objectPrototype = Object.prototype;\n    let parent = Object.getPrototypeOf(type.prototype).constructor; // Go up the prototype until we hit `Object`.\n\n    while (parent && parent !== objectPrototype) {\n      const factory = parent[NG_FACTORY_DEF] || getFactoryOf(parent); // If we hit something that has a factory and the factory isn't the same as the type,\n      // we've found the inherited factory. Note the check that the factory isn't the type's\n      // own factory is redundant in most cases, but if the user has custom decorators on the\n      // class, this lookup will start one level down in the prototype chain, causing us to\n      // find the own factory first and potentially triggering an infinite loop downstream.\n\n      if (factory && factory !== ownFactory) {\n        return factory;\n      }\n\n      parent = Object.getPrototypeOf(parent);\n    } // There is no factory defined. Either this was improper usage of inheritance\n    // (no Angular decorator on the superclass) or there is no constructor at all\n    // in the inheritance chain. Since the two cases cannot be distinguished, the\n    // latter has to be assumed.\n\n\n    return t => new t();\n  });\n}\n\nfunction getFactoryOf(type) {\n  if (isForwardRef(type)) {\n    return () => {\n      const factory = getFactoryOf(resolveForwardRef(type));\n      return factory && factory();\n    };\n  }\n\n  return getFactoryDef(type);\n}\n/**\n * Returns a value from the closest embedded or node injector.\n *\n * @param tNode The Node where the search for the injector should start\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`\n * @returns the value from the injector, `null` when not found, or `notFoundValue` if provided\n */\n\n\nfunction lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, notFoundValue) {\n  let currentTNode = tNode;\n  let currentLView = lView; // When an LView with an embedded view injector is inserted, it'll likely be interlaced with\n  // nodes who may have injectors (e.g. node injector -> embedded view injector -> node injector).\n  // Since the bloom filters for the node injectors have already been constructed and we don't\n  // have a way of extracting the records from an injector, the only way to maintain the correct\n  // hierarchy when resolving the value is to walk it node-by-node while attempting to resolve\n  // the token at each level.\n\n  while (currentTNode !== null && currentLView !== null && currentLView[FLAGS] & 1024\n  /* LViewFlags.HasEmbeddedViewInjector */\n  && !(currentLView[FLAGS] & 256\n  /* LViewFlags.IsRoot */\n  )) {\n    ngDevMode && assertTNodeForLView(currentTNode, currentLView); // Note that this lookup on the node injector is using the `Self` flag, because\n    // we don't want the node injector to look at any parent injectors since we\n    // may hit the embedded view injector first.\n\n    const nodeInjectorValue = lookupTokenUsingNodeInjector(currentTNode, currentLView, token, flags | InjectFlags.Self, NOT_FOUND);\n\n    if (nodeInjectorValue !== NOT_FOUND) {\n      return nodeInjectorValue;\n    } // Has an explicit type due to a TS bug: https://github.com/microsoft/TypeScript/issues/33191\n\n\n    let parentTNode = currentTNode.parent; // `TNode.parent` includes the parent within the current view only. If it doesn't exist,\n    // it means that we've hit the view boundary and we need to go up to the next view.\n\n    if (!parentTNode) {\n      // Before we go to the next LView, check if the token exists on the current embedded injector.\n      const embeddedViewInjector = currentLView[EMBEDDED_VIEW_INJECTOR];\n\n      if (embeddedViewInjector) {\n        const embeddedViewInjectorValue = embeddedViewInjector.get(token, NOT_FOUND, flags);\n\n        if (embeddedViewInjectorValue !== NOT_FOUND) {\n          return embeddedViewInjectorValue;\n        }\n      } // Otherwise keep going up the tree.\n\n\n      parentTNode = getTNodeFromLView(currentLView);\n      currentLView = currentLView[DECLARATION_VIEW];\n    }\n\n    currentTNode = parentTNode;\n  }\n\n  return notFoundValue;\n}\n/** Gets the TNode associated with an LView inside of the declaration view. */\n\n\nfunction getTNodeFromLView(lView) {\n  const tView = lView[TVIEW];\n  const tViewType = tView.type; // The parent pointer differs based on `TView.type`.\n\n  if (tViewType === 2\n  /* TViewType.Embedded */\n  ) {\n    ngDevMode && assertDefined(tView.declTNode, 'Embedded TNodes should have declaration parents.');\n    return tView.declTNode;\n  } else if (tViewType === 1\n  /* TViewType.Component */\n  ) {\n    // Components don't have `TView.declTNode` because each instance of component could be\n    // inserted in different location, hence `TView.declTNode` is meaningless.\n    return lView[T_HOST];\n  }\n\n  return null;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Facade for the attribute injection from DI.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵinjectAttribute(attrNameToInject) {\n  return injectAttributeImpl(getCurrentTNode(), attrNameToInject);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Attribute decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\n\n\nconst Attribute = makeParamDecorator('Attribute', attributeName => ({\n  attributeName,\n  __NG_ELEMENT_ID__: () => ɵɵinjectAttribute(attributeName)\n}));\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nlet _reflect = null;\n\nfunction getReflect() {\n  return _reflect = _reflect || new ReflectionCapabilities();\n}\n\nfunction reflectDependencies(type) {\n  return convertDependencies(getReflect().parameters(type));\n}\n\nfunction convertDependencies(deps) {\n  return deps.map(dep => reflectDependency(dep));\n}\n\nfunction reflectDependency(dep) {\n  const meta = {\n    token: null,\n    attribute: null,\n    host: false,\n    optional: false,\n    self: false,\n    skipSelf: false\n  };\n\n  if (Array.isArray(dep) && dep.length > 0) {\n    for (let j = 0; j < dep.length; j++) {\n      const param = dep[j];\n\n      if (param === undefined) {\n        // param may be undefined if type of dep is not set by ngtsc\n        continue;\n      }\n\n      const proto = Object.getPrototypeOf(param);\n\n      if (param instanceof Optional || proto.ngMetadataName === 'Optional') {\n        meta.optional = true;\n      } else if (param instanceof SkipSelf || proto.ngMetadataName === 'SkipSelf') {\n        meta.skipSelf = true;\n      } else if (param instanceof Self || proto.ngMetadataName === 'Self') {\n        meta.self = true;\n      } else if (param instanceof Host || proto.ngMetadataName === 'Host') {\n        meta.host = true;\n      } else if (param instanceof Inject) {\n        meta.token = param.token;\n      } else if (param instanceof Attribute) {\n        if (param.attributeName === undefined) {\n          throw new Error(`Attribute name must be defined.`);\n        }\n\n        meta.attribute = param.attributeName;\n      } else {\n        meta.token = param;\n      }\n    }\n  } else if (dep === undefined || Array.isArray(dep) && dep.length === 0) {\n    meta.token = null;\n  } else {\n    meta.token = dep;\n  }\n\n  return meta;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Map of module-id to the corresponding NgModule.\n */\n\n\nconst modules = new Map();\n/**\n * Whether to check for duplicate NgModule registrations.\n *\n * This can be disabled for testing.\n */\n\nlet checkForDuplicateNgModules = true;\n\nfunction assertSameOrNotExisting(id, type, incoming) {\n  if (type && type !== incoming && checkForDuplicateNgModules) {\n    throw new Error(`Duplicate module registered for ${id} - ${stringify(type)} vs ${stringify(type.name)}`);\n  }\n}\n/**\n * Adds the given NgModule type to Angular's NgModule registry.\n *\n * This is generated as a side-effect of NgModule compilation. Note that the `id` is passed in\n * explicitly and not read from the NgModule definition. This is for two reasons: it avoids a\n * megamorphic read, and in JIT there's a chicken-and-egg problem where the NgModule may not be\n * fully resolved when it's registered.\n *\n * @codeGenApi\n */\n\n\nfunction registerNgModuleType(ngModuleType, id) {\n  const existing = modules.get(id) || null;\n  assertSameOrNotExisting(id, existing, ngModuleType);\n  modules.set(id, ngModuleType);\n}\n\nfunction clearModulesForTest() {\n  modules.clear();\n}\n\nfunction getRegisteredNgModuleType(id) {\n  return modules.get(id);\n}\n/**\n * Control whether the NgModule registration system enforces that each NgModule type registered has\n * a unique id.\n *\n * This is useful for testing as the NgModule registry cannot be properly reset between tests with\n * Angular's current API.\n */\n\n\nfunction setAllowDuplicateNgModuleIdsForTest(allowDuplicates) {\n  checkForDuplicateNgModules = !allowDuplicates;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nconst defaultScheduler = (() => (typeof requestAnimationFrame !== 'undefined' && requestAnimationFrame || // browser only\nsetTimeout // everything else\n).bind(_global$1))();\n/**\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵresolveWindow(element) {\n  return element.ownerDocument.defaultView;\n}\n/**\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵresolveDocument(element) {\n  return element.ownerDocument;\n}\n/**\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵresolveBody(element) {\n  return element.ownerDocument.body;\n}\n/**\n * The special delimiter we use to separate property names, prefixes, and suffixes\n * in property binding metadata. See storeBindingMetadata().\n *\n * We intentionally use the Unicode \"REPLACEMENT CHARACTER\" (U+FFFD) as a delimiter\n * because it is a very uncommon character that is unlikely to be part of a user's\n * property names or interpolation strings. If it is in fact used in a property\n * binding, DebugElement.properties will not return the correct value for that\n * binding. However, there should be no runtime effect for real applications.\n *\n * This character is typically rendered as a question mark inside of a diamond.\n * See https://en.wikipedia.org/wiki/Specials_(Unicode_block)\n *\n */\n\n\nconst INTERPOLATION_DELIMITER = `�`;\n/**\n * Unwrap a value which might be behind a closure (for forward declaration reasons).\n */\n\nfunction maybeUnwrapFn$1(value) {\n  if (value instanceof Function) {\n    return value();\n  } else {\n    return value;\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * The Trusted Types policy, or null if Trusted Types are not\n * enabled/supported, or undefined if the policy has not been created yet.\n */\n\n\nlet policy$1;\n/**\n * Returns the Trusted Types policy, or null if Trusted Types are not\n * enabled/supported. The first call to this function will create the policy.\n */\n\nfunction getPolicy$1() {\n  if (policy$1 === undefined) {\n    policy$1 = null;\n\n    if (_global$1.trustedTypes) {\n      try {\n        policy$1 = _global$1.trustedTypes.createPolicy('angular', {\n          createHTML: s => s,\n          createScript: s => s,\n          createScriptURL: s => s\n        });\n      } catch (_a) {// trustedTypes.createPolicy throws if called with a name that is\n        // already registered, even in report-only mode. Until the API changes,\n        // catch the error not to break the applications functionally. In such\n        // cases, the code will fall back to using strings.\n      }\n    }\n  }\n\n  return policy$1;\n}\n/**\n * Unsafely promote a string to a TrustedHTML, falling back to strings when\n * Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that the\n * provided string will never cause an XSS vulnerability if used in a context\n * that will be interpreted as HTML by a browser, e.g. when assigning to\n * element.innerHTML.\n */\n\n\nfunction trustedHTMLFromString(html) {\n  var _a;\n\n  return ((_a = getPolicy$1()) === null || _a === void 0 ? void 0 : _a.createHTML(html)) || html;\n}\n/**\n * Unsafely promote a string to a TrustedScript, falling back to strings when\n * Trusted Types are not available.\n * @security In particular, it must be assured that the provided string will\n * never cause an XSS vulnerability if used in a context that will be\n * interpreted and executed as a script by a browser, e.g. when calling eval.\n */\n\n\nfunction trustedScriptFromString(script) {\n  var _a;\n\n  return ((_a = getPolicy$1()) === null || _a === void 0 ? void 0 : _a.createScript(script)) || script;\n}\n/**\n * Unsafely promote a string to a TrustedScriptURL, falling back to strings\n * when Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that the\n * provided string will never cause an XSS vulnerability if used in a context\n * that will cause a browser to load and execute a resource, e.g. when\n * assigning to script.src.\n */\n\n\nfunction trustedScriptURLFromString(url) {\n  var _a;\n\n  return ((_a = getPolicy$1()) === null || _a === void 0 ? void 0 : _a.createScriptURL(url)) || url;\n}\n/**\n * Unsafely call the Function constructor with the given string arguments. It\n * is only available in development mode, and should be stripped out of\n * production code.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only called from development code, as use in production code can lead to\n * XSS vulnerabilities.\n */\n\n\nfunction newTrustedFunctionForDev(...args) {\n  if (typeof ngDevMode === 'undefined') {\n    throw new Error('newTrustedFunctionForDev should never be called in production');\n  }\n\n  if (!_global$1.trustedTypes) {\n    // In environments that don't support Trusted Types, fall back to the most\n    // straightforward implementation:\n    return new Function(...args);\n  } // Chrome currently does not support passing TrustedScript to the Function\n  // constructor. The following implements the workaround proposed on the page\n  // below, where the Chromium bug is also referenced:\n  // https://github.com/w3c/webappsec-trusted-types/wiki/Trusted-Types-for-function-constructor\n\n\n  const fnArgs = args.slice(0, -1).join(',');\n  const fnBody = args[args.length - 1];\n  const body = `(function anonymous(${fnArgs}\n) { ${fnBody}\n})`; // Using eval directly confuses the compiler and prevents this module from\n  // being stripped out of JS binaries even if not used. The global['eval']\n  // indirection fixes that.\n\n  const fn = _global$1['eval'](trustedScriptFromString(body));\n\n  if (fn.bind === undefined) {\n    // Workaround for a browser bug that only exists in Chrome 83, where passing\n    // a TrustedScript to eval just returns the TrustedScript back without\n    // evaluating it. In that case, fall back to the most straightforward\n    // implementation:\n    return new Function(...args);\n  } // To completely mimic the behavior of calling \"new Function\", two more\n  // things need to happen:\n  // 1. Stringifying the resulting function should return its source code\n\n\n  fn.toString = () => body; // 2. When calling the resulting function, `this` should refer to `global`\n\n\n  return fn.bind(_global$1); // When Trusted Types support in Function constructors is widely available,\n  // the implementation of this function can be simplified to:\n  // return new Function(...args.map(a => trustedScriptFromString(a)));\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * The Trusted Types policy, or null if Trusted Types are not\n * enabled/supported, or undefined if the policy has not been created yet.\n */\n\n\nlet policy;\n/**\n * Returns the Trusted Types policy, or null if Trusted Types are not\n * enabled/supported. The first call to this function will create the policy.\n */\n\nfunction getPolicy() {\n  if (policy === undefined) {\n    policy = null;\n\n    if (_global$1.trustedTypes) {\n      try {\n        policy = _global$1.trustedTypes.createPolicy('angular#unsafe-bypass', {\n          createHTML: s => s,\n          createScript: s => s,\n          createScriptURL: s => s\n        });\n      } catch (_a) {// trustedTypes.createPolicy throws if called with a name that is\n        // already registered, even in report-only mode. Until the API changes,\n        // catch the error not to break the applications functionally. In such\n        // cases, the code will fall back to using strings.\n      }\n    }\n  }\n\n  return policy;\n}\n/**\n * Unsafely promote a string to a TrustedHTML, falling back to strings when\n * Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only passed strings that come directly from custom sanitizers or the\n * bypassSecurityTrust* functions.\n */\n\n\nfunction trustedHTMLFromStringBypass(html) {\n  var _a;\n\n  return ((_a = getPolicy()) === null || _a === void 0 ? void 0 : _a.createHTML(html)) || html;\n}\n/**\n * Unsafely promote a string to a TrustedScript, falling back to strings when\n * Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only passed strings that come directly from custom sanitizers or the\n * bypassSecurityTrust* functions.\n */\n\n\nfunction trustedScriptFromStringBypass(script) {\n  var _a;\n\n  return ((_a = getPolicy()) === null || _a === void 0 ? void 0 : _a.createScript(script)) || script;\n}\n/**\n * Unsafely promote a string to a TrustedScriptURL, falling back to strings\n * when Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only passed strings that come directly from custom sanitizers or the\n * bypassSecurityTrust* functions.\n */\n\n\nfunction trustedScriptURLFromStringBypass(url) {\n  var _a;\n\n  return ((_a = getPolicy()) === null || _a === void 0 ? void 0 : _a.createScriptURL(url)) || url;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nclass SafeValueImpl {\n  constructor(changingThisBreaksApplicationSecurity) {\n    this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;\n  }\n\n  toString() {\n    return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity}` + ` (see https://g.co/ng/security#xss)`;\n  }\n\n}\n\nclass SafeHtmlImpl extends SafeValueImpl {\n  getTypeName() {\n    return \"HTML\"\n    /* BypassType.Html */\n    ;\n  }\n\n}\n\nclass SafeStyleImpl extends SafeValueImpl {\n  getTypeName() {\n    return \"Style\"\n    /* BypassType.Style */\n    ;\n  }\n\n}\n\nclass SafeScriptImpl extends SafeValueImpl {\n  getTypeName() {\n    return \"Script\"\n    /* BypassType.Script */\n    ;\n  }\n\n}\n\nclass SafeUrlImpl extends SafeValueImpl {\n  getTypeName() {\n    return \"URL\"\n    /* BypassType.Url */\n    ;\n  }\n\n}\n\nclass SafeResourceUrlImpl extends SafeValueImpl {\n  getTypeName() {\n    return \"ResourceURL\"\n    /* BypassType.ResourceUrl */\n    ;\n  }\n\n}\n\nfunction unwrapSafeValue(value) {\n  return value instanceof SafeValueImpl ? value.changingThisBreaksApplicationSecurity : value;\n}\n\nfunction allowSanitizationBypassAndThrow(value, type) {\n  const actualType = getSanitizationBypassType(value);\n\n  if (actualType != null && actualType !== type) {\n    // Allow ResourceURLs in URL contexts, they are strictly more trusted.\n    if (actualType === \"ResourceURL\"\n    /* BypassType.ResourceUrl */\n    && type === \"URL\"\n    /* BypassType.Url */\n    ) return true;\n    throw new Error(`Required a safe ${type}, got a ${actualType} (see https://g.co/ng/security#xss)`);\n  }\n\n  return actualType === type;\n}\n\nfunction getSanitizationBypassType(value) {\n  return value instanceof SafeValueImpl && value.getTypeName() || null;\n}\n/**\n * Mark `html` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link htmlSanitizer} to be trusted implicitly.\n *\n * @param trustedHtml `html` string which needs to be implicitly trusted.\n * @returns a `html` which has been branded to be implicitly trusted.\n */\n\n\nfunction bypassSanitizationTrustHtml(trustedHtml) {\n  return new SafeHtmlImpl(trustedHtml);\n}\n/**\n * Mark `style` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link styleSanitizer} to be trusted implicitly.\n *\n * @param trustedStyle `style` string which needs to be implicitly trusted.\n * @returns a `style` hich has been branded to be implicitly trusted.\n */\n\n\nfunction bypassSanitizationTrustStyle(trustedStyle) {\n  return new SafeStyleImpl(trustedStyle);\n}\n/**\n * Mark `script` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link scriptSanitizer} to be trusted implicitly.\n *\n * @param trustedScript `script` string which needs to be implicitly trusted.\n * @returns a `script` which has been branded to be implicitly trusted.\n */\n\n\nfunction bypassSanitizationTrustScript(trustedScript) {\n  return new SafeScriptImpl(trustedScript);\n}\n/**\n * Mark `url` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link urlSanitizer} to be trusted implicitly.\n *\n * @param trustedUrl `url` string which needs to be implicitly trusted.\n * @returns a `url`  which has been branded to be implicitly trusted.\n */\n\n\nfunction bypassSanitizationTrustUrl(trustedUrl) {\n  return new SafeUrlImpl(trustedUrl);\n}\n/**\n * Mark `url` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link resourceUrlSanitizer} to be trusted implicitly.\n *\n * @param trustedResourceUrl `url` string which needs to be implicitly trusted.\n * @returns a `url` which has been branded to be implicitly trusted.\n */\n\n\nfunction bypassSanitizationTrustResourceUrl(trustedResourceUrl) {\n  return new SafeResourceUrlImpl(trustedResourceUrl);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * This helper is used to get hold of an inert tree of DOM elements containing dirty HTML\n * that needs sanitizing.\n * Depending upon browser support we use one of two strategies for doing this.\n * Default: DOMParser strategy\n * Fallback: InertDocument strategy\n */\n\n\nfunction getInertBodyHelper(defaultDoc) {\n  const inertDocumentHelper = new InertDocumentHelper(defaultDoc);\n  return isDOMParserAvailable() ? new DOMParserHelper(inertDocumentHelper) : inertDocumentHelper;\n}\n/**\n * Uses DOMParser to create and fill an inert body element.\n * This is the default strategy used in browsers that support it.\n */\n\n\nclass DOMParserHelper {\n  constructor(inertDocumentHelper) {\n    this.inertDocumentHelper = inertDocumentHelper;\n  }\n\n  getInertBodyElement(html) {\n    // We add these extra elements to ensure that the rest of the content is parsed as expected\n    // e.g. leading whitespace is maintained and tags like `<meta>` do not get hoisted to the\n    // `<head>` tag. Note that the `<body>` tag is closed implicitly to prevent unclosed tags\n    // in `html` from consuming the otherwise explicit `</body>` tag.\n    html = '<body><remove></remove>' + html;\n\n    try {\n      const body = new window.DOMParser().parseFromString(trustedHTMLFromString(html), 'text/html').body;\n\n      if (body === null) {\n        // In some browsers (e.g. Mozilla/5.0 iPad AppleWebKit Mobile) the `body` property only\n        // becomes available in the following tick of the JS engine. In that case we fall back to\n        // the `inertDocumentHelper` instead.\n        return this.inertDocumentHelper.getInertBodyElement(html);\n      }\n\n      body.removeChild(body.firstChild);\n      return body;\n    } catch (_a) {\n      return null;\n    }\n  }\n\n}\n/**\n * Use an HTML5 `template` element, if supported, or an inert body element created via\n * `createHtmlDocument` to create and fill an inert DOM element.\n * This is the fallback strategy if the browser does not support DOMParser.\n */\n\n\nclass InertDocumentHelper {\n  constructor(defaultDoc) {\n    this.defaultDoc = defaultDoc;\n    this.inertDocument = this.defaultDoc.implementation.createHTMLDocument('sanitization-inert');\n\n    if (this.inertDocument.body == null) {\n      // usually there should be only one body element in the document, but IE doesn't have any, so\n      // we need to create one.\n      const inertHtml = this.inertDocument.createElement('html');\n      this.inertDocument.appendChild(inertHtml);\n      const inertBodyElement = this.inertDocument.createElement('body');\n      inertHtml.appendChild(inertBodyElement);\n    }\n  }\n\n  getInertBodyElement(html) {\n    // Prefer using <template> element if supported.\n    const templateEl = this.inertDocument.createElement('template');\n\n    if ('content' in templateEl) {\n      templateEl.innerHTML = trustedHTMLFromString(html);\n      return templateEl;\n    } // Note that previously we used to do something like `this.inertDocument.body.innerHTML = html`\n    // and we returned the inert `body` node. This was changed, because IE seems to treat setting\n    // `innerHTML` on an inserted element differently, compared to one that hasn't been inserted\n    // yet. In particular, IE appears to split some of the text into multiple text nodes rather\n    // than keeping them in a single one which ends up messing with Ivy's i18n parsing further\n    // down the line. This has been worked around by creating a new inert `body` and using it as\n    // the root node in which we insert the HTML.\n\n\n    const inertBody = this.inertDocument.createElement('body');\n    inertBody.innerHTML = trustedHTMLFromString(html); // Support: IE 11 only\n    // strip custom-namespaced attributes on IE<=11\n\n    if (this.defaultDoc.documentMode) {\n      this.stripCustomNsAttrs(inertBody);\n    }\n\n    return inertBody;\n  }\n  /**\n   * When IE11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1'\n   * attribute to declare ns1 namespace and prefixes the attribute with 'ns1' (e.g.\n   * 'ns1:xlink:foo').\n   *\n   * This is undesirable since we don't want to allow any of these custom attributes. This method\n   * strips them all.\n   */\n\n\n  stripCustomNsAttrs(el) {\n    const elAttrs = el.attributes; // loop backwards so that we can support removals.\n\n    for (let i = elAttrs.length - 1; 0 < i; i--) {\n      const attrib = elAttrs.item(i);\n      const attrName = attrib.name;\n\n      if (attrName === 'xmlns:ns1' || attrName.indexOf('ns1:') === 0) {\n        el.removeAttribute(attrName);\n      }\n    }\n\n    let childNode = el.firstChild;\n\n    while (childNode) {\n      if (childNode.nodeType === Node.ELEMENT_NODE) this.stripCustomNsAttrs(childNode);\n      childNode = childNode.nextSibling;\n    }\n  }\n\n}\n/**\n * We need to determine whether the DOMParser exists in the global context and\n * supports parsing HTML; HTML parsing support is not as wide as other formats, see\n * https://developer.mozilla.org/en-US/docs/Web/API/DOMParser#Browser_compatibility.\n *\n * @suppress {uselessCode}\n */\n\n\nfunction isDOMParserAvailable() {\n  try {\n    return !!new window.DOMParser().parseFromString(trustedHTMLFromString(''), 'text/html');\n  } catch (_a) {\n    return false;\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A pattern that recognizes a commonly useful subset of URLs that are safe.\n *\n * This regular expression matches a subset of URLs that will not cause script\n * execution if used in URL context within a HTML document. Specifically, this\n * regular expression matches if (comment from here on and regex copied from\n * Soy's EscapingConventions):\n * (1) Either an allowed protocol (http, https, mailto or ftp).\n * (2) or no protocol.  A protocol must be followed by a colon. The below\n *     allows that by allowing colons only after one of the characters [/?#].\n *     A colon after a hash (#) must be in the fragment.\n *     Otherwise, a colon after a (?) must be in a query.\n *     Otherwise, a colon after a single solidus (/) must be in a path.\n *     Otherwise, a colon after a double solidus (//) must be in the authority\n *     (before port).\n *\n * The pattern disallows &, used in HTML entity declarations before\n * one of the characters in [/?#]. This disallows HTML entities used in the\n * protocol name, which should never happen, e.g. \"h&#116;tp\" for \"http\".\n * It also disallows HTML entities in the first path part of a relative path,\n * e.g. \"foo&lt;bar/baz\".  Our existing escaping functions should not produce\n * that. More importantly, it disallows masking of a colon,\n * e.g. \"javascript&#58;...\".\n *\n * This regular expression was taken from the Closure sanitization library.\n */\n\n\nconst SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi;\n/* A pattern that matches safe srcset values */\n\nconst SAFE_SRCSET_PATTERN = /^(?:(?:https?|file):|[^&:/?#]*(?:[/?#]|$))/gi;\n/** A pattern that matches safe data URLs. Only matches image, video and audio types. */\n\nconst DATA_URL_PATTERN = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\\/]+=*$/i;\n\nfunction _sanitizeUrl(url) {\n  url = String(url);\n  if (url.match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN)) return url;\n\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    console.warn(`WARNING: sanitizing unsafe URL value ${url} (see https://g.co/ng/security#xss)`);\n  }\n\n  return 'unsafe:' + url;\n}\n\nfunction sanitizeSrcset(srcset) {\n  srcset = String(srcset);\n  return srcset.split(',').map(srcset => _sanitizeUrl(srcset.trim())).join(', ');\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction tagSet(tags) {\n  const res = {};\n\n  for (const t of tags.split(',')) res[t] = true;\n\n  return res;\n}\n\nfunction merge(...sets) {\n  const res = {};\n\n  for (const s of sets) {\n    for (const v in s) {\n      if (s.hasOwnProperty(v)) res[v] = true;\n    }\n  }\n\n  return res;\n} // Good source of info about elements and attributes\n// https://html.spec.whatwg.org/#semantics\n// https://simon.html5.org/html-elements\n// Safe Void Elements - HTML5\n// https://html.spec.whatwg.org/#void-elements\n\n\nconst VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr'); // Elements that you can, intentionally, leave open (and which close themselves)\n// https://html.spec.whatwg.org/#optional-tags\n\nconst OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');\nconst OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet('rp,rt');\nconst OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS); // Safe Block Elements - HTML5\n\nconst BLOCK_ELEMENTS = merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet('address,article,' + 'aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' + 'h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul')); // Inline Elements - HTML5\n\nconst INLINE_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet('a,abbr,acronym,audio,b,' + 'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,' + 'samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'));\nconst VALID_ELEMENTS = merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS); // Attributes that have href and hence need to be sanitized\n\nconst URI_ATTRS = tagSet('background,cite,href,itemtype,longdesc,poster,src,xlink:href'); // Attributes that have special href set hence need to be sanitized\n\nconst SRCSET_ATTRS = tagSet('srcset');\nconst HTML_ATTRS = tagSet('abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,' + 'compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,' + 'ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,' + 'scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,' + 'valign,value,vspace,width'); // Accessibility attributes as per WAI-ARIA 1.1 (W3C Working Draft 14 December 2018)\n\nconst ARIA_ATTRS = tagSet('aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,' + 'aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,' + 'aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,' + 'aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,' + 'aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,' + 'aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,' + 'aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext'); // NB: This currently consciously doesn't support SVG. SVG sanitization has had several security\n// issues in the past, so it seems safer to leave it out if possible. If support for binding SVG via\n// innerHTML is required, SVG attributes should be added here.\n// NB: Sanitization does not allow <form> elements or other active elements (<button> etc). Those\n// can be sanitized, but they increase security surface area without a legitimate use case, so they\n// are left out here.\n\nconst VALID_ATTRS = merge(URI_ATTRS, SRCSET_ATTRS, HTML_ATTRS, ARIA_ATTRS); // Elements whose content should not be traversed/preserved, if the elements themselves are invalid.\n//\n// Typically, `<invalid>Some content</invalid>` would traverse (and in this case preserve)\n// `Some content`, but strip `invalid-element` opening/closing tags. For some elements, though, we\n// don't want to preserve the content, if the elements themselves are going to be removed.\n\nconst SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet('script,style,template');\n/**\n * SanitizingHtmlSerializer serializes a DOM fragment, stripping out any unsafe elements and unsafe\n * attributes.\n */\n\nclass SanitizingHtmlSerializer {\n  constructor() {\n    // Explicitly track if something was stripped, to avoid accidentally warning of sanitization just\n    // because characters were re-encoded.\n    this.sanitizedSomething = false;\n    this.buf = [];\n  }\n\n  sanitizeChildren(el) {\n    // This cannot use a TreeWalker, as it has to run on Angular's various DOM adapters.\n    // However this code never accesses properties off of `document` before deleting its contents\n    // again, so it shouldn't be vulnerable to DOM clobbering.\n    let current = el.firstChild;\n    let traverseContent = true;\n\n    while (current) {\n      if (current.nodeType === Node.ELEMENT_NODE) {\n        traverseContent = this.startElement(current);\n      } else if (current.nodeType === Node.TEXT_NODE) {\n        this.chars(current.nodeValue);\n      } else {\n        // Strip non-element, non-text nodes.\n        this.sanitizedSomething = true;\n      }\n\n      if (traverseContent && current.firstChild) {\n        current = current.firstChild;\n        continue;\n      }\n\n      while (current) {\n        // Leaving the element. Walk up and to the right, closing tags as we go.\n        if (current.nodeType === Node.ELEMENT_NODE) {\n          this.endElement(current);\n        }\n\n        let next = this.checkClobberedElement(current, current.nextSibling);\n\n        if (next) {\n          current = next;\n          break;\n        }\n\n        current = this.checkClobberedElement(current, current.parentNode);\n      }\n    }\n\n    return this.buf.join('');\n  }\n  /**\n   * Sanitizes an opening element tag (if valid) and returns whether the element's contents should\n   * be traversed. Element content must always be traversed (even if the element itself is not\n   * valid/safe), unless the element is one of `SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS`.\n   *\n   * @param element The element to sanitize.\n   * @return True if the element's contents should be traversed.\n   */\n\n\n  startElement(element) {\n    const tagName = element.nodeName.toLowerCase();\n\n    if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {\n      this.sanitizedSomething = true;\n      return !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);\n    }\n\n    this.buf.push('<');\n    this.buf.push(tagName);\n    const elAttrs = element.attributes;\n\n    for (let i = 0; i < elAttrs.length; i++) {\n      const elAttr = elAttrs.item(i);\n      const attrName = elAttr.name;\n      const lower = attrName.toLowerCase();\n\n      if (!VALID_ATTRS.hasOwnProperty(lower)) {\n        this.sanitizedSomething = true;\n        continue;\n      }\n\n      let value = elAttr.value; // TODO(martinprobst): Special case image URIs for data:image/...\n\n      if (URI_ATTRS[lower]) value = _sanitizeUrl(value);\n      if (SRCSET_ATTRS[lower]) value = sanitizeSrcset(value);\n      this.buf.push(' ', attrName, '=\"', encodeEntities(value), '\"');\n    }\n\n    this.buf.push('>');\n    return true;\n  }\n\n  endElement(current) {\n    const tagName = current.nodeName.toLowerCase();\n\n    if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {\n      this.buf.push('</');\n      this.buf.push(tagName);\n      this.buf.push('>');\n    }\n  }\n\n  chars(chars) {\n    this.buf.push(encodeEntities(chars));\n  }\n\n  checkClobberedElement(node, nextNode) {\n    if (nextNode && (node.compareDocumentPosition(nextNode) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) {\n      throw new Error(`Failed to sanitize html because the element is clobbered: ${node.outerHTML}`);\n    }\n\n    return nextNode;\n  }\n\n} // Regular Expressions for parsing tags and attributes\n\n\nconst SURROGATE_PAIR_REGEXP = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g; // ! to ~ is the ASCII range.\n\nconst NON_ALPHANUMERIC_REGEXP = /([^\\#-~ |!])/g;\n/**\n * Escapes all potentially dangerous characters, so that the\n * resulting string can be safely inserted into attribute or\n * element text.\n * @param value\n */\n\nfunction encodeEntities(value) {\n  return value.replace(/&/g, '&amp;').replace(SURROGATE_PAIR_REGEXP, function (match) {\n    const hi = match.charCodeAt(0);\n    const low = match.charCodeAt(1);\n    return '&#' + ((hi - 0xD800) * 0x400 + (low - 0xDC00) + 0x10000) + ';';\n  }).replace(NON_ALPHANUMERIC_REGEXP, function (match) {\n    return '&#' + match.charCodeAt(0) + ';';\n  }).replace(/</g, '&lt;').replace(/>/g, '&gt;');\n}\n\nlet inertBodyHelper;\n/**\n * Sanitizes the given unsafe, untrusted HTML fragment, and returns HTML text that is safe to add to\n * the DOM in a browser environment.\n */\n\nfunction _sanitizeHtml(defaultDoc, unsafeHtmlInput) {\n  let inertBodyElement = null;\n\n  try {\n    inertBodyHelper = inertBodyHelper || getInertBodyHelper(defaultDoc); // Make sure unsafeHtml is actually a string (TypeScript types are not enforced at runtime).\n\n    let unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : '';\n    inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml); // mXSS protection. Repeatedly parse the document to make sure it stabilizes, so that a browser\n    // trying to auto-correct incorrect HTML cannot cause formerly inert HTML to become dangerous.\n\n    let mXSSAttempts = 5;\n    let parsedHtml = unsafeHtml;\n\n    do {\n      if (mXSSAttempts === 0) {\n        throw new Error('Failed to sanitize html because the input is unstable');\n      }\n\n      mXSSAttempts--;\n      unsafeHtml = parsedHtml;\n      parsedHtml = inertBodyElement.innerHTML;\n      inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);\n    } while (unsafeHtml !== parsedHtml);\n\n    const sanitizer = new SanitizingHtmlSerializer();\n    const safeHtml = sanitizer.sanitizeChildren(getTemplateContent(inertBodyElement) || inertBodyElement);\n\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && sanitizer.sanitizedSomething) {\n      console.warn('WARNING: sanitizing HTML stripped some content, see https://g.co/ng/security#xss');\n    }\n\n    return trustedHTMLFromString(safeHtml);\n  } finally {\n    // In case anything goes wrong, clear out inertElement to reset the entire DOM structure.\n    if (inertBodyElement) {\n      const parent = getTemplateContent(inertBodyElement) || inertBodyElement;\n\n      while (parent.firstChild) {\n        parent.removeChild(parent.firstChild);\n      }\n    }\n  }\n}\n\nfunction getTemplateContent(el) {\n  return 'content' in el\n  /** Microsoft/TypeScript#21517 */\n  && isTemplateElement(el) ? el.content : null;\n}\n\nfunction isTemplateElement(el) {\n  return el.nodeType === Node.ELEMENT_NODE && el.nodeName === 'TEMPLATE';\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A SecurityContext marks a location that has dangerous security implications, e.g. a DOM property\n * like `innerHTML` that could cause Cross Site Scripting (XSS) security bugs when improperly\n * handled.\n *\n * See DomSanitizer for more details on security in Angular applications.\n *\n * @publicApi\n */\n\n\nvar SecurityContext;\n\n(function (SecurityContext) {\n  SecurityContext[SecurityContext[\"NONE\"] = 0] = \"NONE\";\n  SecurityContext[SecurityContext[\"HTML\"] = 1] = \"HTML\";\n  SecurityContext[SecurityContext[\"STYLE\"] = 2] = \"STYLE\";\n  SecurityContext[SecurityContext[\"SCRIPT\"] = 3] = \"SCRIPT\";\n  SecurityContext[SecurityContext[\"URL\"] = 4] = \"URL\";\n  SecurityContext[SecurityContext[\"RESOURCE_URL\"] = 5] = \"RESOURCE_URL\";\n})(SecurityContext || (SecurityContext = {}));\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * An `html` sanitizer which converts untrusted `html` **string** into trusted string by removing\n * dangerous content.\n *\n * This method parses the `html` and locates potentially dangerous content (such as urls and\n * javascript) and removes it.\n *\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustHtml}.\n *\n * @param unsafeHtml untrusted `html`, typically from the user.\n * @returns `html` string which is safe to display to user, because all of the dangerous javascript\n * and urls have been removed.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵsanitizeHtml(unsafeHtml) {\n  const sanitizer = getSanitizer();\n\n  if (sanitizer) {\n    return trustedHTMLFromStringBypass(sanitizer.sanitize(SecurityContext.HTML, unsafeHtml) || '');\n  }\n\n  if (allowSanitizationBypassAndThrow(unsafeHtml, \"HTML\"\n  /* BypassType.Html */\n  )) {\n    return trustedHTMLFromStringBypass(unwrapSafeValue(unsafeHtml));\n  }\n\n  return _sanitizeHtml(getDocument(), renderStringify(unsafeHtml));\n}\n/**\n * A `style` sanitizer which converts untrusted `style` **string** into trusted string by removing\n * dangerous content.\n *\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustStyle}.\n *\n * @param unsafeStyle untrusted `style`, typically from the user.\n * @returns `style` string which is safe to bind to the `style` properties.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵsanitizeStyle(unsafeStyle) {\n  const sanitizer = getSanitizer();\n\n  if (sanitizer) {\n    return sanitizer.sanitize(SecurityContext.STYLE, unsafeStyle) || '';\n  }\n\n  if (allowSanitizationBypassAndThrow(unsafeStyle, \"Style\"\n  /* BypassType.Style */\n  )) {\n    return unwrapSafeValue(unsafeStyle);\n  }\n\n  return renderStringify(unsafeStyle);\n}\n/**\n * A `url` sanitizer which converts untrusted `url` **string** into trusted string by removing\n * dangerous\n * content.\n *\n * This method parses the `url` and locates potentially dangerous content (such as javascript) and\n * removes it.\n *\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustUrl}.\n *\n * @param unsafeUrl untrusted `url`, typically from the user.\n * @returns `url` string which is safe to bind to the `src` properties such as `<img src>`, because\n * all of the dangerous javascript has been removed.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵsanitizeUrl(unsafeUrl) {\n  const sanitizer = getSanitizer();\n\n  if (sanitizer) {\n    return sanitizer.sanitize(SecurityContext.URL, unsafeUrl) || '';\n  }\n\n  if (allowSanitizationBypassAndThrow(unsafeUrl, \"URL\"\n  /* BypassType.Url */\n  )) {\n    return unwrapSafeValue(unsafeUrl);\n  }\n\n  return _sanitizeUrl(renderStringify(unsafeUrl));\n}\n/**\n * A `url` sanitizer which only lets trusted `url`s through.\n *\n * This passes only `url`s marked trusted by calling {@link bypassSanitizationTrustResourceUrl}.\n *\n * @param unsafeResourceUrl untrusted `url`, typically from the user.\n * @returns `url` string which is safe to bind to the `src` properties such as `<img src>`, because\n * only trusted `url`s have been allowed to pass.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵsanitizeResourceUrl(unsafeResourceUrl) {\n  const sanitizer = getSanitizer();\n\n  if (sanitizer) {\n    return trustedScriptURLFromStringBypass(sanitizer.sanitize(SecurityContext.RESOURCE_URL, unsafeResourceUrl) || '');\n  }\n\n  if (allowSanitizationBypassAndThrow(unsafeResourceUrl, \"ResourceURL\"\n  /* BypassType.ResourceUrl */\n  )) {\n    return trustedScriptURLFromStringBypass(unwrapSafeValue(unsafeResourceUrl));\n  }\n\n  throw new RuntimeError(904\n  /* RuntimeErrorCode.UNSAFE_VALUE_IN_RESOURCE_URL */\n  , ngDevMode && 'unsafe value used in a resource URL context (see https://g.co/ng/security#xss)');\n}\n/**\n * A `script` sanitizer which only lets trusted javascript through.\n *\n * This passes only `script`s marked trusted by calling {@link\n * bypassSanitizationTrustScript}.\n *\n * @param unsafeScript untrusted `script`, typically from the user.\n * @returns `url` string which is safe to bind to the `<script>` element such as `<img src>`,\n * because only trusted `scripts` have been allowed to pass.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵsanitizeScript(unsafeScript) {\n  const sanitizer = getSanitizer();\n\n  if (sanitizer) {\n    return trustedScriptFromStringBypass(sanitizer.sanitize(SecurityContext.SCRIPT, unsafeScript) || '');\n  }\n\n  if (allowSanitizationBypassAndThrow(unsafeScript, \"Script\"\n  /* BypassType.Script */\n  )) {\n    return trustedScriptFromStringBypass(unwrapSafeValue(unsafeScript));\n  }\n\n  throw new RuntimeError(905\n  /* RuntimeErrorCode.UNSAFE_VALUE_IN_SCRIPT */\n  , ngDevMode && 'unsafe value used in a script context');\n}\n/**\n * A template tag function for promoting the associated constant literal to a\n * TrustedHTML. Interpolation is explicitly not allowed.\n *\n * @param html constant template literal containing trusted HTML.\n * @returns TrustedHTML wrapping `html`.\n *\n * @security This is a security-sensitive function and should only be used to\n * convert constant values of attributes and properties found in\n * application-provided Angular templates to TrustedHTML.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵtrustConstantHtml(html) {\n  // The following runtime check ensures that the function was called as a\n  // template tag (e.g. ɵɵtrustConstantHtml`content`), without any interpolation\n  // (e.g. not ɵɵtrustConstantHtml`content ${variable}`). A TemplateStringsArray\n  // is an array with a `raw` property that is also an array. The associated\n  // template literal has no interpolation if and only if the length of the\n  // TemplateStringsArray is 1.\n  if (ngDevMode && (!Array.isArray(html) || !Array.isArray(html.raw) || html.length !== 1)) {\n    throw new Error(`Unexpected interpolation in trusted HTML constant: ${html.join('?')}`);\n  }\n\n  return trustedHTMLFromString(html[0]);\n}\n/**\n * A template tag function for promoting the associated constant literal to a\n * TrustedScriptURL. Interpolation is explicitly not allowed.\n *\n * @param url constant template literal containing a trusted script URL.\n * @returns TrustedScriptURL wrapping `url`.\n *\n * @security This is a security-sensitive function and should only be used to\n * convert constant values of attributes and properties found in\n * application-provided Angular templates to TrustedScriptURL.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵtrustConstantResourceUrl(url) {\n  // The following runtime check ensures that the function was called as a\n  // template tag (e.g. ɵɵtrustConstantResourceUrl`content`), without any\n  // interpolation (e.g. not ɵɵtrustConstantResourceUrl`content ${variable}`). A\n  // TemplateStringsArray is an array with a `raw` property that is also an\n  // array. The associated template literal has no interpolation if and only if\n  // the length of the TemplateStringsArray is 1.\n  if (ngDevMode && (!Array.isArray(url) || !Array.isArray(url.raw) || url.length !== 1)) {\n    throw new Error(`Unexpected interpolation in trusted URL constant: ${url.join('?')}`);\n  }\n\n  return trustedScriptURLFromString(url[0]);\n}\n/**\n * Detects which sanitizer to use for URL property, based on tag name and prop name.\n *\n * The rules are based on the RESOURCE_URL context config from\n * `packages/compiler/src/schema/dom_security_schema.ts`.\n * If tag and prop names don't match Resource URL schema, use URL sanitizer.\n */\n\n\nfunction getUrlSanitizer(tag, prop) {\n  if (prop === 'src' && (tag === 'embed' || tag === 'frame' || tag === 'iframe' || tag === 'media' || tag === 'script') || prop === 'href' && (tag === 'base' || tag === 'link')) {\n    return ɵɵsanitizeResourceUrl;\n  }\n\n  return ɵɵsanitizeUrl;\n}\n/**\n * Sanitizes URL, selecting sanitizer function based on tag and property names.\n *\n * This function is used in case we can't define security context at compile time, when only prop\n * name is available. This happens when we generate host bindings for Directives/Components. The\n * host element is unknown at compile time, so we defer calculation of specific sanitizer to\n * runtime.\n *\n * @param unsafeUrl untrusted `url`, typically from the user.\n * @param tag target element tag name.\n * @param prop name of the property that contains the value.\n * @returns `url` string which is safe to bind.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵsanitizeUrlOrResourceUrl(unsafeUrl, tag, prop) {\n  return getUrlSanitizer(tag, prop)(unsafeUrl);\n}\n\nfunction validateAgainstEventProperties(name) {\n  if (name.toLowerCase().startsWith('on')) {\n    const errorMessage = `Binding to event property '${name}' is disallowed for security reasons, ` + `please use (${name.slice(2)})=...` + `\\nIf '${name}' is a directive input, make sure the directive is imported by the` + ` current module.`;\n    throw new RuntimeError(306\n    /* RuntimeErrorCode.INVALID_EVENT_BINDING */\n    , errorMessage);\n  }\n}\n\nfunction validateAgainstEventAttributes(name) {\n  if (name.toLowerCase().startsWith('on')) {\n    const errorMessage = `Binding to event attribute '${name}' is disallowed for security reasons, ` + `please use (${name.slice(2)})=...`;\n    throw new RuntimeError(306\n    /* RuntimeErrorCode.INVALID_EVENT_BINDING */\n    , errorMessage);\n  }\n}\n\nfunction getSanitizer() {\n  const lView = getLView();\n  return lView && lView[SANITIZER];\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nconst ERROR_ORIGINAL_ERROR = 'ngOriginalError';\n\nfunction wrappedError(message, originalError) {\n  const msg = `${message} caused by: ${originalError instanceof Error ? originalError.message : originalError}`;\n  const error = Error(msg);\n  error[ERROR_ORIGINAL_ERROR] = originalError;\n  return error;\n}\n\nfunction getOriginalError(error) {\n  return error[ERROR_ORIGINAL_ERROR];\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Provides a hook for centralized exception handling.\n *\n * The default implementation of `ErrorHandler` prints error messages to the `console`. To\n * intercept error handling, write a custom exception handler that replaces this default as\n * appropriate for your app.\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * class MyErrorHandler implements ErrorHandler {\n *   handleError(error) {\n *     // do something with the exception\n *   }\n * }\n *\n * @NgModule({\n *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]\n * })\n * class MyModule {}\n * ```\n *\n * @publicApi\n */\n\n\nclass ErrorHandler {\n  constructor() {\n    /**\n     * @internal\n     */\n    this._console = console;\n  }\n\n  handleError(error) {\n    const originalError = this._findOriginalError(error);\n\n    this._console.error('ERROR', error);\n\n    if (originalError) {\n      this._console.error('ORIGINAL ERROR', originalError);\n    }\n  }\n  /** @internal */\n\n\n  _findOriginalError(error) {\n    let e = error && getOriginalError(error);\n\n    while (e && getOriginalError(e)) {\n      e = getOriginalError(e);\n    }\n\n    return e || null;\n  }\n\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Disallowed strings in the comment.\n *\n * see: https://html.spec.whatwg.org/multipage/syntax.html#comments\n */\n\n\nconst COMMENT_DISALLOWED = /^>|^->|<!--|-->|--!>|<!-$/g;\n/**\n * Delimiter in the disallowed strings which needs to be wrapped with zero with character.\n */\n\nconst COMMENT_DELIMITER = /(<|>)/;\nconst COMMENT_DELIMITER_ESCAPED = '\\u200B$1\\u200B';\n/**\n * Escape the content of comment strings so that it can be safely inserted into a comment node.\n *\n * The issue is that HTML does not specify any way to escape comment end text inside the comment.\n * Consider: `<!-- The way you close a comment is with \">\", and \"->\" at the beginning or by \"-->\" or\n * \"--!>\" at the end. -->`. Above the `\"-->\"` is meant to be text not an end to the comment. This\n * can be created programmatically through DOM APIs. (`<!--` are also disallowed.)\n *\n * see: https://html.spec.whatwg.org/multipage/syntax.html#comments\n *\n * ```\n * div.innerHTML = div.innerHTML\n * ```\n *\n * One would expect that the above code would be safe to do, but it turns out that because comment\n * text is not escaped, the comment may contain text which will prematurely close the comment\n * opening up the application for XSS attack. (In SSR we programmatically create comment nodes which\n * may contain such text and expect them to be safe.)\n *\n * This function escapes the comment text by looking for comment delimiters (`<` and `>`) and\n * surrounding them with `_>_` where the `_` is a zero width space `\\u200B`. The result is that if a\n * comment contains any of the comment start/end delimiters (such as `<!--`, `-->` or `--!>`) the\n * text it will render normally but it will not cause the HTML parser to close/open the comment.\n *\n * @param value text to make safe for comment node by escaping the comment open/close character\n *     sequence.\n */\n\nfunction escapeCommentText(value) {\n  return value.replace(COMMENT_DISALLOWED, text => text.replace(COMMENT_DELIMITER, COMMENT_DELIMITER_ESCAPED));\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction normalizeDebugBindingName(name) {\n  // Attribute names with `$` (eg `x-y$`) are valid per spec, but unsupported by some browsers\n  name = camelCaseToDashCase(name.replace(/[$@]/g, '_'));\n  return `ng-reflect-${name}`;\n}\n\nconst CAMEL_CASE_REGEXP = /([A-Z])/g;\n\nfunction camelCaseToDashCase(input) {\n  return input.replace(CAMEL_CASE_REGEXP, (...m) => '-' + m[1].toLowerCase());\n}\n\nfunction normalizeDebugBindingValue(value) {\n  try {\n    // Limit the size of the value as otherwise the DOM just gets polluted.\n    return value != null ? value.toString().slice(0, 30) : value;\n  } catch (e) {\n    return '[ERROR] Exception while trying to serialize the value';\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Keeps track of the currently-active LViews.\n\n\nconst TRACKED_LVIEWS = new Map(); // Used for generating unique IDs for LViews.\n\nlet uniqueIdCounter = 0;\n/** Gets a unique ID that can be assigned to an LView. */\n\nfunction getUniqueLViewId() {\n  return uniqueIdCounter++;\n}\n/** Starts tracking an LView. */\n\n\nfunction registerLView(lView) {\n  ngDevMode && assertNumber(lView[ID], 'LView must have an ID in order to be registered');\n  TRACKED_LVIEWS.set(lView[ID], lView);\n}\n/** Gets an LView by its unique ID. */\n\n\nfunction getLViewById(id) {\n  ngDevMode && assertNumber(id, 'ID used for LView lookup must be a number');\n  return TRACKED_LVIEWS.get(id) || null;\n}\n/** Stops tracking an LView. */\n\n\nfunction unregisterLView(lView) {\n  ngDevMode && assertNumber(lView[ID], 'Cannot stop tracking an LView that does not have an ID');\n  TRACKED_LVIEWS.delete(lView[ID]);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * The internal view context which is specific to a given DOM element, directive or\n * component instance. Each value in here (besides the LView and element node details)\n * can be present, null or undefined. If undefined then it implies the value has not been\n * looked up yet, otherwise, if null, then a lookup was executed and nothing was found.\n *\n * Each value will get filled when the respective value is examined within the getContext\n * function. The component, element and each directive instance will share the same instance\n * of the context.\n */\n\n\nclass LContext {\n  constructor(\n  /**\n   * ID of the component's parent view data.\n   */\n  lViewId,\n  /**\n   * The index instance of the node.\n   */\n  nodeIndex,\n  /**\n   * The instance of the DOM node that is attached to the lNode.\n   */\n  native) {\n    this.lViewId = lViewId;\n    this.nodeIndex = nodeIndex;\n    this.native = native;\n  }\n  /** Component's parent view data. */\n\n\n  get lView() {\n    return getLViewById(this.lViewId);\n  }\n\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Returns the matching `LContext` data for a given DOM node, directive or component instance.\n *\n * This function will examine the provided DOM element, component, or directive instance\\'s\n * monkey-patched property to derive the `LContext` data. Once called then the monkey-patched\n * value will be that of the newly created `LContext`.\n *\n * If the monkey-patched value is the `LView` instance then the context value for that\n * target will be created and the monkey-patch reference will be updated. Therefore when this\n * function is called it may mutate the provided element\\'s, component\\'s or any of the associated\n * directive\\'s monkey-patch values.\n *\n * If the monkey-patch value is not detected then the code will walk up the DOM until an element\n * is found which contains a monkey-patch reference. When that occurs then the provided element\n * will be updated with a new context (which is then returned). If the monkey-patch value is not\n * detected for a component/directive instance then it will throw an error (all components and\n * directives should be automatically monkey-patched by ivy).\n *\n * @param target Component, Directive or DOM Node.\n */\n\n\nfunction getLContext(target) {\n  let mpValue = readPatchedData(target);\n\n  if (mpValue) {\n    // only when it's an array is it considered an LView instance\n    // ... otherwise it's an already constructed LContext instance\n    if (isLView(mpValue)) {\n      const lView = mpValue;\n      let nodeIndex;\n      let component = undefined;\n      let directives = undefined;\n\n      if (isComponentInstance(target)) {\n        nodeIndex = findViaComponent(lView, target);\n\n        if (nodeIndex == -1) {\n          throw new Error('The provided component was not found in the application');\n        }\n\n        component = target;\n      } else if (isDirectiveInstance(target)) {\n        nodeIndex = findViaDirective(lView, target);\n\n        if (nodeIndex == -1) {\n          throw new Error('The provided directive was not found in the application');\n        }\n\n        directives = getDirectivesAtNodeIndex(nodeIndex, lView, false);\n      } else {\n        nodeIndex = findViaNativeElement(lView, target);\n\n        if (nodeIndex == -1) {\n          return null;\n        }\n      } // the goal is not to fill the entire context full of data because the lookups\n      // are expensive. Instead, only the target data (the element, component, container, ICU\n      // expression or directive details) are filled into the context. If called multiple times\n      // with different target values then the missing target data will be filled in.\n\n\n      const native = unwrapRNode(lView[nodeIndex]);\n      const existingCtx = readPatchedData(native);\n      const context = existingCtx && !Array.isArray(existingCtx) ? existingCtx : createLContext(lView, nodeIndex, native); // only when the component has been discovered then update the monkey-patch\n\n      if (component && context.component === undefined) {\n        context.component = component;\n        attachPatchData(context.component, context);\n      } // only when the directives have been discovered then update the monkey-patch\n\n\n      if (directives && context.directives === undefined) {\n        context.directives = directives;\n\n        for (let i = 0; i < directives.length; i++) {\n          attachPatchData(directives[i], context);\n        }\n      }\n\n      attachPatchData(context.native, context);\n      mpValue = context;\n    }\n  } else {\n    const rElement = target;\n    ngDevMode && assertDomNode(rElement); // if the context is not found then we need to traverse upwards up the DOM\n    // to find the nearest element that has already been monkey patched with data\n\n    let parent = rElement;\n\n    while (parent = parent.parentNode) {\n      const parentContext = readPatchedData(parent);\n\n      if (parentContext) {\n        const lView = Array.isArray(parentContext) ? parentContext : parentContext.lView; // the edge of the app was also reached here through another means\n        // (maybe because the DOM was changed manually).\n\n        if (!lView) {\n          return null;\n        }\n\n        const index = findViaNativeElement(lView, rElement);\n\n        if (index >= 0) {\n          const native = unwrapRNode(lView[index]);\n          const context = createLContext(lView, index, native);\n          attachPatchData(native, context);\n          mpValue = context;\n          break;\n        }\n      }\n    }\n  }\n\n  return mpValue || null;\n}\n/**\n * Creates an empty instance of a `LContext` context\n */\n\n\nfunction createLContext(lView, nodeIndex, native) {\n  return new LContext(lView[ID], nodeIndex, native);\n}\n/**\n * Takes a component instance and returns the view for that component.\n *\n * @param componentInstance\n * @returns The component's view\n */\n\n\nfunction getComponentViewByInstance(componentInstance) {\n  let patchedData = readPatchedData(componentInstance);\n  let lView;\n\n  if (isLView(patchedData)) {\n    const contextLView = patchedData;\n    const nodeIndex = findViaComponent(contextLView, componentInstance);\n    lView = getComponentLViewByIndex(nodeIndex, contextLView);\n    const context = createLContext(contextLView, nodeIndex, lView[HOST]);\n    context.component = componentInstance;\n    attachPatchData(componentInstance, context);\n    attachPatchData(context.native, context);\n  } else {\n    const context = patchedData;\n    const contextLView = context.lView;\n    ngDevMode && assertLView(contextLView);\n    lView = getComponentLViewByIndex(context.nodeIndex, contextLView);\n  }\n\n  return lView;\n}\n/**\n * This property will be monkey-patched on elements, components and directives.\n */\n\n\nconst MONKEY_PATCH_KEY_NAME = '__ngContext__';\n/**\n * Assigns the given data to the given target (which could be a component,\n * directive or DOM node instance) using monkey-patching.\n */\n\nfunction attachPatchData(target, data) {\n  ngDevMode && assertDefined(target, 'Target expected'); // Only attach the ID of the view in order to avoid memory leaks (see #41047). We only do this\n  // for `LView`, because we have control over when an `LView` is created and destroyed, whereas\n  // we can't know when to remove an `LContext`.\n\n  if (isLView(data)) {\n    target[MONKEY_PATCH_KEY_NAME] = data[ID];\n    registerLView(data);\n  } else {\n    target[MONKEY_PATCH_KEY_NAME] = data;\n  }\n}\n/**\n * Returns the monkey-patch value data present on the target (which could be\n * a component, directive or a DOM node).\n */\n\n\nfunction readPatchedData(target) {\n  ngDevMode && assertDefined(target, 'Target expected');\n  const data = target[MONKEY_PATCH_KEY_NAME];\n  return typeof data === 'number' ? getLViewById(data) : data || null;\n}\n\nfunction readPatchedLView(target) {\n  const value = readPatchedData(target);\n\n  if (value) {\n    return isLView(value) ? value : value.lView;\n  }\n\n  return null;\n}\n\nfunction isComponentInstance(instance) {\n  return instance && instance.constructor && instance.constructor.ɵcmp;\n}\n\nfunction isDirectiveInstance(instance) {\n  return instance && instance.constructor && instance.constructor.ɵdir;\n}\n/**\n * Locates the element within the given LView and returns the matching index\n */\n\n\nfunction findViaNativeElement(lView, target) {\n  const tView = lView[TVIEW];\n\n  for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {\n    if (unwrapRNode(lView[i]) === target) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n/**\n * Locates the next tNode (child, sibling or parent).\n */\n\n\nfunction traverseNextElement(tNode) {\n  if (tNode.child) {\n    return tNode.child;\n  } else if (tNode.next) {\n    return tNode.next;\n  } else {\n    // Let's take the following template: <div><span>text</span></div><component/>\n    // After checking the text node, we need to find the next parent that has a \"next\" TNode,\n    // in this case the parent `div`, so that we can find the component.\n    while (tNode.parent && !tNode.parent.next) {\n      tNode = tNode.parent;\n    }\n\n    return tNode.parent && tNode.parent.next;\n  }\n}\n/**\n * Locates the component within the given LView and returns the matching index\n */\n\n\nfunction findViaComponent(lView, componentInstance) {\n  const componentIndices = lView[TVIEW].components;\n\n  if (componentIndices) {\n    for (let i = 0; i < componentIndices.length; i++) {\n      const elementComponentIndex = componentIndices[i];\n      const componentView = getComponentLViewByIndex(elementComponentIndex, lView);\n\n      if (componentView[CONTEXT] === componentInstance) {\n        return elementComponentIndex;\n      }\n    }\n  } else {\n    const rootComponentView = getComponentLViewByIndex(HEADER_OFFSET, lView);\n    const rootComponent = rootComponentView[CONTEXT];\n\n    if (rootComponent === componentInstance) {\n      // we are dealing with the root element here therefore we know that the\n      // element is the very first element after the HEADER data in the lView\n      return HEADER_OFFSET;\n    }\n  }\n\n  return -1;\n}\n/**\n * Locates the directive within the given LView and returns the matching index\n */\n\n\nfunction findViaDirective(lView, directiveInstance) {\n  // if a directive is monkey patched then it will (by default)\n  // have a reference to the LView of the current view. The\n  // element bound to the directive being search lives somewhere\n  // in the view data. We loop through the nodes and check their\n  // list of directives for the instance.\n  let tNode = lView[TVIEW].firstChild;\n\n  while (tNode) {\n    const directiveIndexStart = tNode.directiveStart;\n    const directiveIndexEnd = tNode.directiveEnd;\n\n    for (let i = directiveIndexStart; i < directiveIndexEnd; i++) {\n      if (lView[i] === directiveInstance) {\n        return tNode.index;\n      }\n    }\n\n    tNode = traverseNextElement(tNode);\n  }\n\n  return -1;\n}\n/**\n * Returns a list of directives extracted from the given view based on the\n * provided list of directive index values.\n *\n * @param nodeIndex The node index\n * @param lView The target view data\n * @param includeComponents Whether or not to include components in returned directives\n */\n\n\nfunction getDirectivesAtNodeIndex(nodeIndex, lView, includeComponents) {\n  const tNode = lView[TVIEW].data[nodeIndex];\n  let directiveStartIndex = tNode.directiveStart;\n  if (directiveStartIndex == 0) return EMPTY_ARRAY;\n  const directiveEndIndex = tNode.directiveEnd;\n  if (!includeComponents && tNode.flags & 2\n  /* TNodeFlags.isComponentHost */\n  ) directiveStartIndex++;\n  return lView.slice(directiveStartIndex, directiveEndIndex);\n}\n\nfunction getComponentAtNodeIndex(nodeIndex, lView) {\n  const tNode = lView[TVIEW].data[nodeIndex];\n  let directiveStartIndex = tNode.directiveStart;\n  return tNode.flags & 2\n  /* TNodeFlags.isComponentHost */\n  ? lView[directiveStartIndex] : null;\n}\n/**\n * Returns a map of local references (local reference name => element or directive instance) that\n * exist on a given element.\n */\n\n\nfunction discoverLocalRefs(lView, nodeIndex) {\n  const tNode = lView[TVIEW].data[nodeIndex];\n\n  if (tNode && tNode.localNames) {\n    const result = {};\n    let localIndex = tNode.index + 1;\n\n    for (let i = 0; i < tNode.localNames.length; i += 2) {\n      result[tNode.localNames[i]] = lView[localIndex];\n      localIndex++;\n    }\n\n    return result;\n  }\n\n  return null;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Verifies that a given type is a Standalone Component. */\n\n\nfunction assertStandaloneComponentType(type) {\n  const componentDef = getComponentDef$1(type);\n\n  if (!componentDef) {\n    throw new RuntimeError(906\n    /* RuntimeErrorCode.MISSING_GENERATED_DEF */\n    , `The ${stringifyForError(type)} is not an Angular component, ` + `make sure it has the \\`@Component\\` decorator.`);\n  }\n\n  if (!componentDef.standalone) {\n    throw new RuntimeError(907\n    /* RuntimeErrorCode.TYPE_IS_NOT_STANDALONE */\n    , `The ${stringifyForError(type)} component is not marked as standalone, ` + `but Angular expects to have a standalone component here. ` + `Please make sure the ${stringifyForError(type)} component has ` + `the \\`standalone: true\\` flag in the decorator.`);\n  }\n}\n/** Called when there are multiple component selectors that match a given node */\n\n\nfunction throwMultipleComponentError(tNode, first, second) {\n  throw new RuntimeError(-300\n  /* RuntimeErrorCode.MULTIPLE_COMPONENTS_MATCH */\n  , `Multiple components match node with tagname ${tNode.value}: ` + `${stringifyForError(first)} and ` + `${stringifyForError(second)}`);\n}\n/** Throws an ExpressionChangedAfterChecked error if checkNoChanges mode is on. */\n\n\nfunction throwErrorIfNoChangesMode(creationMode, oldValue, currValue, propName) {\n  const field = propName ? ` for '${propName}'` : '';\n  let msg = `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value${field}: '${oldValue}'. Current value: '${currValue}'.`;\n\n  if (creationMode) {\n    msg += ` It seems like the view has been created after its parent and its children have been dirty checked.` + ` Has it been created in a change detection hook?`;\n  }\n\n  throw new RuntimeError(-100\n  /* RuntimeErrorCode.EXPRESSION_CHANGED_AFTER_CHECKED */\n  , msg);\n}\n\nfunction constructDetailsForInterpolation(lView, rootIndex, expressionIndex, meta, changedValue) {\n  const [propName, prefix, ...chunks] = meta.split(INTERPOLATION_DELIMITER);\n  let oldValue = prefix,\n      newValue = prefix;\n\n  for (let i = 0; i < chunks.length; i++) {\n    const slotIdx = rootIndex + i;\n    oldValue += `${lView[slotIdx]}${chunks[i]}`;\n    newValue += `${slotIdx === expressionIndex ? changedValue : lView[slotIdx]}${chunks[i]}`;\n  }\n\n  return {\n    propName,\n    oldValue,\n    newValue\n  };\n}\n/**\n * Constructs an object that contains details for the ExpressionChangedAfterItHasBeenCheckedError:\n * - property name (for property bindings or interpolations)\n * - old and new values, enriched using information from metadata\n *\n * More information on the metadata storage format can be found in `storePropertyBindingMetadata`\n * function description.\n */\n\n\nfunction getExpressionChangedErrorDetails(lView, bindingIndex, oldValue, newValue) {\n  const tData = lView[TVIEW].data;\n  const metadata = tData[bindingIndex];\n\n  if (typeof metadata === 'string') {\n    // metadata for property interpolation\n    if (metadata.indexOf(INTERPOLATION_DELIMITER) > -1) {\n      return constructDetailsForInterpolation(lView, bindingIndex, bindingIndex, metadata, newValue);\n    } // metadata for property binding\n\n\n    return {\n      propName: metadata,\n      oldValue,\n      newValue\n    };\n  } // metadata is not available for this expression, check if this expression is a part of the\n  // property interpolation by going from the current binding index left and look for a string that\n  // contains INTERPOLATION_DELIMITER, the layout in tView.data for this case will look like this:\n  // [..., 'id�Prefix � and � suffix', null, null, null, ...]\n\n\n  if (metadata === null) {\n    let idx = bindingIndex - 1;\n\n    while (typeof tData[idx] !== 'string' && tData[idx + 1] === null) {\n      idx--;\n    }\n\n    const meta = tData[idx];\n\n    if (typeof meta === 'string') {\n      const matches = meta.match(new RegExp(INTERPOLATION_DELIMITER, 'g')); // first interpolation delimiter separates property name from interpolation parts (in case of\n      // property interpolations), so we subtract one from total number of found delimiters\n\n      if (matches && matches.length - 1 > bindingIndex - idx) {\n        return constructDetailsForInterpolation(lView, idx, bindingIndex, meta, newValue);\n      }\n    }\n  }\n\n  return {\n    propName: undefined,\n    oldValue,\n    newValue\n  };\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Flags for renderer-specific style modifiers.\n * @publicApi\n */\n\n\nvar RendererStyleFlags2;\n\n(function (RendererStyleFlags2) {\n  // TODO(misko): This needs to be refactored into a separate file so that it can be imported from\n  // `node_manipulation.ts` Currently doing the import cause resolution order to change and fails\n  // the tests. The work around is to have hard coded value in `node_manipulation.ts` for now.\n\n  /**\n   * Marks a style as important.\n   */\n  RendererStyleFlags2[RendererStyleFlags2[\"Important\"] = 1] = \"Important\";\n  /**\n   * Marks a style as using dash case naming (this-is-dash-case).\n   */\n\n  RendererStyleFlags2[RendererStyleFlags2[\"DashCase\"] = 2] = \"DashCase\";\n})(RendererStyleFlags2 || (RendererStyleFlags2 = {}));\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nlet _icuContainerIterate;\n/**\n * Iterator which provides ability to visit all of the `TIcuContainerNode` root `RNode`s.\n */\n\n\nfunction icuContainerIterate(tIcuContainerNode, lView) {\n  return _icuContainerIterate(tIcuContainerNode, lView);\n}\n/**\n * Ensures that `IcuContainerVisitor`'s implementation is present.\n *\n * This function is invoked when i18n instruction comes across an ICU. The purpose is to allow the\n * bundler to tree shake ICU logic and only load it if ICU instruction is executed.\n */\n\n\nfunction ensureIcuContainerVisitorLoaded(loader) {\n  if (_icuContainerIterate === undefined) {\n    // Do not inline this function. We want to keep `ensureIcuContainerVisitorLoaded` light, so it\n    // can be inlined into call-site.\n    _icuContainerIterate = loader();\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\n\n\nconst unusedValueExportToPlacateAjd$3 = 1;\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Gets the parent LView of the passed LView, if the PARENT is an LContainer, will get the parent of\n * that LContainer, which is an LView\n * @param lView the lView whose parent to get\n */\n\nfunction getLViewParent(lView) {\n  ngDevMode && assertLView(lView);\n  const parent = lView[PARENT];\n  return isLContainer(parent) ? parent[PARENT] : parent;\n}\n/**\n * Retrieve the root view from any component or `LView` by walking the parent `LView` until\n * reaching the root `LView`.\n *\n * @param componentOrLView any component or `LView`\n */\n\n\nfunction getRootView(componentOrLView) {\n  ngDevMode && assertDefined(componentOrLView, 'component');\n  let lView = isLView(componentOrLView) ? componentOrLView : readPatchedLView(componentOrLView);\n\n  while (lView && !(lView[FLAGS] & 256\n  /* LViewFlags.IsRoot */\n  )) {\n    lView = getLViewParent(lView);\n  }\n\n  ngDevMode && assertLView(lView);\n  return lView;\n}\n/**\n * Returns the `RootContext` instance that is associated with\n * the application where the target is situated. It does this by walking the parent views until it\n * gets to the root view, then getting the context off of that.\n *\n * @param viewOrComponent the `LView` or component to get the root context for.\n */\n\n\nfunction getRootContext(viewOrComponent) {\n  const rootView = getRootView(viewOrComponent);\n  ngDevMode && assertDefined(rootView[CONTEXT], 'RootView has no context. Perhaps it is disconnected?');\n  return rootView[CONTEXT];\n}\n/**\n * Gets the first `LContainer` in the LView or `null` if none exists.\n */\n\n\nfunction getFirstLContainer(lView) {\n  return getNearestLContainer(lView[CHILD_HEAD]);\n}\n/**\n * Gets the next `LContainer` that is a sibling of the given container.\n */\n\n\nfunction getNextLContainer(container) {\n  return getNearestLContainer(container[NEXT]);\n}\n\nfunction getNearestLContainer(viewOrContainer) {\n  while (viewOrContainer !== null && !isLContainer(viewOrContainer)) {\n    viewOrContainer = viewOrContainer[NEXT];\n  }\n\n  return viewOrContainer;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nconst unusedValueToPlacateAjd$2 = unusedValueExportToPlacateAjd$8 + unusedValueExportToPlacateAjd$4 + unusedValueExportToPlacateAjd$3 + unusedValueExportToPlacateAjd$6 + unusedValueExportToPlacateAjd$7;\n/**\n * NOTE: for performance reasons, the possible actions are inlined within the function instead of\n * being passed as an argument.\n */\n\nfunction applyToElementOrContainer(action, renderer, parent, lNodeToHandle, beforeNode) {\n  // If this slot was allocated for a text node dynamically created by i18n, the text node itself\n  // won't be created until i18nApply() in the update block, so this node should be skipped.\n  // For more info, see \"ICU expressions should work inside an ngTemplateOutlet inside an ngFor\"\n  // in `i18n_spec.ts`.\n  if (lNodeToHandle != null) {\n    let lContainer;\n    let isComponent = false; // We are expecting an RNode, but in the case of a component or LContainer the `RNode` is\n    // wrapped in an array which needs to be unwrapped. We need to know if it is a component and if\n    // it has LContainer so that we can process all of those cases appropriately.\n\n    if (isLContainer(lNodeToHandle)) {\n      lContainer = lNodeToHandle;\n    } else if (isLView(lNodeToHandle)) {\n      isComponent = true;\n      ngDevMode && assertDefined(lNodeToHandle[HOST], 'HOST must be defined for a component LView');\n      lNodeToHandle = lNodeToHandle[HOST];\n    }\n\n    const rNode = unwrapRNode(lNodeToHandle);\n    ngDevMode && !isProceduralRenderer(renderer) && assertDomNode(rNode);\n\n    if (action === 0\n    /* WalkTNodeTreeAction.Create */\n    && parent !== null) {\n      if (beforeNode == null) {\n        nativeAppendChild(renderer, parent, rNode);\n      } else {\n        nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);\n      }\n    } else if (action === 1\n    /* WalkTNodeTreeAction.Insert */\n    && parent !== null) {\n      nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);\n    } else if (action === 2\n    /* WalkTNodeTreeAction.Detach */\n    ) {\n      nativeRemoveNode(renderer, rNode, isComponent);\n    } else if (action === 3\n    /* WalkTNodeTreeAction.Destroy */\n    ) {\n      ngDevMode && ngDevMode.rendererDestroyNode++;\n      renderer.destroyNode(rNode);\n    }\n\n    if (lContainer != null) {\n      applyContainer(renderer, action, lContainer, parent, beforeNode);\n    }\n  }\n}\n\nfunction createTextNode(renderer, value) {\n  ngDevMode && ngDevMode.rendererCreateTextNode++;\n  ngDevMode && ngDevMode.rendererSetText++;\n  return isProceduralRenderer(renderer) ? renderer.createText(value) : renderer.createTextNode(value);\n}\n\nfunction updateTextNode(renderer, rNode, value) {\n  ngDevMode && ngDevMode.rendererSetText++;\n  isProceduralRenderer(renderer) ? renderer.setValue(rNode, value) : rNode.textContent = value;\n}\n\nfunction createCommentNode(renderer, value) {\n  ngDevMode && ngDevMode.rendererCreateComment++; // isProceduralRenderer check is not needed because both `Renderer2` and `Renderer3` have the same\n  // method name.\n\n  return renderer.createComment(escapeCommentText(value));\n}\n/**\n * Creates a native element from a tag name, using a renderer.\n * @param renderer A renderer to use\n * @param name the tag name\n * @param namespace Optional namespace for element.\n * @returns the element created\n */\n\n\nfunction createElementNode(renderer, name, namespace) {\n  ngDevMode && ngDevMode.rendererCreateElement++;\n\n  if (isProceduralRenderer(renderer)) {\n    return renderer.createElement(name, namespace);\n  } else {\n    const namespaceUri = namespace !== null ? getNamespaceUri(namespace) : null;\n    return namespaceUri === null ? renderer.createElement(name) : renderer.createElementNS(namespaceUri, name);\n  }\n}\n/**\n * Removes all DOM elements associated with a view.\n *\n * Because some root nodes of the view may be containers, we sometimes need\n * to propagate deeply into the nested containers to remove all elements in the\n * views beneath it.\n *\n * @param tView The `TView' of the `LView` from which elements should be added or removed\n * @param lView The view from which elements should be added or removed\n */\n\n\nfunction removeViewFromContainer(tView, lView) {\n  const renderer = lView[RENDERER];\n  applyView(tView, lView, renderer, 2\n  /* WalkTNodeTreeAction.Detach */\n  , null, null);\n  lView[HOST] = null;\n  lView[T_HOST] = null;\n}\n/**\n * Adds all DOM elements associated with a view.\n *\n * Because some root nodes of the view may be containers, we sometimes need\n * to propagate deeply into the nested containers to add all elements in the\n * views beneath it.\n *\n * @param tView The `TView' of the `LView` from which elements should be added or removed\n * @param parentTNode The `TNode` where the `LView` should be attached to.\n * @param renderer Current renderer to use for DOM manipulations.\n * @param lView The view from which elements should be added or removed\n * @param parentNativeNode The parent `RElement` where it should be inserted into.\n * @param beforeNode The node before which elements should be added, if insert mode\n */\n\n\nfunction addViewToContainer(tView, parentTNode, renderer, lView, parentNativeNode, beforeNode) {\n  lView[HOST] = parentNativeNode;\n  lView[T_HOST] = parentTNode;\n  applyView(tView, lView, renderer, 1\n  /* WalkTNodeTreeAction.Insert */\n  , parentNativeNode, beforeNode);\n}\n/**\n * Detach a `LView` from the DOM by detaching its nodes.\n *\n * @param tView The `TView' of the `LView` to be detached\n * @param lView the `LView` to be detached.\n */\n\n\nfunction renderDetachView(tView, lView) {\n  applyView(tView, lView, lView[RENDERER], 2\n  /* WalkTNodeTreeAction.Detach */\n  , null, null);\n}\n/**\n * Traverses down and up the tree of views and containers to remove listeners and\n * call onDestroy callbacks.\n *\n * Notes:\n *  - Because it's used for onDestroy calls, it needs to be bottom-up.\n *  - Must process containers instead of their views to avoid splicing\n *  when views are destroyed and re-added.\n *  - Using a while loop because it's faster than recursion\n *  - Destroy only called on movement to sibling or movement to parent (laterally or up)\n *\n *  @param rootView The view to destroy\n */\n\n\nfunction destroyViewTree(rootView) {\n  // If the view has no children, we can clean it up and return early.\n  let lViewOrLContainer = rootView[CHILD_HEAD];\n\n  if (!lViewOrLContainer) {\n    return cleanUpView(rootView[TVIEW], rootView);\n  }\n\n  while (lViewOrLContainer) {\n    let next = null;\n\n    if (isLView(lViewOrLContainer)) {\n      // If LView, traverse down to child.\n      next = lViewOrLContainer[CHILD_HEAD];\n    } else {\n      ngDevMode && assertLContainer(lViewOrLContainer); // If container, traverse down to its first LView.\n\n      const firstView = lViewOrLContainer[CONTAINER_HEADER_OFFSET];\n      if (firstView) next = firstView;\n    }\n\n    if (!next) {\n      // Only clean up view when moving to the side or up, as destroy hooks\n      // should be called in order from the bottom up.\n      while (lViewOrLContainer && !lViewOrLContainer[NEXT] && lViewOrLContainer !== rootView) {\n        if (isLView(lViewOrLContainer)) {\n          cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);\n        }\n\n        lViewOrLContainer = lViewOrLContainer[PARENT];\n      }\n\n      if (lViewOrLContainer === null) lViewOrLContainer = rootView;\n\n      if (isLView(lViewOrLContainer)) {\n        cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);\n      }\n\n      next = lViewOrLContainer && lViewOrLContainer[NEXT];\n    }\n\n    lViewOrLContainer = next;\n  }\n}\n/**\n * Inserts a view into a container.\n *\n * This adds the view to the container's array of active views in the correct\n * position. It also adds the view's elements to the DOM if the container isn't a\n * root node of another view (in that case, the view's elements will be added when\n * the container's parent view is added later).\n *\n * @param tView The `TView' of the `LView` to insert\n * @param lView The view to insert\n * @param lContainer The container into which the view should be inserted\n * @param index Which index in the container to insert the child view into\n */\n\n\nfunction insertView(tView, lView, lContainer, index) {\n  ngDevMode && assertLView(lView);\n  ngDevMode && assertLContainer(lContainer);\n  const indexInContainer = CONTAINER_HEADER_OFFSET + index;\n  const containerLength = lContainer.length;\n\n  if (index > 0) {\n    // This is a new view, we need to add it to the children.\n    lContainer[indexInContainer - 1][NEXT] = lView;\n  }\n\n  if (index < containerLength - CONTAINER_HEADER_OFFSET) {\n    lView[NEXT] = lContainer[indexInContainer];\n    addToArray(lContainer, CONTAINER_HEADER_OFFSET + index, lView);\n  } else {\n    lContainer.push(lView);\n    lView[NEXT] = null;\n  }\n\n  lView[PARENT] = lContainer; // track views where declaration and insertion points are different\n\n  const declarationLContainer = lView[DECLARATION_LCONTAINER];\n\n  if (declarationLContainer !== null && lContainer !== declarationLContainer) {\n    trackMovedView(declarationLContainer, lView);\n  } // notify query that a new view has been added\n\n\n  const lQueries = lView[QUERIES];\n\n  if (lQueries !== null) {\n    lQueries.insertView(tView);\n  } // Sets the attached flag\n\n\n  lView[FLAGS] |= 64\n  /* LViewFlags.Attached */\n  ;\n}\n/**\n * Track views created from the declaration container (TemplateRef) and inserted into a\n * different LContainer.\n */\n\n\nfunction trackMovedView(declarationContainer, lView) {\n  ngDevMode && assertDefined(lView, 'LView required');\n  ngDevMode && assertLContainer(declarationContainer);\n  const movedViews = declarationContainer[MOVED_VIEWS];\n  const insertedLContainer = lView[PARENT];\n  ngDevMode && assertLContainer(insertedLContainer);\n  const insertedComponentLView = insertedLContainer[PARENT][DECLARATION_COMPONENT_VIEW];\n  ngDevMode && assertDefined(insertedComponentLView, 'Missing insertedComponentLView');\n  const declaredComponentLView = lView[DECLARATION_COMPONENT_VIEW];\n  ngDevMode && assertDefined(declaredComponentLView, 'Missing declaredComponentLView');\n\n  if (declaredComponentLView !== insertedComponentLView) {\n    // At this point the declaration-component is not same as insertion-component; this means that\n    // this is a transplanted view. Mark the declared lView as having transplanted views so that\n    // those views can participate in CD.\n    declarationContainer[HAS_TRANSPLANTED_VIEWS] = true;\n  }\n\n  if (movedViews === null) {\n    declarationContainer[MOVED_VIEWS] = [lView];\n  } else {\n    movedViews.push(lView);\n  }\n}\n\nfunction detachMovedView(declarationContainer, lView) {\n  ngDevMode && assertLContainer(declarationContainer);\n  ngDevMode && assertDefined(declarationContainer[MOVED_VIEWS], 'A projected view should belong to a non-empty projected views collection');\n  const movedViews = declarationContainer[MOVED_VIEWS];\n  const declarationViewIndex = movedViews.indexOf(lView);\n  const insertionLContainer = lView[PARENT];\n  ngDevMode && assertLContainer(insertionLContainer); // If the view was marked for refresh but then detached before it was checked (where the flag\n  // would be cleared and the counter decremented), we need to decrement the view counter here\n  // instead.\n\n  if (lView[FLAGS] & 512\n  /* LViewFlags.RefreshTransplantedView */\n  ) {\n    lView[FLAGS] &= ~512\n    /* LViewFlags.RefreshTransplantedView */\n    ;\n    updateTransplantedViewCount(insertionLContainer, -1);\n  }\n\n  movedViews.splice(declarationViewIndex, 1);\n}\n/**\n * Detaches a view from a container.\n *\n * This method removes the view from the container's array of active views. It also\n * removes the view's elements from the DOM.\n *\n * @param lContainer The container from which to detach a view\n * @param removeIndex The index of the view to detach\n * @returns Detached LView instance.\n */\n\n\nfunction detachView(lContainer, removeIndex) {\n  if (lContainer.length <= CONTAINER_HEADER_OFFSET) return;\n  const indexInContainer = CONTAINER_HEADER_OFFSET + removeIndex;\n  const viewToDetach = lContainer[indexInContainer];\n\n  if (viewToDetach) {\n    const declarationLContainer = viewToDetach[DECLARATION_LCONTAINER];\n\n    if (declarationLContainer !== null && declarationLContainer !== lContainer) {\n      detachMovedView(declarationLContainer, viewToDetach);\n    }\n\n    if (removeIndex > 0) {\n      lContainer[indexInContainer - 1][NEXT] = viewToDetach[NEXT];\n    }\n\n    const removedLView = removeFromArray(lContainer, CONTAINER_HEADER_OFFSET + removeIndex);\n    removeViewFromContainer(viewToDetach[TVIEW], viewToDetach); // notify query that a view has been removed\n\n    const lQueries = removedLView[QUERIES];\n\n    if (lQueries !== null) {\n      lQueries.detachView(removedLView[TVIEW]);\n    }\n\n    viewToDetach[PARENT] = null;\n    viewToDetach[NEXT] = null; // Unsets the attached flag\n\n    viewToDetach[FLAGS] &= ~64\n    /* LViewFlags.Attached */\n    ;\n  }\n\n  return viewToDetach;\n}\n/**\n * A standalone function which destroys an LView,\n * conducting clean up (e.g. removing listeners, calling onDestroys).\n *\n * @param tView The `TView' of the `LView` to be destroyed\n * @param lView The view to be destroyed.\n */\n\n\nfunction destroyLView(tView, lView) {\n  if (!(lView[FLAGS] & 128\n  /* LViewFlags.Destroyed */\n  )) {\n    const renderer = lView[RENDERER];\n\n    if (isProceduralRenderer(renderer) && renderer.destroyNode) {\n      applyView(tView, lView, renderer, 3\n      /* WalkTNodeTreeAction.Destroy */\n      , null, null);\n    }\n\n    destroyViewTree(lView);\n  }\n}\n/**\n * Calls onDestroys hooks for all directives and pipes in a given view and then removes all\n * listeners. Listeners are removed as the last step so events delivered in the onDestroys hooks\n * can be propagated to @Output listeners.\n *\n * @param tView `TView` for the `LView` to clean up.\n * @param lView The LView to clean up\n */\n\n\nfunction cleanUpView(tView, lView) {\n  if (!(lView[FLAGS] & 128\n  /* LViewFlags.Destroyed */\n  )) {\n    // Usually the Attached flag is removed when the view is detached from its parent, however\n    // if it's a root view, the flag won't be unset hence why we're also removing on destroy.\n    lView[FLAGS] &= ~64\n    /* LViewFlags.Attached */\n    ; // Mark the LView as destroyed *before* executing the onDestroy hooks. An onDestroy hook\n    // runs arbitrary user code, which could include its own `viewRef.destroy()` (or similar). If\n    // We don't flag the view as destroyed before the hooks, this could lead to an infinite loop.\n    // This also aligns with the ViewEngine behavior. It also means that the onDestroy hook is\n    // really more of an \"afterDestroy\" hook if you think about it.\n\n    lView[FLAGS] |= 128\n    /* LViewFlags.Destroyed */\n    ;\n    executeOnDestroys(tView, lView);\n    processCleanups(tView, lView); // For component views only, the local renderer is destroyed at clean up time.\n\n    if (lView[TVIEW].type === 1\n    /* TViewType.Component */\n    && isProceduralRenderer(lView[RENDERER])) {\n      ngDevMode && ngDevMode.rendererDestroy++;\n      lView[RENDERER].destroy();\n    }\n\n    const declarationContainer = lView[DECLARATION_LCONTAINER]; // we are dealing with an embedded view that is still inserted into a container\n\n    if (declarationContainer !== null && isLContainer(lView[PARENT])) {\n      // and this is a projected view\n      if (declarationContainer !== lView[PARENT]) {\n        detachMovedView(declarationContainer, lView);\n      } // For embedded views still attached to a container: remove query result from this view.\n\n\n      const lQueries = lView[QUERIES];\n\n      if (lQueries !== null) {\n        lQueries.detachView(tView);\n      }\n    } // Unregister the view once everything else has been cleaned up.\n\n\n    unregisterLView(lView);\n  }\n}\n/** Removes listeners and unsubscribes from output subscriptions */\n\n\nfunction processCleanups(tView, lView) {\n  const tCleanup = tView.cleanup;\n  const lCleanup = lView[CLEANUP]; // `LCleanup` contains both share information with `TCleanup` as well as instance specific\n  // information appended at the end. We need to know where the end of the `TCleanup` information\n  // is, and we track this with `lastLCleanupIndex`.\n\n  let lastLCleanupIndex = -1;\n\n  if (tCleanup !== null) {\n    for (let i = 0; i < tCleanup.length - 1; i += 2) {\n      if (typeof tCleanup[i] === 'string') {\n        // This is a native DOM listener\n        const idxOrTargetGetter = tCleanup[i + 1];\n        const target = typeof idxOrTargetGetter === 'function' ? idxOrTargetGetter(lView) : unwrapRNode(lView[idxOrTargetGetter]);\n        const listener = lCleanup[lastLCleanupIndex = tCleanup[i + 2]];\n        const useCaptureOrSubIdx = tCleanup[i + 3];\n\n        if (typeof useCaptureOrSubIdx === 'boolean') {\n          // native DOM listener registered with Renderer3\n          target.removeEventListener(tCleanup[i], listener, useCaptureOrSubIdx);\n        } else {\n          if (useCaptureOrSubIdx >= 0) {\n            // unregister\n            lCleanup[lastLCleanupIndex = useCaptureOrSubIdx]();\n          } else {\n            // Subscription\n            lCleanup[lastLCleanupIndex = -useCaptureOrSubIdx].unsubscribe();\n          }\n        }\n\n        i += 2;\n      } else {\n        // This is a cleanup function that is grouped with the index of its context\n        const context = lCleanup[lastLCleanupIndex = tCleanup[i + 1]];\n        tCleanup[i].call(context);\n      }\n    }\n  }\n\n  if (lCleanup !== null) {\n    for (let i = lastLCleanupIndex + 1; i < lCleanup.length; i++) {\n      const instanceCleanupFn = lCleanup[i];\n      ngDevMode && assertFunction(instanceCleanupFn, 'Expecting instance cleanup function.');\n      instanceCleanupFn();\n    }\n\n    lView[CLEANUP] = null;\n  }\n}\n/** Calls onDestroy hooks for this view */\n\n\nfunction executeOnDestroys(tView, lView) {\n  let destroyHooks;\n\n  if (tView != null && (destroyHooks = tView.destroyHooks) != null) {\n    for (let i = 0; i < destroyHooks.length; i += 2) {\n      const context = lView[destroyHooks[i]]; // Only call the destroy hook if the context has been requested.\n\n      if (!(context instanceof NodeInjectorFactory)) {\n        const toCall = destroyHooks[i + 1];\n\n        if (Array.isArray(toCall)) {\n          for (let j = 0; j < toCall.length; j += 2) {\n            const callContext = context[toCall[j]];\n            const hook = toCall[j + 1];\n            profiler(4\n            /* ProfilerEvent.LifecycleHookStart */\n            , callContext, hook);\n\n            try {\n              hook.call(callContext);\n            } finally {\n              profiler(5\n              /* ProfilerEvent.LifecycleHookEnd */\n              , callContext, hook);\n            }\n          }\n        } else {\n          profiler(4\n          /* ProfilerEvent.LifecycleHookStart */\n          , context, toCall);\n\n          try {\n            toCall.call(context);\n          } finally {\n            profiler(5\n            /* ProfilerEvent.LifecycleHookEnd */\n            , context, toCall);\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Returns a native element if a node can be inserted into the given parent.\n *\n * There are two reasons why we may not be able to insert a element immediately.\n * - Projection: When creating a child content element of a component, we have to skip the\n *   insertion because the content of a component will be projected.\n *   `<component><content>delayed due to projection</content></component>`\n * - Parent container is disconnected: This can happen when we are inserting a view into\n *   parent container, which itself is disconnected. For example the parent container is part\n *   of a View which has not be inserted or is made for projection but has not been inserted\n *   into destination.\n *\n * @param tView: Current `TView`.\n * @param tNode: `TNode` for which we wish to retrieve render parent.\n * @param lView: Current `LView`.\n */\n\n\nfunction getParentRElement(tView, tNode, lView) {\n  return getClosestRElement(tView, tNode.parent, lView);\n}\n/**\n * Get closest `RElement` or `null` if it can't be found.\n *\n * If `TNode` is `TNodeType.Element` => return `RElement` at `LView[tNode.index]` location.\n * If `TNode` is `TNodeType.ElementContainer|IcuContain` => return the parent (recursively).\n * If `TNode` is `null` then return host `RElement`:\n *   - return `null` if projection\n *   - return `null` if parent container is disconnected (we have no parent.)\n *\n * @param tView: Current `TView`.\n * @param tNode: `TNode` for which we wish to retrieve `RElement` (or `null` if host element is\n *     needed).\n * @param lView: Current `LView`.\n * @returns `null` if the `RElement` can't be determined at this time (no parent / projection)\n */\n\n\nfunction getClosestRElement(tView, tNode, lView) {\n  let parentTNode = tNode; // Skip over element and ICU containers as those are represented by a comment node and\n  // can't be used as a render parent.\n\n  while (parentTNode !== null && parentTNode.type & (8\n  /* TNodeType.ElementContainer */\n  | 32\n  /* TNodeType.Icu */\n  )) {\n    tNode = parentTNode;\n    parentTNode = tNode.parent;\n  } // If the parent tNode is null, then we are inserting across views: either into an embedded view\n  // or a component view.\n\n\n  if (parentTNode === null) {\n    // We are inserting a root element of the component view into the component host element and\n    // it should always be eager.\n    return lView[HOST];\n  } else {\n    ngDevMode && assertTNodeType(parentTNode, 3\n    /* TNodeType.AnyRNode */\n    | 4\n    /* TNodeType.Container */\n    );\n\n    if (parentTNode.flags & 2\n    /* TNodeFlags.isComponentHost */\n    ) {\n      ngDevMode && assertTNodeForLView(parentTNode, lView);\n      const encapsulation = tView.data[parentTNode.directiveStart].encapsulation; // We've got a parent which is an element in the current view. We just need to verify if the\n      // parent element is not a component. Component's content nodes are not inserted immediately\n      // because they will be projected, and so doing insert at this point would be wasteful.\n      // Since the projection would then move it to its final destination. Note that we can't\n      // make this assumption when using the Shadow DOM, because the native projection placeholders\n      // (<content> or <slot>) have to be in place as elements are being inserted.\n\n      if (encapsulation === ViewEncapsulation.None || encapsulation === ViewEncapsulation.Emulated) {\n        return null;\n      }\n    }\n\n    return getNativeByTNode(parentTNode, lView);\n  }\n}\n/**\n * Inserts a native node before another native node for a given parent using {@link Renderer3}.\n * This is a utility function that can be used when native nodes were determined - it abstracts an\n * actual renderer being used.\n */\n\n\nfunction nativeInsertBefore(renderer, parent, child, beforeNode, isMove) {\n  ngDevMode && ngDevMode.rendererInsertBefore++;\n\n  if (isProceduralRenderer(renderer)) {\n    renderer.insertBefore(parent, child, beforeNode, isMove);\n  } else {\n    const targetParent = isTemplateNode(parent) ? parent.content : parent;\n    targetParent.insertBefore(child, beforeNode, isMove);\n  }\n}\n\nfunction nativeAppendChild(renderer, parent, child) {\n  ngDevMode && ngDevMode.rendererAppendChild++;\n  ngDevMode && assertDefined(parent, 'parent node must be defined');\n\n  if (isProceduralRenderer(renderer)) {\n    renderer.appendChild(parent, child);\n  } else {\n    const targetParent = isTemplateNode(parent) ? parent.content : parent;\n    targetParent.appendChild(child);\n  }\n}\n\nfunction nativeAppendOrInsertBefore(renderer, parent, child, beforeNode, isMove) {\n  if (beforeNode !== null) {\n    nativeInsertBefore(renderer, parent, child, beforeNode, isMove);\n  } else {\n    nativeAppendChild(renderer, parent, child);\n  }\n}\n/** Removes a node from the DOM given its native parent. */\n\n\nfunction nativeRemoveChild(renderer, parent, child, isHostElement) {\n  if (isProceduralRenderer(renderer)) {\n    renderer.removeChild(parent, child, isHostElement);\n  } else {\n    parent.removeChild(child);\n  }\n}\n/** Checks if an element is a `<template>` node. */\n\n\nfunction isTemplateNode(node) {\n  return node.tagName === 'TEMPLATE' && node.content !== undefined;\n}\n/**\n * Returns a native parent of a given native node.\n */\n\n\nfunction nativeParentNode(renderer, node) {\n  return isProceduralRenderer(renderer) ? renderer.parentNode(node) : node.parentNode;\n}\n/**\n * Returns a native sibling of a given native node.\n */\n\n\nfunction nativeNextSibling(renderer, node) {\n  return isProceduralRenderer(renderer) ? renderer.nextSibling(node) : node.nextSibling;\n}\n/**\n * Find a node in front of which `currentTNode` should be inserted.\n *\n * This method determines the `RNode` in front of which we should insert the `currentRNode`. This\n * takes `TNode.insertBeforeIndex` into account if i18n code has been invoked.\n *\n * @param parentTNode parent `TNode`\n * @param currentTNode current `TNode` (The node which we would like to insert into the DOM)\n * @param lView current `LView`\n */\n\n\nfunction getInsertInFrontOfRNode(parentTNode, currentTNode, lView) {\n  return _getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView);\n}\n/**\n * Find a node in front of which `currentTNode` should be inserted. (Does not take i18n into\n * account)\n *\n * This method determines the `RNode` in front of which we should insert the `currentRNode`. This\n * does not take `TNode.insertBeforeIndex` into account.\n *\n * @param parentTNode parent `TNode`\n * @param currentTNode current `TNode` (The node which we would like to insert into the DOM)\n * @param lView current `LView`\n */\n\n\nfunction getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView) {\n  if (parentTNode.type & (8\n  /* TNodeType.ElementContainer */\n  | 32\n  /* TNodeType.Icu */\n  )) {\n    return getNativeByTNode(parentTNode, lView);\n  }\n\n  return null;\n}\n/**\n * Tree shakable boundary for `getInsertInFrontOfRNodeWithI18n` function.\n *\n * This function will only be set if i18n code runs.\n */\n\n\nlet _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithNoI18n;\n/**\n * Tree shakable boundary for `processI18nInsertBefore` function.\n *\n * This function will only be set if i18n code runs.\n */\n\nlet _processI18nInsertBefore;\n\nfunction setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore) {\n  _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithI18n;\n  _processI18nInsertBefore = processI18nInsertBefore;\n}\n/**\n * Appends the `child` native node (or a collection of nodes) to the `parent`.\n *\n * @param tView The `TView' to be appended\n * @param lView The current LView\n * @param childRNode The native child (or children) that should be appended\n * @param childTNode The TNode of the child element\n */\n\n\nfunction appendChild(tView, lView, childRNode, childTNode) {\n  const parentRNode = getParentRElement(tView, childTNode, lView);\n  const renderer = lView[RENDERER];\n  const parentTNode = childTNode.parent || lView[T_HOST];\n  const anchorNode = getInsertInFrontOfRNode(parentTNode, childTNode, lView);\n\n  if (parentRNode != null) {\n    if (Array.isArray(childRNode)) {\n      for (let i = 0; i < childRNode.length; i++) {\n        nativeAppendOrInsertBefore(renderer, parentRNode, childRNode[i], anchorNode, false);\n      }\n    } else {\n      nativeAppendOrInsertBefore(renderer, parentRNode, childRNode, anchorNode, false);\n    }\n  }\n\n  _processI18nInsertBefore !== undefined && _processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRNode);\n}\n/**\n * Returns the first native node for a given LView, starting from the provided TNode.\n *\n * Native nodes are returned in the order in which those appear in the native tree (DOM).\n */\n\n\nfunction getFirstNativeNode(lView, tNode) {\n  if (tNode !== null) {\n    ngDevMode && assertTNodeType(tNode, 3\n    /* TNodeType.AnyRNode */\n    | 12\n    /* TNodeType.AnyContainer */\n    | 32\n    /* TNodeType.Icu */\n    | 16\n    /* TNodeType.Projection */\n    );\n    const tNodeType = tNode.type;\n\n    if (tNodeType & 3\n    /* TNodeType.AnyRNode */\n    ) {\n      return getNativeByTNode(tNode, lView);\n    } else if (tNodeType & 4\n    /* TNodeType.Container */\n    ) {\n      return getBeforeNodeForView(-1, lView[tNode.index]);\n    } else if (tNodeType & 8\n    /* TNodeType.ElementContainer */\n    ) {\n      const elIcuContainerChild = tNode.child;\n\n      if (elIcuContainerChild !== null) {\n        return getFirstNativeNode(lView, elIcuContainerChild);\n      } else {\n        const rNodeOrLContainer = lView[tNode.index];\n\n        if (isLContainer(rNodeOrLContainer)) {\n          return getBeforeNodeForView(-1, rNodeOrLContainer);\n        } else {\n          return unwrapRNode(rNodeOrLContainer);\n        }\n      }\n    } else if (tNodeType & 32\n    /* TNodeType.Icu */\n    ) {\n      let nextRNode = icuContainerIterate(tNode, lView);\n      let rNode = nextRNode(); // If the ICU container has no nodes, than we use the ICU anchor as the node.\n\n      return rNode || unwrapRNode(lView[tNode.index]);\n    } else {\n      const projectionNodes = getProjectionNodes(lView, tNode);\n\n      if (projectionNodes !== null) {\n        if (Array.isArray(projectionNodes)) {\n          return projectionNodes[0];\n        }\n\n        const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);\n        ngDevMode && assertParentView(parentView);\n        return getFirstNativeNode(parentView, projectionNodes);\n      } else {\n        return getFirstNativeNode(lView, tNode.next);\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction getProjectionNodes(lView, tNode) {\n  if (tNode !== null) {\n    const componentView = lView[DECLARATION_COMPONENT_VIEW];\n    const componentHost = componentView[T_HOST];\n    const slotIdx = tNode.projection;\n    ngDevMode && assertProjectionSlots(lView);\n    return componentHost.projection[slotIdx];\n  }\n\n  return null;\n}\n\nfunction getBeforeNodeForView(viewIndexInContainer, lContainer) {\n  const nextViewIndex = CONTAINER_HEADER_OFFSET + viewIndexInContainer + 1;\n\n  if (nextViewIndex < lContainer.length) {\n    const lView = lContainer[nextViewIndex];\n    const firstTNodeOfView = lView[TVIEW].firstChild;\n\n    if (firstTNodeOfView !== null) {\n      return getFirstNativeNode(lView, firstTNodeOfView);\n    }\n  }\n\n  return lContainer[NATIVE];\n}\n/**\n * Removes a native node itself using a given renderer. To remove the node we are looking up its\n * parent from the native tree as not all platforms / browsers support the equivalent of\n * node.remove().\n *\n * @param renderer A renderer to be used\n * @param rNode The native node that should be removed\n * @param isHostElement A flag indicating if a node to be removed is a host of a component.\n */\n\n\nfunction nativeRemoveNode(renderer, rNode, isHostElement) {\n  ngDevMode && ngDevMode.rendererRemoveNode++;\n  const nativeParent = nativeParentNode(renderer, rNode);\n\n  if (nativeParent) {\n    nativeRemoveChild(renderer, nativeParent, rNode, isHostElement);\n  }\n}\n/**\n * Performs the operation of `action` on the node. Typically this involves inserting or removing\n * nodes on the LView or projection boundary.\n */\n\n\nfunction applyNodes(renderer, action, tNode, lView, parentRElement, beforeNode, isProjection) {\n  while (tNode != null) {\n    ngDevMode && assertTNodeForLView(tNode, lView);\n    ngDevMode && assertTNodeType(tNode, 3\n    /* TNodeType.AnyRNode */\n    | 12\n    /* TNodeType.AnyContainer */\n    | 16\n    /* TNodeType.Projection */\n    | 32\n    /* TNodeType.Icu */\n    );\n    const rawSlotValue = lView[tNode.index];\n    const tNodeType = tNode.type;\n\n    if (isProjection) {\n      if (action === 0\n      /* WalkTNodeTreeAction.Create */\n      ) {\n        rawSlotValue && attachPatchData(unwrapRNode(rawSlotValue), lView);\n        tNode.flags |= 4\n        /* TNodeFlags.isProjected */\n        ;\n      }\n    }\n\n    if ((tNode.flags & 64\n    /* TNodeFlags.isDetached */\n    ) !== 64\n    /* TNodeFlags.isDetached */\n    ) {\n      if (tNodeType & 8\n      /* TNodeType.ElementContainer */\n      ) {\n        applyNodes(renderer, action, tNode.child, lView, parentRElement, beforeNode, false);\n        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);\n      } else if (tNodeType & 32\n      /* TNodeType.Icu */\n      ) {\n        const nextRNode = icuContainerIterate(tNode, lView);\n        let rNode;\n\n        while (rNode = nextRNode()) {\n          applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);\n        }\n\n        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);\n      } else if (tNodeType & 16\n      /* TNodeType.Projection */\n      ) {\n        applyProjectionRecursive(renderer, action, lView, tNode, parentRElement, beforeNode);\n      } else {\n        ngDevMode && assertTNodeType(tNode, 3\n        /* TNodeType.AnyRNode */\n        | 4\n        /* TNodeType.Container */\n        );\n        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);\n      }\n    }\n\n    tNode = isProjection ? tNode.projectionNext : tNode.next;\n  }\n}\n\nfunction applyView(tView, lView, renderer, action, parentRElement, beforeNode) {\n  applyNodes(renderer, action, tView.firstChild, lView, parentRElement, beforeNode, false);\n}\n/**\n * `applyProjection` performs operation on the projection.\n *\n * Inserting a projection requires us to locate the projected nodes from the parent component. The\n * complication is that those nodes themselves could be re-projected from their parent component.\n *\n * @param tView The `TView` of `LView` which needs to be inserted, detached, destroyed\n * @param lView The `LView` which needs to be inserted, detached, destroyed.\n * @param tProjectionNode node to project\n */\n\n\nfunction applyProjection(tView, lView, tProjectionNode) {\n  const renderer = lView[RENDERER];\n  const parentRNode = getParentRElement(tView, tProjectionNode, lView);\n  const parentTNode = tProjectionNode.parent || lView[T_HOST];\n  let beforeNode = getInsertInFrontOfRNode(parentTNode, tProjectionNode, lView);\n  applyProjectionRecursive(renderer, 0\n  /* WalkTNodeTreeAction.Create */\n  , lView, tProjectionNode, parentRNode, beforeNode);\n}\n/**\n * `applyProjectionRecursive` performs operation on the projection specified by `action` (insert,\n * detach, destroy)\n *\n * Inserting a projection requires us to locate the projected nodes from the parent component. The\n * complication is that those nodes themselves could be re-projected from their parent component.\n *\n * @param renderer Render to use\n * @param action action to perform (insert, detach, destroy)\n * @param lView The LView which needs to be inserted, detached, destroyed.\n * @param tProjectionNode node to project\n * @param parentRElement parent DOM element for insertion/removal.\n * @param beforeNode Before which node the insertions should happen.\n */\n\n\nfunction applyProjectionRecursive(renderer, action, lView, tProjectionNode, parentRElement, beforeNode) {\n  const componentLView = lView[DECLARATION_COMPONENT_VIEW];\n  const componentNode = componentLView[T_HOST];\n  ngDevMode && assertEqual(typeof tProjectionNode.projection, 'number', 'expecting projection index');\n  const nodeToProjectOrRNodes = componentNode.projection[tProjectionNode.projection];\n\n  if (Array.isArray(nodeToProjectOrRNodes)) {\n    // This should not exist, it is a bit of a hack. When we bootstrap a top level node and we\n    // need to support passing projectable nodes, so we cheat and put them in the TNode\n    // of the Host TView. (Yes we put instance info at the T Level). We can get away with it\n    // because we know that that TView is not shared and therefore it will not be a problem.\n    // This should be refactored and cleaned up.\n    for (let i = 0; i < nodeToProjectOrRNodes.length; i++) {\n      const rNode = nodeToProjectOrRNodes[i];\n      applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);\n    }\n  } else {\n    let nodeToProject = nodeToProjectOrRNodes;\n    const projectedComponentLView = componentLView[PARENT];\n    applyNodes(renderer, action, nodeToProject, projectedComponentLView, parentRElement, beforeNode, true);\n  }\n}\n/**\n * `applyContainer` performs an operation on the container and its views as specified by\n * `action` (insert, detach, destroy)\n *\n * Inserting a Container is complicated by the fact that the container may have Views which\n * themselves have containers or projections.\n *\n * @param renderer Renderer to use\n * @param action action to perform (insert, detach, destroy)\n * @param lContainer The LContainer which needs to be inserted, detached, destroyed.\n * @param parentRElement parent DOM element for insertion/removal.\n * @param beforeNode Before which node the insertions should happen.\n */\n\n\nfunction applyContainer(renderer, action, lContainer, parentRElement, beforeNode) {\n  ngDevMode && assertLContainer(lContainer);\n  const anchor = lContainer[NATIVE]; // LContainer has its own before node.\n\n  const native = unwrapRNode(lContainer); // An LContainer can be created dynamically on any node by injecting ViewContainerRef.\n  // Asking for a ViewContainerRef on an element will result in a creation of a separate anchor\n  // node (comment in the DOM) that will be different from the LContainer's host node. In this\n  // particular case we need to execute action on 2 nodes:\n  // - container's host node (this is done in the executeActionOnElementOrContainer)\n  // - container's host node (this is done here)\n\n  if (anchor !== native) {\n    // This is very strange to me (Misko). I would expect that the native is same as anchor. I\n    // don't see a reason why they should be different, but they are.\n    //\n    // If they are we need to process the second anchor as well.\n    applyToElementOrContainer(action, renderer, parentRElement, anchor, beforeNode);\n  }\n\n  for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n    const lView = lContainer[i];\n    applyView(lView[TVIEW], lView, renderer, action, parentRElement, anchor);\n  }\n}\n/**\n * Writes class/style to element.\n *\n * @param renderer Renderer to use.\n * @param isClassBased `true` if it should be written to `class` (`false` to write to `style`)\n * @param rNode The Node to write to.\n * @param prop Property to write to. This would be the class/style name.\n * @param value Value to write. If `null`/`undefined`/`false` this is considered a remove (set/add\n *        otherwise).\n */\n\n\nfunction applyStyling(renderer, isClassBased, rNode, prop, value) {\n  const isProcedural = isProceduralRenderer(renderer);\n\n  if (isClassBased) {\n    // We actually want JS true/false here because any truthy value should add the class\n    if (!value) {\n      ngDevMode && ngDevMode.rendererRemoveClass++;\n\n      if (isProcedural) {\n        renderer.removeClass(rNode, prop);\n      } else {\n        rNode.classList.remove(prop);\n      }\n    } else {\n      ngDevMode && ngDevMode.rendererAddClass++;\n\n      if (isProcedural) {\n        renderer.addClass(rNode, prop);\n      } else {\n        ngDevMode && assertDefined(rNode.classList, 'HTMLElement expected');\n        rNode.classList.add(prop);\n      }\n    }\n  } else {\n    let flags = prop.indexOf('-') === -1 ? undefined : RendererStyleFlags2.DashCase;\n\n    if (value == null\n    /** || value === undefined */\n    ) {\n      ngDevMode && ngDevMode.rendererRemoveStyle++;\n\n      if (isProcedural) {\n        renderer.removeStyle(rNode, prop, flags);\n      } else {\n        rNode.style.removeProperty(prop);\n      }\n    } else {\n      // A value is important if it ends with `!important`. The style\n      // parser strips any semicolons at the end of the value.\n      const isImportant = typeof value === 'string' ? value.endsWith('!important') : false;\n\n      if (isImportant) {\n        // !important has to be stripped from the value for it to be valid.\n        value = value.slice(0, -10);\n        flags |= RendererStyleFlags2.Important;\n      }\n\n      ngDevMode && ngDevMode.rendererSetStyle++;\n\n      if (isProcedural) {\n        renderer.setStyle(rNode, prop, value, flags);\n      } else {\n        ngDevMode && assertDefined(rNode.style, 'HTMLElement expected');\n        rNode.style.setProperty(prop, value, isImportant ? 'important' : '');\n      }\n    }\n  }\n}\n/**\n * Write `cssText` to `RElement`.\n *\n * This function does direct write without any reconciliation. Used for writing initial values, so\n * that static styling values do not pull in the style parser.\n *\n * @param renderer Renderer to use\n * @param element The element which needs to be updated.\n * @param newValue The new class list to write.\n */\n\n\nfunction writeDirectStyle(renderer, element, newValue) {\n  ngDevMode && assertString(newValue, '\\'newValue\\' should be a string');\n\n  if (isProceduralRenderer(renderer)) {\n    renderer.setAttribute(element, 'style', newValue);\n  } else {\n    element.style.cssText = newValue;\n  }\n\n  ngDevMode && ngDevMode.rendererSetStyle++;\n}\n/**\n * Write `className` to `RElement`.\n *\n * This function does direct write without any reconciliation. Used for writing initial values, so\n * that static styling values do not pull in the style parser.\n *\n * @param renderer Renderer to use\n * @param element The element which needs to be updated.\n * @param newValue The new class list to write.\n */\n\n\nfunction writeDirectClass(renderer, element, newValue) {\n  ngDevMode && assertString(newValue, '\\'newValue\\' should be a string');\n\n  if (isProceduralRenderer(renderer)) {\n    if (newValue === '') {\n      // There are tests in `google3` which expect `element.getAttribute('class')` to be `null`.\n      renderer.removeAttribute(element, 'class');\n    } else {\n      renderer.setAttribute(element, 'class', newValue);\n    }\n  } else {\n    element.className = newValue;\n  }\n\n  ngDevMode && ngDevMode.rendererSetClassName++;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Returns an index of `classToSearch` in `className` taking token boundaries into account.\n *\n * `classIndexOf('AB A', 'A', 0)` will be 3 (not 0 since `AB!==A`)\n *\n * @param className A string containing classes (whitespace separated)\n * @param classToSearch A class name to locate\n * @param startingIndex Starting location of search\n * @returns an index of the located class (or -1 if not found)\n */\n\n\nfunction classIndexOf(className, classToSearch, startingIndex) {\n  ngDevMode && assertNotEqual(classToSearch, '', 'can not look for \"\" string.');\n  let end = className.length;\n\n  while (true) {\n    const foundIndex = className.indexOf(classToSearch, startingIndex);\n    if (foundIndex === -1) return foundIndex;\n\n    if (foundIndex === 0 || className.charCodeAt(foundIndex - 1) <= 32\n    /* CharCode.SPACE */\n    ) {\n      // Ensure that it has leading whitespace\n      const length = classToSearch.length;\n\n      if (foundIndex + length === end || className.charCodeAt(foundIndex + length) <= 32\n      /* CharCode.SPACE */\n      ) {\n        // Ensure that it has trailing whitespace\n        return foundIndex;\n      }\n    } // False positive, keep searching from where we left off.\n\n\n    startingIndex = foundIndex + 1;\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nconst unusedValueToPlacateAjd$1 = unusedValueExportToPlacateAjd$4 + unusedValueExportToPlacateAjd$3;\nconst NG_TEMPLATE_SELECTOR = 'ng-template';\n/**\n * Search the `TAttributes` to see if it contains `cssClassToMatch` (case insensitive)\n *\n * @param attrs `TAttributes` to search through.\n * @param cssClassToMatch class to match (lowercase)\n * @param isProjectionMode Whether or not class matching should look into the attribute `class` in\n *    addition to the `AttributeMarker.Classes`.\n */\n\nfunction isCssClassMatching(attrs, cssClassToMatch, isProjectionMode) {\n  // TODO(misko): The fact that this function needs to know about `isProjectionMode` seems suspect.\n  // It is strange to me that sometimes the class information comes in form of `class` attribute\n  // and sometimes in form of `AttributeMarker.Classes`. Some investigation is needed to determine\n  // if that is the right behavior.\n  ngDevMode && assertEqual(cssClassToMatch, cssClassToMatch.toLowerCase(), 'Class name expected to be lowercase.');\n  let i = 0;\n\n  while (i < attrs.length) {\n    let item = attrs[i++];\n\n    if (isProjectionMode && item === 'class') {\n      item = attrs[i];\n\n      if (classIndexOf(item.toLowerCase(), cssClassToMatch, 0) !== -1) {\n        return true;\n      }\n    } else if (item === 1\n    /* AttributeMarker.Classes */\n    ) {\n      // We found the classes section. Start searching for the class.\n      while (i < attrs.length && typeof (item = attrs[i++]) == 'string') {\n        // while we have strings\n        if (item.toLowerCase() === cssClassToMatch) return true;\n      }\n\n      return false;\n    }\n  }\n\n  return false;\n}\n/**\n * Checks whether the `tNode` represents an inline template (e.g. `*ngFor`).\n *\n * @param tNode current TNode\n */\n\n\nfunction isInlineTemplate(tNode) {\n  return tNode.type === 4\n  /* TNodeType.Container */\n  && tNode.value !== NG_TEMPLATE_SELECTOR;\n}\n/**\n * Function that checks whether a given tNode matches tag-based selector and has a valid type.\n *\n * Matching can be performed in 2 modes: projection mode (when we project nodes) and regular\n * directive matching mode:\n * - in the \"directive matching\" mode we do _not_ take TContainer's tagName into account if it is\n * different from NG_TEMPLATE_SELECTOR (value different from NG_TEMPLATE_SELECTOR indicates that a\n * tag name was extracted from * syntax so we would match the same directive twice);\n * - in the \"projection\" mode, we use a tag name potentially extracted from the * syntax processing\n * (applicable to TNodeType.Container only).\n */\n\n\nfunction hasTagAndTypeMatch(tNode, currentSelector, isProjectionMode) {\n  const tagNameToCompare = tNode.type === 4\n  /* TNodeType.Container */\n  && !isProjectionMode ? NG_TEMPLATE_SELECTOR : tNode.value;\n  return currentSelector === tagNameToCompare;\n}\n/**\n * A utility function to match an Ivy node static data against a simple CSS selector\n *\n * @param node static data of the node to match\n * @param selector The selector to try matching against the node.\n * @param isProjectionMode if `true` we are matching for content projection, otherwise we are doing\n * directive matching.\n * @returns true if node matches the selector.\n */\n\n\nfunction isNodeMatchingSelector(tNode, selector, isProjectionMode) {\n  ngDevMode && assertDefined(selector[0], 'Selector should have a tag name');\n  let mode = 4\n  /* SelectorFlags.ELEMENT */\n  ;\n  const nodeAttrs = tNode.attrs || []; // Find the index of first attribute that has no value, only a name.\n\n  const nameOnlyMarkerIdx = getNameOnlyMarkerIndex(nodeAttrs); // When processing \":not\" selectors, we skip to the next \":not\" if the\n  // current one doesn't match\n\n  let skipToNextSelector = false;\n\n  for (let i = 0; i < selector.length; i++) {\n    const current = selector[i];\n\n    if (typeof current === 'number') {\n      // If we finish processing a :not selector and it hasn't failed, return false\n      if (!skipToNextSelector && !isPositive(mode) && !isPositive(current)) {\n        return false;\n      } // If we are skipping to the next :not() and this mode flag is positive,\n      // it's a part of the current :not() selector, and we should keep skipping\n\n\n      if (skipToNextSelector && isPositive(current)) continue;\n      skipToNextSelector = false;\n      mode = current | mode & 1\n      /* SelectorFlags.NOT */\n      ;\n      continue;\n    }\n\n    if (skipToNextSelector) continue;\n\n    if (mode & 4\n    /* SelectorFlags.ELEMENT */\n    ) {\n      mode = 2\n      /* SelectorFlags.ATTRIBUTE */\n      | mode & 1\n      /* SelectorFlags.NOT */\n      ;\n\n      if (current !== '' && !hasTagAndTypeMatch(tNode, current, isProjectionMode) || current === '' && selector.length === 1) {\n        if (isPositive(mode)) return false;\n        skipToNextSelector = true;\n      }\n    } else {\n      const selectorAttrValue = mode & 8\n      /* SelectorFlags.CLASS */\n      ? current : selector[++i]; // special case for matching against classes when a tNode has been instantiated with\n      // class and style values as separate attribute values (e.g. ['title', CLASS, 'foo'])\n\n      if (mode & 8\n      /* SelectorFlags.CLASS */\n      && tNode.attrs !== null) {\n        if (!isCssClassMatching(tNode.attrs, selectorAttrValue, isProjectionMode)) {\n          if (isPositive(mode)) return false;\n          skipToNextSelector = true;\n        }\n\n        continue;\n      }\n\n      const attrName = mode & 8\n      /* SelectorFlags.CLASS */\n      ? 'class' : current;\n      const attrIndexInNode = findAttrIndexInNode(attrName, nodeAttrs, isInlineTemplate(tNode), isProjectionMode);\n\n      if (attrIndexInNode === -1) {\n        if (isPositive(mode)) return false;\n        skipToNextSelector = true;\n        continue;\n      }\n\n      if (selectorAttrValue !== '') {\n        let nodeAttrValue;\n\n        if (attrIndexInNode > nameOnlyMarkerIdx) {\n          nodeAttrValue = '';\n        } else {\n          ngDevMode && assertNotEqual(nodeAttrs[attrIndexInNode], 0\n          /* AttributeMarker.NamespaceURI */\n          , 'We do not match directives on namespaced attributes'); // we lowercase the attribute value to be able to match\n          // selectors without case-sensitivity\n          // (selectors are already in lowercase when generated)\n\n          nodeAttrValue = nodeAttrs[attrIndexInNode + 1].toLowerCase();\n        }\n\n        const compareAgainstClassName = mode & 8\n        /* SelectorFlags.CLASS */\n        ? nodeAttrValue : null;\n\n        if (compareAgainstClassName && classIndexOf(compareAgainstClassName, selectorAttrValue, 0) !== -1 || mode & 2\n        /* SelectorFlags.ATTRIBUTE */\n        && selectorAttrValue !== nodeAttrValue) {\n          if (isPositive(mode)) return false;\n          skipToNextSelector = true;\n        }\n      }\n    }\n  }\n\n  return isPositive(mode) || skipToNextSelector;\n}\n\nfunction isPositive(mode) {\n  return (mode & 1\n  /* SelectorFlags.NOT */\n  ) === 0;\n}\n/**\n * Examines the attribute's definition array for a node to find the index of the\n * attribute that matches the given `name`.\n *\n * NOTE: This will not match namespaced attributes.\n *\n * Attribute matching depends upon `isInlineTemplate` and `isProjectionMode`.\n * The following table summarizes which types of attributes we attempt to match:\n *\n * ===========================================================================================================\n * Modes                   | Normal Attributes | Bindings Attributes | Template Attributes | I18n\n * Attributes\n * ===========================================================================================================\n * Inline + Projection     | YES               | YES                 | NO                  | YES\n * -----------------------------------------------------------------------------------------------------------\n * Inline + Directive      | NO                | NO                  | YES                 | NO\n * -----------------------------------------------------------------------------------------------------------\n * Non-inline + Projection | YES               | YES                 | NO                  | YES\n * -----------------------------------------------------------------------------------------------------------\n * Non-inline + Directive  | YES               | YES                 | NO                  | YES\n * ===========================================================================================================\n *\n * @param name the name of the attribute to find\n * @param attrs the attribute array to examine\n * @param isInlineTemplate true if the node being matched is an inline template (e.g. `*ngFor`)\n * rather than a manually expanded template node (e.g `<ng-template>`).\n * @param isProjectionMode true if we are matching against content projection otherwise we are\n * matching against directives.\n */\n\n\nfunction findAttrIndexInNode(name, attrs, isInlineTemplate, isProjectionMode) {\n  if (attrs === null) return -1;\n  let i = 0;\n\n  if (isProjectionMode || !isInlineTemplate) {\n    let bindingsMode = false;\n\n    while (i < attrs.length) {\n      const maybeAttrName = attrs[i];\n\n      if (maybeAttrName === name) {\n        return i;\n      } else if (maybeAttrName === 3\n      /* AttributeMarker.Bindings */\n      || maybeAttrName === 6\n      /* AttributeMarker.I18n */\n      ) {\n        bindingsMode = true;\n      } else if (maybeAttrName === 1\n      /* AttributeMarker.Classes */\n      || maybeAttrName === 2\n      /* AttributeMarker.Styles */\n      ) {\n        let value = attrs[++i]; // We should skip classes here because we have a separate mechanism for\n        // matching classes in projection mode.\n\n        while (typeof value === 'string') {\n          value = attrs[++i];\n        }\n\n        continue;\n      } else if (maybeAttrName === 4\n      /* AttributeMarker.Template */\n      ) {\n        // We do not care about Template attributes in this scenario.\n        break;\n      } else if (maybeAttrName === 0\n      /* AttributeMarker.NamespaceURI */\n      ) {\n        // Skip the whole namespaced attribute and value. This is by design.\n        i += 4;\n        continue;\n      } // In binding mode there are only names, rather than name-value pairs.\n\n\n      i += bindingsMode ? 1 : 2;\n    } // We did not match the attribute\n\n\n    return -1;\n  } else {\n    return matchTemplateAttribute(attrs, name);\n  }\n}\n\nfunction isNodeMatchingSelectorList(tNode, selector, isProjectionMode = false) {\n  for (let i = 0; i < selector.length; i++) {\n    if (isNodeMatchingSelector(tNode, selector[i], isProjectionMode)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getProjectAsAttrValue(tNode) {\n  const nodeAttrs = tNode.attrs;\n\n  if (nodeAttrs != null) {\n    const ngProjectAsAttrIdx = nodeAttrs.indexOf(5\n    /* AttributeMarker.ProjectAs */\n    ); // only check for ngProjectAs in attribute names, don't accidentally match attribute's value\n    // (attribute names are stored at even indexes)\n\n    if ((ngProjectAsAttrIdx & 1) === 0) {\n      return nodeAttrs[ngProjectAsAttrIdx + 1];\n    }\n  }\n\n  return null;\n}\n\nfunction getNameOnlyMarkerIndex(nodeAttrs) {\n  for (let i = 0; i < nodeAttrs.length; i++) {\n    const nodeAttr = nodeAttrs[i];\n\n    if (isNameOnlyAttributeMarker(nodeAttr)) {\n      return i;\n    }\n  }\n\n  return nodeAttrs.length;\n}\n\nfunction matchTemplateAttribute(attrs, name) {\n  let i = attrs.indexOf(4\n  /* AttributeMarker.Template */\n  );\n\n  if (i > -1) {\n    i++;\n\n    while (i < attrs.length) {\n      const attr = attrs[i]; // Return in case we checked all template attrs and are switching to the next section in the\n      // attrs array (that starts with a number that represents an attribute marker).\n\n      if (typeof attr === 'number') return -1;\n      if (attr === name) return i;\n      i++;\n    }\n  }\n\n  return -1;\n}\n/**\n * Checks whether a selector is inside a CssSelectorList\n * @param selector Selector to be checked.\n * @param list List in which to look for the selector.\n */\n\n\nfunction isSelectorInSelectorList(selector, list) {\n  selectorListLoop: for (let i = 0; i < list.length; i++) {\n    const currentSelectorInList = list[i];\n\n    if (selector.length !== currentSelectorInList.length) {\n      continue;\n    }\n\n    for (let j = 0; j < selector.length; j++) {\n      if (selector[j] !== currentSelectorInList[j]) {\n        continue selectorListLoop;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction maybeWrapInNotSelector(isNegativeMode, chunk) {\n  return isNegativeMode ? ':not(' + chunk.trim() + ')' : chunk;\n}\n\nfunction stringifyCSSSelector(selector) {\n  let result = selector[0];\n  let i = 1;\n  let mode = 2\n  /* SelectorFlags.ATTRIBUTE */\n  ;\n  let currentChunk = '';\n  let isNegativeMode = false;\n\n  while (i < selector.length) {\n    let valueOrMarker = selector[i];\n\n    if (typeof valueOrMarker === 'string') {\n      if (mode & 2\n      /* SelectorFlags.ATTRIBUTE */\n      ) {\n        const attrValue = selector[++i];\n        currentChunk += '[' + valueOrMarker + (attrValue.length > 0 ? '=\"' + attrValue + '\"' : '') + ']';\n      } else if (mode & 8\n      /* SelectorFlags.CLASS */\n      ) {\n        currentChunk += '.' + valueOrMarker;\n      } else if (mode & 4\n      /* SelectorFlags.ELEMENT */\n      ) {\n        currentChunk += ' ' + valueOrMarker;\n      }\n    } else {\n      //\n      // Append current chunk to the final result in case we come across SelectorFlag, which\n      // indicates that the previous section of a selector is over. We need to accumulate content\n      // between flags to make sure we wrap the chunk later in :not() selector if needed, e.g.\n      // ```\n      //  ['', Flags.CLASS, '.classA', Flags.CLASS | Flags.NOT, '.classB', '.classC']\n      // ```\n      // should be transformed to `.classA :not(.classB .classC)`.\n      //\n      // Note: for negative selector part, we accumulate content between flags until we find the\n      // next negative flag. This is needed to support a case where `:not()` rule contains more than\n      // one chunk, e.g. the following selector:\n      // ```\n      //  ['', Flags.ELEMENT | Flags.NOT, 'p', Flags.CLASS, 'foo', Flags.CLASS | Flags.NOT, 'bar']\n      // ```\n      // should be stringified to `:not(p.foo) :not(.bar)`\n      //\n      if (currentChunk !== '' && !isPositive(valueOrMarker)) {\n        result += maybeWrapInNotSelector(isNegativeMode, currentChunk);\n        currentChunk = '';\n      }\n\n      mode = valueOrMarker; // According to CssSelector spec, once we come across `SelectorFlags.NOT` flag, the negative\n      // mode is maintained for remaining chunks of a selector.\n\n      isNegativeMode = isNegativeMode || !isPositive(mode);\n    }\n\n    i++;\n  }\n\n  if (currentChunk !== '') {\n    result += maybeWrapInNotSelector(isNegativeMode, currentChunk);\n  }\n\n  return result;\n}\n/**\n * Generates string representation of CSS selector in parsed form.\n *\n * ComponentDef and DirectiveDef are generated with the selector in parsed form to avoid doing\n * additional parsing at runtime (for example, for directive matching). However in some cases (for\n * example, while bootstrapping a component), a string version of the selector is required to query\n * for the host element on the page. This function takes the parsed form of a selector and returns\n * its string representation.\n *\n * @param selectorList selector in parsed form\n * @returns string representation of a given selector\n */\n\n\nfunction stringifyCSSSelectorList(selectorList) {\n  return selectorList.map(stringifyCSSSelector).join(',');\n}\n/**\n * Extracts attributes and classes information from a given CSS selector.\n *\n * This function is used while creating a component dynamically. In this case, the host element\n * (that is created dynamically) should contain attributes and classes specified in component's CSS\n * selector.\n *\n * @param selector CSS selector in parsed form (in a form of array)\n * @returns object with `attrs` and `classes` fields that contain extracted information\n */\n\n\nfunction extractAttrsAndClassesFromSelector(selector) {\n  const attrs = [];\n  const classes = [];\n  let i = 1;\n  let mode = 2\n  /* SelectorFlags.ATTRIBUTE */\n  ;\n\n  while (i < selector.length) {\n    let valueOrMarker = selector[i];\n\n    if (typeof valueOrMarker === 'string') {\n      if (mode === 2\n      /* SelectorFlags.ATTRIBUTE */\n      ) {\n        if (valueOrMarker !== '') {\n          attrs.push(valueOrMarker, selector[++i]);\n        }\n      } else if (mode === 8\n      /* SelectorFlags.CLASS */\n      ) {\n        classes.push(valueOrMarker);\n      }\n    } else {\n      // According to CssSelector spec, once we come across `SelectorFlags.NOT` flag, the negative\n      // mode is maintained for remaining chunks of a selector. Since attributes and classes are\n      // extracted only for \"positive\" part of the selector, we can stop here.\n      if (!isPositive(mode)) break;\n      mode = valueOrMarker;\n    }\n\n    i++;\n  }\n\n  return {\n    attrs,\n    classes\n  };\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** A special value which designates that a value has not changed. */\n\n\nconst NO_CHANGE = typeof ngDevMode === 'undefined' || ngDevMode ? {\n  __brand__: 'NO_CHANGE'\n} : {};\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Advances to an element for later binding instructions.\n *\n * Used in conjunction with instructions like {@link property} to act on elements with specified\n * indices, for example those created with {@link element} or {@link elementStart}.\n *\n * ```ts\n * (rf: RenderFlags, ctx: any) => {\n *   if (rf & 1) {\n *     text(0, 'Hello');\n *     text(1, 'Goodbye')\n *     element(2, 'div');\n *   }\n *   if (rf & 2) {\n *     advance(2); // Advance twice to the <div>.\n *     property('title', 'test');\n *   }\n *  }\n * ```\n * @param delta Number of elements to advance forwards by.\n *\n * @codeGenApi\n */\n\nfunction ɵɵadvance(delta) {\n  ngDevMode && assertGreaterThan(delta, 0, 'Can only advance forward');\n  selectIndexInternal(getTView(), getLView(), getSelectedIndex() + delta, !!ngDevMode && isInCheckNoChangesMode());\n}\n\nfunction selectIndexInternal(tView, lView, index, checkNoChangesMode) {\n  ngDevMode && assertIndexInDeclRange(lView, index); // Flush the initial hooks for elements in the view that have been added up to this point.\n  // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n\n  if (!checkNoChangesMode) {\n    const hooksInitPhaseCompleted = (lView[FLAGS] & 3\n    /* LViewFlags.InitPhaseStateMask */\n    ) === 3\n    /* InitPhaseState.InitPhaseCompleted */\n    ;\n\n    if (hooksInitPhaseCompleted) {\n      const preOrderCheckHooks = tView.preOrderCheckHooks;\n\n      if (preOrderCheckHooks !== null) {\n        executeCheckHooks(lView, preOrderCheckHooks, index);\n      }\n    } else {\n      const preOrderHooks = tView.preOrderHooks;\n\n      if (preOrderHooks !== null) {\n        executeInitAndCheckHooks(lView, preOrderHooks, 0\n        /* InitPhaseState.OnInitHooksToBeRun */\n        , index);\n      }\n    }\n  } // We must set the selected index *after* running the hooks, because hooks may have side-effects\n  // that cause other template functions to run, thus updating the selected index, which is global\n  // state. If we run `setSelectedIndex` *before* we run the hooks, in some cases the selected index\n  // will be altered by the time we leave the `ɵɵadvance` instruction.\n\n\n  setSelectedIndex(index);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A mapping of the @angular/core API surface used in generated expressions to the actual symbols.\n *\n * This should be kept up to date with the public exports of @angular/core.\n */\n\n\nconst angularCoreDiEnv = {\n  'ɵɵdefineInjectable': ɵɵdefineInjectable,\n  'ɵɵdefineInjector': ɵɵdefineInjector,\n  'ɵɵinject': ɵɵinject,\n  'ɵɵinvalidFactoryDep': ɵɵinvalidFactoryDep,\n  'resolveForwardRef': resolveForwardRef\n};\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Compile an Angular injectable according to its `Injectable` metadata, and patch the resulting\n * injectable def (`ɵprov`) onto the injectable type.\n */\n\nfunction compileInjectable(type, meta) {\n  let ngInjectableDef = null;\n  let ngFactoryDef = null; // if NG_PROV_DEF is already defined on this class then don't overwrite it\n\n  if (!type.hasOwnProperty(NG_PROV_DEF)) {\n    Object.defineProperty(type, NG_PROV_DEF, {\n      get: () => {\n        if (ngInjectableDef === null) {\n          const compiler = getCompilerFacade({\n            usage: 0\n            /* JitCompilerUsage.Decorator */\n            ,\n            kind: 'injectable',\n            type\n          });\n          ngInjectableDef = compiler.compileInjectable(angularCoreDiEnv, `ng:///${type.name}/ɵprov.js`, getInjectableMetadata(type, meta));\n        }\n\n        return ngInjectableDef;\n      }\n    });\n  } // if NG_FACTORY_DEF is already defined on this class then don't overwrite it\n\n\n  if (!type.hasOwnProperty(NG_FACTORY_DEF)) {\n    Object.defineProperty(type, NG_FACTORY_DEF, {\n      get: () => {\n        if (ngFactoryDef === null) {\n          const compiler = getCompilerFacade({\n            usage: 0\n            /* JitCompilerUsage.Decorator */\n            ,\n            kind: 'injectable',\n            type\n          });\n          ngFactoryDef = compiler.compileFactory(angularCoreDiEnv, `ng:///${type.name}/ɵfac.js`, {\n            name: type.name,\n            type,\n            typeArgumentCount: 0,\n            deps: reflectDependencies(type),\n            target: compiler.FactoryTarget.Injectable\n          });\n        }\n\n        return ngFactoryDef;\n      },\n      // Leave this configurable so that the factories from directives or pipes can take precedence.\n      configurable: true\n    });\n  }\n}\n\nconst USE_VALUE$1 = getClosureSafeProperty({\n  provide: String,\n  useValue: getClosureSafeProperty\n});\n\nfunction isUseClassProvider(meta) {\n  return meta.useClass !== undefined;\n}\n\nfunction isUseValueProvider(meta) {\n  return USE_VALUE$1 in meta;\n}\n\nfunction isUseFactoryProvider(meta) {\n  return meta.useFactory !== undefined;\n}\n\nfunction isUseExistingProvider(meta) {\n  return meta.useExisting !== undefined;\n}\n\nfunction getInjectableMetadata(type, srcMeta) {\n  // Allow the compilation of a class with a `@Injectable()` decorator without parameters\n  const meta = srcMeta || {\n    providedIn: null\n  };\n  const compilerMeta = {\n    name: type.name,\n    type: type,\n    typeArgumentCount: 0,\n    providedIn: meta.providedIn\n  };\n\n  if ((isUseClassProvider(meta) || isUseFactoryProvider(meta)) && meta.deps !== undefined) {\n    compilerMeta.deps = convertDependencies(meta.deps);\n  } // Check to see if the user explicitly provided a `useXxxx` property.\n\n\n  if (isUseClassProvider(meta)) {\n    compilerMeta.useClass = meta.useClass;\n  } else if (isUseValueProvider(meta)) {\n    compilerMeta.useValue = meta.useValue;\n  } else if (isUseFactoryProvider(meta)) {\n    compilerMeta.useFactory = meta.useFactory;\n  } else if (isUseExistingProvider(meta)) {\n    compilerMeta.useExisting = meta.useExisting;\n  }\n\n  return compilerMeta;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Injectable decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\n\n\nconst Injectable = makeDecorator('Injectable', undefined, undefined, undefined, (type, meta) => compileInjectable(type, meta));\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Creates a token that can be used in a DI Provider.\n *\n * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a\n * runtime representation) such as when injecting an interface, callable type, array or\n * parameterized type.\n *\n * `InjectionToken` is parameterized on `T` which is the type of object which will be returned by\n * the `Injector`. This provides an additional level of type safety.\n *\n * ```\n * interface MyInterface {...}\n * const myInterface = injector.get(new InjectionToken<MyInterface>('SomeToken'));\n * // myInterface is inferred to be MyInterface.\n * ```\n *\n * When creating an `InjectionToken`, you can optionally specify a factory function which returns\n * (possibly by creating) a default value of the parameterized type `T`. This sets up the\n * `InjectionToken` using this factory as a provider as if it was defined explicitly in the\n * application's root injector. If the factory function, which takes zero arguments, needs to inject\n * dependencies, it can do so using the `inject` function.\n * As you can see in the Tree-shakable InjectionToken example below.\n *\n * Additionally, if a `factory` is specified you can also specify the `providedIn` option, which\n * overrides the above behavior and marks the token as belonging to a particular `@NgModule`. As\n * mentioned above, `'root'` is the default value for `providedIn`.\n *\n * @usageNotes\n * ### Basic Examples\n *\n * ### Plain InjectionToken\n *\n * {@example core/di/ts/injector_spec.ts region='InjectionToken'}\n *\n * ### Tree-shakable InjectionToken\n *\n * {@example core/di/ts/injector_spec.ts region='ShakableInjectionToken'}\n *\n *\n * @publicApi\n */\n\nclass InjectionToken {\n  /**\n   * @param _desc   Description for the token,\n   *                used only for debugging purposes,\n   *                it should but does not need to be unique\n   * @param options Options for the token's usage, as described above\n   */\n  constructor(_desc, options) {\n    this._desc = _desc;\n    /** @internal */\n\n    this.ngMetadataName = 'InjectionToken';\n    this.ɵprov = undefined;\n\n    if (typeof options == 'number') {\n      (typeof ngDevMode === 'undefined' || ngDevMode) && assertLessThan(options, 0, 'Only negative numbers are supported here'); // This is a special hack to assign __NG_ELEMENT_ID__ to this instance.\n      // See `InjectorMarkers`\n\n      this.__NG_ELEMENT_ID__ = options;\n    } else if (options !== undefined) {\n      this.ɵprov = ɵɵdefineInjectable({\n        token: this,\n        providedIn: options.providedIn || 'root',\n        factory: options.factory\n      });\n    }\n  }\n  /**\n   * @internal\n   */\n\n\n  get multi() {\n    return this;\n  }\n\n  toString() {\n    return `InjectionToken ${this._desc}`;\n  }\n\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A multi-provider token for initialization functions that will run upon construction of an\n * environment injector.\n *\n * @publicApi\n */\n\n\nconst ENVIRONMENT_INITIALIZER = new InjectionToken('ENVIRONMENT_INITIALIZER');\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nconst INJECTOR_DEF_TYPES = new InjectionToken('INJECTOR_DEF_TYPES');\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Collects providers from all NgModules and standalone components, including transitively imported\n * ones.\n *\n * Providers extracted via `importProvidersFrom` are only usable in an application injector or\n * another environment injector (such as a route injector). They should not be used in component\n * providers.\n *\n * More information about standalone components can be found in [this\n * guide](guide/standalone-components).\n *\n * @usageNotes\n * The results of the `importProvidersFrom` call can be used in the `bootstrapApplication` call:\n *\n * ```typescript\n * await bootstrapApplication(RootComponent, {\n *   providers: [\n *     importProvidersFrom(NgModuleOne, NgModuleTwo)\n *   ]\n * });\n * ```\n *\n * You can also use the `importProvidersFrom` results in the `providers` field of a route, when a\n * standalone component is used:\n *\n * ```typescript\n * export const ROUTES: Route[] = [\n *   {\n *     path: 'foo',\n *     providers: [\n *       importProvidersFrom(NgModuleOne, NgModuleTwo)\n *     ],\n *     component: YourStandaloneComponent\n *   }\n * ];\n * ```\n *\n * @returns Collected providers from the specified list of types.\n * @publicApi\n * @developerPreview\n */\n\nfunction importProvidersFrom(...sources) {\n  return {\n    ɵproviders: internalImportProvidersFrom(true, sources)\n  };\n}\n\nfunction internalImportProvidersFrom(checkForStandaloneCmp, ...sources) {\n  const providersOut = [];\n  const dedup = new Set(); // already seen types\n\n  let injectorTypesWithProviders;\n  deepForEach(sources, source => {\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && checkForStandaloneCmp) {\n      const cmpDef = getComponentDef$1(source);\n\n      if (cmpDef === null || cmpDef === void 0 ? void 0 : cmpDef.standalone) {\n        throw new RuntimeError(800\n        /* RuntimeErrorCode.IMPORT_PROVIDERS_FROM_STANDALONE */\n        , `Importing providers supports NgModule or ModuleWithProviders but got a standalone component \"${stringifyForError(source)}\"`);\n      }\n    } // Narrow `source` to access the internal type analogue for `ModuleWithProviders`.\n\n\n    const internalSource = source;\n\n    if (walkProviderTree(internalSource, providersOut, [], dedup)) {\n      injectorTypesWithProviders || (injectorTypesWithProviders = []);\n      injectorTypesWithProviders.push(internalSource);\n    }\n  }); // Collect all providers from `ModuleWithProviders` types.\n\n  if (injectorTypesWithProviders !== undefined) {\n    processInjectorTypesWithProviders(injectorTypesWithProviders, providersOut);\n  }\n\n  return providersOut;\n}\n/**\n * Collects all providers from the list of `ModuleWithProviders` and appends them to the provided\n * array.\n */\n\n\nfunction processInjectorTypesWithProviders(typesWithProviders, providersOut) {\n  for (let i = 0; i < typesWithProviders.length; i++) {\n    const {\n      ngModule,\n      providers\n    } = typesWithProviders[i];\n    deepForEach(providers, provider => {\n      ngDevMode && validateProvider(provider, providers || EMPTY_ARRAY, ngModule);\n      providersOut.push(provider);\n    });\n  }\n}\n/**\n * The logic visits an `InjectorType`, an `InjectorTypeWithProviders`, or a standalone\n * `ComponentType`, and all of its transitive providers and collects providers.\n *\n * If an `InjectorTypeWithProviders` that declares providers besides the type is specified,\n * the function will return \"true\" to indicate that the providers of the type definition need\n * to be processed. This allows us to process providers of injector types after all imports of\n * an injector definition are processed. (following View Engine semantics: see FW-1349)\n */\n\n\nfunction walkProviderTree(container, providersOut, parents, dedup) {\n  container = resolveForwardRef(container);\n  if (!container) return false; // The actual type which had the definition. Usually `container`, but may be an unwrapped type\n  // from `InjectorTypeWithProviders`.\n\n  let defType = null;\n  let injDef = getInjectorDef(container);\n  const cmpDef = !injDef && getComponentDef$1(container);\n\n  if (!injDef && !cmpDef) {\n    // `container` is not an injector type or a component type. It might be:\n    //  * An `InjectorTypeWithProviders` that wraps an injector type.\n    //  * A standalone directive or pipe that got pulled in from a standalone component's\n    //    dependencies.\n    // Try to unwrap it as an `InjectorTypeWithProviders` first.\n    const ngModule = container.ngModule;\n    injDef = getInjectorDef(ngModule);\n\n    if (injDef) {\n      defType = ngModule;\n    } else {\n      // Not a component or injector type, so ignore it.\n      return false;\n    }\n  } else if (cmpDef && !cmpDef.standalone) {\n    return false;\n  } else {\n    defType = container;\n  } // Check for circular dependencies.\n\n\n  if (ngDevMode && parents.indexOf(defType) !== -1) {\n    const defName = stringify(defType);\n    const path = parents.map(stringify);\n    throwCyclicDependencyError(defName, path);\n  } // Check for multiple imports of the same module\n\n\n  const isDuplicate = dedup.has(defType);\n\n  if (cmpDef) {\n    if (isDuplicate) {\n      // This component definition has already been processed.\n      return false;\n    }\n\n    dedup.add(defType);\n\n    if (cmpDef.dependencies) {\n      const deps = typeof cmpDef.dependencies === 'function' ? cmpDef.dependencies() : cmpDef.dependencies;\n\n      for (const dep of deps) {\n        walkProviderTree(dep, providersOut, parents, dedup);\n      }\n    }\n  } else if (injDef) {\n    // First, include providers from any imports.\n    if (injDef.imports != null && !isDuplicate) {\n      // Before processing defType's imports, add it to the set of parents. This way, if it ends\n      // up deeply importing itself, this can be detected.\n      ngDevMode && parents.push(defType); // Add it to the set of dedups. This way we can detect multiple imports of the same module\n\n      dedup.add(defType);\n      let importTypesWithProviders;\n\n      try {\n        deepForEach(injDef.imports, imported => {\n          if (walkProviderTree(imported, providersOut, parents, dedup)) {\n            importTypesWithProviders || (importTypesWithProviders = []); // If the processed import is an injector type with providers, we store it in the\n            // list of import types with providers, so that we can process those afterwards.\n\n            importTypesWithProviders.push(imported);\n          }\n        });\n      } finally {\n        // Remove it from the parents set when finished.\n        ngDevMode && parents.pop();\n      } // Imports which are declared with providers (TypeWithProviders) need to be processed\n      // after all imported modules are processed. This is similar to how View Engine\n      // processes/merges module imports in the metadata resolver. See: FW-1349.\n\n\n      if (importTypesWithProviders !== undefined) {\n        processInjectorTypesWithProviders(importTypesWithProviders, providersOut);\n      }\n    }\n\n    if (!isDuplicate) {\n      // Track the InjectorType and add a provider for it.\n      // It's important that this is done after the def's imports.\n      const factory = getFactoryDef(defType) || (() => new defType()); // Append extra providers to make more info available for consumers (to retrieve an injector\n      // type), as well as internally (to calculate an injection scope correctly and eagerly\n      // instantiate a `defType` when an injector is created).\n\n\n      providersOut.push( // Provider to create `defType` using its factory.\n      {\n        provide: defType,\n        useFactory: factory,\n        deps: EMPTY_ARRAY\n      }, // Make this `defType` available to an internal logic that calculates injector scope.\n      {\n        provide: INJECTOR_DEF_TYPES,\n        useValue: defType,\n        multi: true\n      }, // Provider to eagerly instantiate `defType` via `ENVIRONMENT_INITIALIZER`.\n      {\n        provide: ENVIRONMENT_INITIALIZER,\n        useValue: () => ɵɵinject(defType),\n        multi: true\n      } //\n      );\n    } // Next, include providers listed on the definition itself.\n\n\n    const defProviders = injDef.providers;\n\n    if (defProviders != null && !isDuplicate) {\n      const injectorType = container;\n      deepForEach(defProviders, provider => {\n        ngDevMode && validateProvider(provider, defProviders, injectorType);\n        providersOut.push(provider);\n      });\n    }\n  } else {\n    // Should not happen, but just in case.\n    return false;\n  }\n\n  return defType !== container && container.providers !== undefined;\n}\n\nfunction validateProvider(provider, providers, containerType) {\n  if (isTypeProvider(provider) || isValueProvider(provider) || isFactoryProvider(provider) || isExistingProvider(provider)) {\n    return;\n  } // Here we expect the provider to be a `useClass` provider (by elimination).\n\n\n  const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));\n\n  if (!classRef) {\n    throwInvalidProviderError(containerType, providers, provider);\n  }\n}\n\nconst USE_VALUE = getClosureSafeProperty({\n  provide: String,\n  useValue: getClosureSafeProperty\n});\n\nfunction isValueProvider(value) {\n  return value !== null && typeof value == 'object' && USE_VALUE in value;\n}\n\nfunction isExistingProvider(value) {\n  return !!(value && value.useExisting);\n}\n\nfunction isFactoryProvider(value) {\n  return !!(value && value.useFactory);\n}\n\nfunction isTypeProvider(value) {\n  return typeof value === 'function';\n}\n\nfunction isClassProvider(value) {\n  return !!value.useClass;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.\n *\n * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a\n * project.\n *\n * @publicApi\n */\n\n\nconst INJECTOR = new InjectionToken('INJECTOR', // Dissable tslint because this is const enum which gets inlined not top level prop access.\n// tslint:disable-next-line: no-toplevel-property-access\n-1\n/* InjectorMarkers.Injector */\n);\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nclass NullInjector {\n  get(token, notFoundValue = THROW_IF_NOT_FOUND) {\n    if (notFoundValue === THROW_IF_NOT_FOUND) {\n      const error = new Error(`NullInjectorError: No provider for ${stringify(token)}!`);\n      error.name = 'NullInjectorError';\n      throw error;\n    }\n\n    return notFoundValue;\n  }\n\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * An internal token whose presence in an injector indicates that the injector should treat itself\n * as a root scoped injector when processing requests for unknown tokens which may indicate\n * they are provided in the root scope.\n */\n\n\nconst INJECTOR_SCOPE = new InjectionToken('Set Injector scope.');\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Marker which indicates that a value has not yet been created from the factory function.\n */\n\nconst NOT_YET = {};\n/**\n * Marker which indicates that the factory function for a token is in the process of being called.\n *\n * If the injector is asked to inject a token with its value set to CIRCULAR, that indicates\n * injection of a dependency has recursively attempted to inject the original token, and there is\n * a circular dependency among the providers.\n */\n\nconst CIRCULAR = {};\n/**\n * A lazily initialized NullInjector.\n */\n\nlet NULL_INJECTOR$1 = undefined;\n\nfunction getNullInjector() {\n  if (NULL_INJECTOR$1 === undefined) {\n    NULL_INJECTOR$1 = new NullInjector();\n  }\n\n  return NULL_INJECTOR$1;\n}\n/**\n * An `Injector` that's part of the environment injector hierarchy, which exists outside of the\n * component tree.\n *\n * @developerPreview\n */\n\n\nclass EnvironmentInjector {}\n\nclass R3Injector extends EnvironmentInjector {\n  constructor(providers, parent, source, scopes) {\n    super();\n    this.parent = parent;\n    this.source = source;\n    this.scopes = scopes;\n    /**\n     * Map of tokens to records which contain the instances of those tokens.\n     * - `null` value implies that we don't have the record. Used by tree-shakable injectors\n     * to prevent further searches.\n     */\n\n    this.records = new Map();\n    /**\n     * Set of values instantiated by this injector which contain `ngOnDestroy` lifecycle hooks.\n     */\n\n    this._ngOnDestroyHooks = new Set();\n    this._onDestroyHooks = [];\n    this._destroyed = false; // Start off by creating Records for every provider.\n\n    forEachSingleProvider(providers, provider => this.processProvider(provider)); // Make sure the INJECTOR token provides this injector.\n\n    this.records.set(INJECTOR, makeRecord(undefined, this)); // And `EnvironmentInjector` if the current injector is supposed to be env-scoped.\n\n    if (scopes.has('environment')) {\n      this.records.set(EnvironmentInjector, makeRecord(undefined, this));\n    } // Detect whether this injector has the APP_ROOT_SCOPE token and thus should provide\n    // any injectable scoped to APP_ROOT_SCOPE.\n\n\n    const record = this.records.get(INJECTOR_SCOPE);\n\n    if (record != null && typeof record.value === 'string') {\n      this.scopes.add(record.value);\n    }\n\n    this.injectorDefTypes = new Set(this.get(INJECTOR_DEF_TYPES.multi, EMPTY_ARRAY, InjectFlags.Self));\n  }\n  /**\n   * Flag indicating that this injector was previously destroyed.\n   */\n\n\n  get destroyed() {\n    return this._destroyed;\n  }\n  /**\n   * Destroy the injector and release references to every instance or provider associated with it.\n   *\n   * Also calls the `OnDestroy` lifecycle hooks of every instance that was created for which a\n   * hook was found.\n   */\n\n\n  destroy() {\n    this.assertNotDestroyed(); // Set destroyed = true first, in case lifecycle hooks re-enter destroy().\n\n    this._destroyed = true;\n\n    try {\n      // Call all the lifecycle hooks.\n      for (const service of this._ngOnDestroyHooks) {\n        service.ngOnDestroy();\n      }\n\n      for (const hook of this._onDestroyHooks) {\n        hook();\n      }\n    } finally {\n      // Release all references.\n      this.records.clear();\n\n      this._ngOnDestroyHooks.clear();\n\n      this.injectorDefTypes.clear();\n      this._onDestroyHooks.length = 0;\n    }\n  }\n\n  onDestroy(callback) {\n    this._onDestroyHooks.push(callback);\n  }\n\n  get(token, notFoundValue = THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\n    this.assertNotDestroyed(); // Set the injection context.\n\n    const previousInjector = setCurrentInjector(this);\n    const previousInjectImplementation = setInjectImplementation(undefined);\n\n    try {\n      // Check for the SkipSelf flag.\n      if (!(flags & InjectFlags.SkipSelf)) {\n        // SkipSelf isn't set, check if the record belongs to this injector.\n        let record = this.records.get(token);\n\n        if (record === undefined) {\n          // No record, but maybe the token is scoped to this injector. Look for an injectable\n          // def with a scope matching this injector.\n          const def = couldBeInjectableType(token) && getInjectableDef(token);\n\n          if (def && this.injectableDefInScope(def)) {\n            // Found an injectable def and it's scoped to this injector. Pretend as if it was here\n            // all along.\n            record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET);\n          } else {\n            record = null;\n          }\n\n          this.records.set(token, record);\n        } // If a record was found, get the instance for it and return it.\n\n\n        if (record != null\n        /* NOT null || undefined */\n        ) {\n          return this.hydrate(token, record);\n        }\n      } // Select the next injector based on the Self flag - if self is set, the next injector is\n      // the NullInjector, otherwise it's the parent.\n\n\n      const nextInjector = !(flags & InjectFlags.Self) ? this.parent : getNullInjector(); // Set the notFoundValue based on the Optional flag - if optional is set and notFoundValue\n      // is undefined, the value is null, otherwise it's the notFoundValue.\n\n      notFoundValue = flags & InjectFlags.Optional && notFoundValue === THROW_IF_NOT_FOUND ? null : notFoundValue;\n      return nextInjector.get(token, notFoundValue);\n    } catch (e) {\n      if (e.name === 'NullInjectorError') {\n        const path = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];\n        path.unshift(stringify(token));\n\n        if (previousInjector) {\n          // We still have a parent injector, keep throwing\n          throw e;\n        } else {\n          // Format & throw the final error message when we don't have any previous injector\n          return catchInjectorError(e, token, 'R3InjectorError', this.source);\n        }\n      } else {\n        throw e;\n      }\n    } finally {\n      // Lastly, restore the previous injection context.\n      setInjectImplementation(previousInjectImplementation);\n      setCurrentInjector(previousInjector);\n    }\n  }\n  /** @internal */\n\n\n  resolveInjectorInitializers() {\n    const previousInjector = setCurrentInjector(this);\n    const previousInjectImplementation = setInjectImplementation(undefined);\n\n    try {\n      const initializers = this.get(ENVIRONMENT_INITIALIZER.multi, EMPTY_ARRAY, InjectFlags.Self);\n\n      for (const initializer of initializers) {\n        initializer();\n      }\n    } finally {\n      setCurrentInjector(previousInjector);\n      setInjectImplementation(previousInjectImplementation);\n    }\n  }\n\n  toString() {\n    const tokens = [];\n    const records = this.records;\n\n    for (const token of records.keys()) {\n      tokens.push(stringify(token));\n    }\n\n    return `R3Injector[${tokens.join(', ')}]`;\n  }\n\n  assertNotDestroyed() {\n    if (this._destroyed) {\n      throw new RuntimeError(205\n      /* RuntimeErrorCode.INJECTOR_ALREADY_DESTROYED */\n      , ngDevMode && 'Injector has already been destroyed.');\n    }\n  }\n  /**\n   * Process a `SingleProvider` and add it.\n   */\n\n\n  processProvider(provider) {\n    // Determine the token from the provider. Either it's its own token, or has a {provide: ...}\n    // property.\n    provider = resolveForwardRef(provider);\n    let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider && provider.provide); // Construct a `Record` for the provider.\n\n    const record = providerToRecord(provider);\n\n    if (!isTypeProvider(provider) && provider.multi === true) {\n      // If the provider indicates that it's a multi-provider, process it specially.\n      // First check whether it's been defined already.\n      let multiRecord = this.records.get(token);\n\n      if (multiRecord) {\n        // It has. Throw a nice error if\n        if (ngDevMode && multiRecord.multi === undefined) {\n          throwMixedMultiProviderError();\n        }\n      } else {\n        multiRecord = makeRecord(undefined, NOT_YET, true);\n\n        multiRecord.factory = () => injectArgs(multiRecord.multi);\n\n        this.records.set(token, multiRecord);\n      }\n\n      token = provider;\n      multiRecord.multi.push(provider);\n    } else {\n      const existing = this.records.get(token);\n\n      if (ngDevMode && existing && existing.multi !== undefined) {\n        throwMixedMultiProviderError();\n      }\n    }\n\n    this.records.set(token, record);\n  }\n\n  hydrate(token, record) {\n    if (ngDevMode && record.value === CIRCULAR) {\n      throwCyclicDependencyError(stringify(token));\n    } else if (record.value === NOT_YET) {\n      record.value = CIRCULAR;\n      record.value = record.factory();\n    }\n\n    if (typeof record.value === 'object' && record.value && hasOnDestroy(record.value)) {\n      this._ngOnDestroyHooks.add(record.value);\n    }\n\n    return record.value;\n  }\n\n  injectableDefInScope(def) {\n    if (!def.providedIn) {\n      return false;\n    }\n\n    const providedIn = resolveForwardRef(def.providedIn);\n\n    if (typeof providedIn === 'string') {\n      return providedIn === 'any' || this.scopes.has(providedIn);\n    } else {\n      return this.injectorDefTypes.has(providedIn);\n    }\n  }\n\n}\n\nfunction injectableDefOrInjectorDefFactory(token) {\n  // Most tokens will have an injectable def directly on them, which specifies a factory directly.\n  const injectableDef = getInjectableDef(token);\n  const factory = injectableDef !== null ? injectableDef.factory : getFactoryDef(token);\n\n  if (factory !== null) {\n    return factory;\n  } // InjectionTokens should have an injectable def (ɵprov) and thus should be handled above.\n  // If it's missing that, it's an error.\n\n\n  if (token instanceof InjectionToken) {\n    throw new RuntimeError(204\n    /* RuntimeErrorCode.INVALID_INJECTION_TOKEN */\n    , ngDevMode && `Token ${stringify(token)} is missing a ɵprov definition.`);\n  } // Undecorated types can sometimes be created if they have no constructor arguments.\n\n\n  if (token instanceof Function) {\n    return getUndecoratedInjectableFactory(token);\n  } // There was no way to resolve a factory for this token.\n\n\n  throw new RuntimeError(204\n  /* RuntimeErrorCode.INVALID_INJECTION_TOKEN */\n  , ngDevMode && 'unreachable');\n}\n\nfunction getUndecoratedInjectableFactory(token) {\n  // If the token has parameters then it has dependencies that we cannot resolve implicitly.\n  const paramLength = token.length;\n\n  if (paramLength > 0) {\n    const args = newArray(paramLength, '?');\n    throw new RuntimeError(204\n    /* RuntimeErrorCode.INVALID_INJECTION_TOKEN */\n    , ngDevMode && `Can't resolve all parameters for ${stringify(token)}: (${args.join(', ')}).`);\n  } // The constructor function appears to have no parameters.\n  // This might be because it inherits from a super-class. In which case, use an injectable\n  // def from an ancestor if there is one.\n  // Otherwise this really is a simple class with no dependencies, so return a factory that\n  // just instantiates the zero-arg constructor.\n\n\n  const inheritedInjectableDef = getInheritedInjectableDef(token);\n\n  if (inheritedInjectableDef !== null) {\n    return () => inheritedInjectableDef.factory(token);\n  } else {\n    return () => new token();\n  }\n}\n\nfunction providerToRecord(provider) {\n  if (isValueProvider(provider)) {\n    return makeRecord(undefined, provider.useValue);\n  } else {\n    const factory = providerToFactory(provider);\n    return makeRecord(factory, NOT_YET);\n  }\n}\n/**\n * Converts a `SingleProvider` into a factory function.\n *\n * @param provider provider to convert to factory\n */\n\n\nfunction providerToFactory(provider, ngModuleType, providers) {\n  let factory = undefined;\n\n  if (ngDevMode && isImportedNgModuleProviders(provider)) {\n    throwInvalidProviderError(undefined, providers, provider);\n  }\n\n  if (isTypeProvider(provider)) {\n    const unwrappedProvider = resolveForwardRef(provider);\n    return getFactoryDef(unwrappedProvider) || injectableDefOrInjectorDefFactory(unwrappedProvider);\n  } else {\n    if (isValueProvider(provider)) {\n      factory = () => resolveForwardRef(provider.useValue);\n    } else if (isFactoryProvider(provider)) {\n      factory = () => provider.useFactory(...injectArgs(provider.deps || []));\n    } else if (isExistingProvider(provider)) {\n      factory = () => ɵɵinject(resolveForwardRef(provider.useExisting));\n    } else {\n      const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));\n\n      if (ngDevMode && !classRef) {\n        throwInvalidProviderError(ngModuleType, providers, provider);\n      }\n\n      if (hasDeps(provider)) {\n        factory = () => new classRef(...injectArgs(provider.deps));\n      } else {\n        return getFactoryDef(classRef) || injectableDefOrInjectorDefFactory(classRef);\n      }\n    }\n  }\n\n  return factory;\n}\n\nfunction makeRecord(factory, value, multi = false) {\n  return {\n    factory: factory,\n    value: value,\n    multi: multi ? [] : undefined\n  };\n}\n\nfunction hasDeps(value) {\n  return !!value.deps;\n}\n\nfunction hasOnDestroy(value) {\n  return value !== null && typeof value === 'object' && typeof value.ngOnDestroy === 'function';\n}\n\nfunction couldBeInjectableType(value) {\n  return typeof value === 'function' || typeof value === 'object' && value instanceof InjectionToken;\n}\n\nfunction isImportedNgModuleProviders(provider) {\n  return !!provider.ɵproviders;\n}\n\nfunction forEachSingleProvider(providers, fn) {\n  for (const provider of providers) {\n    if (Array.isArray(provider)) {\n      forEachSingleProvider(provider, fn);\n    } else if (isImportedNgModuleProviders(provider)) {\n      forEachSingleProvider(provider.ɵproviders, fn);\n    } else {\n      fn(provider);\n    }\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Create a new `Injector` which is configured using a `defType` of `InjectorType<any>`s.\n *\n * @publicApi\n */\n\n\nfunction createInjector(defType, parent = null, additionalProviders = null, name) {\n  const injector = createInjectorWithoutInjectorInstances(defType, parent, additionalProviders, name);\n  injector.resolveInjectorInitializers();\n  return injector;\n}\n/**\n * Creates a new injector without eagerly resolving its injector types. Can be used in places\n * where resolving the injector types immediately can lead to an infinite loop. The injector types\n * should be resolved at a later point by calling `_resolveInjectorDefTypes`.\n */\n\n\nfunction createInjectorWithoutInjectorInstances(defType, parent = null, additionalProviders = null, name, scopes = new Set()) {\n  const providers = [additionalProviders || EMPTY_ARRAY, importProvidersFrom(defType)];\n  name = name || (typeof defType === 'object' ? undefined : stringify(defType));\n  return new R3Injector(providers, parent || getNullInjector(), name || null, scopes);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Concrete injectors implement this interface. Injectors are configured\n * with [providers](guide/glossary#provider) that associate\n * dependencies of various types with [injection tokens](guide/glossary#di-token).\n *\n * @see [\"DI Providers\"](guide/dependency-injection-providers).\n * @see `StaticProvider`\n *\n * @usageNotes\n *\n *  The following example creates a service injector instance.\n *\n * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}\n *\n * ### Usage example\n *\n * {@example core/di/ts/injector_spec.ts region='Injector'}\n *\n * `Injector` returns itself when given `Injector` as a token:\n *\n * {@example core/di/ts/injector_spec.ts region='injectInjector'}\n *\n * @publicApi\n */\n\n\nclass Injector {\n  static create(options, parent) {\n    var _a;\n\n    if (Array.isArray(options)) {\n      return createInjector({\n        name: ''\n      }, parent, options, '');\n    } else {\n      const name = (_a = options.name) !== null && _a !== void 0 ? _a : '';\n      return createInjector({\n        name\n      }, options.parent, options.providers, name);\n    }\n  }\n\n}\n\nInjector.THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;\nInjector.NULL = /* @__PURE__ */new NullInjector();\n/** @nocollapse */\n\nInjector.ɵprov = ɵɵdefineInjectable({\n  token: Injector,\n  providedIn: 'any',\n  factory: () => ɵɵinject(INJECTOR)\n});\n/**\n * @internal\n * @nocollapse\n */\n\nInjector.__NG_ELEMENT_ID__ = -1\n/* InjectorMarkers.Injector */\n;\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nfunction findFirstClosedCycle(keys) {\n  const res = [];\n\n  for (let i = 0; i < keys.length; ++i) {\n    if (res.indexOf(keys[i]) > -1) {\n      res.push(keys[i]);\n      return res;\n    }\n\n    res.push(keys[i]);\n  }\n\n  return res;\n}\n\nfunction constructResolvingPath(keys) {\n  if (keys.length > 1) {\n    const reversed = findFirstClosedCycle(keys.slice().reverse());\n    const tokenStrs = reversed.map(k => stringify(k.token));\n    return ' (' + tokenStrs.join(' -> ') + ')';\n  }\n\n  return '';\n}\n\nfunction injectionError(injector, key, constructResolvingMessage, originalError) {\n  const keys = [key];\n  const errMsg = constructResolvingMessage(keys);\n  const error = originalError ? wrappedError(errMsg, originalError) : Error(errMsg);\n  error.addKey = addKey;\n  error.keys = keys;\n  error.injectors = [injector];\n  error.constructResolvingMessage = constructResolvingMessage;\n  error[ERROR_ORIGINAL_ERROR] = originalError;\n  return error;\n}\n\nfunction addKey(injector, key) {\n  this.injectors.push(injector);\n  this.keys.push(key); // Note: This updated message won't be reflected in the `.stack` property\n\n  this.message = this.constructResolvingMessage(this.keys);\n}\n/**\n * Thrown when trying to retrieve a dependency by key from {@link Injector}, but the\n * {@link Injector} does not have a {@link Provider} for the given key.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * class A {\n *   constructor(b:B) {}\n * }\n *\n * expect(() => Injector.resolveAndCreate([A])).toThrowError();\n * ```\n */\n\n\nfunction noProviderError(injector, key) {\n  return injectionError(injector, key, function (keys) {\n    const first = stringify(keys[0].token);\n    return `No provider for ${first}!${constructResolvingPath(keys)}`;\n  });\n}\n/**\n * Thrown when dependencies form a cycle.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * var injector = Injector.resolveAndCreate([\n *   {provide: \"one\", useFactory: (two) => \"two\", deps: [[new Inject(\"two\")]]},\n *   {provide: \"two\", useFactory: (one) => \"one\", deps: [[new Inject(\"one\")]]}\n * ]);\n *\n * expect(() => injector.get(\"one\")).toThrowError();\n * ```\n *\n * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.\n */\n\n\nfunction cyclicDependencyError(injector, key) {\n  return injectionError(injector, key, function (keys) {\n    return `Cannot instantiate cyclic dependency!${constructResolvingPath(keys)}`;\n  });\n}\n/**\n * Thrown when a constructing type returns with an Error.\n *\n * The `InstantiationError` class contains the original error plus the dependency graph which caused\n * this object to be instantiated.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * class A {\n *   constructor() {\n *     throw new Error('message');\n *   }\n * }\n *\n * var injector = Injector.resolveAndCreate([A]);\n\n * try {\n *   injector.get(A);\n * } catch (e) {\n *   expect(e instanceof InstantiationError).toBe(true);\n *   expect(e.originalException.message).toEqual(\"message\");\n *   expect(e.originalStack).toBeDefined();\n * }\n * ```\n */\n\n\nfunction instantiationError(injector, originalException, originalStack, key) {\n  return injectionError(injector, key, function (keys) {\n    const first = stringify(keys[0].token);\n    return `${originalException.message}: Error during instantiation of ${first}!${constructResolvingPath(keys)}.`;\n  }, originalException);\n}\n/**\n * Thrown when an object other then {@link Provider} (or `Type`) is passed to {@link Injector}\n * creation.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * expect(() => Injector.resolveAndCreate([\"not a type\"])).toThrowError();\n * ```\n */\n\n\nfunction invalidProviderError(provider) {\n  return Error(`Invalid provider - only instances of Provider and Type are allowed, got: ${provider}`);\n}\n/**\n * Thrown when the class has no annotation information.\n *\n * Lack of annotation information prevents the {@link Injector} from determining which dependencies\n * need to be injected into the constructor.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * class A {\n *   constructor(b) {}\n * }\n *\n * expect(() => Injector.resolveAndCreate([A])).toThrowError();\n * ```\n *\n * This error is also thrown when the class not marked with {@link Injectable} has parameter types.\n *\n * ```typescript\n * class B {}\n *\n * class A {\n *   constructor(b:B) {} // no information about the parameter types of A is available at runtime.\n * }\n *\n * expect(() => Injector.resolveAndCreate([A,B])).toThrowError();\n * ```\n *\n */\n\n\nfunction noAnnotationError(typeOrFunc, params) {\n  const signature = [];\n\n  for (let i = 0, ii = params.length; i < ii; i++) {\n    const parameter = params[i];\n\n    if (!parameter || parameter.length == 0) {\n      signature.push('?');\n    } else {\n      signature.push(parameter.map(stringify).join(' '));\n    }\n  }\n\n  return Error('Cannot resolve all parameters for \\'' + stringify(typeOrFunc) + '\\'(' + signature.join(', ') + '). ' + 'Make sure that all the parameters are decorated with Inject or have valid type annotations and that \\'' + stringify(typeOrFunc) + '\\' is decorated with Injectable.');\n}\n/**\n * Thrown when getting an object by index.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * class A {}\n *\n * var injector = Injector.resolveAndCreate([A]);\n *\n * expect(() => injector.getAt(100)).toThrowError();\n * ```\n *\n */\n\n\nfunction outOfBoundsError(index) {\n  return Error(`Index ${index} is out-of-bounds.`);\n} // TODO: add a working example after alpha38 is released\n\n/**\n * Thrown when a multi provider and a regular provider are bound to the same token.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * expect(() => Injector.resolveAndCreate([\n *   { provide: \"Strings\", useValue: \"string1\", multi: true},\n *   { provide: \"Strings\", useValue: \"string2\", multi: false}\n * ])).toThrowError();\n * ```\n */\n\n\nfunction mixingMultiProvidersWithRegularProvidersError(provider1, provider2) {\n  return Error(`Cannot mix multi providers and regular providers, got: ${provider1} ${provider2}`);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A unique object used for retrieving items from the {@link ReflectiveInjector}.\n *\n * Keys have:\n * - a system-wide unique `id`.\n * - a `token`.\n *\n * `Key` is used internally by {@link ReflectiveInjector} because its system-wide unique `id` allows\n * the\n * injector to store created objects in a more efficient way.\n *\n * `Key` should not be created directly. {@link ReflectiveInjector} creates keys automatically when\n * resolving\n * providers.\n *\n * @deprecated No replacement\n * @publicApi\n */\n\n\nclass ReflectiveKey {\n  /**\n   * Private\n   */\n  constructor(token, id) {\n    this.token = token;\n    this.id = id;\n\n    if (!token) {\n      throw new Error('Token must be defined!');\n    }\n\n    this.displayName = stringify(this.token);\n  }\n  /**\n   * Retrieves a `Key` for a token.\n   */\n\n\n  static get(token) {\n    return _globalKeyRegistry.get(resolveForwardRef(token));\n  }\n  /**\n   * @returns the number of keys registered in the system.\n   */\n\n\n  static get numberOfKeys() {\n    return _globalKeyRegistry.numberOfKeys;\n  }\n\n}\n\nclass KeyRegistry {\n  constructor() {\n    this._allKeys = new Map();\n  }\n\n  get(token) {\n    if (token instanceof ReflectiveKey) return token;\n\n    if (this._allKeys.has(token)) {\n      return this._allKeys.get(token);\n    }\n\n    const newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);\n\n    this._allKeys.set(token, newKey);\n\n    return newKey;\n  }\n\n  get numberOfKeys() {\n    return this._allKeys.size;\n  }\n\n}\n\nconst _globalKeyRegistry = new KeyRegistry();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * `Dependency` is used by the framework to extend DI.\n * This is internal to Angular and should not be used directly.\n */\n\n\nclass ReflectiveDependency {\n  constructor(key, optional, visibility) {\n    this.key = key;\n    this.optional = optional;\n    this.visibility = visibility;\n  }\n\n  static fromKey(key) {\n    return new ReflectiveDependency(key, false, null);\n  }\n\n}\n\nconst _EMPTY_LIST = [];\n\nclass ResolvedReflectiveProvider_ {\n  constructor(key, resolvedFactories, multiProvider) {\n    this.key = key;\n    this.resolvedFactories = resolvedFactories;\n    this.multiProvider = multiProvider;\n    this.resolvedFactory = this.resolvedFactories[0];\n  }\n\n}\n/**\n * An internal resolved representation of a factory function created by resolving `Provider`.\n * @publicApi\n */\n\n\nclass ResolvedReflectiveFactory {\n  constructor(\n  /**\n   * Factory function which can return an instance of an object represented by a key.\n   */\n  factory,\n  /**\n   * Arguments (dependencies) to the `factory` function.\n   */\n  dependencies) {\n    this.factory = factory;\n    this.dependencies = dependencies;\n  }\n\n}\n/**\n * Resolve a single provider.\n */\n\n\nfunction resolveReflectiveFactory(provider) {\n  let factoryFn;\n  let resolvedDeps;\n\n  if (provider.useClass) {\n    const useClass = resolveForwardRef(provider.useClass);\n    factoryFn = getReflect().factory(useClass);\n    resolvedDeps = _dependenciesFor(useClass);\n  } else if (provider.useExisting) {\n    factoryFn = aliasInstance => aliasInstance;\n\n    resolvedDeps = [ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))];\n  } else if (provider.useFactory) {\n    factoryFn = provider.useFactory;\n    resolvedDeps = constructDependencies(provider.useFactory, provider.deps);\n  } else {\n    factoryFn = () => provider.useValue;\n\n    resolvedDeps = _EMPTY_LIST;\n  }\n\n  return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);\n}\n/**\n * Converts the `Provider` into `ResolvedProvider`.\n *\n * `Injector` internally only uses `ResolvedProvider`, `Provider` contains convenience provider\n * syntax.\n */\n\n\nfunction resolveReflectiveProvider(provider) {\n  return new ResolvedReflectiveProvider_(ReflectiveKey.get(provider.provide), [resolveReflectiveFactory(provider)], provider.multi || false);\n}\n/**\n * Resolve a list of Providers.\n */\n\n\nfunction resolveReflectiveProviders(providers) {\n  const normalized = _normalizeProviders(providers, []);\n\n  const resolved = normalized.map(resolveReflectiveProvider);\n  const resolvedProviderMap = mergeResolvedReflectiveProviders(resolved, new Map());\n  return Array.from(resolvedProviderMap.values());\n}\n/**\n * Merges a list of ResolvedProviders into a list where each key is contained exactly once and\n * multi providers have been merged.\n */\n\n\nfunction mergeResolvedReflectiveProviders(providers, normalizedProvidersMap) {\n  for (let i = 0; i < providers.length; i++) {\n    const provider = providers[i];\n    const existing = normalizedProvidersMap.get(provider.key.id);\n\n    if (existing) {\n      if (provider.multiProvider !== existing.multiProvider) {\n        throw mixingMultiProvidersWithRegularProvidersError(existing, provider);\n      }\n\n      if (provider.multiProvider) {\n        for (let j = 0; j < provider.resolvedFactories.length; j++) {\n          existing.resolvedFactories.push(provider.resolvedFactories[j]);\n        }\n      } else {\n        normalizedProvidersMap.set(provider.key.id, provider);\n      }\n    } else {\n      let resolvedProvider;\n\n      if (provider.multiProvider) {\n        resolvedProvider = new ResolvedReflectiveProvider_(provider.key, provider.resolvedFactories.slice(), provider.multiProvider);\n      } else {\n        resolvedProvider = provider;\n      }\n\n      normalizedProvidersMap.set(provider.key.id, resolvedProvider);\n    }\n  }\n\n  return normalizedProvidersMap;\n}\n\nfunction _normalizeProviders(providers, res) {\n  providers.forEach(b => {\n    if (b instanceof Type) {\n      res.push({\n        provide: b,\n        useClass: b\n      });\n    } else if (b && typeof b == 'object' && b.provide !== undefined) {\n      res.push(b);\n    } else if (Array.isArray(b)) {\n      _normalizeProviders(b, res);\n    } else {\n      throw invalidProviderError(b);\n    }\n  });\n  return res;\n}\n\nfunction constructDependencies(typeOrFunc, dependencies) {\n  if (!dependencies) {\n    return _dependenciesFor(typeOrFunc);\n  } else {\n    const params = dependencies.map(t => [t]);\n    return dependencies.map(t => _extractToken(typeOrFunc, t, params));\n  }\n}\n\nfunction _dependenciesFor(typeOrFunc) {\n  const params = getReflect().parameters(typeOrFunc);\n  if (!params) return [];\n\n  if (params.some(p => p == null)) {\n    throw noAnnotationError(typeOrFunc, params);\n  }\n\n  return params.map(p => _extractToken(typeOrFunc, p, params));\n}\n\nfunction _extractToken(typeOrFunc, metadata, params) {\n  let token = null;\n  let optional = false;\n\n  if (!Array.isArray(metadata)) {\n    if (metadata instanceof Inject) {\n      return _createDependency(metadata.token, optional, null);\n    } else {\n      return _createDependency(metadata, optional, null);\n    }\n  }\n\n  let visibility = null;\n\n  for (let i = 0; i < metadata.length; ++i) {\n    const paramMetadata = metadata[i];\n\n    if (paramMetadata instanceof Type) {\n      token = paramMetadata;\n    } else if (paramMetadata instanceof Inject) {\n      token = paramMetadata.token;\n    } else if (paramMetadata instanceof Optional) {\n      optional = true;\n    } else if (paramMetadata instanceof Self || paramMetadata instanceof SkipSelf) {\n      visibility = paramMetadata;\n    } else if (paramMetadata instanceof InjectionToken) {\n      token = paramMetadata;\n    }\n  }\n\n  token = resolveForwardRef(token);\n\n  if (token != null) {\n    return _createDependency(token, optional, visibility);\n  } else {\n    throw noAnnotationError(typeOrFunc, params);\n  }\n}\n\nfunction _createDependency(token, optional, visibility) {\n  return new ReflectiveDependency(ReflectiveKey.get(token), optional, visibility);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Threshold for the dynamic version\n\n\nconst UNDEFINED = {};\n/**\n * A ReflectiveDependency injection container used for instantiating objects and resolving\n * dependencies.\n *\n * An `Injector` is a replacement for a `new` operator, which can automatically resolve the\n * constructor dependencies.\n *\n * In typical use, application code asks for the dependencies in the constructor and they are\n * resolved by the `Injector`.\n *\n * @usageNotes\n * ### Example\n *\n * The following example creates an `Injector` configured to create `Engine` and `Car`.\n *\n * ```typescript\n * @Injectable()\n * class Engine {\n * }\n *\n * @Injectable()\n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n *\n * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\n * var car = injector.get(Car);\n * expect(car instanceof Car).toBe(true);\n * expect(car.engine instanceof Engine).toBe(true);\n * ```\n *\n * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`\n * resolve all of the object's dependencies automatically.\n *\n * TODO: delete in v14.\n *\n * @deprecated from v5 - slow and brings in a lot of code, Use `Injector.create` instead.\n * @publicApi\n */\n\nclass ReflectiveInjector {\n  /**\n   * Turns an array of provider definitions into an array of resolved providers.\n   *\n   * A resolution is a process of flattening multiple nested arrays and converting individual\n   * providers into an array of `ResolvedReflectiveProvider`s.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Injectable()\n   * class Engine {\n   * }\n   *\n   * @Injectable()\n   * class Car {\n   *   constructor(public engine:Engine) {}\n   * }\n   *\n   * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);\n   *\n   * expect(providers.length).toEqual(2);\n   *\n   * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);\n   * expect(providers[0].key.displayName).toBe(\"Car\");\n   * expect(providers[0].dependencies.length).toEqual(1);\n   * expect(providers[0].factory).toBeDefined();\n   *\n   * expect(providers[1].key.displayName).toBe(\"Engine\");\n   * });\n   * ```\n   *\n   */\n  static resolve(providers) {\n    return resolveReflectiveProviders(providers);\n  }\n  /**\n   * Resolves an array of providers and creates an injector from those providers.\n   *\n   * The passed-in providers can be an array of `Type`, `Provider`,\n   * or a recursive array of more providers.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Injectable()\n   * class Engine {\n   * }\n   *\n   * @Injectable()\n   * class Car {\n   *   constructor(public engine:Engine) {}\n   * }\n   *\n   * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\n   * expect(injector.get(Car) instanceof Car).toBe(true);\n   * ```\n   */\n\n\n  static resolveAndCreate(providers, parent) {\n    const ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);\n    return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);\n  }\n  /**\n   * Creates an injector from previously resolved providers.\n   *\n   * This API is the recommended way to construct injectors in performance-sensitive parts.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Injectable()\n   * class Engine {\n   * }\n   *\n   * @Injectable()\n   * class Car {\n   *   constructor(public engine:Engine) {}\n   * }\n   *\n   * var providers = ReflectiveInjector.resolve([Car, Engine]);\n   * var injector = ReflectiveInjector.fromResolvedProviders(providers);\n   * expect(injector.get(Car) instanceof Car).toBe(true);\n   * ```\n   */\n\n\n  static fromResolvedProviders(providers, parent) {\n    return new ReflectiveInjector_(providers, parent);\n  }\n\n}\n\nclass ReflectiveInjector_ {\n  /**\n   * Private\n   */\n  constructor(_providers, _parent) {\n    /** @internal */\n    this._constructionCounter = 0;\n    this._providers = _providers;\n    this.parent = _parent || null;\n    const len = _providers.length;\n    this.keyIds = [];\n    this.objs = [];\n\n    for (let i = 0; i < len; i++) {\n      this.keyIds[i] = _providers[i].key.id;\n      this.objs[i] = UNDEFINED;\n    }\n  }\n\n  get(token, notFoundValue = THROW_IF_NOT_FOUND) {\n    return this._getByKey(ReflectiveKey.get(token), null, notFoundValue);\n  }\n\n  resolveAndCreateChild(providers) {\n    const ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);\n    return this.createChildFromResolved(ResolvedReflectiveProviders);\n  }\n\n  createChildFromResolved(providers) {\n    const inj = new ReflectiveInjector_(providers);\n    inj.parent = this;\n    return inj;\n  }\n\n  resolveAndInstantiate(provider) {\n    return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);\n  }\n\n  instantiateResolved(provider) {\n    return this._instantiateProvider(provider);\n  }\n\n  getProviderAtIndex(index) {\n    if (index < 0 || index >= this._providers.length) {\n      throw outOfBoundsError(index);\n    }\n\n    return this._providers[index];\n  }\n  /** @internal */\n\n\n  _new(provider) {\n    if (this._constructionCounter++ > this._getMaxNumberOfObjects()) {\n      throw cyclicDependencyError(this, provider.key);\n    }\n\n    return this._instantiateProvider(provider);\n  }\n\n  _getMaxNumberOfObjects() {\n    return this.objs.length;\n  }\n\n  _instantiateProvider(provider) {\n    if (provider.multiProvider) {\n      const res = [];\n\n      for (let i = 0; i < provider.resolvedFactories.length; ++i) {\n        res[i] = this._instantiate(provider, provider.resolvedFactories[i]);\n      }\n\n      return res;\n    } else {\n      return this._instantiate(provider, provider.resolvedFactories[0]);\n    }\n  }\n\n  _instantiate(provider, ResolvedReflectiveFactory) {\n    const factory = ResolvedReflectiveFactory.factory;\n    let deps;\n\n    try {\n      deps = ResolvedReflectiveFactory.dependencies.map(dep => this._getByReflectiveDependency(dep));\n    } catch (e) {\n      if (e.addKey) {\n        e.addKey(this, provider.key);\n      }\n\n      throw e;\n    }\n\n    let obj;\n\n    try {\n      obj = factory(...deps);\n    } catch (e) {\n      throw instantiationError(this, e, e.stack, provider.key);\n    }\n\n    return obj;\n  }\n\n  _getByReflectiveDependency(dep) {\n    return this._getByKey(dep.key, dep.visibility, dep.optional ? null : THROW_IF_NOT_FOUND);\n  }\n\n  _getByKey(key, visibility, notFoundValue) {\n    if (key === ReflectiveInjector_.INJECTOR_KEY) {\n      return this;\n    }\n\n    if (visibility instanceof Self) {\n      return this._getByKeySelf(key, notFoundValue);\n    } else {\n      return this._getByKeyDefault(key, notFoundValue, visibility);\n    }\n  }\n\n  _getObjByKeyId(keyId) {\n    for (let i = 0; i < this.keyIds.length; i++) {\n      if (this.keyIds[i] === keyId) {\n        if (this.objs[i] === UNDEFINED) {\n          this.objs[i] = this._new(this._providers[i]);\n        }\n\n        return this.objs[i];\n      }\n    }\n\n    return UNDEFINED;\n  }\n  /** @internal */\n\n\n  _throwOrNull(key, notFoundValue) {\n    if (notFoundValue !== THROW_IF_NOT_FOUND) {\n      return notFoundValue;\n    } else {\n      throw noProviderError(this, key);\n    }\n  }\n  /** @internal */\n\n\n  _getByKeySelf(key, notFoundValue) {\n    const obj = this._getObjByKeyId(key.id);\n\n    return obj !== UNDEFINED ? obj : this._throwOrNull(key, notFoundValue);\n  }\n  /** @internal */\n\n\n  _getByKeyDefault(key, notFoundValue, visibility) {\n    let inj;\n\n    if (visibility instanceof SkipSelf) {\n      inj = this.parent;\n    } else {\n      inj = this;\n    }\n\n    while (inj instanceof ReflectiveInjector_) {\n      const inj_ = inj;\n\n      const obj = inj_._getObjByKeyId(key.id);\n\n      if (obj !== UNDEFINED) return obj;\n      inj = inj_.parent;\n    }\n\n    if (inj !== null) {\n      return inj.get(key.token, notFoundValue);\n    } else {\n      return this._throwOrNull(key, notFoundValue);\n    }\n  }\n\n  get displayName() {\n    const providers = _mapProviders(this, b => ' \"' + b.key.displayName + '\" ').join(', ');\n\n    return `ReflectiveInjector(providers: [${providers}])`;\n  }\n\n  toString() {\n    return this.displayName;\n  }\n\n}\n\nReflectiveInjector_.INJECTOR_KEY = /* @__PURE__ */ReflectiveKey.get(Injector);\n\nfunction _mapProviders(injector, fn) {\n  const res = [];\n\n  for (let i = 0; i < injector._providers.length; ++i) {\n    res[i] = fn(injector.getProviderAtIndex(i));\n  }\n\n  return res;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction ɵɵdirectiveInject(token, flags = InjectFlags.Default) {\n  const lView = getLView(); // Fall back to inject() if view hasn't been created. This situation can happen in tests\n  // if inject utilities are used before bootstrapping.\n\n  if (lView === null) {\n    // Verify that we will not get into infinite loop.\n    ngDevMode && assertInjectImplementationNotEqual(ɵɵdirectiveInject);\n    return ɵɵinject(token, flags);\n  }\n\n  const tNode = getCurrentTNode();\n  return getOrCreateInjectable(tNode, lView, resolveForwardRef(token), flags);\n}\n/**\n * Throws an error indicating that a factory function could not be generated by the compiler for a\n * particular class.\n *\n * This instruction allows the actual error message to be optimized away when ngDevMode is turned\n * off, saving bytes of generated code while still providing a good experience in dev mode.\n *\n * The name of the class is not mentioned here, but will be in the generated factory function name\n * and thus in the stack trace.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵinvalidFactory() {\n  const msg = ngDevMode ? `This constructor was not compatible with Dependency Injection.` : 'invalid';\n  throw new Error(msg);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Defines a schema that allows an NgModule to contain the following:\n * - Non-Angular elements named with dash case (`-`).\n * - Element properties named with dash case (`-`).\n * Dash case is the naming convention for custom elements.\n *\n * @publicApi\n */\n\n\nconst CUSTOM_ELEMENTS_SCHEMA = {\n  name: 'custom-elements'\n};\n/**\n * Defines a schema that allows any property on any element.\n *\n * This schema allows you to ignore the errors related to any unknown elements or properties in a\n * template. The usage of this schema is generally discouraged because it prevents useful validation\n * and may hide real errors in your template. Consider using the `CUSTOM_ELEMENTS_SCHEMA` instead.\n *\n * @publicApi\n */\n\nconst NO_ERRORS_SCHEMA = {\n  name: 'no-errors-schema'\n};\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nlet shouldThrowErrorOnUnknownElement = false;\n/**\n * Sets a strict mode for JIT-compiled components to throw an error on unknown elements,\n * instead of just logging the error.\n * (for AOT-compiled ones this check happens at build time).\n */\n\nfunction ɵsetUnknownElementStrictMode(shouldThrow) {\n  shouldThrowErrorOnUnknownElement = shouldThrow;\n}\n/**\n * Gets the current value of the strict mode.\n */\n\n\nfunction ɵgetUnknownElementStrictMode() {\n  return shouldThrowErrorOnUnknownElement;\n}\n\nlet shouldThrowErrorOnUnknownProperty = false;\n/**\n * Sets a strict mode for JIT-compiled components to throw an error on unknown properties,\n * instead of just logging the error.\n * (for AOT-compiled ones this check happens at build time).\n */\n\nfunction ɵsetUnknownPropertyStrictMode(shouldThrow) {\n  shouldThrowErrorOnUnknownProperty = shouldThrow;\n}\n/**\n * Gets the current value of the strict mode.\n */\n\n\nfunction ɵgetUnknownPropertyStrictMode() {\n  return shouldThrowErrorOnUnknownProperty;\n}\n/**\n * Validates that the element is known at runtime and produces\n * an error if it's not the case.\n * This check is relevant for JIT-compiled components (for AOT-compiled\n * ones this check happens at build time).\n *\n * The element is considered known if either:\n * - it's a known HTML element\n * - it's a known custom element\n * - the element matches any directive\n * - the element is allowed by one of the schemas\n *\n * @param element Element to validate\n * @param lView An `LView` that represents a current component that is being rendered\n * @param tagName Name of the tag to check\n * @param schemas Array of schemas\n * @param hasDirectives Boolean indicating that the element matches any directive\n */\n\n\nfunction validateElementIsKnown(element, lView, tagName, schemas, hasDirectives) {\n  // If `schemas` is set to `null`, that's an indication that this Component was compiled in AOT\n  // mode where this check happens at compile time. In JIT mode, `schemas` is always present and\n  // defined as an array (as an empty array in case `schemas` field is not defined) and we should\n  // execute the check below.\n  if (schemas === null) return; // If the element matches any directive, it's considered as valid.\n\n  if (!hasDirectives && tagName !== null) {\n    // The element is unknown if it's an instance of HTMLUnknownElement, or it isn't registered\n    // as a custom element. Note that unknown elements with a dash in their name won't be instances\n    // of HTMLUnknownElement in browsers that support web components.\n    const isUnknown = // Note that we can't check for `typeof HTMLUnknownElement === 'function'`,\n    // because while most browsers return 'function', IE returns 'object'.\n    typeof HTMLUnknownElement !== 'undefined' && HTMLUnknownElement && element instanceof HTMLUnknownElement || typeof customElements !== 'undefined' && tagName.indexOf('-') > -1 && !customElements.get(tagName);\n\n    if (isUnknown && !matchingSchemas(schemas, tagName)) {\n      const isHostStandalone = isHostComponentStandalone(lView);\n      const templateLocation = getTemplateLocationDetails(lView);\n      const schemas = `'${isHostStandalone ? '@Component' : '@NgModule'}.schemas'`;\n      let message = `'${tagName}' is not a known element${templateLocation}:\\n`;\n      message += `1. If '${tagName}' is an Angular component, then verify that it is ${isHostStandalone ? 'included in the \\'@Component.imports\\' of this component' : 'a part of an @NgModule where this component is declared'}.\\n`;\n\n      if (tagName && tagName.indexOf('-') > -1) {\n        message += `2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas} of this component to suppress this message.`;\n      } else {\n        message += `2. To allow any element add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;\n      }\n\n      if (shouldThrowErrorOnUnknownElement) {\n        throw new RuntimeError(304\n        /* RuntimeErrorCode.UNKNOWN_ELEMENT */\n        , message);\n      } else {\n        console.error(formatRuntimeError(304\n        /* RuntimeErrorCode.UNKNOWN_ELEMENT */\n        , message));\n      }\n    }\n  }\n}\n/**\n * Validates that the property of the element is known at runtime and returns\n * false if it's not the case.\n * This check is relevant for JIT-compiled components (for AOT-compiled\n * ones this check happens at build time).\n *\n * The property is considered known if either:\n * - it's a known property of the element\n * - the element is allowed by one of the schemas\n * - the property is used for animations\n *\n * @param element Element to validate\n * @param propName Name of the property to check\n * @param tagName Name of the tag hosting the property\n * @param schemas Array of schemas\n */\n\n\nfunction isPropertyValid(element, propName, tagName, schemas) {\n  // If `schemas` is set to `null`, that's an indication that this Component was compiled in AOT\n  // mode where this check happens at compile time. In JIT mode, `schemas` is always present and\n  // defined as an array (as an empty array in case `schemas` field is not defined) and we should\n  // execute the check below.\n  if (schemas === null) return true; // The property is considered valid if the element matches the schema, it exists on the element,\n  // or it is synthetic, and we are in a browser context (web worker nodes should be skipped).\n\n  if (matchingSchemas(schemas, tagName) || propName in element || isAnimationProp(propName)) {\n    return true;\n  } // Note: `typeof Node` returns 'function' in most browsers, but on IE it is 'object' so we\n  // need to account for both here, while being careful with `typeof null` also returning 'object'.\n\n\n  return typeof Node === 'undefined' || Node === null || !(element instanceof Node);\n}\n/**\n * Logs or throws an error that a property is not supported on an element.\n *\n * @param propName Name of the invalid property\n * @param tagName Name of the tag hosting the property\n * @param nodeType Type of the node hosting the property\n * @param lView An `LView` that represents a current component\n */\n\n\nfunction handleUnknownPropertyError(propName, tagName, nodeType, lView) {\n  // Special-case a situation when a structural directive is applied to\n  // an `<ng-template>` element, for example: `<ng-template *ngIf=\"true\">`.\n  // In this case the compiler generates the `ɵɵtemplate` instruction with\n  // the `null` as the tagName. The directive matching logic at runtime relies\n  // on this effect (see `isInlineTemplate`), thus using the 'ng-template' as\n  // a default value of the `tNode.value` is not feasible at this moment.\n  if (!tagName && nodeType === 4\n  /* TNodeType.Container */\n  ) {\n    tagName = 'ng-template';\n  }\n\n  const isHostStandalone = isHostComponentStandalone(lView);\n  const templateLocation = getTemplateLocationDetails(lView);\n  let message = `Can't bind to '${propName}' since it isn't a known property of '${tagName}'${templateLocation}.`;\n  const schemas = `'${isHostStandalone ? '@Component' : '@NgModule'}.schemas'`;\n  const importLocation = isHostStandalone ? 'included in the \\'@Component.imports\\' of this component' : 'a part of an @NgModule where this component is declared';\n\n  if (KNOWN_CONTROL_FLOW_DIRECTIVES.has(propName)) {\n    // Most likely this is a control flow directive (such as `*ngIf`) used in\n    // a template, but the `CommonModule` is not imported.\n    message += `\\nIf the '${propName}' is an Angular control flow directive, ` + `please make sure that the 'CommonModule' is ${importLocation}.`;\n  } else {\n    // May be an Angular component, which is not imported/declared?\n    message += `\\n1. If '${tagName}' is an Angular component and it has the ` + `'${propName}' input, then verify that it is ${importLocation}.`; // May be a Web Component?\n\n    if (tagName && tagName.indexOf('-') > -1) {\n      message += `\\n2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' ` + `to the ${schemas} of this component to suppress this message.`;\n      message += `\\n3. To allow any property add 'NO_ERRORS_SCHEMA' to ` + `the ${schemas} of this component.`;\n    } else {\n      // If it's expected, the error can be suppressed by the `NO_ERRORS_SCHEMA` schema.\n      message += `\\n2. To allow any property add 'NO_ERRORS_SCHEMA' to ` + `the ${schemas} of this component.`;\n    }\n  }\n\n  if (shouldThrowErrorOnUnknownProperty) {\n    throw new RuntimeError(303\n    /* RuntimeErrorCode.UNKNOWN_BINDING */\n    , message);\n  } else {\n    console.error(formatRuntimeError(303\n    /* RuntimeErrorCode.UNKNOWN_BINDING */\n    , message));\n  }\n}\n/**\n * WARNING: this is a **dev-mode only** function (thus should always be guarded by the `ngDevMode`)\n * and must **not** be used in production bundles. The function makes megamorphic reads, which might\n * be too slow for production mode and also it relies on the constructor function being available.\n *\n * Gets a reference to the host component def (where a current component is declared).\n *\n * @param lView An `LView` that represents a current component that is being rendered.\n */\n\n\nfunction getDeclarationComponentDef(lView) {\n  !ngDevMode && throwError('Must never be called in production mode');\n  const declarationLView = lView[DECLARATION_COMPONENT_VIEW];\n  const context = declarationLView[CONTEXT]; // Unable to obtain a context.\n\n  if (!context) return null;\n  return context.constructor ? getComponentDef$1(context.constructor) : null;\n}\n/**\n * WARNING: this is a **dev-mode only** function (thus should always be guarded by the `ngDevMode`)\n * and must **not** be used in production bundles. The function makes megamorphic reads, which might\n * be too slow for production mode.\n *\n * Checks if the current component is declared inside of a standalone component template.\n *\n * @param lView An `LView` that represents a current component that is being rendered.\n */\n\n\nfunction isHostComponentStandalone(lView) {\n  !ngDevMode && throwError('Must never be called in production mode');\n  const componentDef = getDeclarationComponentDef(lView); // Treat host component as non-standalone if we can't obtain the def.\n\n  return !!(componentDef === null || componentDef === void 0 ? void 0 : componentDef.standalone);\n}\n/**\n * WARNING: this is a **dev-mode only** function (thus should always be guarded by the `ngDevMode`)\n * and must **not** be used in production bundles. The function makes megamorphic reads, which might\n * be too slow for production mode.\n *\n * Constructs a string describing the location of the host component template. The function is used\n * in dev mode to produce error messages.\n *\n * @param lView An `LView` that represents a current component that is being rendered.\n */\n\n\nfunction getTemplateLocationDetails(lView) {\n  var _a;\n\n  !ngDevMode && throwError('Must never be called in production mode');\n  const hostComponentDef = getDeclarationComponentDef(lView);\n  const componentClassName = (_a = hostComponentDef === null || hostComponentDef === void 0 ? void 0 : hostComponentDef.type) === null || _a === void 0 ? void 0 : _a.name;\n  return componentClassName ? ` (used in the '${componentClassName}' component template)` : '';\n}\n/**\n * The set of known control flow directives.\n * We use this set to produce a more precises error message with a note\n * that the `CommonModule` should also be included.\n */\n\n\nconst KNOWN_CONTROL_FLOW_DIRECTIVES = new Set(['ngIf', 'ngFor', 'ngSwitch', 'ngSwitchCase', 'ngSwitchDefault']);\n/**\n * Returns true if the tag name is allowed by specified schemas.\n * @param schemas Array of schemas\n * @param tagName Name of the tag\n */\n\nfunction matchingSchemas(schemas, tagName) {\n  if (schemas !== null) {\n    for (let i = 0; i < schemas.length; i++) {\n      const schema = schemas[i];\n\n      if (schema === NO_ERRORS_SCHEMA || schema === CUSTOM_ELEMENTS_SCHEMA && tagName && tagName.indexOf('-') > -1) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * THIS FILE CONTAINS CODE WHICH SHOULD BE TREE SHAKEN AND NEVER CALLED FROM PRODUCTION CODE!!!\n */\n\n/**\n * Creates an `Array` construction with a given name. This is useful when\n * looking for memory consumption to see what time of array it is.\n *\n *\n * @param name Name to give to the constructor\n * @returns A subclass of `Array` if possible. This can only be done in\n *          environments which support `class` construct.\n */\n\n\nfunction createNamedArrayType(name) {\n  // This should never be called in prod mode, so let's verify that is the case.\n  if (ngDevMode) {\n    try {\n      // If this function were compromised the following could lead to arbitrary\n      // script execution. We bless it with Trusted Types anyway since this\n      // function is stripped out of production binaries.\n      return newTrustedFunctionForDev('Array', `return class ${name} extends Array{}`)(Array);\n    } catch (e) {\n      // If it does not work just give up and fall back to regular Array.\n      return Array;\n    }\n  } else {\n    throw new Error('Looks like we are in \\'prod mode\\', but we are creating a named Array type, which is wrong! Check your code');\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction toTStylingRange(prev, next) {\n  ngDevMode && assertNumberInRange(prev, 0, 32767\n  /* StylingRange.UNSIGNED_MASK */\n  );\n  ngDevMode && assertNumberInRange(next, 0, 32767\n  /* StylingRange.UNSIGNED_MASK */\n  );\n  return prev << 17\n  /* StylingRange.PREV_SHIFT */\n  | next << 2\n  /* StylingRange.NEXT_SHIFT */\n  ;\n}\n\nfunction getTStylingRangePrev(tStylingRange) {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return tStylingRange >> 17\n  /* StylingRange.PREV_SHIFT */\n  & 32767\n  /* StylingRange.UNSIGNED_MASK */\n  ;\n}\n\nfunction getTStylingRangePrevDuplicate(tStylingRange) {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return (tStylingRange & 2\n  /* StylingRange.PREV_DUPLICATE */\n  ) == 2\n  /* StylingRange.PREV_DUPLICATE */\n  ;\n}\n\nfunction setTStylingRangePrev(tStylingRange, previous) {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  ngDevMode && assertNumberInRange(previous, 0, 32767\n  /* StylingRange.UNSIGNED_MASK */\n  );\n  return tStylingRange & ~4294836224\n  /* StylingRange.PREV_MASK */\n  | previous << 17\n  /* StylingRange.PREV_SHIFT */\n  ;\n}\n\nfunction setTStylingRangePrevDuplicate(tStylingRange) {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return tStylingRange | 2\n  /* StylingRange.PREV_DUPLICATE */\n  ;\n}\n\nfunction getTStylingRangeNext(tStylingRange) {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return (tStylingRange & 131068\n  /* StylingRange.NEXT_MASK */\n  ) >> 2\n  /* StylingRange.NEXT_SHIFT */\n  ;\n}\n\nfunction setTStylingRangeNext(tStylingRange, next) {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  ngDevMode && assertNumberInRange(next, 0, 32767\n  /* StylingRange.UNSIGNED_MASK */\n  );\n  return tStylingRange & ~131068\n  /* StylingRange.NEXT_MASK */\n  | //\n  next << 2\n  /* StylingRange.NEXT_SHIFT */\n  ;\n}\n\nfunction getTStylingRangeNextDuplicate(tStylingRange) {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return (tStylingRange & 1\n  /* StylingRange.NEXT_DUPLICATE */\n  ) === 1\n  /* StylingRange.NEXT_DUPLICATE */\n  ;\n}\n\nfunction setTStylingRangeNextDuplicate(tStylingRange) {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return tStylingRange | 1\n  /* StylingRange.NEXT_DUPLICATE */\n  ;\n}\n\nfunction getTStylingRangeTail(tStylingRange) {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  const next = getTStylingRangeNext(tStylingRange);\n  return next === 0 ? getTStylingRangePrev(tStylingRange) : next;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Patch a `debug` property on top of the existing object.\n *\n * NOTE: always call this method with `ngDevMode && attachDebugObject(...)`\n *\n * @param obj Object to patch\n * @param debug Value to patch\n */\n\n\nfunction attachDebugObject(obj, debug) {\n  if (ngDevMode) {\n    Object.defineProperty(obj, 'debug', {\n      value: debug,\n      enumerable: false\n    });\n  } else {\n    throw new Error('This method should be guarded with `ngDevMode` so that it can be tree shaken in production!');\n  }\n}\n/**\n * Patch a `debug` property getter on top of the existing object.\n *\n * NOTE: always call this method with `ngDevMode && attachDebugObject(...)`\n *\n * @param obj Object to patch\n * @param debugGetter Getter returning a value to patch\n */\n\n\nfunction attachDebugGetter(obj, debugGetter) {\n  if (ngDevMode) {\n    Object.defineProperty(obj, 'debug', {\n      get: debugGetter,\n      enumerable: false\n    });\n  } else {\n    throw new Error('This method should be guarded with `ngDevMode` so that it can be tree shaken in production!');\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/*\n * This file contains conditionally attached classes which provide human readable (debug) level\n * information for `LView`, `LContainer` and other internal data structures. These data structures\n * are stored internally as array which makes it very difficult during debugging to reason about the\n * current state of the system.\n *\n * Patching the array with extra property does change the array's hidden class' but it does not\n * change the cost of access, therefore this patching should not have significant if any impact in\n * `ngDevMode` mode. (see: https://jsperf.com/array-vs-monkey-patch-array)\n *\n * So instead of seeing:\n * ```\n * Array(30) [Object, 659, null, …]\n * ```\n *\n * You get to see:\n * ```\n * LViewDebug {\n *   views: [...],\n *   flags: {attached: true, ...}\n *   nodes: [\n *     {html: '<div id=\"123\">', ..., nodes: [\n *       {html: '<span>', ..., nodes: null}\n *     ]}\n *   ]\n * }\n * ```\n */\n\n\nlet LVIEW_COMPONENT_CACHE;\nlet LVIEW_EMBEDDED_CACHE;\nlet LVIEW_ROOT;\nlet LVIEW_COMPONENT;\nlet LVIEW_EMBEDDED;\n/**\n * This function clones a blueprint and creates LView.\n *\n * Simple slice will keep the same type, and we need it to be LView\n */\n\nfunction cloneToLViewFromTViewBlueprint(tView) {\n  const debugTView = tView;\n  const lView = getLViewToClone(debugTView.type, tView.template && tView.template.name);\n  return lView.concat(tView.blueprint);\n}\n\nclass LRootView extends Array {}\n\nclass LComponentView extends Array {}\n\nclass LEmbeddedView extends Array {}\n\nfunction getLViewToClone(type, name) {\n  switch (type) {\n    case 0\n    /* TViewType.Root */\n    :\n      if (LVIEW_ROOT === undefined) LVIEW_ROOT = new LRootView();\n      return LVIEW_ROOT;\n\n    case 1\n    /* TViewType.Component */\n    :\n      if (!ngDevMode || !ngDevMode.namedConstructors) {\n        if (LVIEW_COMPONENT === undefined) LVIEW_COMPONENT = new LComponentView();\n        return LVIEW_COMPONENT;\n      }\n\n      if (LVIEW_COMPONENT_CACHE === undefined) LVIEW_COMPONENT_CACHE = new Map();\n      let componentArray = LVIEW_COMPONENT_CACHE.get(name);\n\n      if (componentArray === undefined) {\n        componentArray = new (createNamedArrayType('LComponentView' + nameSuffix(name)))();\n        LVIEW_COMPONENT_CACHE.set(name, componentArray);\n      }\n\n      return componentArray;\n\n    case 2\n    /* TViewType.Embedded */\n    :\n      if (!ngDevMode || !ngDevMode.namedConstructors) {\n        if (LVIEW_EMBEDDED === undefined) LVIEW_EMBEDDED = new LEmbeddedView();\n        return LVIEW_EMBEDDED;\n      }\n\n      if (LVIEW_EMBEDDED_CACHE === undefined) LVIEW_EMBEDDED_CACHE = new Map();\n      let embeddedArray = LVIEW_EMBEDDED_CACHE.get(name);\n\n      if (embeddedArray === undefined) {\n        embeddedArray = new (createNamedArrayType('LEmbeddedView' + nameSuffix(name)))();\n        LVIEW_EMBEDDED_CACHE.set(name, embeddedArray);\n      }\n\n      return embeddedArray;\n  }\n}\n\nfunction nameSuffix(text) {\n  if (text == null) return '';\n  const index = text.lastIndexOf('_Template');\n  return '_' + (index === -1 ? text : text.slice(0, index));\n}\n/**\n * This class is a debug version of Object literal so that we can have constructor name show up\n * in\n * debug tools in ngDevMode.\n */\n\n\nconst TViewConstructor = class TView {\n  constructor(type, blueprint, template, queries, viewQuery, declTNode, data, bindingStartIndex, expandoStartIndex, hostBindingOpCodes, firstCreatePass, firstUpdatePass, staticViewQueries, staticContentQueries, preOrderHooks, preOrderCheckHooks, contentHooks, contentCheckHooks, viewHooks, viewCheckHooks, destroyHooks, cleanup, contentQueries, components, directiveRegistry, pipeRegistry, firstChild, schemas, consts, incompleteFirstPass, _decls, _vars) {\n    this.type = type;\n    this.blueprint = blueprint;\n    this.template = template;\n    this.queries = queries;\n    this.viewQuery = viewQuery;\n    this.declTNode = declTNode;\n    this.data = data;\n    this.bindingStartIndex = bindingStartIndex;\n    this.expandoStartIndex = expandoStartIndex;\n    this.hostBindingOpCodes = hostBindingOpCodes;\n    this.firstCreatePass = firstCreatePass;\n    this.firstUpdatePass = firstUpdatePass;\n    this.staticViewQueries = staticViewQueries;\n    this.staticContentQueries = staticContentQueries;\n    this.preOrderHooks = preOrderHooks;\n    this.preOrderCheckHooks = preOrderCheckHooks;\n    this.contentHooks = contentHooks;\n    this.contentCheckHooks = contentCheckHooks;\n    this.viewHooks = viewHooks;\n    this.viewCheckHooks = viewCheckHooks;\n    this.destroyHooks = destroyHooks;\n    this.cleanup = cleanup;\n    this.contentQueries = contentQueries;\n    this.components = components;\n    this.directiveRegistry = directiveRegistry;\n    this.pipeRegistry = pipeRegistry;\n    this.firstChild = firstChild;\n    this.schemas = schemas;\n    this.consts = consts;\n    this.incompleteFirstPass = incompleteFirstPass;\n    this._decls = _decls;\n    this._vars = _vars;\n  }\n\n  get template_() {\n    const buf = [];\n    processTNodeChildren(this.firstChild, buf);\n    return buf.join('');\n  }\n\n  get type_() {\n    return TViewTypeAsString[this.type] || `TViewType.?${this.type}?`;\n  }\n\n};\n\nclass TNode {\n  constructor(tView_, //\n  type, //\n  index, //\n  insertBeforeIndex, //\n  injectorIndex, //\n  directiveStart, //\n  directiveEnd, //\n  directiveStylingLast, //\n  propertyBindings, //\n  flags, //\n  providerIndexes, //\n  value, //\n  attrs, //\n  mergedAttrs, //\n  localNames, //\n  initialInputs, //\n  inputs, //\n  outputs, //\n  tViews, //\n  next, //\n  projectionNext, //\n  child, //\n  parent, //\n  projection, //\n  styles, //\n  stylesWithoutHost, //\n  residualStyles, //\n  classes, //\n  classesWithoutHost, //\n  residualClasses, //\n  classBindings, //\n  styleBindings) {\n    this.tView_ = tView_;\n    this.type = type;\n    this.index = index;\n    this.insertBeforeIndex = insertBeforeIndex;\n    this.injectorIndex = injectorIndex;\n    this.directiveStart = directiveStart;\n    this.directiveEnd = directiveEnd;\n    this.directiveStylingLast = directiveStylingLast;\n    this.propertyBindings = propertyBindings;\n    this.flags = flags;\n    this.providerIndexes = providerIndexes;\n    this.value = value;\n    this.attrs = attrs;\n    this.mergedAttrs = mergedAttrs;\n    this.localNames = localNames;\n    this.initialInputs = initialInputs;\n    this.inputs = inputs;\n    this.outputs = outputs;\n    this.tViews = tViews;\n    this.next = next;\n    this.projectionNext = projectionNext;\n    this.child = child;\n    this.parent = parent;\n    this.projection = projection;\n    this.styles = styles;\n    this.stylesWithoutHost = stylesWithoutHost;\n    this.residualStyles = residualStyles;\n    this.classes = classes;\n    this.classesWithoutHost = classesWithoutHost;\n    this.residualClasses = residualClasses;\n    this.classBindings = classBindings;\n    this.styleBindings = styleBindings;\n  }\n  /**\n   * Return a human debug version of the set of `NodeInjector`s which will be consulted when\n   * resolving tokens from this `TNode`.\n   *\n   * When debugging applications, it is often difficult to determine which `NodeInjector`s will be\n   * consulted. This method shows a list of `DebugNode`s representing the `TNode`s which will be\n   * consulted in order when resolving a token starting at this `TNode`.\n   *\n   * The original data is stored in `LView` and `TView` with a lot of offset indexes, and so it is\n   * difficult to reason about.\n   *\n   * @param lView The `LView` instance for this `TNode`.\n   */\n\n\n  debugNodeInjectorPath(lView) {\n    const path = [];\n    let injectorIndex = getInjectorIndex(this, lView);\n\n    if (injectorIndex === -1) {\n      // Looks like the current `TNode` does not have `NodeInjector` associated with it => look for\n      // parent NodeInjector.\n      const parentLocation = getParentInjectorLocation(this, lView);\n\n      if (parentLocation !== NO_PARENT_INJECTOR) {\n        // We found a parent, so start searching from the parent location.\n        injectorIndex = getParentInjectorIndex(parentLocation);\n        lView = getParentInjectorView(parentLocation, lView);\n      } else {// No parents have been found, so there are no `NodeInjector`s to consult.\n      }\n    }\n\n    while (injectorIndex !== -1) {\n      ngDevMode && assertNodeInjector(lView, injectorIndex);\n      const tNode = lView[TVIEW].data[injectorIndex + 8\n      /* NodeInjectorOffset.TNODE */\n      ];\n      path.push(buildDebugNode(tNode, lView));\n      const parentLocation = lView[injectorIndex + 8\n      /* NodeInjectorOffset.PARENT */\n      ];\n\n      if (parentLocation === NO_PARENT_INJECTOR) {\n        injectorIndex = -1;\n      } else {\n        injectorIndex = getParentInjectorIndex(parentLocation);\n        lView = getParentInjectorView(parentLocation, lView);\n      }\n    }\n\n    return path;\n  }\n\n  get type_() {\n    return toTNodeTypeAsString(this.type) || `TNodeType.?${this.type}?`;\n  }\n\n  get flags_() {\n    const flags = [];\n    if (this.flags & 16\n    /* TNodeFlags.hasClassInput */\n    ) flags.push('TNodeFlags.hasClassInput');\n    if (this.flags & 8\n    /* TNodeFlags.hasContentQuery */\n    ) flags.push('TNodeFlags.hasContentQuery');\n    if (this.flags & 32\n    /* TNodeFlags.hasStyleInput */\n    ) flags.push('TNodeFlags.hasStyleInput');\n    if (this.flags & 128\n    /* TNodeFlags.hasHostBindings */\n    ) flags.push('TNodeFlags.hasHostBindings');\n    if (this.flags & 2\n    /* TNodeFlags.isComponentHost */\n    ) flags.push('TNodeFlags.isComponentHost');\n    if (this.flags & 1\n    /* TNodeFlags.isDirectiveHost */\n    ) flags.push('TNodeFlags.isDirectiveHost');\n    if (this.flags & 64\n    /* TNodeFlags.isDetached */\n    ) flags.push('TNodeFlags.isDetached');\n    if (this.flags & 4\n    /* TNodeFlags.isProjected */\n    ) flags.push('TNodeFlags.isProjected');\n    return flags.join('|');\n  }\n\n  get template_() {\n    if (this.type & 1\n    /* TNodeType.Text */\n    ) return this.value;\n    const buf = [];\n    const tagName = typeof this.value === 'string' && this.value || this.type_;\n    buf.push('<', tagName);\n\n    if (this.flags) {\n      buf.push(' ', this.flags_);\n    }\n\n    if (this.attrs) {\n      for (let i = 0; i < this.attrs.length;) {\n        const attrName = this.attrs[i++];\n\n        if (typeof attrName == 'number') {\n          break;\n        }\n\n        const attrValue = this.attrs[i++];\n        buf.push(' ', attrName, '=\"', attrValue, '\"');\n      }\n    }\n\n    buf.push('>');\n    processTNodeChildren(this.child, buf);\n    buf.push('</', tagName, '>');\n    return buf.join('');\n  }\n\n  get styleBindings_() {\n    return toDebugStyleBinding(this, false);\n  }\n\n  get classBindings_() {\n    return toDebugStyleBinding(this, true);\n  }\n\n  get providerIndexStart_() {\n    return this.providerIndexes & 1048575\n    /* TNodeProviderIndexes.ProvidersStartIndexMask */\n    ;\n  }\n\n  get providerIndexEnd_() {\n    return this.providerIndexStart_ + (this.providerIndexes >>> 20\n    /* TNodeProviderIndexes.CptViewProvidersCountShift */\n    );\n  }\n\n}\n\nconst TNodeDebug = TNode;\n\nfunction toDebugStyleBinding(tNode, isClassBased) {\n  const tData = tNode.tView_.data;\n  const bindings = [];\n  const range = isClassBased ? tNode.classBindings : tNode.styleBindings;\n  const prev = getTStylingRangePrev(range);\n  const next = getTStylingRangeNext(range);\n  let isTemplate = next !== 0;\n  let cursor = isTemplate ? next : prev;\n\n  while (cursor !== 0) {\n    const itemKey = tData[cursor];\n    const itemRange = tData[cursor + 1];\n    bindings.unshift({\n      key: itemKey,\n      index: cursor,\n      isTemplate: isTemplate,\n      prevDuplicate: getTStylingRangePrevDuplicate(itemRange),\n      nextDuplicate: getTStylingRangeNextDuplicate(itemRange),\n      nextIndex: getTStylingRangeNext(itemRange),\n      prevIndex: getTStylingRangePrev(itemRange)\n    });\n    if (cursor === prev) isTemplate = false;\n    cursor = getTStylingRangePrev(itemRange);\n  }\n\n  bindings.push((isClassBased ? tNode.residualClasses : tNode.residualStyles) || null);\n  return bindings;\n}\n\nfunction processTNodeChildren(tNode, buf) {\n  while (tNode) {\n    buf.push(tNode.template_);\n    tNode = tNode.next;\n  }\n}\n\nclass TViewData extends Array {}\n\nlet TVIEWDATA_EMPTY; // can't initialize here or it will not be tree shaken, because\n// `LView` constructor could have side-effects.\n\n/**\n * This function clones a blueprint and creates TData.\n *\n * Simple slice will keep the same type, and we need it to be TData\n */\n\nfunction cloneToTViewData(list) {\n  if (TVIEWDATA_EMPTY === undefined) TVIEWDATA_EMPTY = new TViewData();\n  return TVIEWDATA_EMPTY.concat(list);\n}\n\nclass LViewBlueprint extends Array {}\n\nclass MatchesArray extends Array {}\n\nclass TViewComponents extends Array {}\n\nclass TNodeLocalNames extends Array {}\n\nclass TNodeInitialInputs extends Array {}\n\nclass LCleanup extends Array {}\n\nclass TCleanup extends Array {}\n\nfunction attachLViewDebug(lView) {\n  attachDebugObject(lView, new LViewDebug(lView));\n}\n\nfunction attachLContainerDebug(lContainer) {\n  attachDebugObject(lContainer, new LContainerDebug(lContainer));\n}\n\nfunction toDebug(obj) {\n  if (obj) {\n    const debug = obj.debug;\n    assertDefined(debug, 'Object does not have a debug representation.');\n    return debug;\n  } else {\n    return obj;\n  }\n}\n/**\n * Use this method to unwrap a native element in `LView` and convert it into HTML for easier\n * reading.\n *\n * @param value possibly wrapped native DOM node.\n * @param includeChildren If `true` then the serialized HTML form will include child elements\n * (same\n * as `outerHTML`). If `false` then the serialized HTML form will only contain the element\n * itself\n * (will not serialize child elements).\n */\n\n\nfunction toHtml(value, includeChildren = false) {\n  const node = unwrapRNode(value);\n\n  if (node) {\n    switch (node.nodeType) {\n      case Node.TEXT_NODE:\n        return node.textContent;\n\n      case Node.COMMENT_NODE:\n        return `<!--${node.textContent}-->`;\n\n      case Node.ELEMENT_NODE:\n        const outerHTML = node.outerHTML;\n\n        if (includeChildren) {\n          return outerHTML;\n        } else {\n          const innerHTML = '>' + node.innerHTML + '<';\n          return outerHTML.split(innerHTML)[0] + '>';\n        }\n\n    }\n  }\n\n  return null;\n}\n\nclass LViewDebug {\n  constructor(_raw_lView) {\n    this._raw_lView = _raw_lView;\n  }\n  /**\n   * Flags associated with the `LView` unpacked into a more readable state.\n   */\n\n\n  get flags() {\n    const flags = this._raw_lView[FLAGS];\n    return {\n      __raw__flags__: flags,\n      initPhaseState: flags & 3\n      /* LViewFlags.InitPhaseStateMask */\n      ,\n      creationMode: !!(flags & 4\n      /* LViewFlags.CreationMode */\n      ),\n      firstViewPass: !!(flags & 8\n      /* LViewFlags.FirstLViewPass */\n      ),\n      checkAlways: !!(flags & 16\n      /* LViewFlags.CheckAlways */\n      ),\n      dirty: !!(flags & 32\n      /* LViewFlags.Dirty */\n      ),\n      attached: !!(flags & 64\n      /* LViewFlags.Attached */\n      ),\n      destroyed: !!(flags & 128\n      /* LViewFlags.Destroyed */\n      ),\n      isRoot: !!(flags & 256\n      /* LViewFlags.IsRoot */\n      ),\n      indexWithinInitPhase: flags >> 11\n      /* LViewFlags.IndexWithinInitPhaseShift */\n\n    };\n  }\n\n  get parent() {\n    return toDebug(this._raw_lView[PARENT]);\n  }\n\n  get hostHTML() {\n    return toHtml(this._raw_lView[HOST], true);\n  }\n\n  get html() {\n    return (this.nodes || []).map(mapToHTML).join('');\n  }\n\n  get context() {\n    return this._raw_lView[CONTEXT];\n  }\n  /**\n   * The tree of nodes associated with the current `LView`. The nodes have been normalized into\n   * a tree structure with relevant details pulled out for readability.\n   */\n\n\n  get nodes() {\n    const lView = this._raw_lView;\n    const tNode = lView[TVIEW].firstChild;\n    return toDebugNodes(tNode, lView);\n  }\n\n  get template() {\n    return this.tView.template_;\n  }\n\n  get tView() {\n    return this._raw_lView[TVIEW];\n  }\n\n  get cleanup() {\n    return this._raw_lView[CLEANUP];\n  }\n\n  get injector() {\n    return this._raw_lView[INJECTOR$1];\n  }\n\n  get rendererFactory() {\n    return this._raw_lView[RENDERER_FACTORY];\n  }\n\n  get renderer() {\n    return this._raw_lView[RENDERER];\n  }\n\n  get sanitizer() {\n    return this._raw_lView[SANITIZER];\n  }\n\n  get childHead() {\n    return toDebug(this._raw_lView[CHILD_HEAD]);\n  }\n\n  get next() {\n    return toDebug(this._raw_lView[NEXT]);\n  }\n\n  get childTail() {\n    return toDebug(this._raw_lView[CHILD_TAIL]);\n  }\n\n  get declarationView() {\n    return toDebug(this._raw_lView[DECLARATION_VIEW]);\n  }\n\n  get queries() {\n    return this._raw_lView[QUERIES];\n  }\n\n  get tHost() {\n    return this._raw_lView[T_HOST];\n  }\n\n  get id() {\n    return this._raw_lView[ID];\n  }\n\n  get decls() {\n    return toLViewRange(this.tView, this._raw_lView, HEADER_OFFSET, this.tView.bindingStartIndex);\n  }\n\n  get vars() {\n    return toLViewRange(this.tView, this._raw_lView, this.tView.bindingStartIndex, this.tView.expandoStartIndex);\n  }\n\n  get expando() {\n    return toLViewRange(this.tView, this._raw_lView, this.tView.expandoStartIndex, this._raw_lView.length);\n  }\n  /**\n   * Normalized view of child views (and containers) attached at this location.\n   */\n\n\n  get childViews() {\n    const childViews = [];\n    let child = this.childHead;\n\n    while (child) {\n      childViews.push(child);\n      child = child.next;\n    }\n\n    return childViews;\n  }\n\n}\n\nfunction mapToHTML(node) {\n  if (node.type === 'ElementContainer') {\n    return (node.children || []).map(mapToHTML).join('');\n  } else if (node.type === 'IcuContainer') {\n    throw new Error('Not implemented');\n  } else {\n    return toHtml(node.native, true) || '';\n  }\n}\n\nfunction toLViewRange(tView, lView, start, end) {\n  let content = [];\n\n  for (let index = start; index < end; index++) {\n    content.push({\n      index: index,\n      t: tView.data[index],\n      l: lView[index]\n    });\n  }\n\n  return {\n    start: start,\n    end: end,\n    length: end - start,\n    content: content\n  };\n}\n/**\n * Turns a flat list of nodes into a tree by walking the associated `TNode` tree.\n *\n * @param tNode\n * @param lView\n */\n\n\nfunction toDebugNodes(tNode, lView) {\n  if (tNode) {\n    const debugNodes = [];\n    let tNodeCursor = tNode;\n\n    while (tNodeCursor) {\n      debugNodes.push(buildDebugNode(tNodeCursor, lView));\n      tNodeCursor = tNodeCursor.next;\n    }\n\n    return debugNodes;\n  } else {\n    return [];\n  }\n}\n\nfunction buildDebugNode(tNode, lView) {\n  const rawValue = lView[tNode.index];\n  const native = unwrapRNode(rawValue);\n  const factories = [];\n  const instances = [];\n  const tView = lView[TVIEW];\n\n  for (let i = tNode.directiveStart; i < tNode.directiveEnd; i++) {\n    const def = tView.data[i];\n    factories.push(def.type);\n    instances.push(lView[i]);\n  }\n\n  return {\n    html: toHtml(native),\n    type: toTNodeTypeAsString(tNode.type),\n    tNode,\n    native: native,\n    children: toDebugNodes(tNode.child, lView),\n    factories,\n    instances,\n    injector: buildNodeInjectorDebug(tNode, tView, lView),\n\n    get injectorResolutionPath() {\n      return tNode.debugNodeInjectorPath(lView);\n    }\n\n  };\n}\n\nfunction buildNodeInjectorDebug(tNode, tView, lView) {\n  const viewProviders = [];\n\n  for (let i = tNode.providerIndexStart_; i < tNode.providerIndexEnd_; i++) {\n    viewProviders.push(tView.data[i]);\n  }\n\n  const providers = [];\n\n  for (let i = tNode.providerIndexEnd_; i < tNode.directiveEnd; i++) {\n    providers.push(tView.data[i]);\n  }\n\n  const nodeInjectorDebug = {\n    bloom: toBloom(lView, tNode.injectorIndex),\n    cumulativeBloom: toBloom(tView.data, tNode.injectorIndex),\n    providers,\n    viewProviders,\n    parentInjectorIndex: lView[tNode.providerIndexStart_ - 1]\n  };\n  return nodeInjectorDebug;\n}\n/**\n * Convert a number at `idx` location in `array` into binary representation.\n *\n * @param array\n * @param idx\n */\n\n\nfunction binary(array, idx) {\n  const value = array[idx]; // If not a number we print 8 `?` to retain alignment but let user know that it was called on\n  // wrong type.\n\n  if (typeof value !== 'number') return '????????'; // We prefix 0s so that we have constant length number\n\n  const text = '00000000' + value.toString(2);\n  return text.substring(text.length - 8);\n}\n/**\n * Convert a bloom filter at location `idx` in `array` into binary representation.\n *\n * @param array\n * @param idx\n */\n\n\nfunction toBloom(array, idx) {\n  if (idx < 0) {\n    return 'NO_NODE_INJECTOR';\n  }\n\n  return `${binary(array, idx + 7)}_${binary(array, idx + 6)}_${binary(array, idx + 5)}_${binary(array, idx + 4)}_${binary(array, idx + 3)}_${binary(array, idx + 2)}_${binary(array, idx + 1)}_${binary(array, idx + 0)}`;\n}\n\nclass LContainerDebug {\n  constructor(_raw_lContainer) {\n    this._raw_lContainer = _raw_lContainer;\n  }\n\n  get hasTransplantedViews() {\n    return this._raw_lContainer[HAS_TRANSPLANTED_VIEWS];\n  }\n\n  get views() {\n    return this._raw_lContainer.slice(CONTAINER_HEADER_OFFSET).map(toDebug);\n  }\n\n  get parent() {\n    return toDebug(this._raw_lContainer[PARENT]);\n  }\n\n  get movedViews() {\n    return this._raw_lContainer[MOVED_VIEWS];\n  }\n\n  get host() {\n    return this._raw_lContainer[HOST];\n  }\n\n  get native() {\n    return this._raw_lContainer[NATIVE];\n  }\n\n  get next() {\n    return toDebug(this._raw_lContainer[NEXT]);\n  }\n\n}\n/**\n * A permanent marker promise which signifies that the current CD tree is\n * clean.\n */\n\n\nconst _CLEAN_PROMISE = (() => Promise.resolve(null))();\n/**\n * Invoke `HostBindingsFunction`s for view.\n *\n * This methods executes `TView.hostBindingOpCodes`. It is used to execute the\n * `HostBindingsFunction`s associated with the current `LView`.\n *\n * @param tView Current `TView`.\n * @param lView Current `LView`.\n */\n\n\nfunction processHostBindingOpCodes(tView, lView) {\n  const hostBindingOpCodes = tView.hostBindingOpCodes;\n  if (hostBindingOpCodes === null) return;\n\n  try {\n    for (let i = 0; i < hostBindingOpCodes.length; i++) {\n      const opCode = hostBindingOpCodes[i];\n\n      if (opCode < 0) {\n        // Negative numbers are element indexes.\n        setSelectedIndex(~opCode);\n      } else {\n        // Positive numbers are NumberTuple which store bindingRootIndex and directiveIndex.\n        const directiveIdx = opCode;\n        const bindingRootIndx = hostBindingOpCodes[++i];\n        const hostBindingFn = hostBindingOpCodes[++i];\n        setBindingRootForHostBindings(bindingRootIndx, directiveIdx);\n        const context = lView[directiveIdx];\n        hostBindingFn(2\n        /* RenderFlags.Update */\n        , context);\n      }\n    }\n  } finally {\n    setSelectedIndex(-1);\n  }\n}\n/** Refreshes all content queries declared by directives in a given view */\n\n\nfunction refreshContentQueries(tView, lView) {\n  const contentQueries = tView.contentQueries;\n\n  if (contentQueries !== null) {\n    for (let i = 0; i < contentQueries.length; i += 2) {\n      const queryStartIdx = contentQueries[i];\n      const directiveDefIdx = contentQueries[i + 1];\n\n      if (directiveDefIdx !== -1) {\n        const directiveDef = tView.data[directiveDefIdx];\n        ngDevMode && assertDefined(directiveDef, 'DirectiveDef not found.');\n        ngDevMode && assertDefined(directiveDef.contentQueries, 'contentQueries function should be defined');\n        setCurrentQueryIndex(queryStartIdx);\n        directiveDef.contentQueries(2\n        /* RenderFlags.Update */\n        , lView[directiveDefIdx], directiveDefIdx);\n      }\n    }\n  }\n}\n/** Refreshes child components in the current view (update mode). */\n\n\nfunction refreshChildComponents(hostLView, components) {\n  for (let i = 0; i < components.length; i++) {\n    refreshComponent(hostLView, components[i]);\n  }\n}\n/** Renders child components in the current view (creation mode). */\n\n\nfunction renderChildComponents(hostLView, components) {\n  for (let i = 0; i < components.length; i++) {\n    renderComponent$1(hostLView, components[i]);\n  }\n}\n\nfunction createLView(parentLView, tView, context, flags, host, tHostNode, rendererFactory, renderer, sanitizer, injector, embeddedViewInjector) {\n  const lView = ngDevMode ? cloneToLViewFromTViewBlueprint(tView) : tView.blueprint.slice();\n  lView[HOST] = host;\n  lView[FLAGS] = flags | 4\n  /* LViewFlags.CreationMode */\n  | 64\n  /* LViewFlags.Attached */\n  | 8\n  /* LViewFlags.FirstLViewPass */\n  ;\n\n  if (embeddedViewInjector !== null || parentLView && parentLView[FLAGS] & 1024\n  /* LViewFlags.HasEmbeddedViewInjector */\n  ) {\n    lView[FLAGS] |= 1024\n    /* LViewFlags.HasEmbeddedViewInjector */\n    ;\n  }\n\n  resetPreOrderHookFlags(lView);\n  ngDevMode && tView.declTNode && parentLView && assertTNodeForLView(tView.declTNode, parentLView);\n  lView[PARENT] = lView[DECLARATION_VIEW] = parentLView;\n  lView[CONTEXT] = context;\n  lView[RENDERER_FACTORY] = rendererFactory || parentLView && parentLView[RENDERER_FACTORY];\n  ngDevMode && assertDefined(lView[RENDERER_FACTORY], 'RendererFactory is required');\n  lView[RENDERER] = renderer || parentLView && parentLView[RENDERER];\n  ngDevMode && assertDefined(lView[RENDERER], 'Renderer is required');\n  lView[SANITIZER] = sanitizer || parentLView && parentLView[SANITIZER] || null;\n  lView[INJECTOR$1] = injector || parentLView && parentLView[INJECTOR$1] || null;\n  lView[T_HOST] = tHostNode;\n  lView[ID] = getUniqueLViewId();\n  lView[EMBEDDED_VIEW_INJECTOR] = embeddedViewInjector;\n  ngDevMode && assertEqual(tView.type == 2\n  /* TViewType.Embedded */\n  ? parentLView !== null : true, true, 'Embedded views must have parentLView');\n  lView[DECLARATION_COMPONENT_VIEW] = tView.type == 2\n  /* TViewType.Embedded */\n  ? parentLView[DECLARATION_COMPONENT_VIEW] : lView;\n  ngDevMode && attachLViewDebug(lView);\n  return lView;\n}\n\nfunction getOrCreateTNode(tView, index, type, name, attrs) {\n  ngDevMode && index !== 0 && // 0 are bogus nodes and they are OK. See `createContainerRef` in\n  // `view_engine_compatibility` for additional context.\n  assertGreaterThanOrEqual(index, HEADER_OFFSET, 'TNodes can\\'t be in the LView header.'); // Keep this function short, so that the VM will inline it.\n\n  ngDevMode && assertPureTNodeType(type);\n  let tNode = tView.data[index];\n\n  if (tNode === null) {\n    tNode = createTNodeAtIndex(tView, index, type, name, attrs);\n\n    if (isInI18nBlock()) {\n      // If we are in i18n block then all elements should be pre declared through `Placeholder`\n      // See `TNodeType.Placeholder` and `LFrame.inI18n` for more context.\n      // If the `TNode` was not pre-declared than it means it was not mentioned which means it was\n      // removed, so we mark it as detached.\n      tNode.flags |= 64\n      /* TNodeFlags.isDetached */\n      ;\n    }\n  } else if (tNode.type & 64\n  /* TNodeType.Placeholder */\n  ) {\n    tNode.type = type;\n    tNode.value = name;\n    tNode.attrs = attrs;\n    const parent = getCurrentParentTNode();\n    tNode.injectorIndex = parent === null ? -1 : parent.injectorIndex;\n    ngDevMode && assertTNodeForTView(tNode, tView);\n    ngDevMode && assertEqual(index, tNode.index, 'Expecting same index');\n  }\n\n  setCurrentTNode(tNode, true);\n  return tNode;\n}\n\nfunction createTNodeAtIndex(tView, index, type, name, attrs) {\n  const currentTNode = getCurrentTNodePlaceholderOk();\n  const isParent = isCurrentTNodeParent();\n  const parent = isParent ? currentTNode : currentTNode && currentTNode.parent; // Parents cannot cross component boundaries because components will be used in multiple places.\n\n  const tNode = tView.data[index] = createTNode(tView, parent, type, index, name, attrs); // Assign a pointer to the first child node of a given view. The first node is not always the one\n  // at index 0, in case of i18n, index 0 can be the instruction `i18nStart` and the first node has\n  // the index 1 or more, so we can't just check node index.\n\n  if (tView.firstChild === null) {\n    tView.firstChild = tNode;\n  }\n\n  if (currentTNode !== null) {\n    if (isParent) {\n      // FIXME(misko): This logic looks unnecessarily complicated. Could we simplify?\n      if (currentTNode.child == null && tNode.parent !== null) {\n        // We are in the same view, which means we are adding content node to the parent view.\n        currentTNode.child = tNode;\n      }\n    } else {\n      if (currentTNode.next === null) {\n        // In the case of i18n the `currentTNode` may already be linked, in which case we don't want\n        // to break the links which i18n created.\n        currentTNode.next = tNode;\n      }\n    }\n  }\n\n  return tNode;\n}\n/**\n * When elements are created dynamically after a view blueprint is created (e.g. through\n * i18nApply()), we need to adjust the blueprint for future\n * template passes.\n *\n * @param tView `TView` associated with `LView`\n * @param lView The `LView` containing the blueprint to adjust\n * @param numSlotsToAlloc The number of slots to alloc in the LView, should be >0\n * @param initialValue Initial value to store in blueprint\n */\n\n\nfunction allocExpando(tView, lView, numSlotsToAlloc, initialValue) {\n  if (numSlotsToAlloc === 0) return -1;\n\n  if (ngDevMode) {\n    assertFirstCreatePass(tView);\n    assertSame(tView, lView[TVIEW], '`LView` must be associated with `TView`!');\n    assertEqual(tView.data.length, lView.length, 'Expecting LView to be same size as TView');\n    assertEqual(tView.data.length, tView.blueprint.length, 'Expecting Blueprint to be same size as TView');\n    assertFirstUpdatePass(tView);\n  }\n\n  const allocIdx = lView.length;\n\n  for (let i = 0; i < numSlotsToAlloc; i++) {\n    lView.push(initialValue);\n    tView.blueprint.push(initialValue);\n    tView.data.push(null);\n  }\n\n  return allocIdx;\n} //////////////////////////\n//// Render\n//////////////////////////\n\n/**\n * Processes a view in the creation mode. This includes a number of steps in a specific order:\n * - creating view query functions (if any);\n * - executing a template function in the creation mode;\n * - updating static queries (if any);\n * - creating child components defined in a given view.\n */\n\n\nfunction renderView(tView, lView, context) {\n  ngDevMode && assertEqual(isCreationMode(lView), true, 'Should be run in creation mode');\n  enterView(lView);\n\n  try {\n    const viewQuery = tView.viewQuery;\n\n    if (viewQuery !== null) {\n      executeViewQueryFn(1\n      /* RenderFlags.Create */\n      , viewQuery, context);\n    } // Execute a template associated with this view, if it exists. A template function might not be\n    // defined for the root component views.\n\n\n    const templateFn = tView.template;\n\n    if (templateFn !== null) {\n      executeTemplate(tView, lView, templateFn, 1\n      /* RenderFlags.Create */\n      , context);\n    } // This needs to be set before children are processed to support recursive components.\n    // This must be set to false immediately after the first creation run because in an\n    // ngFor loop, all the views will be created together before update mode runs and turns\n    // off firstCreatePass. If we don't set it here, instances will perform directive\n    // matching, etc again and again.\n\n\n    if (tView.firstCreatePass) {\n      tView.firstCreatePass = false;\n    } // We resolve content queries specifically marked as `static` in creation mode. Dynamic\n    // content queries are resolved during change detection (i.e. update mode), after embedded\n    // views are refreshed (see block above).\n\n\n    if (tView.staticContentQueries) {\n      refreshContentQueries(tView, lView);\n    } // We must materialize query results before child components are processed\n    // in case a child component has projected a container. The LContainer needs\n    // to exist so the embedded views are properly attached by the container.\n\n\n    if (tView.staticViewQueries) {\n      executeViewQueryFn(2\n      /* RenderFlags.Update */\n      , tView.viewQuery, context);\n    } // Render child component views.\n\n\n    const components = tView.components;\n\n    if (components !== null) {\n      renderChildComponents(lView, components);\n    }\n  } catch (error) {\n    // If we didn't manage to get past the first template pass due to\n    // an error, mark the view as corrupted so we can try to recover.\n    if (tView.firstCreatePass) {\n      tView.incompleteFirstPass = true;\n      tView.firstCreatePass = false;\n    }\n\n    throw error;\n  } finally {\n    lView[FLAGS] &= ~4\n    /* LViewFlags.CreationMode */\n    ;\n    leaveView();\n  }\n}\n/**\n * Processes a view in update mode. This includes a number of steps in a specific order:\n * - executing a template function in update mode;\n * - executing hooks;\n * - refreshing queries;\n * - setting host bindings;\n * - refreshing child (embedded and component) views.\n */\n\n\nfunction refreshView(tView, lView, templateFn, context) {\n  ngDevMode && assertEqual(isCreationMode(lView), false, 'Should be run in update mode');\n  const flags = lView[FLAGS];\n  if ((flags & 128\n  /* LViewFlags.Destroyed */\n  ) === 128\n  /* LViewFlags.Destroyed */\n  ) return;\n  enterView(lView); // Check no changes mode is a dev only mode used to verify that bindings have not changed\n  // since they were assigned. We do not want to execute lifecycle hooks in that mode.\n\n  const isInCheckNoChangesPass = ngDevMode && isInCheckNoChangesMode();\n\n  try {\n    resetPreOrderHookFlags(lView);\n    setBindingIndex(tView.bindingStartIndex);\n\n    if (templateFn !== null) {\n      executeTemplate(tView, lView, templateFn, 2\n      /* RenderFlags.Update */\n      , context);\n    }\n\n    const hooksInitPhaseCompleted = (flags & 3\n    /* LViewFlags.InitPhaseStateMask */\n    ) === 3\n    /* InitPhaseState.InitPhaseCompleted */\n    ; // execute pre-order hooks (OnInit, OnChanges, DoCheck)\n    // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n\n    if (!isInCheckNoChangesPass) {\n      if (hooksInitPhaseCompleted) {\n        const preOrderCheckHooks = tView.preOrderCheckHooks;\n\n        if (preOrderCheckHooks !== null) {\n          executeCheckHooks(lView, preOrderCheckHooks, null);\n        }\n      } else {\n        const preOrderHooks = tView.preOrderHooks;\n\n        if (preOrderHooks !== null) {\n          executeInitAndCheckHooks(lView, preOrderHooks, 0\n          /* InitPhaseState.OnInitHooksToBeRun */\n          , null);\n        }\n\n        incrementInitPhaseFlags(lView, 0\n        /* InitPhaseState.OnInitHooksToBeRun */\n        );\n      }\n    } // First mark transplanted views that are declared in this lView as needing a refresh at their\n    // insertion points. This is needed to avoid the situation where the template is defined in this\n    // `LView` but its declaration appears after the insertion component.\n\n\n    markTransplantedViewsForRefresh(lView);\n    refreshEmbeddedViews(lView); // Content query results must be refreshed before content hooks are called.\n\n    if (tView.contentQueries !== null) {\n      refreshContentQueries(tView, lView);\n    } // execute content hooks (AfterContentInit, AfterContentChecked)\n    // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n\n\n    if (!isInCheckNoChangesPass) {\n      if (hooksInitPhaseCompleted) {\n        const contentCheckHooks = tView.contentCheckHooks;\n\n        if (contentCheckHooks !== null) {\n          executeCheckHooks(lView, contentCheckHooks);\n        }\n      } else {\n        const contentHooks = tView.contentHooks;\n\n        if (contentHooks !== null) {\n          executeInitAndCheckHooks(lView, contentHooks, 1\n          /* InitPhaseState.AfterContentInitHooksToBeRun */\n          );\n        }\n\n        incrementInitPhaseFlags(lView, 1\n        /* InitPhaseState.AfterContentInitHooksToBeRun */\n        );\n      }\n    }\n\n    processHostBindingOpCodes(tView, lView); // Refresh child component views.\n\n    const components = tView.components;\n\n    if (components !== null) {\n      refreshChildComponents(lView, components);\n    } // View queries must execute after refreshing child components because a template in this view\n    // could be inserted in a child component. If the view query executes before child component\n    // refresh, the template might not yet be inserted.\n\n\n    const viewQuery = tView.viewQuery;\n\n    if (viewQuery !== null) {\n      executeViewQueryFn(2\n      /* RenderFlags.Update */\n      , viewQuery, context);\n    } // execute view hooks (AfterViewInit, AfterViewChecked)\n    // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n\n\n    if (!isInCheckNoChangesPass) {\n      if (hooksInitPhaseCompleted) {\n        const viewCheckHooks = tView.viewCheckHooks;\n\n        if (viewCheckHooks !== null) {\n          executeCheckHooks(lView, viewCheckHooks);\n        }\n      } else {\n        const viewHooks = tView.viewHooks;\n\n        if (viewHooks !== null) {\n          executeInitAndCheckHooks(lView, viewHooks, 2\n          /* InitPhaseState.AfterViewInitHooksToBeRun */\n          );\n        }\n\n        incrementInitPhaseFlags(lView, 2\n        /* InitPhaseState.AfterViewInitHooksToBeRun */\n        );\n      }\n    }\n\n    if (tView.firstUpdatePass === true) {\n      // We need to make sure that we only flip the flag on successful `refreshView` only\n      // Don't do this in `finally` block.\n      // If we did this in `finally` block then an exception could block the execution of styling\n      // instructions which in turn would be unable to insert themselves into the styling linked\n      // list. The result of this would be that if the exception would not be throw on subsequent CD\n      // the styling would be unable to process it data and reflect to the DOM.\n      tView.firstUpdatePass = false;\n    } // Do not reset the dirty state when running in check no changes mode. We don't want components\n    // to behave differently depending on whether check no changes is enabled or not. For example:\n    // Marking an OnPush component as dirty from within the `ngAfterViewInit` hook in order to\n    // refresh a `NgClass` binding should work. If we would reset the dirty state in the check\n    // no changes cycle, the component would be not be dirty for the next update pass. This would\n    // be different in production mode where the component dirty state is not reset.\n\n\n    if (!isInCheckNoChangesPass) {\n      lView[FLAGS] &= ~(32\n      /* LViewFlags.Dirty */\n      | 8\n      /* LViewFlags.FirstLViewPass */\n      );\n    }\n\n    if (lView[FLAGS] & 512\n    /* LViewFlags.RefreshTransplantedView */\n    ) {\n      lView[FLAGS] &= ~512\n      /* LViewFlags.RefreshTransplantedView */\n      ;\n      updateTransplantedViewCount(lView[PARENT], -1);\n    }\n  } finally {\n    leaveView();\n  }\n}\n\nfunction renderComponentOrTemplate(tView, lView, templateFn, context) {\n  const rendererFactory = lView[RENDERER_FACTORY]; // Check no changes mode is a dev only mode used to verify that bindings have not changed\n  // since they were assigned. We do not want to invoke renderer factory functions in that mode\n  // to avoid any possible side-effects.\n\n  const checkNoChangesMode = !!ngDevMode && isInCheckNoChangesMode();\n  const creationModeIsActive = isCreationMode(lView);\n\n  try {\n    if (!checkNoChangesMode && !creationModeIsActive && rendererFactory.begin) {\n      rendererFactory.begin();\n    }\n\n    if (creationModeIsActive) {\n      renderView(tView, lView, context);\n    }\n\n    refreshView(tView, lView, templateFn, context);\n  } finally {\n    if (!checkNoChangesMode && !creationModeIsActive && rendererFactory.end) {\n      rendererFactory.end();\n    }\n  }\n}\n\nfunction executeTemplate(tView, lView, templateFn, rf, context) {\n  const prevSelectedIndex = getSelectedIndex();\n  const isUpdatePhase = rf & 2\n  /* RenderFlags.Update */\n  ;\n\n  try {\n    setSelectedIndex(-1);\n\n    if (isUpdatePhase && lView.length > HEADER_OFFSET) {\n      // When we're updating, inherently select 0 so we don't\n      // have to generate that instruction for most update blocks.\n      selectIndexInternal(tView, lView, HEADER_OFFSET, !!ngDevMode && isInCheckNoChangesMode());\n    }\n\n    const preHookType = isUpdatePhase ? 2\n    /* ProfilerEvent.TemplateUpdateStart */\n    : 0\n    /* ProfilerEvent.TemplateCreateStart */\n    ;\n    profiler(preHookType, context);\n    templateFn(rf, context);\n  } finally {\n    setSelectedIndex(prevSelectedIndex);\n    const postHookType = isUpdatePhase ? 3\n    /* ProfilerEvent.TemplateUpdateEnd */\n    : 1\n    /* ProfilerEvent.TemplateCreateEnd */\n    ;\n    profiler(postHookType, context);\n  }\n} //////////////////////////\n//// Element\n//////////////////////////\n\n\nfunction executeContentQueries(tView, tNode, lView) {\n  if (isContentQueryHost(tNode)) {\n    const start = tNode.directiveStart;\n    const end = tNode.directiveEnd;\n\n    for (let directiveIndex = start; directiveIndex < end; directiveIndex++) {\n      const def = tView.data[directiveIndex];\n\n      if (def.contentQueries) {\n        def.contentQueries(1\n        /* RenderFlags.Create */\n        , lView[directiveIndex], directiveIndex);\n      }\n    }\n  }\n}\n/**\n * Creates directive instances.\n */\n\n\nfunction createDirectivesInstances(tView, lView, tNode) {\n  if (!getBindingsEnabled()) return;\n  instantiateAllDirectives(tView, lView, tNode, getNativeByTNode(tNode, lView));\n\n  if ((tNode.flags & 128\n  /* TNodeFlags.hasHostBindings */\n  ) === 128\n  /* TNodeFlags.hasHostBindings */\n  ) {\n    invokeDirectivesHostBindings(tView, lView, tNode);\n  }\n}\n/**\n * Takes a list of local names and indices and pushes the resolved local variable values\n * to LView in the same order as they are loaded in the template with load().\n */\n\n\nfunction saveResolvedLocalsInData(viewData, tNode, localRefExtractor = getNativeByTNode) {\n  const localNames = tNode.localNames;\n\n  if (localNames !== null) {\n    let localIndex = tNode.index + 1;\n\n    for (let i = 0; i < localNames.length; i += 2) {\n      const index = localNames[i + 1];\n      const value = index === -1 ? localRefExtractor(tNode, viewData) : viewData[index];\n      viewData[localIndex++] = value;\n    }\n  }\n}\n/**\n * Gets TView from a template function or creates a new TView\n * if it doesn't already exist.\n *\n * @param def ComponentDef\n * @returns TView\n */\n\n\nfunction getOrCreateTComponentView(def) {\n  const tView = def.tView; // Create a TView if there isn't one, or recreate it if the first create pass didn't\n  // complete successfully since we can't know for sure whether it's in a usable shape.\n\n  if (tView === null || tView.incompleteFirstPass) {\n    // Declaration node here is null since this function is called when we dynamically create a\n    // component and hence there is no declaration.\n    const declTNode = null;\n    return def.tView = createTView(1\n    /* TViewType.Component */\n    , declTNode, def.template, def.decls, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery, def.schemas, def.consts);\n  }\n\n  return tView;\n}\n/**\n * Creates a TView instance\n *\n * @param type Type of `TView`.\n * @param declTNode Declaration location of this `TView`.\n * @param templateFn Template function\n * @param decls The number of nodes, local refs, and pipes in this template\n * @param directives Registry of directives for this view\n * @param pipes Registry of pipes for this view\n * @param viewQuery View queries for this view\n * @param schemas Schemas for this view\n * @param consts Constants for this view\n */\n\n\nfunction createTView(type, declTNode, templateFn, decls, vars, directives, pipes, viewQuery, schemas, constsOrFactory) {\n  ngDevMode && ngDevMode.tView++;\n  const bindingStartIndex = HEADER_OFFSET + decls; // This length does not yet contain host bindings from child directives because at this point,\n  // we don't know which directives are active on this template. As soon as a directive is matched\n  // that has a host binding, we will update the blueprint with that def's hostVars count.\n\n  const initialViewLength = bindingStartIndex + vars;\n  const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);\n  const consts = typeof constsOrFactory === 'function' ? constsOrFactory() : constsOrFactory;\n  const tView = blueprint[TVIEW] = ngDevMode ? new TViewConstructor(type, // type: TViewType,\n  blueprint, // blueprint: LView,\n  templateFn, // template: ComponentTemplate<{}>|null,\n  null, // queries: TQueries|null\n  viewQuery, // viewQuery: ViewQueriesFunction<{}>|null,\n  declTNode, // declTNode: TNode|null,\n  cloneToTViewData(blueprint).fill(null, bindingStartIndex), // data: TData,\n  bindingStartIndex, // bindingStartIndex: number,\n  initialViewLength, // expandoStartIndex: number,\n  null, // hostBindingOpCodes: HostBindingOpCodes,\n  true, // firstCreatePass: boolean,\n  true, // firstUpdatePass: boolean,\n  false, // staticViewQueries: boolean,\n  false, // staticContentQueries: boolean,\n  null, // preOrderHooks: HookData|null,\n  null, // preOrderCheckHooks: HookData|null,\n  null, // contentHooks: HookData|null,\n  null, // contentCheckHooks: HookData|null,\n  null, // viewHooks: HookData|null,\n  null, // viewCheckHooks: HookData|null,\n  null, // destroyHooks: DestroyHookData|null,\n  null, // cleanup: any[]|null,\n  null, // contentQueries: number[]|null,\n  null, // components: number[]|null,\n  typeof directives === 'function' ? //\n  directives() : //\n  directives, // directiveRegistry: DirectiveDefList|null,\n  typeof pipes === 'function' ? pipes() : pipes, // pipeRegistry: PipeDefList|null,\n  null, // firstChild: TNode|null,\n  schemas, // schemas: SchemaMetadata[]|null,\n  consts, // consts: TConstants|null\n  false, // incompleteFirstPass: boolean\n  decls, // ngDevMode only: decls\n  vars) : {\n    type: type,\n    blueprint: blueprint,\n    template: templateFn,\n    queries: null,\n    viewQuery: viewQuery,\n    declTNode: declTNode,\n    data: blueprint.slice().fill(null, bindingStartIndex),\n    bindingStartIndex: bindingStartIndex,\n    expandoStartIndex: initialViewLength,\n    hostBindingOpCodes: null,\n    firstCreatePass: true,\n    firstUpdatePass: true,\n    staticViewQueries: false,\n    staticContentQueries: false,\n    preOrderHooks: null,\n    preOrderCheckHooks: null,\n    contentHooks: null,\n    contentCheckHooks: null,\n    viewHooks: null,\n    viewCheckHooks: null,\n    destroyHooks: null,\n    cleanup: null,\n    contentQueries: null,\n    components: null,\n    directiveRegistry: typeof directives === 'function' ? directives() : directives,\n    pipeRegistry: typeof pipes === 'function' ? pipes() : pipes,\n    firstChild: null,\n    schemas: schemas,\n    consts: consts,\n    incompleteFirstPass: false\n  };\n\n  if (ngDevMode) {\n    // For performance reasons it is important that the tView retains the same shape during runtime.\n    // (To make sure that all of the code is monomorphic.) For this reason we seal the object to\n    // prevent class transitions.\n    Object.seal(tView);\n  }\n\n  return tView;\n}\n\nfunction createViewBlueprint(bindingStartIndex, initialViewLength) {\n  const blueprint = ngDevMode ? new LViewBlueprint() : [];\n\n  for (let i = 0; i < initialViewLength; i++) {\n    blueprint.push(i < bindingStartIndex ? null : NO_CHANGE);\n  }\n\n  return blueprint;\n}\n\nfunction createError(text, token) {\n  return new Error(`Renderer: ${text} [${stringifyForError(token)}]`);\n}\n\nfunction assertHostNodeExists(rElement, elementOrSelector) {\n  if (!rElement) {\n    if (typeof elementOrSelector === 'string') {\n      throw createError('Host node with selector not found:', elementOrSelector);\n    } else {\n      throw createError('Host node is required:', elementOrSelector);\n    }\n  }\n}\n/**\n * Locates the host native element, used for bootstrapping existing nodes into rendering pipeline.\n *\n * @param rendererFactory Factory function to create renderer instance.\n * @param elementOrSelector Render element or CSS selector to locate the element.\n * @param encapsulation View Encapsulation defined for component that requests host element.\n */\n\n\nfunction locateHostElement(renderer, elementOrSelector, encapsulation) {\n  if (isProceduralRenderer(renderer)) {\n    // When using native Shadow DOM, do not clear host element to allow native slot projection\n    const preserveContent = encapsulation === ViewEncapsulation.ShadowDom;\n    return renderer.selectRootElement(elementOrSelector, preserveContent);\n  }\n\n  let rElement = typeof elementOrSelector === 'string' ? renderer.querySelector(elementOrSelector) : elementOrSelector;\n  ngDevMode && assertHostNodeExists(rElement, elementOrSelector); // Always clear host element's content when Renderer3 is in use. For procedural renderer case we\n  // make it depend on whether ShadowDom encapsulation is used (in which case the content should be\n  // preserved to allow native slot projection). ShadowDom encapsulation requires procedural\n  // renderer, and procedural renderer case is handled above.\n\n  rElement.textContent = '';\n  return rElement;\n}\n/**\n * Saves context for this cleanup function in LView.cleanupInstances.\n *\n * On the first template pass, saves in TView:\n * - Cleanup function\n * - Index of context we just saved in LView.cleanupInstances\n *\n * This function can also be used to store instance specific cleanup fns. In that case the `context`\n * is `null` and the function is store in `LView` (rather than it `TView`).\n */\n\n\nfunction storeCleanupWithContext(tView, lView, context, cleanupFn) {\n  const lCleanup = getOrCreateLViewCleanup(lView);\n\n  if (context === null) {\n    // If context is null that this is instance specific callback. These callbacks can only be\n    // inserted after template shared instances. For this reason in ngDevMode we freeze the TView.\n    if (ngDevMode) {\n      Object.freeze(getOrCreateTViewCleanup(tView));\n    }\n\n    lCleanup.push(cleanupFn);\n  } else {\n    lCleanup.push(context);\n\n    if (tView.firstCreatePass) {\n      getOrCreateTViewCleanup(tView).push(cleanupFn, lCleanup.length - 1);\n    }\n  }\n}\n\nfunction createTNode(tView, tParent, type, index, value, attrs) {\n  ngDevMode && index !== 0 && // 0 are bogus nodes and they are OK. See `createContainerRef` in\n  // `view_engine_compatibility` for additional context.\n  assertGreaterThanOrEqual(index, HEADER_OFFSET, 'TNodes can\\'t be in the LView header.');\n  ngDevMode && assertNotSame(attrs, undefined, '\\'undefined\\' is not valid value for \\'attrs\\'');\n  ngDevMode && ngDevMode.tNode++;\n  ngDevMode && tParent && assertTNodeForTView(tParent, tView);\n  let injectorIndex = tParent ? tParent.injectorIndex : -1;\n  const tNode = ngDevMode ? new TNodeDebug(tView, // tView_: TView\n  type, // type: TNodeType\n  index, // index: number\n  null, // insertBeforeIndex: null|-1|number|number[]\n  injectorIndex, // injectorIndex: number\n  -1, // directiveStart: number\n  -1, // directiveEnd: number\n  -1, // directiveStylingLast: number\n  null, // propertyBindings: number[]|null\n  0, // flags: TNodeFlags\n  0, // providerIndexes: TNodeProviderIndexes\n  value, // value: string|null\n  attrs, // attrs: (string|AttributeMarker|(string|SelectorFlags)[])[]|null\n  null, // mergedAttrs\n  null, // localNames: (string|number)[]|null\n  undefined, // initialInputs: (string[]|null)[]|null|undefined\n  null, // inputs: PropertyAliases|null\n  null, // outputs: PropertyAliases|null\n  null, // tViews: ITView|ITView[]|null\n  null, // next: ITNode|null\n  null, // projectionNext: ITNode|null\n  null, // child: ITNode|null\n  tParent, // parent: TElementNode|TContainerNode|null\n  null, // projection: number|(ITNode|RNode[])[]|null\n  null, // styles: string|null\n  null, // stylesWithoutHost: string|null\n  undefined, // residualStyles: string|null\n  null, // classes: string|null\n  null, // classesWithoutHost: string|null\n  undefined, // residualClasses: string|null\n  0, // classBindings: TStylingRange;\n  0) : {\n    type,\n    index,\n    insertBeforeIndex: null,\n    injectorIndex,\n    directiveStart: -1,\n    directiveEnd: -1,\n    directiveStylingLast: -1,\n    propertyBindings: null,\n    flags: 0,\n    providerIndexes: 0,\n    value: value,\n    attrs: attrs,\n    mergedAttrs: null,\n    localNames: null,\n    initialInputs: undefined,\n    inputs: null,\n    outputs: null,\n    tViews: null,\n    next: null,\n    projectionNext: null,\n    child: null,\n    parent: tParent,\n    projection: null,\n    styles: null,\n    stylesWithoutHost: null,\n    residualStyles: undefined,\n    classes: null,\n    classesWithoutHost: null,\n    residualClasses: undefined,\n    classBindings: 0,\n    styleBindings: 0\n  };\n\n  if (ngDevMode) {\n    // For performance reasons it is important that the tNode retains the same shape during runtime.\n    // (To make sure that all of the code is monomorphic.) For this reason we seal the object to\n    // prevent class transitions.\n    Object.seal(tNode);\n  }\n\n  return tNode;\n}\n\nfunction generatePropertyAliases(inputAliasMap, directiveDefIdx, propStore) {\n  for (let publicName in inputAliasMap) {\n    if (inputAliasMap.hasOwnProperty(publicName)) {\n      propStore = propStore === null ? {} : propStore;\n      const internalName = inputAliasMap[publicName];\n\n      if (propStore.hasOwnProperty(publicName)) {\n        propStore[publicName].push(directiveDefIdx, internalName);\n      } else {\n        propStore[publicName] = [directiveDefIdx, internalName];\n      }\n    }\n  }\n\n  return propStore;\n}\n/**\n * Initializes data structures required to work with directive inputs and outputs.\n * Initialization is done for all directives matched on a given TNode.\n */\n\n\nfunction initializeInputAndOutputAliases(tView, tNode) {\n  ngDevMode && assertFirstCreatePass(tView);\n  const start = tNode.directiveStart;\n  const end = tNode.directiveEnd;\n  const tViewData = tView.data;\n  const tNodeAttrs = tNode.attrs;\n  const inputsFromAttrs = ngDevMode ? new TNodeInitialInputs() : [];\n  let inputsStore = null;\n  let outputsStore = null;\n\n  for (let i = start; i < end; i++) {\n    const directiveDef = tViewData[i];\n    const directiveInputs = directiveDef.inputs; // Do not use unbound attributes as inputs to structural directives, since structural\n    // directive inputs can only be set using microsyntax (e.g. `<div *dir=\"exp\">`).\n    // TODO(FW-1930): microsyntax expressions may also contain unbound/static attributes, which\n    // should be set for inline templates.\n\n    const initialInputs = tNodeAttrs !== null && !isInlineTemplate(tNode) ? generateInitialInputs(directiveInputs, tNodeAttrs) : null;\n    inputsFromAttrs.push(initialInputs);\n    inputsStore = generatePropertyAliases(directiveInputs, i, inputsStore);\n    outputsStore = generatePropertyAliases(directiveDef.outputs, i, outputsStore);\n  }\n\n  if (inputsStore !== null) {\n    if (inputsStore.hasOwnProperty('class')) {\n      tNode.flags |= 16\n      /* TNodeFlags.hasClassInput */\n      ;\n    }\n\n    if (inputsStore.hasOwnProperty('style')) {\n      tNode.flags |= 32\n      /* TNodeFlags.hasStyleInput */\n      ;\n    }\n  }\n\n  tNode.initialInputs = inputsFromAttrs;\n  tNode.inputs = inputsStore;\n  tNode.outputs = outputsStore;\n}\n/**\n * Mapping between attributes names that don't correspond to their element property names.\n *\n * Performance note: this function is written as a series of if checks (instead of, say, a property\n * object lookup) for performance reasons - the series of `if` checks seems to be the fastest way of\n * mapping property names. Do NOT change without benchmarking.\n *\n * Note: this mapping has to be kept in sync with the equally named mapping in the template\n * type-checking machinery of ngtsc.\n */\n\n\nfunction mapPropName(name) {\n  if (name === 'class') return 'className';\n  if (name === 'for') return 'htmlFor';\n  if (name === 'formaction') return 'formAction';\n  if (name === 'innerHtml') return 'innerHTML';\n  if (name === 'readonly') return 'readOnly';\n  if (name === 'tabindex') return 'tabIndex';\n  return name;\n}\n\nfunction elementPropertyInternal(tView, tNode, lView, propName, value, renderer, sanitizer, nativeOnly) {\n  ngDevMode && assertNotSame(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');\n  const element = getNativeByTNode(tNode, lView);\n  let inputData = tNode.inputs;\n  let dataValue;\n\n  if (!nativeOnly && inputData != null && (dataValue = inputData[propName])) {\n    setInputsForProperty(tView, lView, dataValue, propName, value);\n    if (isComponentHost(tNode)) markDirtyIfOnPush(lView, tNode.index);\n\n    if (ngDevMode) {\n      setNgReflectProperties(lView, element, tNode.type, dataValue, value);\n    }\n  } else if (tNode.type & 3\n  /* TNodeType.AnyRNode */\n  ) {\n    propName = mapPropName(propName);\n\n    if (ngDevMode) {\n      validateAgainstEventProperties(propName);\n\n      if (!isPropertyValid(element, propName, tNode.value, tView.schemas)) {\n        handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);\n      }\n\n      ngDevMode.rendererSetProperty++;\n    } // It is assumed that the sanitizer is only added when the compiler determines that the\n    // property is risky, so sanitization can be done without further checks.\n\n\n    value = sanitizer != null ? sanitizer(value, tNode.value || '', propName) : value;\n\n    if (isProceduralRenderer(renderer)) {\n      renderer.setProperty(element, propName, value);\n    } else if (!isAnimationProp(propName)) {\n      element.setProperty ? element.setProperty(propName, value) : element[propName] = value;\n    }\n  } else if (tNode.type & 12\n  /* TNodeType.AnyContainer */\n  ) {\n    // If the node is a container and the property didn't\n    // match any of the inputs or schemas we should throw.\n    if (ngDevMode && !matchingSchemas(tView.schemas, tNode.value)) {\n      handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);\n    }\n  }\n}\n/** If node is an OnPush component, marks its LView dirty. */\n\n\nfunction markDirtyIfOnPush(lView, viewIndex) {\n  ngDevMode && assertLView(lView);\n  const childComponentLView = getComponentLViewByIndex(viewIndex, lView);\n\n  if (!(childComponentLView[FLAGS] & 16\n  /* LViewFlags.CheckAlways */\n  )) {\n    childComponentLView[FLAGS] |= 32\n    /* LViewFlags.Dirty */\n    ;\n  }\n}\n\nfunction setNgReflectProperty(lView, element, type, attrName, value) {\n  const renderer = lView[RENDERER];\n  attrName = normalizeDebugBindingName(attrName);\n  const debugValue = normalizeDebugBindingValue(value);\n\n  if (type & 3\n  /* TNodeType.AnyRNode */\n  ) {\n    if (value == null) {\n      isProceduralRenderer(renderer) ? renderer.removeAttribute(element, attrName) : element.removeAttribute(attrName);\n    } else {\n      isProceduralRenderer(renderer) ? renderer.setAttribute(element, attrName, debugValue) : element.setAttribute(attrName, debugValue);\n    }\n  } else {\n    const textContent = escapeCommentText(`bindings=${JSON.stringify({\n      [attrName]: debugValue\n    }, null, 2)}`);\n\n    if (isProceduralRenderer(renderer)) {\n      renderer.setValue(element, textContent);\n    } else {\n      element.textContent = textContent;\n    }\n  }\n}\n\nfunction setNgReflectProperties(lView, element, type, dataValue, value) {\n  if (type & (3\n  /* TNodeType.AnyRNode */\n  | 4\n  /* TNodeType.Container */\n  )) {\n    /**\n     * dataValue is an array containing runtime input or output names for the directives:\n     * i+0: directive instance index\n     * i+1: privateName\n     *\n     * e.g. [0, 'change', 'change-minified']\n     * we want to set the reflected property with the privateName: dataValue[i+1]\n     */\n    for (let i = 0; i < dataValue.length; i += 2) {\n      setNgReflectProperty(lView, element, type, dataValue[i + 1], value);\n    }\n  }\n}\n/**\n * Instantiate a root component.\n */\n\n\nfunction instantiateRootComponent(tView, lView, def) {\n  const rootTNode = getCurrentTNode();\n\n  if (tView.firstCreatePass) {\n    if (def.providersResolver) def.providersResolver(def);\n    const directiveIndex = allocExpando(tView, lView, 1, null);\n    ngDevMode && assertEqual(directiveIndex, rootTNode.directiveStart, 'Because this is a root component the allocated expando should match the TNode component.');\n    configureViewWithDirective(tView, rootTNode, lView, directiveIndex, def);\n  }\n\n  const directive = getNodeInjectable(lView, tView, rootTNode.directiveStart, rootTNode);\n  attachPatchData(directive, lView);\n  const native = getNativeByTNode(rootTNode, lView);\n\n  if (native) {\n    attachPatchData(native, lView);\n  }\n\n  return directive;\n}\n/**\n * Resolve the matched directives on a node.\n */\n\n\nfunction resolveDirectives(tView, lView, tNode, localRefs) {\n  // Please make sure to have explicit type for `exportsMap`. Inferred type triggers bug in\n  // tsickle.\n  ngDevMode && assertFirstCreatePass(tView);\n  let hasDirectives = false;\n\n  if (getBindingsEnabled()) {\n    const directiveDefs = findDirectiveDefMatches(tView, lView, tNode);\n    const exportsMap = localRefs === null ? null : {\n      '': -1\n    };\n\n    if (directiveDefs !== null) {\n      hasDirectives = true;\n      initTNodeFlags(tNode, tView.data.length, directiveDefs.length); // When the same token is provided by several directives on the same node, some rules apply in\n      // the viewEngine:\n      // - viewProviders have priority over providers\n      // - the last directive in NgModule.declarations has priority over the previous one\n      // So to match these rules, the order in which providers are added in the arrays is very\n      // important.\n\n      for (let i = 0; i < directiveDefs.length; i++) {\n        const def = directiveDefs[i];\n        if (def.providersResolver) def.providersResolver(def);\n      }\n\n      let preOrderHooksFound = false;\n      let preOrderCheckHooksFound = false;\n      let directiveIdx = allocExpando(tView, lView, directiveDefs.length, null);\n      ngDevMode && assertSame(directiveIdx, tNode.directiveStart, 'TNode.directiveStart should point to just allocated space');\n\n      for (let i = 0; i < directiveDefs.length; i++) {\n        const def = directiveDefs[i]; // Merge the attrs in the order of matches. This assumes that the first directive is the\n        // component itself, so that the component has the least priority.\n\n        tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);\n        configureViewWithDirective(tView, tNode, lView, directiveIdx, def);\n        saveNameToExportMap(directiveIdx, def, exportsMap);\n        if (def.contentQueries !== null) tNode.flags |= 8\n        /* TNodeFlags.hasContentQuery */\n        ;\n        if (def.hostBindings !== null || def.hostAttrs !== null || def.hostVars !== 0) tNode.flags |= 128\n        /* TNodeFlags.hasHostBindings */\n        ;\n        const lifeCycleHooks = def.type.prototype; // Only push a node index into the preOrderHooks array if this is the first\n        // pre-order hook found on this node.\n\n        if (!preOrderHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngOnInit || lifeCycleHooks.ngDoCheck)) {\n          // We will push the actual hook function into this array later during dir instantiation.\n          // We cannot do it now because we must ensure hooks are registered in the same\n          // order that directives are created (i.e. injection order).\n          (tView.preOrderHooks || (tView.preOrderHooks = [])).push(tNode.index);\n          preOrderHooksFound = true;\n        }\n\n        if (!preOrderCheckHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngDoCheck)) {\n          (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(tNode.index);\n          preOrderCheckHooksFound = true;\n        }\n\n        directiveIdx++;\n      }\n\n      initializeInputAndOutputAliases(tView, tNode);\n    }\n\n    if (exportsMap) cacheMatchingLocalNames(tNode, localRefs, exportsMap);\n  } // Merge the template attrs last so that they have the highest priority.\n\n\n  tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);\n  return hasDirectives;\n}\n/**\n * Add `hostBindings` to the `TView.hostBindingOpCodes`.\n *\n * @param tView `TView` to which the `hostBindings` should be added.\n * @param tNode `TNode` the element which contains the directive\n * @param lView `LView` current `LView`\n * @param directiveIdx Directive index in view.\n * @param directiveVarsIdx Where will the directive's vars be stored\n * @param def `ComponentDef`/`DirectiveDef`, which contains the `hostVars`/`hostBindings` to add.\n */\n\n\nfunction registerHostBindingOpCodes(tView, tNode, lView, directiveIdx, directiveVarsIdx, def) {\n  ngDevMode && assertFirstCreatePass(tView);\n  const hostBindings = def.hostBindings;\n\n  if (hostBindings) {\n    let hostBindingOpCodes = tView.hostBindingOpCodes;\n\n    if (hostBindingOpCodes === null) {\n      hostBindingOpCodes = tView.hostBindingOpCodes = [];\n    }\n\n    const elementIndx = ~tNode.index;\n\n    if (lastSelectedElementIdx(hostBindingOpCodes) != elementIndx) {\n      // Conditionally add select element so that we are more efficient in execution.\n      // NOTE: this is strictly not necessary and it trades code size for runtime perf.\n      // (We could just always add it.)\n      hostBindingOpCodes.push(elementIndx);\n    }\n\n    hostBindingOpCodes.push(directiveIdx, directiveVarsIdx, hostBindings);\n  }\n}\n/**\n * Returns the last selected element index in the `HostBindingOpCodes`\n *\n * For perf reasons we don't need to update the selected element index in `HostBindingOpCodes` only\n * if it changes. This method returns the last index (or '0' if not found.)\n *\n * Selected element index are only the ones which are negative.\n */\n\n\nfunction lastSelectedElementIdx(hostBindingOpCodes) {\n  let i = hostBindingOpCodes.length;\n\n  while (i > 0) {\n    const value = hostBindingOpCodes[--i];\n\n    if (typeof value === 'number' && value < 0) {\n      return value;\n    }\n  }\n\n  return 0;\n}\n/**\n * Instantiate all the directives that were previously resolved on the current node.\n */\n\n\nfunction instantiateAllDirectives(tView, lView, tNode, native) {\n  const start = tNode.directiveStart;\n  const end = tNode.directiveEnd;\n\n  if (!tView.firstCreatePass) {\n    getOrCreateNodeInjectorForNode(tNode, lView);\n  }\n\n  attachPatchData(native, lView);\n  const initialInputs = tNode.initialInputs;\n\n  for (let i = start; i < end; i++) {\n    const def = tView.data[i];\n    const isComponent = isComponentDef(def);\n\n    if (isComponent) {\n      ngDevMode && assertTNodeType(tNode, 3\n      /* TNodeType.AnyRNode */\n      );\n      addComponentLogic(lView, tNode, def);\n    }\n\n    const directive = getNodeInjectable(lView, tView, i, tNode);\n    attachPatchData(directive, lView);\n\n    if (initialInputs !== null) {\n      setInputsFromAttrs(lView, i - start, directive, def, tNode, initialInputs);\n    }\n\n    if (isComponent) {\n      const componentView = getComponentLViewByIndex(tNode.index, lView);\n      componentView[CONTEXT] = directive;\n    }\n  }\n}\n\nfunction invokeDirectivesHostBindings(tView, lView, tNode) {\n  const start = tNode.directiveStart;\n  const end = tNode.directiveEnd;\n  const elementIndex = tNode.index;\n  const currentDirectiveIndex = getCurrentDirectiveIndex();\n\n  try {\n    setSelectedIndex(elementIndex);\n\n    for (let dirIndex = start; dirIndex < end; dirIndex++) {\n      const def = tView.data[dirIndex];\n      const directive = lView[dirIndex];\n      setCurrentDirectiveIndex(dirIndex);\n\n      if (def.hostBindings !== null || def.hostVars !== 0 || def.hostAttrs !== null) {\n        invokeHostBindingsInCreationMode(def, directive);\n      }\n    }\n  } finally {\n    setSelectedIndex(-1);\n    setCurrentDirectiveIndex(currentDirectiveIndex);\n  }\n}\n/**\n * Invoke the host bindings in creation mode.\n *\n * @param def `DirectiveDef` which may contain the `hostBindings` function.\n * @param directive Instance of directive.\n */\n\n\nfunction invokeHostBindingsInCreationMode(def, directive) {\n  if (def.hostBindings !== null) {\n    def.hostBindings(1\n    /* RenderFlags.Create */\n    , directive);\n  }\n}\n/**\n * Matches the current node against all available selectors.\n * If a component is matched (at most one), it is returned in first position in the array.\n */\n\n\nfunction findDirectiveDefMatches(tView, viewData, tNode) {\n  ngDevMode && assertFirstCreatePass(tView);\n  ngDevMode && assertTNodeType(tNode, 3\n  /* TNodeType.AnyRNode */\n  | 12\n  /* TNodeType.AnyContainer */\n  );\n  const registry = tView.directiveRegistry;\n  let matches = null;\n\n  if (registry) {\n    for (let i = 0; i < registry.length; i++) {\n      const def = registry[i];\n\n      if (isNodeMatchingSelectorList(tNode, def.selectors,\n      /* isProjectionMode */\n      false)) {\n        matches || (matches = ngDevMode ? new MatchesArray() : []);\n        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, viewData), tView, def.type);\n\n        if (isComponentDef(def)) {\n          if (ngDevMode) {\n            assertTNodeType(tNode, 2\n            /* TNodeType.Element */\n            , `\"${tNode.value}\" tags cannot be used as component hosts. ` + `Please use a different tag to activate the ${stringify(def.type)} component.`);\n\n            if (tNode.flags & 2\n            /* TNodeFlags.isComponentHost */\n            ) {\n              // If another component has been matched previously, it's the first element in the\n              // `matches` array, see how we store components/directives in `matches` below.\n              throwMultipleComponentError(tNode, matches[0].type, def.type);\n            }\n          }\n\n          markAsComponentHost(tView, tNode); // The component is always stored first with directives after.\n\n          matches.unshift(def);\n        } else {\n          matches.push(def);\n        }\n      }\n    }\n  }\n\n  return matches;\n}\n/**\n * Marks a given TNode as a component's host. This consists of:\n * - setting appropriate TNode flags;\n * - storing index of component's host element so it will be queued for view refresh during CD.\n */\n\n\nfunction markAsComponentHost(tView, hostTNode) {\n  ngDevMode && assertFirstCreatePass(tView);\n  hostTNode.flags |= 2\n  /* TNodeFlags.isComponentHost */\n  ;\n  (tView.components || (tView.components = ngDevMode ? new TViewComponents() : [])).push(hostTNode.index);\n}\n/** Caches local names and their matching directive indices for query and template lookups. */\n\n\nfunction cacheMatchingLocalNames(tNode, localRefs, exportsMap) {\n  if (localRefs) {\n    const localNames = tNode.localNames = ngDevMode ? new TNodeLocalNames() : []; // Local names must be stored in tNode in the same order that localRefs are defined\n    // in the template to ensure the data is loaded in the same slots as their refs\n    // in the template (for template queries).\n\n    for (let i = 0; i < localRefs.length; i += 2) {\n      const index = exportsMap[localRefs[i + 1]];\n      if (index == null) throw new RuntimeError(-301\n      /* RuntimeErrorCode.EXPORT_NOT_FOUND */\n      , ngDevMode && `Export of name '${localRefs[i + 1]}' not found!`);\n      localNames.push(localRefs[i], index);\n    }\n  }\n}\n/**\n * Builds up an export map as directives are created, so local refs can be quickly mapped\n * to their directive instances.\n */\n\n\nfunction saveNameToExportMap(directiveIdx, def, exportsMap) {\n  if (exportsMap) {\n    if (def.exportAs) {\n      for (let i = 0; i < def.exportAs.length; i++) {\n        exportsMap[def.exportAs[i]] = directiveIdx;\n      }\n    }\n\n    if (isComponentDef(def)) exportsMap[''] = directiveIdx;\n  }\n}\n/**\n * Initializes the flags on the current node, setting all indices to the initial index,\n * the directive count to 0, and adding the isComponent flag.\n * @param index the initial index\n */\n\n\nfunction initTNodeFlags(tNode, index, numberOfDirectives) {\n  ngDevMode && assertNotEqual(numberOfDirectives, tNode.directiveEnd - tNode.directiveStart, 'Reached the max number of directives');\n  tNode.flags |= 1\n  /* TNodeFlags.isDirectiveHost */\n  ; // When the first directive is created on a node, save the index\n\n  tNode.directiveStart = index;\n  tNode.directiveEnd = index + numberOfDirectives;\n  tNode.providerIndexes = index;\n}\n/**\n * Setup directive for instantiation.\n *\n * We need to create a `NodeInjectorFactory` which is then inserted in both the `Blueprint` as well\n * as `LView`. `TView` gets the `DirectiveDef`.\n *\n * @param tView `TView`\n * @param tNode `TNode`\n * @param lView `LView`\n * @param directiveIndex Index where the directive will be stored in the Expando.\n * @param def `DirectiveDef`\n */\n\n\nfunction configureViewWithDirective(tView, tNode, lView, directiveIndex, def) {\n  ngDevMode && assertGreaterThanOrEqual(directiveIndex, HEADER_OFFSET, 'Must be in Expando section');\n  tView.data[directiveIndex] = def;\n  const directiveFactory = def.factory || (def.factory = getFactoryDef(def.type, true)); // Even though `directiveFactory` will already be using `ɵɵdirectiveInject` in its generated code,\n  // we also want to support `inject()` directly from the directive constructor context so we set\n  // `ɵɵdirectiveInject` as the inject implementation here too.\n\n  const nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, isComponentDef(def), ɵɵdirectiveInject);\n  tView.blueprint[directiveIndex] = nodeInjectorFactory;\n  lView[directiveIndex] = nodeInjectorFactory;\n  registerHostBindingOpCodes(tView, tNode, lView, directiveIndex, allocExpando(tView, lView, def.hostVars, NO_CHANGE), def);\n}\n\nfunction addComponentLogic(lView, hostTNode, def) {\n  const native = getNativeByTNode(hostTNode, lView);\n  const tView = getOrCreateTComponentView(def); // Only component views should be added to the view tree directly. Embedded views are\n  // accessed through their containers because they may be removed / re-added later.\n\n  const rendererFactory = lView[RENDERER_FACTORY];\n  const componentView = addToViewTree(lView, createLView(lView, tView, null, def.onPush ? 32\n  /* LViewFlags.Dirty */\n  : 16\n  /* LViewFlags.CheckAlways */\n  , native, hostTNode, rendererFactory, rendererFactory.createRenderer(native, def), null, null, null)); // Component view will always be created before any injected LContainers,\n  // so this is a regular element, wrap it with the component view\n\n  lView[hostTNode.index] = componentView;\n}\n\nfunction elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace) {\n  if (ngDevMode) {\n    assertNotSame(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');\n    validateAgainstEventAttributes(name);\n    assertTNodeType(tNode, 2\n    /* TNodeType.Element */\n    , `Attempted to set attribute \\`${name}\\` on a container node. ` + `Host bindings are not valid on ng-container or ng-template.`);\n  }\n\n  const element = getNativeByTNode(tNode, lView);\n  setElementAttribute(lView[RENDERER], element, namespace, tNode.value, name, value, sanitizer);\n}\n\nfunction setElementAttribute(renderer, element, namespace, tagName, name, value, sanitizer) {\n  if (value == null) {\n    ngDevMode && ngDevMode.rendererRemoveAttribute++;\n    isProceduralRenderer(renderer) ? renderer.removeAttribute(element, name, namespace) : element.removeAttribute(name);\n  } else {\n    ngDevMode && ngDevMode.rendererSetAttribute++;\n    const strValue = sanitizer == null ? renderStringify(value) : sanitizer(value, tagName || '', name);\n\n    if (isProceduralRenderer(renderer)) {\n      renderer.setAttribute(element, name, strValue, namespace);\n    } else {\n      namespace ? element.setAttributeNS(namespace, name, strValue) : element.setAttribute(name, strValue);\n    }\n  }\n}\n/**\n * Sets initial input properties on directive instances from attribute data\n *\n * @param lView Current LView that is being processed.\n * @param directiveIndex Index of the directive in directives array\n * @param instance Instance of the directive on which to set the initial inputs\n * @param def The directive def that contains the list of inputs\n * @param tNode The static data for this node\n */\n\n\nfunction setInputsFromAttrs(lView, directiveIndex, instance, def, tNode, initialInputData) {\n  const initialInputs = initialInputData[directiveIndex];\n\n  if (initialInputs !== null) {\n    const setInput = def.setInput;\n\n    for (let i = 0; i < initialInputs.length;) {\n      const publicName = initialInputs[i++];\n      const privateName = initialInputs[i++];\n      const value = initialInputs[i++];\n\n      if (setInput !== null) {\n        def.setInput(instance, value, publicName, privateName);\n      } else {\n        instance[privateName] = value;\n      }\n\n      if (ngDevMode) {\n        const nativeElement = getNativeByTNode(tNode, lView);\n        setNgReflectProperty(lView, nativeElement, tNode.type, privateName, value);\n      }\n    }\n  }\n}\n/**\n * Generates initialInputData for a node and stores it in the template's static storage\n * so subsequent template invocations don't have to recalculate it.\n *\n * initialInputData is an array containing values that need to be set as input properties\n * for directives on this node, but only once on creation. We need this array to support\n * the case where you set an @Input property of a directive using attribute-like syntax.\n * e.g. if you have a `name` @Input, you can set it once like this:\n *\n * <my-component name=\"Bess\"></my-component>\n *\n * @param inputs The list of inputs from the directive def\n * @param attrs The static attrs on this node\n */\n\n\nfunction generateInitialInputs(inputs, attrs) {\n  let inputsToStore = null;\n  let i = 0;\n\n  while (i < attrs.length) {\n    const attrName = attrs[i];\n\n    if (attrName === 0\n    /* AttributeMarker.NamespaceURI */\n    ) {\n      // We do not allow inputs on namespaced attributes.\n      i += 4;\n      continue;\n    } else if (attrName === 5\n    /* AttributeMarker.ProjectAs */\n    ) {\n      // Skip over the `ngProjectAs` value.\n      i += 2;\n      continue;\n    } // If we hit any other attribute markers, we're done anyway. None of those are valid inputs.\n\n\n    if (typeof attrName === 'number') break;\n\n    if (inputs.hasOwnProperty(attrName)) {\n      if (inputsToStore === null) inputsToStore = [];\n      inputsToStore.push(attrName, inputs[attrName], attrs[i + 1]);\n    }\n\n    i += 2;\n  }\n\n  return inputsToStore;\n} //////////////////////////\n//// ViewContainer & View\n//////////////////////////\n// Not sure why I need to do `any` here but TS complains later.\n\n\nconst LContainerArray = class LContainer extends Array {};\n/**\n * Creates a LContainer, either from a container instruction, or for a ViewContainerRef.\n *\n * @param hostNative The host element for the LContainer\n * @param hostTNode The host TNode for the LContainer\n * @param currentView The parent view of the LContainer\n * @param native The native comment element\n * @param isForViewContainerRef Optional a flag indicating the ViewContainerRef case\n * @returns LContainer\n */\n\nfunction createLContainer(hostNative, currentView, native, tNode) {\n  ngDevMode && assertLView(currentView);\n  ngDevMode && !isProceduralRenderer(currentView[RENDERER]) && assertDomNode(native); // https://jsperf.com/array-literal-vs-new-array-really\n\n  const lContainer = new (ngDevMode ? LContainerArray : Array)(hostNative, // host native\n  true, // Boolean `true` in this position signifies that this is an `LContainer`\n  false, // has transplanted views\n  currentView, // parent\n  null, // next\n  0, // transplanted views to refresh count\n  tNode, // t_host\n  native, // native,\n  null, // view refs\n  null);\n  ngDevMode && assertEqual(lContainer.length, CONTAINER_HEADER_OFFSET, 'Should allocate correct number of slots for LContainer header.');\n  ngDevMode && attachLContainerDebug(lContainer);\n  return lContainer;\n}\n/**\n * Goes over embedded views (ones created through ViewContainerRef APIs) and refreshes\n * them by executing an associated template function.\n */\n\n\nfunction refreshEmbeddedViews(lView) {\n  for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {\n    for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n      const embeddedLView = lContainer[i];\n      const embeddedTView = embeddedLView[TVIEW];\n      ngDevMode && assertDefined(embeddedTView, 'TView must be allocated');\n\n      if (viewAttachedToChangeDetector(embeddedLView)) {\n        refreshView(embeddedTView, embeddedLView, embeddedTView.template, embeddedLView[CONTEXT]);\n      }\n    }\n  }\n}\n/**\n * Mark transplanted views as needing to be refreshed at their insertion points.\n *\n * @param lView The `LView` that may have transplanted views.\n */\n\n\nfunction markTransplantedViewsForRefresh(lView) {\n  for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {\n    if (!lContainer[HAS_TRANSPLANTED_VIEWS]) continue;\n    const movedViews = lContainer[MOVED_VIEWS];\n    ngDevMode && assertDefined(movedViews, 'Transplanted View flags set but missing MOVED_VIEWS');\n\n    for (let i = 0; i < movedViews.length; i++) {\n      const movedLView = movedViews[i];\n      const insertionLContainer = movedLView[PARENT];\n      ngDevMode && assertLContainer(insertionLContainer); // We don't want to increment the counter if the moved LView was already marked for\n      // refresh.\n\n      if ((movedLView[FLAGS] & 512\n      /* LViewFlags.RefreshTransplantedView */\n      ) === 0) {\n        updateTransplantedViewCount(insertionLContainer, 1);\n      } // Note, it is possible that the `movedViews` is tracking views that are transplanted *and*\n      // those that aren't (declaration component === insertion component). In the latter case,\n      // it's fine to add the flag, as we will clear it immediately in\n      // `refreshEmbeddedViews` for the view currently being refreshed.\n\n\n      movedLView[FLAGS] |= 512\n      /* LViewFlags.RefreshTransplantedView */\n      ;\n    }\n  }\n} /////////////\n\n/**\n * Refreshes components by entering the component view and processing its bindings, queries, etc.\n *\n * @param componentHostIdx  Element index in LView[] (adjusted for HEADER_OFFSET)\n */\n\n\nfunction refreshComponent(hostLView, componentHostIdx) {\n  ngDevMode && assertEqual(isCreationMode(hostLView), false, 'Should be run in update mode');\n  const componentView = getComponentLViewByIndex(componentHostIdx, hostLView); // Only attached components that are CheckAlways or OnPush and dirty should be refreshed\n\n  if (viewAttachedToChangeDetector(componentView)) {\n    const tView = componentView[TVIEW];\n\n    if (componentView[FLAGS] & (16\n    /* LViewFlags.CheckAlways */\n    | 32\n    /* LViewFlags.Dirty */\n    )) {\n      refreshView(tView, componentView, tView.template, componentView[CONTEXT]);\n    } else if (componentView[TRANSPLANTED_VIEWS_TO_REFRESH] > 0) {\n      // Only attached components that are CheckAlways or OnPush and dirty should be refreshed\n      refreshContainsDirtyView(componentView);\n    }\n  }\n}\n/**\n * Refreshes all transplanted views marked with `LViewFlags.RefreshTransplantedView` that are\n * children or descendants of the given lView.\n *\n * @param lView The lView which contains descendant transplanted views that need to be refreshed.\n */\n\n\nfunction refreshContainsDirtyView(lView) {\n  for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {\n    for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n      const embeddedLView = lContainer[i];\n\n      if (embeddedLView[FLAGS] & 512\n      /* LViewFlags.RefreshTransplantedView */\n      ) {\n        const embeddedTView = embeddedLView[TVIEW];\n        ngDevMode && assertDefined(embeddedTView, 'TView must be allocated');\n        refreshView(embeddedTView, embeddedLView, embeddedTView.template, embeddedLView[CONTEXT]);\n      } else if (embeddedLView[TRANSPLANTED_VIEWS_TO_REFRESH] > 0) {\n        refreshContainsDirtyView(embeddedLView);\n      }\n    }\n  }\n\n  const tView = lView[TVIEW]; // Refresh child component views.\n\n  const components = tView.components;\n\n  if (components !== null) {\n    for (let i = 0; i < components.length; i++) {\n      const componentView = getComponentLViewByIndex(components[i], lView); // Only attached components that are CheckAlways or OnPush and dirty should be refreshed\n\n      if (viewAttachedToChangeDetector(componentView) && componentView[TRANSPLANTED_VIEWS_TO_REFRESH] > 0) {\n        refreshContainsDirtyView(componentView);\n      }\n    }\n  }\n}\n\nfunction renderComponent$1(hostLView, componentHostIdx) {\n  ngDevMode && assertEqual(isCreationMode(hostLView), true, 'Should be run in creation mode');\n  const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);\n  const componentTView = componentView[TVIEW];\n  syncViewWithBlueprint(componentTView, componentView);\n  renderView(componentTView, componentView, componentView[CONTEXT]);\n}\n/**\n * Syncs an LView instance with its blueprint if they have gotten out of sync.\n *\n * Typically, blueprints and their view instances should always be in sync, so the loop here\n * will be skipped. However, consider this case of two components side-by-side:\n *\n * App template:\n * ```\n * <comp></comp>\n * <comp></comp>\n * ```\n *\n * The following will happen:\n * 1. App template begins processing.\n * 2. First <comp> is matched as a component and its LView is created.\n * 3. Second <comp> is matched as a component and its LView is created.\n * 4. App template completes processing, so it's time to check child templates.\n * 5. First <comp> template is checked. It has a directive, so its def is pushed to blueprint.\n * 6. Second <comp> template is checked. Its blueprint has been updated by the first\n * <comp> template, but its LView was created before this update, so it is out of sync.\n *\n * Note that embedded views inside ngFor loops will never be out of sync because these views\n * are processed as soon as they are created.\n *\n * @param tView The `TView` that contains the blueprint for syncing\n * @param lView The view to sync\n */\n\n\nfunction syncViewWithBlueprint(tView, lView) {\n  for (let i = lView.length; i < tView.blueprint.length; i++) {\n    lView.push(tView.blueprint[i]);\n  }\n}\n/**\n * Adds LView or LContainer to the end of the current view tree.\n *\n * This structure will be used to traverse through nested views to remove listeners\n * and call onDestroy callbacks.\n *\n * @param lView The view where LView or LContainer should be added\n * @param adjustedHostIndex Index of the view's host node in LView[], adjusted for header\n * @param lViewOrLContainer The LView or LContainer to add to the view tree\n * @returns The state passed in\n */\n\n\nfunction addToViewTree(lView, lViewOrLContainer) {\n  // TODO(benlesh/misko): This implementation is incorrect, because it always adds the LContainer\n  // to the end of the queue, which means if the developer retrieves the LContainers from RNodes out\n  // of order, the change detection will run out of order, as the act of retrieving the the\n  // LContainer from the RNode is what adds it to the queue.\n  if (lView[CHILD_HEAD]) {\n    lView[CHILD_TAIL][NEXT] = lViewOrLContainer;\n  } else {\n    lView[CHILD_HEAD] = lViewOrLContainer;\n  }\n\n  lView[CHILD_TAIL] = lViewOrLContainer;\n  return lViewOrLContainer;\n} ///////////////////////////////\n//// Change detection\n///////////////////////////////\n\n/**\n * Marks current view and all ancestors dirty.\n *\n * Returns the root view because it is found as a byproduct of marking the view tree\n * dirty, and can be used by methods that consume markViewDirty() to easily schedule\n * change detection. Otherwise, such methods would need to traverse up the view tree\n * an additional time to get the root view and schedule a tick on it.\n *\n * @param lView The starting LView to mark dirty\n * @returns the root LView\n */\n\n\nfunction markViewDirty(lView) {\n  while (lView) {\n    lView[FLAGS] |= 32\n    /* LViewFlags.Dirty */\n    ;\n    const parent = getLViewParent(lView); // Stop traversing up as soon as you find a root view that wasn't attached to any container\n\n    if (isRootView(lView) && !parent) {\n      return lView;\n    } // continue otherwise\n\n\n    lView = parent;\n  }\n\n  return null;\n}\n/**\n * Used to schedule change detection on the whole application.\n *\n * Unlike `tick`, `scheduleTick` coalesces multiple calls into one change detection run.\n * It is usually called indirectly by calling `markDirty` when the view needs to be\n * re-rendered.\n *\n * Typically `scheduleTick` uses `requestAnimationFrame` to coalesce multiple\n * `scheduleTick` requests. The scheduling function can be overridden in\n * `renderComponent`'s `scheduler` option.\n */\n\n\nfunction scheduleTick(rootContext, flags) {\n  const nothingScheduled = rootContext.flags === 0\n  /* RootContextFlags.Empty */\n  ;\n\n  if (nothingScheduled && rootContext.clean == _CLEAN_PROMISE) {\n    // https://github.com/angular/angular/issues/39296\n    // should only attach the flags when really scheduling a tick\n    rootContext.flags |= flags;\n    let res;\n    rootContext.clean = new Promise(r => res = r);\n    rootContext.scheduler(() => {\n      if (rootContext.flags & 1\n      /* RootContextFlags.DetectChanges */\n      ) {\n        rootContext.flags &= ~1\n        /* RootContextFlags.DetectChanges */\n        ;\n        tickRootContext(rootContext);\n      }\n\n      if (rootContext.flags & 2\n      /* RootContextFlags.FlushPlayers */\n      ) {\n        rootContext.flags &= ~2\n        /* RootContextFlags.FlushPlayers */\n        ;\n        const playerHandler = rootContext.playerHandler;\n\n        if (playerHandler) {\n          playerHandler.flushPlayers();\n        }\n      }\n\n      rootContext.clean = _CLEAN_PROMISE;\n      res(null);\n    });\n  }\n}\n\nfunction tickRootContext(rootContext) {\n  for (let i = 0; i < rootContext.components.length; i++) {\n    const rootComponent = rootContext.components[i];\n    const lView = readPatchedLView(rootComponent); // We might not have an `LView` if the component was destroyed.\n\n    if (lView !== null) {\n      const tView = lView[TVIEW];\n      renderComponentOrTemplate(tView, lView, tView.template, rootComponent);\n    }\n  }\n}\n\nfunction detectChangesInternal(tView, lView, context) {\n  const rendererFactory = lView[RENDERER_FACTORY];\n  if (rendererFactory.begin) rendererFactory.begin();\n\n  try {\n    refreshView(tView, lView, tView.template, context);\n  } catch (error) {\n    handleError(lView, error);\n    throw error;\n  } finally {\n    if (rendererFactory.end) rendererFactory.end();\n  }\n}\n/**\n * Synchronously perform change detection on a root view and its components.\n *\n * @param lView The view which the change detection should be performed on.\n */\n\n\nfunction detectChangesInRootView(lView) {\n  tickRootContext(lView[CONTEXT]);\n}\n\nfunction checkNoChangesInternal(tView, view, context) {\n  setIsInCheckNoChangesMode(true);\n\n  try {\n    detectChangesInternal(tView, view, context);\n  } finally {\n    setIsInCheckNoChangesMode(false);\n  }\n}\n/**\n * Checks the change detector on a root view and its components, and throws if any changes are\n * detected.\n *\n * This is used in development mode to verify that running change detection doesn't\n * introduce other changes.\n *\n * @param lView The view which the change detection should be checked on.\n */\n\n\nfunction checkNoChangesInRootView(lView) {\n  setIsInCheckNoChangesMode(true);\n\n  try {\n    detectChangesInRootView(lView);\n  } finally {\n    setIsInCheckNoChangesMode(false);\n  }\n}\n\nfunction executeViewQueryFn(flags, viewQueryFn, component) {\n  ngDevMode && assertDefined(viewQueryFn, 'View queries function to execute must be defined.');\n  setCurrentQueryIndex(0);\n  viewQueryFn(flags, component);\n} ///////////////////////////////\n//// Bindings & interpolations\n///////////////////////////////\n\n/**\n * Stores meta-data for a property binding to be used by TestBed's `DebugElement.properties`.\n *\n * In order to support TestBed's `DebugElement.properties` we need to save, for each binding:\n * - a bound property name;\n * - a static parts of interpolated strings;\n *\n * A given property metadata is saved at the binding's index in the `TView.data` (in other words, a\n * property binding metadata will be stored in `TView.data` at the same index as a bound value in\n * `LView`). Metadata are represented as `INTERPOLATION_DELIMITER`-delimited string with the\n * following format:\n * - `propertyName` for bound properties;\n * - `propertyName�prefix�interpolation_static_part1�..interpolation_static_partN�suffix` for\n * interpolated properties.\n *\n * @param tData `TData` where meta-data will be saved;\n * @param tNode `TNode` that is a target of the binding;\n * @param propertyName bound property name;\n * @param bindingIndex binding index in `LView`\n * @param interpolationParts static interpolation parts (for property interpolations)\n */\n\n\nfunction storePropertyBindingMetadata(tData, tNode, propertyName, bindingIndex, ...interpolationParts) {\n  // Binding meta-data are stored only the first time a given property instruction is processed.\n  // Since we don't have a concept of the \"first update pass\" we need to check for presence of the\n  // binding meta-data to decide if one should be stored (or if was stored already).\n  if (tData[bindingIndex] === null) {\n    if (tNode.inputs == null || !tNode.inputs[propertyName]) {\n      const propBindingIdxs = tNode.propertyBindings || (tNode.propertyBindings = []);\n      propBindingIdxs.push(bindingIndex);\n      let bindingMetadata = propertyName;\n\n      if (interpolationParts.length > 0) {\n        bindingMetadata += INTERPOLATION_DELIMITER + interpolationParts.join(INTERPOLATION_DELIMITER);\n      }\n\n      tData[bindingIndex] = bindingMetadata;\n    }\n  }\n}\n\nconst CLEAN_PROMISE = _CLEAN_PROMISE;\n\nfunction getOrCreateLViewCleanup(view) {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return view[CLEANUP] || (view[CLEANUP] = ngDevMode ? new LCleanup() : []);\n}\n\nfunction getOrCreateTViewCleanup(tView) {\n  return tView.cleanup || (tView.cleanup = ngDevMode ? new TCleanup() : []);\n}\n/**\n * There are cases where the sub component's renderer needs to be included\n * instead of the current renderer (see the componentSyntheticHost* instructions).\n */\n\n\nfunction loadComponentRenderer(currentDef, tNode, lView) {\n  // TODO(FW-2043): the `currentDef` is null when host bindings are invoked while creating root\n  // component (see packages/core/src/render3/component.ts). This is not consistent with the process\n  // of creating inner components, when current directive index is available in the state. In order\n  // to avoid relying on current def being `null` (thus special-casing root component creation), the\n  // process of creating root component should be unified with the process of creating inner\n  // components.\n  if (currentDef === null || isComponentDef(currentDef)) {\n    lView = unwrapLView(lView[tNode.index]);\n  }\n\n  return lView[RENDERER];\n}\n/** Handles an error thrown in an LView. */\n\n\nfunction handleError(lView, error) {\n  const injector = lView[INJECTOR$1];\n  const errorHandler = injector ? injector.get(ErrorHandler, null) : null;\n  errorHandler && errorHandler.handleError(error);\n}\n/**\n * Set the inputs of directives at the current node to corresponding value.\n *\n * @param tView The current TView\n * @param lView the `LView` which contains the directives.\n * @param inputs mapping between the public \"input\" name and privately-known,\n *        possibly minified, property names to write to.\n * @param value Value to set.\n */\n\n\nfunction setInputsForProperty(tView, lView, inputs, publicName, value) {\n  for (let i = 0; i < inputs.length;) {\n    const index = inputs[i++];\n    const privateName = inputs[i++];\n    const instance = lView[index];\n    ngDevMode && assertIndexInRange(lView, index);\n    const def = tView.data[index];\n\n    if (def.setInput !== null) {\n      def.setInput(instance, value, publicName, privateName);\n    } else {\n      instance[privateName] = value;\n    }\n  }\n}\n/**\n * Updates a text binding at a given index in a given LView.\n */\n\n\nfunction textBindingInternal(lView, index, value) {\n  ngDevMode && assertString(value, 'Value should be a string');\n  ngDevMode && assertNotSame(value, NO_CHANGE, 'value should not be NO_CHANGE');\n  ngDevMode && assertIndexInRange(lView, index);\n  const element = getNativeByIndex(index, lView);\n  ngDevMode && assertDefined(element, 'native element should exist');\n  updateTextNode(lView[RENDERER], element, value);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Compute the static styling (class/style) from `TAttributes`.\n *\n * This function should be called during `firstCreatePass` only.\n *\n * @param tNode The `TNode` into which the styling information should be loaded.\n * @param attrs `TAttributes` containing the styling information.\n * @param writeToHost Where should the resulting static styles be written?\n *   - `false` Write to `TNode.stylesWithoutHost` / `TNode.classesWithoutHost`\n *   - `true` Write to `TNode.styles` / `TNode.classes`\n */\n\n\nfunction computeStaticStyling(tNode, attrs, writeToHost) {\n  ngDevMode && assertFirstCreatePass(getTView(), 'Expecting to be called in first template pass only');\n  let styles = writeToHost ? tNode.styles : null;\n  let classes = writeToHost ? tNode.classes : null;\n  let mode = 0;\n\n  if (attrs !== null) {\n    for (let i = 0; i < attrs.length; i++) {\n      const value = attrs[i];\n\n      if (typeof value === 'number') {\n        mode = value;\n      } else if (mode == 1\n      /* AttributeMarker.Classes */\n      ) {\n        classes = concatStringsWithSpace(classes, value);\n      } else if (mode == 2\n      /* AttributeMarker.Styles */\n      ) {\n        const style = value;\n        const styleValue = attrs[++i];\n        styles = concatStringsWithSpace(styles, style + ': ' + styleValue + ';');\n      }\n    }\n  }\n\n  writeToHost ? tNode.styles = styles : tNode.stylesWithoutHost = styles;\n  writeToHost ? tNode.classes = classes : tNode.classesWithoutHost = classes;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Synchronously perform change detection on a component (and possibly its sub-components).\n *\n * This function triggers change detection in a synchronous way on a component.\n *\n * @param component The component which the change detection should be performed on.\n */\n\n\nfunction detectChanges(component) {\n  const view = getComponentViewByInstance(component);\n  detectChangesInternal(view[TVIEW], view, component);\n}\n/**\n * Marks the component as dirty (needing change detection). Marking a component dirty will\n * schedule a change detection on it at some point in the future.\n *\n * Marking an already dirty component as dirty won't do anything. Only one outstanding change\n * detection can be scheduled per component tree.\n *\n * @param component Component to mark as dirty.\n */\n\n\nfunction markDirty(component) {\n  ngDevMode && assertDefined(component, 'component');\n  const rootView = markViewDirty(getComponentViewByInstance(component));\n  ngDevMode && assertDefined(rootView[CONTEXT], 'rootContext should be defined');\n  scheduleTick(rootView[CONTEXT], 1\n  /* RootContextFlags.DetectChanges */\n  );\n}\n/**\n * Used to perform change detection on the whole application.\n *\n * This is equivalent to `detectChanges`, but invoked on root component. Additionally, `tick`\n * executes lifecycle hooks and conditionally checks components based on their\n * `ChangeDetectionStrategy` and dirtiness.\n *\n * The preferred way to trigger change detection is to call `markDirty`. `markDirty` internally\n * schedules `tick` using a scheduler in order to coalesce multiple `markDirty` calls into a\n * single change detection run. By default, the scheduler is `requestAnimationFrame`, but can\n * be changed when calling `renderComponent` and providing the `scheduler` option.\n */\n\n\nfunction tick(component) {\n  const rootView = getRootView(component);\n  const rootContext = rootView[CONTEXT];\n  tickRootContext(rootContext);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Retrieves the component instance associated with a given DOM element.\n *\n * @usageNotes\n * Given the following DOM structure:\n *\n * ```html\n * <app-root>\n *   <div>\n *     <child-comp></child-comp>\n *   </div>\n * </app-root>\n * ```\n *\n * Calling `getComponent` on `<child-comp>` will return the instance of `ChildComponent`\n * associated with this DOM element.\n *\n * Calling the function on `<app-root>` will return the `MyApp` instance.\n *\n *\n * @param element DOM element from which the component should be retrieved.\n * @returns Component instance associated with the element or `null` if there\n *    is no component associated with it.\n *\n * @publicApi\n * @globalApi ng\n */\n\n\nfunction getComponent$1(element) {\n  ngDevMode && assertDomElement(element);\n  const context = getLContext(element);\n  if (context === null) return null;\n\n  if (context.component === undefined) {\n    const lView = context.lView;\n\n    if (lView === null) {\n      return null;\n    }\n\n    context.component = getComponentAtNodeIndex(context.nodeIndex, lView);\n  }\n\n  return context.component;\n}\n/**\n * If inside an embedded view (e.g. `*ngIf` or `*ngFor`), retrieves the context of the embedded\n * view that the element is part of. Otherwise retrieves the instance of the component whose view\n * owns the element (in this case, the result is the same as calling `getOwningComponent`).\n *\n * @param element Element for which to get the surrounding component instance.\n * @returns Instance of the component that is around the element or null if the element isn't\n *    inside any component.\n *\n * @publicApi\n * @globalApi ng\n */\n\n\nfunction getContext(element) {\n  assertDomElement(element);\n  const context = getLContext(element);\n  const lView = context ? context.lView : null;\n  return lView === null ? null : lView[CONTEXT];\n}\n/**\n * Retrieves the component instance whose view contains the DOM element.\n *\n * For example, if `<child-comp>` is used in the template of `<app-comp>`\n * (i.e. a `ViewChild` of `<app-comp>`), calling `getOwningComponent` on `<child-comp>`\n * would return `<app-comp>`.\n *\n * @param elementOrDir DOM element, component or directive instance\n *    for which to retrieve the root components.\n * @returns Component instance whose view owns the DOM element or null if the element is not\n *    part of a component view.\n *\n * @publicApi\n * @globalApi ng\n */\n\n\nfunction getOwningComponent(elementOrDir) {\n  const context = getLContext(elementOrDir);\n  let lView = context ? context.lView : null;\n  if (lView === null) return null;\n  let parent;\n\n  while (lView[TVIEW].type === 2\n  /* TViewType.Embedded */\n  && (parent = getLViewParent(lView))) {\n    lView = parent;\n  }\n\n  return lView[FLAGS] & 256\n  /* LViewFlags.IsRoot */\n  ? null : lView[CONTEXT];\n}\n/**\n * Retrieves all root components associated with a DOM element, directive or component instance.\n * Root components are those which have been bootstrapped by Angular.\n *\n * @param elementOrDir DOM element, component or directive instance\n *    for which to retrieve the root components.\n * @returns Root components associated with the target object.\n *\n * @publicApi\n * @globalApi ng\n */\n\n\nfunction getRootComponents(elementOrDir) {\n  const lView = readPatchedLView(elementOrDir);\n  return lView !== null ? [...getRootContext(lView).components] : [];\n}\n/**\n * Retrieves an `Injector` associated with an element, component or directive instance.\n *\n * @param elementOrDir DOM element, component or directive instance for which to\n *    retrieve the injector.\n * @returns Injector associated with the element, component or directive instance.\n *\n * @publicApi\n * @globalApi ng\n */\n\n\nfunction getInjector(elementOrDir) {\n  const context = getLContext(elementOrDir);\n  const lView = context ? context.lView : null;\n  if (lView === null) return Injector.NULL;\n  const tNode = lView[TVIEW].data[context.nodeIndex];\n  return new NodeInjector(tNode, lView);\n}\n/**\n * Retrieve a set of injection tokens at a given DOM node.\n *\n * @param element Element for which the injection tokens should be retrieved.\n */\n\n\nfunction getInjectionTokens(element) {\n  const context = getLContext(element);\n  const lView = context ? context.lView : null;\n  if (lView === null) return [];\n  const tView = lView[TVIEW];\n  const tNode = tView.data[context.nodeIndex];\n  const providerTokens = [];\n  const startIndex = tNode.providerIndexes & 1048575\n  /* TNodeProviderIndexes.ProvidersStartIndexMask */\n  ;\n  const endIndex = tNode.directiveEnd;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    let value = tView.data[i];\n\n    if (isDirectiveDefHack(value)) {\n      // The fact that we sometimes store Type and sometimes DirectiveDef in this location is a\n      // design flaw.  We should always store same type so that we can be monomorphic. The issue\n      // is that for Components/Directives we store the def instead the type. The correct behavior\n      // is that we should always be storing injectable type in this location.\n      value = value.type;\n    }\n\n    providerTokens.push(value);\n  }\n\n  return providerTokens;\n}\n/**\n * Retrieves directive instances associated with a given DOM node. Does not include\n * component instances.\n *\n * @usageNotes\n * Given the following DOM structure:\n *\n * ```html\n * <app-root>\n *   <button my-button></button>\n *   <my-comp></my-comp>\n * </app-root>\n * ```\n *\n * Calling `getDirectives` on `<button>` will return an array with an instance of the `MyButton`\n * directive that is associated with the DOM node.\n *\n * Calling `getDirectives` on `<my-comp>` will return an empty array.\n *\n * @param node DOM node for which to get the directives.\n * @returns Array of directives associated with the node.\n *\n * @publicApi\n * @globalApi ng\n */\n\n\nfunction getDirectives(node) {\n  // Skip text nodes because we can't have directives associated with them.\n  if (node instanceof Text) {\n    return [];\n  }\n\n  const context = getLContext(node);\n  const lView = context ? context.lView : null;\n\n  if (lView === null) {\n    return [];\n  }\n\n  const tView = lView[TVIEW];\n  const nodeIndex = context.nodeIndex;\n\n  if (!(tView === null || tView === void 0 ? void 0 : tView.data[nodeIndex])) {\n    return [];\n  }\n\n  if (context.directives === undefined) {\n    context.directives = getDirectivesAtNodeIndex(nodeIndex, lView, false);\n  } // The `directives` in this case are a named array called `LComponentView`. Clone the\n  // result so we don't expose an internal data structure in the user's console.\n\n\n  return context.directives === null ? [] : [...context.directives];\n}\n/**\n * Returns the debug (partial) metadata for a particular directive or component instance.\n * The function accepts an instance of a directive or component and returns the corresponding\n * metadata.\n *\n * @param directiveOrComponentInstance Instance of a directive or component\n * @returns metadata of the passed directive or component\n *\n * @publicApi\n * @globalApi ng\n */\n\n\nfunction getDirectiveMetadata(directiveOrComponentInstance) {\n  const {\n    constructor\n  } = directiveOrComponentInstance;\n\n  if (!constructor) {\n    throw new Error('Unable to find the instance constructor');\n  } // In case a component inherits from a directive, we may have component and directive metadata\n  // To ensure we don't get the metadata of the directive, we want to call `getComponentDef` first.\n\n\n  const componentDef = getComponentDef$1(constructor);\n\n  if (componentDef) {\n    return {\n      inputs: componentDef.inputs,\n      outputs: componentDef.outputs,\n      encapsulation: componentDef.encapsulation,\n      changeDetection: componentDef.onPush ? ChangeDetectionStrategy.OnPush : ChangeDetectionStrategy.Default\n    };\n  }\n\n  const directiveDef = getDirectiveDef(constructor);\n\n  if (directiveDef) {\n    return {\n      inputs: directiveDef.inputs,\n      outputs: directiveDef.outputs\n    };\n  }\n\n  return null;\n}\n/**\n * Retrieve map of local references.\n *\n * The references are retrieved as a map of local reference name to element or directive instance.\n *\n * @param target DOM element, component or directive instance for which to retrieve\n *    the local references.\n */\n\n\nfunction getLocalRefs(target) {\n  const context = getLContext(target);\n  if (context === null) return {};\n\n  if (context.localRefs === undefined) {\n    const lView = context.lView;\n\n    if (lView === null) {\n      return {};\n    }\n\n    context.localRefs = discoverLocalRefs(lView, context.nodeIndex);\n  }\n\n  return context.localRefs || {};\n}\n/**\n * Retrieves the host element of a component or directive instance.\n * The host element is the DOM element that matched the selector of the directive.\n *\n * @param componentOrDirective Component or directive instance for which the host\n *     element should be retrieved.\n * @returns Host element of the target.\n *\n * @publicApi\n * @globalApi ng\n */\n\n\nfunction getHostElement(componentOrDirective) {\n  return getLContext(componentOrDirective).native;\n}\n/**\n * Retrieves the rendered text for a given component.\n *\n * This function retrieves the host element of a component and\n * and then returns the `textContent` for that element. This implies\n * that the text returned will include re-projected content of\n * the component as well.\n *\n * @param component The component to return the content text for.\n */\n\n\nfunction getRenderedText(component) {\n  const hostElement = getHostElement(component);\n  return hostElement.textContent || '';\n}\n/**\n * Retrieves a list of event listeners associated with a DOM element. The list does include host\n * listeners, but it does not include event listeners defined outside of the Angular context\n * (e.g. through `addEventListener`).\n *\n * @usageNotes\n * Given the following DOM structure:\n *\n * ```html\n * <app-root>\n *   <div (click)=\"doSomething()\"></div>\n * </app-root>\n * ```\n *\n * Calling `getListeners` on `<div>` will return an object that looks as follows:\n *\n * ```ts\n * {\n *   name: 'click',\n *   element: <div>,\n *   callback: () => doSomething(),\n *   useCapture: false\n * }\n * ```\n *\n * @param element Element for which the DOM listeners should be retrieved.\n * @returns Array of event listeners on the DOM element.\n *\n * @publicApi\n * @globalApi ng\n */\n\n\nfunction getListeners(element) {\n  ngDevMode && assertDomElement(element);\n  const lContext = getLContext(element);\n  const lView = lContext === null ? null : lContext.lView;\n  if (lView === null) return [];\n  const tView = lView[TVIEW];\n  const lCleanup = lView[CLEANUP];\n  const tCleanup = tView.cleanup;\n  const listeners = [];\n\n  if (tCleanup && lCleanup) {\n    for (let i = 0; i < tCleanup.length;) {\n      const firstParam = tCleanup[i++];\n      const secondParam = tCleanup[i++];\n\n      if (typeof firstParam === 'string') {\n        const name = firstParam;\n        const listenerElement = unwrapRNode(lView[secondParam]);\n        const callback = lCleanup[tCleanup[i++]];\n        const useCaptureOrIndx = tCleanup[i++]; // if useCaptureOrIndx is boolean then report it as is.\n        // if useCaptureOrIndx is positive number then it in unsubscribe method\n        // if useCaptureOrIndx is negative number then it is a Subscription\n\n        const type = typeof useCaptureOrIndx === 'boolean' || useCaptureOrIndx >= 0 ? 'dom' : 'output';\n        const useCapture = typeof useCaptureOrIndx === 'boolean' ? useCaptureOrIndx : false;\n\n        if (element == listenerElement) {\n          listeners.push({\n            element,\n            name,\n            callback,\n            useCapture,\n            type\n          });\n        }\n      }\n    }\n  }\n\n  listeners.sort(sortListeners);\n  return listeners;\n}\n\nfunction sortListeners(a, b) {\n  if (a.name == b.name) return 0;\n  return a.name < b.name ? -1 : 1;\n}\n/**\n * This function should not exist because it is megamorphic and only mostly correct.\n *\n * See call site for more info.\n */\n\n\nfunction isDirectiveDefHack(obj) {\n  return obj.type !== undefined && obj.template !== undefined && obj.declaredInputs !== undefined;\n}\n/**\n * Returns the attached `DebugNode` instance for an element in the DOM.\n *\n * @param element DOM element which is owned by an existing component's view.\n */\n\n\nfunction getDebugNode(element) {\n  if (ngDevMode && !(element instanceof Node)) {\n    throw new Error('Expecting instance of DOM Element');\n  }\n\n  const lContext = getLContext(element);\n  const lView = lContext ? lContext.lView : null;\n\n  if (lView === null) {\n    return null;\n  }\n\n  const nodeIndex = lContext.nodeIndex;\n\n  if (nodeIndex !== -1) {\n    const valueInLView = lView[nodeIndex]; // this means that value in the lView is a component with its own\n    // data. In this situation the TNode is not accessed at the same spot.\n\n    const tNode = isLView(valueInLView) ? valueInLView[T_HOST] : getTNode(lView[TVIEW], nodeIndex);\n    ngDevMode && assertEqual(tNode.index, nodeIndex, 'Expecting that TNode at index is same as index');\n    return buildDebugNode(tNode, lView);\n  }\n\n  return null;\n}\n/**\n * Retrieve the component `LView` from component/element.\n *\n * NOTE: `LView` is a private and should not be leaked outside.\n *       Don't export this method to `ng.*` on window.\n *\n * @param target DOM element or component instance for which to retrieve the LView.\n */\n\n\nfunction getComponentLView(target) {\n  const lContext = getLContext(target);\n  const nodeIndx = lContext.nodeIndex;\n  const lView = lContext.lView;\n  ngDevMode && assertLView(lView);\n  const componentLView = lView[nodeIndx];\n  ngDevMode && assertLView(componentLView);\n  return componentLView;\n}\n/** Asserts that a value is a DOM Element. */\n\n\nfunction assertDomElement(value) {\n  if (typeof Element !== 'undefined' && !(value instanceof Element)) {\n    throw new Error('Expecting instance of DOM Element');\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Marks a component for check (in case of OnPush components) and synchronously\n * performs change detection on the application this component belongs to.\n *\n * @param component Component to {@link ChangeDetectorRef#markForCheck mark for check}.\n *\n * @publicApi\n * @globalApi ng\n */\n\n\nfunction applyChanges(component) {\n  markDirty(component);\n  getRootComponents(component).forEach(rootComponent => detectChanges(rootComponent));\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * This file introduces series of globally accessible debug tools\n * to allow for the Angular debugging story to function.\n *\n * To see this in action run the following command:\n *\n *   bazel run //packages/core/test/bundling/todo:devserver\n *\n *  Then load `localhost:5432` and start using the console tools.\n */\n\n/**\n * This value reflects the property on the window where the dev\n * tools are patched (window.ng).\n * */\n\n\nconst GLOBAL_PUBLISH_EXPANDO_KEY = 'ng';\nlet _published = false;\n/**\n * Publishes a collection of default debug tools onto`window.ng`.\n *\n * These functions are available globally when Angular is in development\n * mode and are automatically stripped away from prod mode is on.\n */\n\nfunction publishDefaultGlobalUtils() {\n  if (!_published) {\n    _published = true;\n    /**\n     * Warning: this function is *INTERNAL* and should not be relied upon in application's code.\n     * The contract of the function might be changed in any release and/or the function can be\n     * removed completely.\n     */\n\n    publishGlobalUtil('ɵsetProfiler', setProfiler);\n    publishGlobalUtil('getDirectiveMetadata', getDirectiveMetadata);\n    publishGlobalUtil('getComponent', getComponent$1);\n    publishGlobalUtil('getContext', getContext);\n    publishGlobalUtil('getListeners', getListeners);\n    publishGlobalUtil('getOwningComponent', getOwningComponent);\n    publishGlobalUtil('getHostElement', getHostElement);\n    publishGlobalUtil('getInjector', getInjector);\n    publishGlobalUtil('getRootComponents', getRootComponents);\n    publishGlobalUtil('getDirectives', getDirectives);\n    publishGlobalUtil('applyChanges', applyChanges);\n  }\n}\n/**\n * Publishes the given function to `window.ng` so that it can be\n * used from the browser console when an application is not in production.\n */\n\n\nfunction publishGlobalUtil(name, fn) {\n  if (typeof COMPILED === 'undefined' || !COMPILED) {\n    // Note: we can't export `ng` when using closure enhanced optimization as:\n    // - closure declares globals itself for minified names, which sometimes clobber our `ng` global\n    // - we can't declare a closure extern as the namespace `ng` is already used within Google\n    //   for typings for AngularJS (via `goog.provide('ng....')`).\n    const w = _global$1;\n    ngDevMode && assertDefined(fn, 'function not defined');\n\n    if (w) {\n      let container = w[GLOBAL_PUBLISH_EXPANDO_KEY];\n\n      if (!container) {\n        container = w[GLOBAL_PUBLISH_EXPANDO_KEY] = {};\n      }\n\n      container[name] = fn;\n    }\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// TODO: A hack to not pull in the NullInjector from @angular/core.\n\n\nconst NULL_INJECTOR = {\n  get: (token, notFoundValue) => {\n    throwProviderNotFoundError(token, 'NullInjector');\n  }\n};\n/**\n * Bootstraps a Component into an existing host element and returns an instance\n * of the component.\n *\n * Use this function to bootstrap a component into the DOM tree. Each invocation\n * of this function will create a separate tree of components, injectors and\n * change detection cycles and lifetimes. To dynamically insert a new component\n * into an existing tree such that it shares the same injection, change detection\n * and object lifetime, use {@link ViewContainer#createComponent}.\n *\n * @param componentType Component to bootstrap\n * @param options Optional parameters which control bootstrapping\n */\n\nfunction renderComponent(componentType\n/* Type as workaround for: Microsoft/TypeScript/issues/4881 */\n, opts = {}) {\n  ngDevMode && publishDefaultGlobalUtils();\n  ngDevMode && assertComponentType(componentType);\n  const rendererFactory = opts.rendererFactory || domRendererFactory3;\n  const sanitizer = opts.sanitizer || null;\n  const componentDef = getComponentDef$1(componentType);\n  if (componentDef.type != componentType) componentDef.type = componentType; // The first index of the first selector is the tag name.\n\n  const componentTag = componentDef.selectors[0][0];\n  const hostRenderer = rendererFactory.createRenderer(null, null);\n  const hostRNode = locateHostElement(hostRenderer, opts.host || componentTag, componentDef.encapsulation);\n  const rootFlags = componentDef.onPush ? 32\n  /* LViewFlags.Dirty */\n  | 256\n  /* LViewFlags.IsRoot */\n  : 16\n  /* LViewFlags.CheckAlways */\n  | 256\n  /* LViewFlags.IsRoot */\n  ;\n  const rootContext = createRootContext(opts.scheduler, opts.playerHandler);\n  const renderer = rendererFactory.createRenderer(hostRNode, componentDef);\n  const rootTView = createTView(0\n  /* TViewType.Root */\n  , null, null, 1, 0, null, null, null, null, null);\n  const rootView = createLView(null, rootTView, rootContext, rootFlags, null, null, rendererFactory, renderer, null, opts.injector || null, null);\n  enterView(rootView);\n  let component;\n\n  try {\n    if (rendererFactory.begin) rendererFactory.begin();\n    const componentView = createRootComponentView(hostRNode, componentDef, rootView, rendererFactory, renderer, sanitizer);\n    component = createRootComponent(componentView, componentDef, rootView, rootContext, opts.hostFeatures || null); // create mode pass\n\n    renderView(rootTView, rootView, null); // update mode pass\n\n    refreshView(rootTView, rootView, null, null);\n  } finally {\n    leaveView();\n    if (rendererFactory.end) rendererFactory.end();\n  }\n\n  return component;\n}\n/**\n * Creates the root component view and the root component node.\n *\n * @param rNode Render host element.\n * @param def ComponentDef\n * @param rootView The parent view where the host node is stored\n * @param rendererFactory Factory to be used for creating child renderers.\n * @param hostRenderer The current renderer\n * @param sanitizer The sanitizer, if provided\n *\n * @returns Component view created\n */\n\n\nfunction createRootComponentView(rNode, def, rootView, rendererFactory, hostRenderer, sanitizer) {\n  const tView = rootView[TVIEW];\n  const index = HEADER_OFFSET;\n  ngDevMode && assertIndexInRange(rootView, index);\n  rootView[index] = rNode; // '#host' is added here as we don't know the real host DOM name (we don't want to read it) and at\n  // the same time we want to communicate the debug `TNode` that this is a special `TNode`\n  // representing a host element.\n\n  const tNode = getOrCreateTNode(tView, index, 2\n  /* TNodeType.Element */\n  , '#host', null);\n  const mergedAttrs = tNode.mergedAttrs = def.hostAttrs;\n\n  if (mergedAttrs !== null) {\n    computeStaticStyling(tNode, mergedAttrs, true);\n\n    if (rNode !== null) {\n      setUpAttributes(hostRenderer, rNode, mergedAttrs);\n\n      if (tNode.classes !== null) {\n        writeDirectClass(hostRenderer, rNode, tNode.classes);\n      }\n\n      if (tNode.styles !== null) {\n        writeDirectStyle(hostRenderer, rNode, tNode.styles);\n      }\n    }\n  }\n\n  const viewRenderer = rendererFactory.createRenderer(rNode, def);\n  const componentView = createLView(rootView, getOrCreateTComponentView(def), null, def.onPush ? 32\n  /* LViewFlags.Dirty */\n  : 16\n  /* LViewFlags.CheckAlways */\n  , rootView[index], tNode, rendererFactory, viewRenderer, sanitizer || null, null, null);\n\n  if (tView.firstCreatePass) {\n    diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, rootView), tView, def.type);\n    markAsComponentHost(tView, tNode);\n    initTNodeFlags(tNode, rootView.length, 1);\n  }\n\n  addToViewTree(rootView, componentView); // Store component view at node index, with node as the HOST\n\n  return rootView[index] = componentView;\n}\n/**\n * Creates a root component and sets it up with features and host bindings. Shared by\n * renderComponent() and ViewContainerRef.createComponent().\n */\n\n\nfunction createRootComponent(componentView, componentDef, rootLView, rootContext, hostFeatures) {\n  const tView = rootLView[TVIEW]; // Create directive instance with factory() and store at next index in viewData\n\n  const component = instantiateRootComponent(tView, rootLView, componentDef);\n  rootContext.components.push(component);\n  componentView[CONTEXT] = component;\n\n  if (hostFeatures !== null) {\n    for (const feature of hostFeatures) {\n      feature(component, componentDef);\n    }\n  } // We want to generate an empty QueryList for root content queries for backwards\n  // compatibility with ViewEngine.\n\n\n  if (componentDef.contentQueries) {\n    const tNode = getCurrentTNode();\n    ngDevMode && assertDefined(tNode, 'TNode expected');\n    componentDef.contentQueries(1\n    /* RenderFlags.Create */\n    , component, tNode.directiveStart);\n  }\n\n  const rootTNode = getCurrentTNode();\n  ngDevMode && assertDefined(rootTNode, 'tNode should have been already created');\n\n  if (tView.firstCreatePass && (componentDef.hostBindings !== null || componentDef.hostAttrs !== null)) {\n    setSelectedIndex(rootTNode.index);\n    const rootTView = rootLView[TVIEW];\n    registerHostBindingOpCodes(rootTView, rootTNode, rootLView, rootTNode.directiveStart, rootTNode.directiveEnd, componentDef);\n    invokeHostBindingsInCreationMode(componentDef, component);\n  }\n\n  return component;\n}\n\nfunction createRootContext(scheduler, playerHandler) {\n  return {\n    components: [],\n    scheduler: scheduler || defaultScheduler,\n    clean: CLEAN_PROMISE,\n    playerHandler: playerHandler || null,\n    flags: 0\n    /* RootContextFlags.Empty */\n\n  };\n}\n/**\n * Used to enable lifecycle hooks on the root component.\n *\n * Include this feature when calling `renderComponent` if the root component\n * you are rendering has lifecycle hooks defined. Otherwise, the hooks won't\n * be called properly.\n *\n * Example:\n *\n * ```\n * renderComponent(AppComponent, {hostFeatures: [LifecycleHooksFeature]});\n * ```\n */\n\n\nfunction LifecycleHooksFeature() {\n  const tNode = getCurrentTNode();\n  ngDevMode && assertDefined(tNode, 'TNode is required');\n  registerPostOrderHooks(getLView()[TVIEW], tNode);\n}\n/**\n * Wait on component until it is rendered.\n *\n * This function returns a `Promise` which is resolved when the component's\n * change detection is executed. This is determined by finding the scheduler\n * associated with the `component`'s render tree and waiting until the scheduler\n * flushes. If nothing is scheduled, the function returns a resolved promise.\n *\n * Example:\n * ```\n * await whenRendered(myComponent);\n * ```\n *\n * @param component Component to wait upon\n * @returns Promise which resolves when the component is rendered.\n */\n\n\nfunction whenRendered(component) {\n  return getRootContext(component).clean;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction getSuperType(type) {\n  return Object.getPrototypeOf(type.prototype).constructor;\n}\n/**\n * Merges the definition from a super class to a sub class.\n * @param definition The definition that is a SubClass of another directive of component\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵInheritDefinitionFeature(definition) {\n  let superType = getSuperType(definition.type);\n  let shouldInheritFields = true;\n  const inheritanceChain = [definition];\n\n  while (superType) {\n    let superDef = undefined;\n\n    if (isComponentDef(definition)) {\n      // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n      superDef = superType.ɵcmp || superType.ɵdir;\n    } else {\n      if (superType.ɵcmp) {\n        throw new RuntimeError(903\n        /* RuntimeErrorCode.INVALID_INHERITANCE */\n        , ngDevMode && `Directives cannot inherit Components. Directive ${stringifyForError(definition.type)} is attempting to extend component ${stringifyForError(superType)}`);\n      } // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n\n\n      superDef = superType.ɵdir;\n    }\n\n    if (superDef) {\n      if (shouldInheritFields) {\n        inheritanceChain.push(superDef); // Some fields in the definition may be empty, if there were no values to put in them that\n        // would've justified object creation. Unwrap them if necessary.\n\n        const writeableDef = definition;\n        writeableDef.inputs = maybeUnwrapEmpty(definition.inputs);\n        writeableDef.declaredInputs = maybeUnwrapEmpty(definition.declaredInputs);\n        writeableDef.outputs = maybeUnwrapEmpty(definition.outputs); // Merge hostBindings\n\n        const superHostBindings = superDef.hostBindings;\n        superHostBindings && inheritHostBindings(definition, superHostBindings); // Merge queries\n\n        const superViewQuery = superDef.viewQuery;\n        const superContentQueries = superDef.contentQueries;\n        superViewQuery && inheritViewQuery(definition, superViewQuery);\n        superContentQueries && inheritContentQueries(definition, superContentQueries); // Merge inputs and outputs\n\n        fillProperties(definition.inputs, superDef.inputs);\n        fillProperties(definition.declaredInputs, superDef.declaredInputs);\n        fillProperties(definition.outputs, superDef.outputs); // Merge animations metadata.\n        // If `superDef` is a Component, the `data` field is present (defaults to an empty object).\n\n        if (isComponentDef(superDef) && superDef.data.animation) {\n          // If super def is a Component, the `definition` is also a Component, since Directives can\n          // not inherit Components (we throw an error above and cannot reach this code).\n          const defData = definition.data;\n          defData.animation = (defData.animation || []).concat(superDef.data.animation);\n        }\n      } // Run parent features\n\n\n      const features = superDef.features;\n\n      if (features) {\n        for (let i = 0; i < features.length; i++) {\n          const feature = features[i];\n\n          if (feature && feature.ngInherit) {\n            feature(definition);\n          } // If `InheritDefinitionFeature` is a part of the current `superDef`, it means that this\n          // def already has all the necessary information inherited from its super class(es), so we\n          // can stop merging fields from super classes. However we need to iterate through the\n          // prototype chain to look for classes that might contain other \"features\" (like\n          // NgOnChanges), which we should invoke for the original `definition`. We set the\n          // `shouldInheritFields` flag to indicate that, essentially skipping fields inheritance\n          // logic and only invoking functions from the \"features\" list.\n\n\n          if (feature === ɵɵInheritDefinitionFeature) {\n            shouldInheritFields = false;\n          }\n        }\n      }\n    }\n\n    superType = Object.getPrototypeOf(superType);\n  }\n\n  mergeHostAttrsAcrossInheritance(inheritanceChain);\n}\n/**\n * Merge the `hostAttrs` and `hostVars` from the inherited parent to the base class.\n *\n * @param inheritanceChain A list of `WritableDefs` starting at the top most type and listing\n * sub-types in order. For each type take the `hostAttrs` and `hostVars` and merge it with the child\n * type.\n */\n\n\nfunction mergeHostAttrsAcrossInheritance(inheritanceChain) {\n  let hostVars = 0;\n  let hostAttrs = null; // We process the inheritance order from the base to the leaves here.\n\n  for (let i = inheritanceChain.length - 1; i >= 0; i--) {\n    const def = inheritanceChain[i]; // For each `hostVars`, we need to add the superclass amount.\n\n    def.hostVars = hostVars += def.hostVars; // for each `hostAttrs` we need to merge it with superclass.\n\n    def.hostAttrs = mergeHostAttrs(def.hostAttrs, hostAttrs = mergeHostAttrs(hostAttrs, def.hostAttrs));\n  }\n}\n\nfunction maybeUnwrapEmpty(value) {\n  if (value === EMPTY_OBJ) {\n    return {};\n  } else if (value === EMPTY_ARRAY) {\n    return [];\n  } else {\n    return value;\n  }\n}\n\nfunction inheritViewQuery(definition, superViewQuery) {\n  const prevViewQuery = definition.viewQuery;\n\n  if (prevViewQuery) {\n    definition.viewQuery = (rf, ctx) => {\n      superViewQuery(rf, ctx);\n      prevViewQuery(rf, ctx);\n    };\n  } else {\n    definition.viewQuery = superViewQuery;\n  }\n}\n\nfunction inheritContentQueries(definition, superContentQueries) {\n  const prevContentQueries = definition.contentQueries;\n\n  if (prevContentQueries) {\n    definition.contentQueries = (rf, ctx, directiveIndex) => {\n      superContentQueries(rf, ctx, directiveIndex);\n      prevContentQueries(rf, ctx, directiveIndex);\n    };\n  } else {\n    definition.contentQueries = superContentQueries;\n  }\n}\n\nfunction inheritHostBindings(definition, superHostBindings) {\n  const prevHostBindings = definition.hostBindings;\n\n  if (prevHostBindings) {\n    definition.hostBindings = (rf, ctx) => {\n      superHostBindings(rf, ctx);\n      prevHostBindings(rf, ctx);\n    };\n  } else {\n    definition.hostBindings = superHostBindings;\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Fields which exist on either directive or component definitions, and need to be copied from\n * parent to child classes by the `ɵɵCopyDefinitionFeature`.\n */\n\n\nconst COPY_DIRECTIVE_FIELDS = [// The child class should use the providers of its parent.\n'providersResolver' // Not listed here are any fields which are handled by the `ɵɵInheritDefinitionFeature`, such\n// as inputs, outputs, and host binding functions.\n];\n/**\n * Fields which exist only on component definitions, and need to be copied from parent to child\n * classes by the `ɵɵCopyDefinitionFeature`.\n *\n * The type here allows any field of `ComponentDef` which is not also a property of `DirectiveDef`,\n * since those should go in `COPY_DIRECTIVE_FIELDS` above.\n */\n\nconst COPY_COMPONENT_FIELDS = [// The child class should use the template function of its parent, including all template\n// semantics.\n'template', 'decls', 'consts', 'vars', 'onPush', 'ngContentSelectors', // The child class should use the CSS styles of its parent, including all styling semantics.\n'styles', 'encapsulation', // The child class should be checked by the runtime in the same way as its parent.\n'schemas'];\n/**\n * Copies the fields not handled by the `ɵɵInheritDefinitionFeature` from the supertype of a\n * definition.\n *\n * This exists primarily to support ngcc migration of an existing View Engine pattern, where an\n * entire decorator is inherited from a parent to a child class. When ngcc detects this case, it\n * generates a skeleton definition on the child class, and applies this feature.\n *\n * The `ɵɵCopyDefinitionFeature` then copies any needed fields from the parent class' definition,\n * including things like the component template function.\n *\n * @param definition The definition of a child class which inherits from a parent class with its\n * own definition.\n *\n * @codeGenApi\n */\n\nfunction ɵɵCopyDefinitionFeature(definition) {\n  let superType = getSuperType(definition.type);\n  let superDef = undefined;\n\n  if (isComponentDef(definition)) {\n    // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n    superDef = superType.ɵcmp;\n  } else {\n    // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n    superDef = superType.ɵdir;\n  } // Needed because `definition` fields are readonly.\n\n\n  const defAny = definition; // Copy over any fields that apply to either directives or components.\n\n  for (const field of COPY_DIRECTIVE_FIELDS) {\n    defAny[field] = superDef[field];\n  }\n\n  if (isComponentDef(superDef)) {\n    // Copy over any component-specific fields.\n    for (const field of COPY_COMPONENT_FIELDS) {\n      defAny[field] = superDef[field];\n    }\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nlet _symbolIterator = null;\n\nfunction getSymbolIterator() {\n  if (!_symbolIterator) {\n    const Symbol = _global$1['Symbol'];\n\n    if (Symbol && Symbol.iterator) {\n      _symbolIterator = Symbol.iterator;\n    } else {\n      // es6-shim specific logic\n      const keys = Object.getOwnPropertyNames(Map.prototype);\n\n      for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n\n        if (key !== 'entries' && key !== 'size' && Map.prototype[key] === Map.prototype['entries']) {\n          _symbolIterator = key;\n        }\n      }\n    }\n  }\n\n  return _symbolIterator;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction isIterable(obj) {\n  return obj !== null && typeof obj === 'object' && obj[getSymbolIterator()] !== undefined;\n}\n\nfunction isListLikeIterable(obj) {\n  if (!isJsObject(obj)) return false;\n  return Array.isArray(obj) || !(obj instanceof Map) && // JS Map are iterables but return entries as [k, v]\n  getSymbolIterator() in obj; // JS Iterable have a Symbol.iterator prop\n}\n\nfunction areIterablesEqual(a, b, comparator) {\n  const iterator1 = a[getSymbolIterator()]();\n  const iterator2 = b[getSymbolIterator()]();\n\n  while (true) {\n    const item1 = iterator1.next();\n    const item2 = iterator2.next();\n    if (item1.done && item2.done) return true;\n    if (item1.done || item2.done) return false;\n    if (!comparator(item1.value, item2.value)) return false;\n  }\n}\n\nfunction iterateListLike(obj, fn) {\n  if (Array.isArray(obj)) {\n    for (let i = 0; i < obj.length; i++) {\n      fn(obj[i]);\n    }\n  } else {\n    const iterator = obj[getSymbolIterator()]();\n    let item;\n\n    while (!(item = iterator.next()).done) {\n      fn(item.value);\n    }\n  }\n}\n\nfunction isJsObject(o) {\n  return o !== null && (typeof o === 'function' || typeof o === 'object');\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction devModeEqual(a, b) {\n  const isListLikeIterableA = isListLikeIterable(a);\n  const isListLikeIterableB = isListLikeIterable(b);\n\n  if (isListLikeIterableA && isListLikeIterableB) {\n    return areIterablesEqual(a, b, devModeEqual);\n  } else {\n    const isAObject = a && (typeof a === 'object' || typeof a === 'function');\n    const isBObject = b && (typeof b === 'object' || typeof b === 'function');\n\n    if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {\n      return true;\n    } else {\n      return Object.is(a, b);\n    }\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// TODO(misko): consider inlining\n\n/** Updates binding and returns the value. */\n\n\nfunction updateBinding(lView, bindingIndex, value) {\n  return lView[bindingIndex] = value;\n}\n/** Gets the current binding value. */\n\n\nfunction getBinding(lView, bindingIndex) {\n  ngDevMode && assertIndexInRange(lView, bindingIndex);\n  ngDevMode && assertNotSame(lView[bindingIndex], NO_CHANGE, 'Stored value should never be NO_CHANGE.');\n  return lView[bindingIndex];\n}\n/**\n * Updates binding if changed, then returns whether it was updated.\n *\n * This function also checks the `CheckNoChangesMode` and throws if changes are made.\n * Some changes (Objects/iterables) during `CheckNoChangesMode` are exempt to comply with VE\n * behavior.\n *\n * @param lView current `LView`\n * @param bindingIndex The binding in the `LView` to check\n * @param value New value to check against `lView[bindingIndex]`\n * @returns `true` if the bindings has changed. (Throws if binding has changed during\n *          `CheckNoChangesMode`)\n */\n\n\nfunction bindingUpdated(lView, bindingIndex, value) {\n  ngDevMode && assertNotSame(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');\n  ngDevMode && assertLessThan(bindingIndex, lView.length, `Slot should have been initialized to NO_CHANGE`);\n  const oldValue = lView[bindingIndex];\n\n  if (Object.is(oldValue, value)) {\n    return false;\n  } else {\n    if (ngDevMode && isInCheckNoChangesMode()) {\n      // View engine didn't report undefined values as changed on the first checkNoChanges pass\n      // (before the change detection was run).\n      const oldValueToCompare = oldValue !== NO_CHANGE ? oldValue : undefined;\n\n      if (!devModeEqual(oldValueToCompare, value)) {\n        const details = getExpressionChangedErrorDetails(lView, bindingIndex, oldValueToCompare, value);\n        throwErrorIfNoChangesMode(oldValue === NO_CHANGE, details.oldValue, details.newValue, details.propName);\n      } // There was a change, but the `devModeEqual` decided that the change is exempt from an error.\n      // For this reason we exit as if no change. The early exit is needed to prevent the changed\n      // value to be written into `LView` (If we would write the new value that we would not see it\n      // as change on next CD.)\n\n\n      return false;\n    }\n\n    lView[bindingIndex] = value;\n    return true;\n  }\n}\n/** Updates 2 bindings if changed, then returns whether either was updated. */\n\n\nfunction bindingUpdated2(lView, bindingIndex, exp1, exp2) {\n  const different = bindingUpdated(lView, bindingIndex, exp1);\n  return bindingUpdated(lView, bindingIndex + 1, exp2) || different;\n}\n/** Updates 3 bindings if changed, then returns whether any was updated. */\n\n\nfunction bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) {\n  const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);\n  return bindingUpdated(lView, bindingIndex + 2, exp3) || different;\n}\n/** Updates 4 bindings if changed, then returns whether any was updated. */\n\n\nfunction bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) {\n  const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);\n  return bindingUpdated2(lView, bindingIndex + 2, exp3, exp4) || different;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Updates the value of or removes a bound attribute on an Element.\n *\n * Used in the case of `[attr.title]=\"value\"`\n *\n * @param name name The name of the attribute.\n * @param value value The attribute is removed when value is `null` or `undefined`.\n *                  Otherwise the attribute value is set to the stringified value.\n * @param sanitizer An optional function used to sanitize the value.\n * @param namespace Optional namespace to use when setting the attribute.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵattribute(name, value, sanitizer, namespace) {\n  const lView = getLView();\n  const bindingIndex = nextBindingIndex();\n\n  if (bindingUpdated(lView, bindingIndex, value)) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, 'attr.' + name, bindingIndex);\n  }\n\n  return ɵɵattribute;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Create interpolation bindings with a variable number of expressions.\n *\n * If there are 1 to 8 expressions `interpolation1()` to `interpolation8()` should be used instead.\n * Those are faster because there is no need to create an array of expressions and iterate over it.\n *\n * `values`:\n * - has static text at even indexes,\n * - has evaluated expressions at odd indexes.\n *\n * Returns the concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\n\n\nfunction interpolationV(lView, values) {\n  ngDevMode && assertLessThan(2, values.length, 'should have at least 3 values');\n  ngDevMode && assertEqual(values.length % 2, 1, 'should have an odd number of values');\n  let isBindingUpdated = false;\n  let bindingIndex = getBindingIndex();\n\n  for (let i = 1; i < values.length; i += 2) {\n    // Check if bindings (odd indexes) have changed\n    isBindingUpdated = bindingUpdated(lView, bindingIndex++, values[i]) || isBindingUpdated;\n  }\n\n  setBindingIndex(bindingIndex);\n\n  if (!isBindingUpdated) {\n    return NO_CHANGE;\n  } // Build the updated content\n\n\n  let content = values[0];\n\n  for (let i = 1; i < values.length; i += 2) {\n    content += renderStringify(values[i]) + values[i + 1];\n  }\n\n  return content;\n}\n/**\n * Creates an interpolation binding with 1 expression.\n *\n * @param prefix static value used for concatenation only.\n * @param v0 value checked for change.\n * @param suffix static value used for concatenation only.\n */\n\n\nfunction interpolation1(lView, prefix, v0, suffix) {\n  const different = bindingUpdated(lView, nextBindingIndex(), v0);\n  return different ? prefix + renderStringify(v0) + suffix : NO_CHANGE;\n}\n/**\n * Creates an interpolation binding with 2 expressions.\n */\n\n\nfunction interpolation2(lView, prefix, v0, i0, v1, suffix) {\n  const bindingIndex = getBindingIndex();\n  const different = bindingUpdated2(lView, bindingIndex, v0, v1);\n  incrementBindingIndex(2);\n  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + suffix : NO_CHANGE;\n}\n/**\n * Creates an interpolation binding with 3 expressions.\n */\n\n\nfunction interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix) {\n  const bindingIndex = getBindingIndex();\n  const different = bindingUpdated3(lView, bindingIndex, v0, v1, v2);\n  incrementBindingIndex(3);\n  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + suffix : NO_CHANGE;\n}\n/**\n * Create an interpolation binding with 4 expressions.\n */\n\n\nfunction interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {\n  const bindingIndex = getBindingIndex();\n  const different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  incrementBindingIndex(4);\n  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + suffix : NO_CHANGE;\n}\n/**\n * Creates an interpolation binding with 5 expressions.\n */\n\n\nfunction interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {\n  const bindingIndex = getBindingIndex();\n  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  different = bindingUpdated(lView, bindingIndex + 4, v4) || different;\n  incrementBindingIndex(5);\n  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + suffix : NO_CHANGE;\n}\n/**\n * Creates an interpolation binding with 6 expressions.\n */\n\n\nfunction interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {\n  const bindingIndex = getBindingIndex();\n  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  different = bindingUpdated2(lView, bindingIndex + 4, v4, v5) || different;\n  incrementBindingIndex(6);\n  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + suffix : NO_CHANGE;\n}\n/**\n * Creates an interpolation binding with 7 expressions.\n */\n\n\nfunction interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {\n  const bindingIndex = getBindingIndex();\n  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  different = bindingUpdated3(lView, bindingIndex + 4, v4, v5, v6) || different;\n  incrementBindingIndex(7);\n  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 + renderStringify(v6) + suffix : NO_CHANGE;\n}\n/**\n * Creates an interpolation binding with 8 expressions.\n */\n\n\nfunction interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {\n  const bindingIndex = getBindingIndex();\n  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  different = bindingUpdated4(lView, bindingIndex + 4, v4, v5, v6, v7) || different;\n  incrementBindingIndex(8);\n  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 + renderStringify(v6) + i6 + renderStringify(v7) + suffix : NO_CHANGE;\n}\n/**\n *\n * Update an interpolated attribute on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate1('title', 'prefix', v0, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\n\n\nfunction ɵɵattributeInterpolate1(attrName, prefix, v0, suffix, sanitizer, namespace) {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 1, prefix, suffix);\n  }\n\n  return ɵɵattributeInterpolate1;\n}\n/**\n *\n * Update an interpolated attribute on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate2('title', 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\n\n\nfunction ɵɵattributeInterpolate2(attrName, prefix, v0, i0, v1, suffix, sanitizer, namespace) {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 2, prefix, i0, suffix);\n  }\n\n  return ɵɵattributeInterpolate2;\n}\n/**\n *\n * Update an interpolated attribute on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate3(\n * 'title', 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\n\n\nfunction ɵɵattributeInterpolate3(attrName, prefix, v0, i0, v1, i1, v2, suffix, sanitizer, namespace) {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 3, prefix, i0, i1, suffix);\n  }\n\n  return ɵɵattributeInterpolate3;\n}\n/**\n *\n * Update an interpolated attribute on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate4(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\n\n\nfunction ɵɵattributeInterpolate4(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, sanitizer, namespace) {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 4, prefix, i0, i1, i2, suffix);\n  }\n\n  return ɵɵattributeInterpolate4;\n}\n/**\n *\n * Update an interpolated attribute on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate5(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\n\n\nfunction ɵɵattributeInterpolate5(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, sanitizer, namespace) {\n  const lView = getLView();\n  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 5, prefix, i0, i1, i2, i3, suffix);\n  }\n\n  return ɵɵattributeInterpolate5;\n}\n/**\n *\n * Update an interpolated attribute on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate6(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\n\n\nfunction ɵɵattributeInterpolate6(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, sanitizer, namespace) {\n  const lView = getLView();\n  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 6, prefix, i0, i1, i2, i3, i4, suffix);\n  }\n\n  return ɵɵattributeInterpolate6;\n}\n/**\n *\n * Update an interpolated attribute on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate7(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\n\n\nfunction ɵɵattributeInterpolate7(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer, namespace) {\n  const lView = getLView();\n  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 7, prefix, i0, i1, i2, i3, i4, i5, suffix);\n  }\n\n  return ɵɵattributeInterpolate7;\n}\n/**\n *\n * Update an interpolated attribute on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate8(\n *  'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\n\n\nfunction ɵɵattributeInterpolate8(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer, namespace) {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 8, prefix, i0, i1, i2, i3, i4, i5, i6, suffix);\n  }\n\n  return ɵɵattributeInterpolate8;\n}\n/**\n * Update an interpolated attribute on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolateV(\n *  'title', ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * @param attrName The name of the attribute to update.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\n\n\nfunction ɵɵattributeInterpolateV(attrName, values, sanitizer, namespace) {\n  const lView = getLView();\n  const interpolated = interpolationV(lView, values);\n\n  if (interpolated !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolated, sanitizer, namespace);\n\n    if (ngDevMode) {\n      const interpolationInBetween = [values[0]]; // prefix\n\n      for (let i = 2; i < values.length; i += 2) {\n        interpolationInBetween.push(values[i]);\n      }\n\n      storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);\n    }\n  }\n\n  return ɵɵattributeInterpolateV;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction templateFirstCreatePass(index, tView, lView, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex) {\n  ngDevMode && assertFirstCreatePass(tView);\n  ngDevMode && ngDevMode.firstCreatePass++;\n  const tViewConsts = tView.consts; // TODO(pk): refactor getOrCreateTNode to have the \"create\" only version\n\n  const tNode = getOrCreateTNode(tView, index, 4\n  /* TNodeType.Container */\n  , tagName || null, getConstant(tViewConsts, attrsIndex));\n  resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex));\n  registerPostOrderHooks(tView, tNode);\n  const embeddedTView = tNode.tViews = createTView(2\n  /* TViewType.Embedded */\n  , tNode, templateFn, decls, vars, tView.directiveRegistry, tView.pipeRegistry, null, tView.schemas, tViewConsts);\n\n  if (tView.queries !== null) {\n    tView.queries.template(tView, tNode);\n    embeddedTView.queries = tView.queries.embeddedTView(tNode);\n  }\n\n  return tNode;\n}\n/**\n * Creates an LContainer for an ng-template (dynamically-inserted view), e.g.\n *\n * <ng-template #foo>\n *    <div></div>\n * </ng-template>\n *\n * @param index The index of the container in the data array\n * @param templateFn Inline template\n * @param decls The number of nodes, local refs, and pipes for this template\n * @param vars The number of bindings for this template\n * @param tagName The name of the container element, if applicable\n * @param attrsIndex Index of template attributes in the `consts` array.\n * @param localRefs Index of the local references in the `consts` array.\n * @param localRefExtractor A function which extracts local-refs values from the template.\n *        Defaults to the current element associated with the local-ref.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵtemplate(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {\n  const lView = getLView();\n  const tView = getTView();\n  const adjustedIndex = index + HEADER_OFFSET;\n  const tNode = tView.firstCreatePass ? templateFirstCreatePass(adjustedIndex, tView, lView, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];\n  setCurrentTNode(tNode, false);\n  const comment = lView[RENDERER].createComment(ngDevMode ? 'container' : '');\n  appendChild(tView, lView, comment, tNode);\n  attachPatchData(comment, lView);\n  addToViewTree(lView, lView[adjustedIndex] = createLContainer(comment, lView, comment, tNode));\n\n  if (isDirectiveHost(tNode)) {\n    createDirectivesInstances(tView, lView, tNode);\n  }\n\n  if (localRefsIndex != null) {\n    saveResolvedLocalsInData(lView, tNode, localRefExtractor);\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Store a value in the `data` at a given `index`. */\n\n\nfunction store(tView, lView, index, value) {\n  // We don't store any static data for local variables, so the first time\n  // we see the template, we should store as null to avoid a sparse array\n  if (index >= tView.data.length) {\n    tView.data[index] = null;\n    tView.blueprint[index] = null;\n  }\n\n  lView[index] = value;\n}\n/**\n * Retrieves a local reference from the current contextViewData.\n *\n * If the reference to retrieve is in a parent view, this instruction is used in conjunction\n * with a nextContext() call, which walks up the tree and updates the contextViewData instance.\n *\n * @param index The index of the local ref in contextViewData.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵreference(index) {\n  const contextLView = getContextLView();\n  return load(contextLView, HEADER_OFFSET + index);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Update a property on a selected element.\n *\n * Operates on the element selected by index via the {@link select} instruction.\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled\n *\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n * @returns This function returns itself so that it may be chained\n * (e.g. `property('name', ctx.name)('title', ctx.title)`)\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵproperty(propName, value, sanitizer) {\n  const lView = getLView();\n  const bindingIndex = nextBindingIndex();\n\n  if (bindingUpdated(lView, bindingIndex, value)) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, false);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);\n  }\n\n  return ɵɵproperty;\n}\n/**\n * Given `<div style=\"...\" my-dir>` and `MyDir` with `@Input('style')` we need to write to\n * directive input.\n */\n\n\nfunction setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased) {\n  const inputs = tNode.inputs;\n  const property = isClassBased ? 'class' : 'style'; // We support both 'class' and `className` hence the fallback.\n\n  setInputsForProperty(tView, lView, inputs[property], property, value);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction elementStartFirstCreatePass(index, tView, lView, native, name, attrsIndex, localRefsIndex) {\n  ngDevMode && assertFirstCreatePass(tView);\n  ngDevMode && ngDevMode.firstCreatePass++;\n  const tViewConsts = tView.consts;\n  const attrs = getConstant(tViewConsts, attrsIndex);\n  const tNode = getOrCreateTNode(tView, index, 2\n  /* TNodeType.Element */\n  , name, attrs);\n  const hasDirectives = resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex));\n\n  if (ngDevMode) {\n    validateElementIsKnown(native, lView, tNode.value, tView.schemas, hasDirectives);\n  }\n\n  if (tNode.attrs !== null) {\n    computeStaticStyling(tNode, tNode.attrs, false);\n  }\n\n  if (tNode.mergedAttrs !== null) {\n    computeStaticStyling(tNode, tNode.mergedAttrs, true);\n  }\n\n  if (tView.queries !== null) {\n    tView.queries.elementStart(tView, tNode);\n  }\n\n  return tNode;\n}\n/**\n * Create DOM element. The instruction must later be followed by `elementEnd()` call.\n *\n * @param index Index of the element in the LView array\n * @param name Name of the DOM Node\n * @param attrsIndex Index of the element's attributes in the `consts` array.\n * @param localRefsIndex Index of the element's local references in the `consts` array.\n * @returns This function returns itself so that it may be chained.\n *\n * Attributes and localRefs are passed as an array of strings where elements with an even index\n * hold an attribute name and elements with an odd index hold an attribute value, ex.:\n * ['id', 'warning5', 'class', 'alert']\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵelementStart(index, name, attrsIndex, localRefsIndex) {\n  const lView = getLView();\n  const tView = getTView();\n  const adjustedIndex = HEADER_OFFSET + index;\n  ngDevMode && assertEqual(getBindingIndex(), tView.bindingStartIndex, 'elements should be created before any bindings');\n  ngDevMode && assertIndexInRange(lView, adjustedIndex);\n  const renderer = lView[RENDERER];\n  const native = lView[adjustedIndex] = createElementNode(renderer, name, getNamespace$1());\n  const tNode = tView.firstCreatePass ? elementStartFirstCreatePass(adjustedIndex, tView, lView, native, name, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];\n  setCurrentTNode(tNode, true);\n  const mergedAttrs = tNode.mergedAttrs;\n\n  if (mergedAttrs !== null) {\n    setUpAttributes(renderer, native, mergedAttrs);\n  }\n\n  const classes = tNode.classes;\n\n  if (classes !== null) {\n    writeDirectClass(renderer, native, classes);\n  }\n\n  const styles = tNode.styles;\n\n  if (styles !== null) {\n    writeDirectStyle(renderer, native, styles);\n  }\n\n  if ((tNode.flags & 64\n  /* TNodeFlags.isDetached */\n  ) !== 64\n  /* TNodeFlags.isDetached */\n  ) {\n    // In the i18n case, the translation may have removed this element, so only add it if it is not\n    // detached. See `TNodeType.Placeholder` and `LFrame.inI18n` for more context.\n    appendChild(tView, lView, native, tNode);\n  } // any immediate children of a component or template container must be pre-emptively\n  // monkey-patched with the component view data so that the element can be inspected\n  // later on using any element discovery utility methods (see `element_discovery.ts`)\n\n\n  if (getElementDepthCount() === 0) {\n    attachPatchData(native, lView);\n  }\n\n  increaseElementDepthCount();\n\n  if (isDirectiveHost(tNode)) {\n    createDirectivesInstances(tView, lView, tNode);\n    executeContentQueries(tView, tNode, lView);\n  }\n\n  if (localRefsIndex !== null) {\n    saveResolvedLocalsInData(lView, tNode);\n  }\n\n  return ɵɵelementStart;\n}\n/**\n * Mark the end of the element.\n * @returns This function returns itself so that it may be chained.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵelementEnd() {\n  let currentTNode = getCurrentTNode();\n  ngDevMode && assertDefined(currentTNode, 'No parent node to close.');\n\n  if (isCurrentTNodeParent()) {\n    setCurrentTNodeAsNotParent();\n  } else {\n    ngDevMode && assertHasParent(getCurrentTNode());\n    currentTNode = currentTNode.parent;\n    setCurrentTNode(currentTNode, false);\n  }\n\n  const tNode = currentTNode;\n  ngDevMode && assertTNodeType(tNode, 3\n  /* TNodeType.AnyRNode */\n  );\n  decreaseElementDepthCount();\n  const tView = getTView();\n\n  if (tView.firstCreatePass) {\n    registerPostOrderHooks(tView, currentTNode);\n\n    if (isContentQueryHost(currentTNode)) {\n      tView.queries.elementEnd(currentTNode);\n    }\n  }\n\n  if (tNode.classesWithoutHost != null && hasClassInput(tNode)) {\n    setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.classesWithoutHost, true);\n  }\n\n  if (tNode.stylesWithoutHost != null && hasStyleInput(tNode)) {\n    setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.stylesWithoutHost, false);\n  }\n\n  return ɵɵelementEnd;\n}\n/**\n * Creates an empty element using {@link elementStart} and {@link elementEnd}\n *\n * @param index Index of the element in the data array\n * @param name Name of the DOM Node\n * @param attrsIndex Index of the element's attributes in the `consts` array.\n * @param localRefsIndex Index of the element's local references in the `consts` array.\n * @returns This function returns itself so that it may be chained.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵelement(index, name, attrsIndex, localRefsIndex) {\n  ɵɵelementStart(index, name, attrsIndex, localRefsIndex);\n  ɵɵelementEnd();\n  return ɵɵelement;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction elementContainerStartFirstCreatePass(index, tView, lView, attrsIndex, localRefsIndex) {\n  ngDevMode && ngDevMode.firstCreatePass++;\n  const tViewConsts = tView.consts;\n  const attrs = getConstant(tViewConsts, attrsIndex);\n  const tNode = getOrCreateTNode(tView, index, 8\n  /* TNodeType.ElementContainer */\n  , 'ng-container', attrs); // While ng-container doesn't necessarily support styling, we use the style context to identify\n  // and execute directives on the ng-container.\n\n  if (attrs !== null) {\n    computeStaticStyling(tNode, attrs, true);\n  }\n\n  const localRefs = getConstant(tViewConsts, localRefsIndex);\n  resolveDirectives(tView, lView, tNode, localRefs);\n\n  if (tView.queries !== null) {\n    tView.queries.elementStart(tView, tNode);\n  }\n\n  return tNode;\n}\n/**\n * Creates a logical container for other nodes (<ng-container>) backed by a comment node in the DOM.\n * The instruction must later be followed by `elementContainerEnd()` call.\n *\n * @param index Index of the element in the LView array\n * @param attrsIndex Index of the container attributes in the `consts` array.\n * @param localRefsIndex Index of the container's local references in the `consts` array.\n * @returns This function returns itself so that it may be chained.\n *\n * Even if this instruction accepts a set of attributes no actual attribute values are propagated to\n * the DOM (as a comment node can't have attributes). Attributes are here only for directive\n * matching purposes and setting initial inputs of directives.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵelementContainerStart(index, attrsIndex, localRefsIndex) {\n  const lView = getLView();\n  const tView = getTView();\n  const adjustedIndex = index + HEADER_OFFSET;\n  ngDevMode && assertIndexInRange(lView, adjustedIndex);\n  ngDevMode && assertEqual(getBindingIndex(), tView.bindingStartIndex, 'element containers should be created before any bindings');\n  const tNode = tView.firstCreatePass ? elementContainerStartFirstCreatePass(adjustedIndex, tView, lView, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];\n  setCurrentTNode(tNode, true);\n  ngDevMode && ngDevMode.rendererCreateComment++;\n  const native = lView[adjustedIndex] = lView[RENDERER].createComment(ngDevMode ? 'ng-container' : '');\n  appendChild(tView, lView, native, tNode);\n  attachPatchData(native, lView);\n\n  if (isDirectiveHost(tNode)) {\n    createDirectivesInstances(tView, lView, tNode);\n    executeContentQueries(tView, tNode, lView);\n  }\n\n  if (localRefsIndex != null) {\n    saveResolvedLocalsInData(lView, tNode);\n  }\n\n  return ɵɵelementContainerStart;\n}\n/**\n * Mark the end of the <ng-container>.\n * @returns This function returns itself so that it may be chained.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵelementContainerEnd() {\n  let currentTNode = getCurrentTNode();\n  const tView = getTView();\n\n  if (isCurrentTNodeParent()) {\n    setCurrentTNodeAsNotParent();\n  } else {\n    ngDevMode && assertHasParent(currentTNode);\n    currentTNode = currentTNode.parent;\n    setCurrentTNode(currentTNode, false);\n  }\n\n  ngDevMode && assertTNodeType(currentTNode, 8\n  /* TNodeType.ElementContainer */\n  );\n\n  if (tView.firstCreatePass) {\n    registerPostOrderHooks(tView, currentTNode);\n\n    if (isContentQueryHost(currentTNode)) {\n      tView.queries.elementEnd(currentTNode);\n    }\n  }\n\n  return ɵɵelementContainerEnd;\n}\n/**\n * Creates an empty logical container using {@link elementContainerStart}\n * and {@link elementContainerEnd}\n *\n * @param index Index of the element in the LView array\n * @param attrsIndex Index of the container attributes in the `consts` array.\n * @param localRefsIndex Index of the container's local references in the `consts` array.\n * @returns This function returns itself so that it may be chained.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵelementContainer(index, attrsIndex, localRefsIndex) {\n  ɵɵelementContainerStart(index, attrsIndex, localRefsIndex);\n  ɵɵelementContainerEnd();\n  return ɵɵelementContainer;\n}\n/**\n * Returns the current OpaqueViewState instance.\n *\n * Used in conjunction with the restoreView() instruction to save a snapshot\n * of the current view and restore it when listeners are invoked. This allows\n * walking the declaration view tree in listeners to get vars from parent views.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵgetCurrentView() {\n  return getLView();\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Determine if the argument is shaped like a Promise\n */\n\n\nfunction isPromise(obj) {\n  // allow any Promise/A+ compliant thenable.\n  // It's up to the caller to ensure that obj.then conforms to the spec\n  return !!obj && typeof obj.then === 'function';\n}\n/**\n * Determine if the argument is a Subscribable\n */\n\n\nfunction isSubscribable(obj) {\n  return !!obj && typeof obj.subscribe === 'function';\n}\n/**\n * Determine if the argument is an Observable\n *\n * Strictly this tests that the `obj` is `Subscribable`, since `Observable`\n * types need additional methods, such as `lift()`. But it is adequate for our\n * needs since within the Angular framework code we only ever need to use the\n * `subscribe()` method, and RxJS has mechanisms to wrap `Subscribable` objects\n * into `Observable` as needed.\n */\n\n\nconst isObservable = isSubscribable;\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Adds an event listener to the current node.\n *\n * If an output exists on one of the node's directives, it also subscribes to the output\n * and saves the subscription for later cleanup.\n *\n * @param eventName Name of the event\n * @param listenerFn The function to be called when event emits\n * @param useCapture Whether or not to use capture in event listener\n * @param eventTargetResolver Function that returns global target information in case this listener\n * should be attached to a global object like window, document or body\n *\n * @codeGenApi\n */\n\nfunction ɵɵlistener(eventName, listenerFn, useCapture, eventTargetResolver) {\n  const lView = getLView();\n  const tView = getTView();\n  const tNode = getCurrentTNode();\n  listenerInternal(tView, lView, lView[RENDERER], tNode, eventName, listenerFn, !!useCapture, eventTargetResolver);\n  return ɵɵlistener;\n}\n/**\n * Registers a synthetic host listener (e.g. `(@foo.start)`) on a component or directive.\n *\n * This instruction is for compatibility purposes and is designed to ensure that a\n * synthetic host listener (e.g. `@HostListener('@foo.start')`) properly gets rendered\n * in the component's renderer. Normally all host listeners are evaluated with the\n * parent component's renderer, but, in the case of animation @triggers, they need\n * to be evaluated with the sub component's renderer (because that's where the\n * animation triggers are defined).\n *\n * Do not use this instruction as a replacement for `listener`. This instruction\n * only exists to ensure compatibility with the ViewEngine's host binding behavior.\n *\n * @param eventName Name of the event\n * @param listenerFn The function to be called when event emits\n * @param useCapture Whether or not to use capture in event listener\n * @param eventTargetResolver Function that returns global target information in case this listener\n * should be attached to a global object like window, document or body\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵsyntheticHostListener(eventName, listenerFn) {\n  const tNode = getCurrentTNode();\n  const lView = getLView();\n  const tView = getTView();\n  const currentDef = getCurrentDirectiveDef(tView.data);\n  const renderer = loadComponentRenderer(currentDef, tNode, lView);\n  listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn, false);\n  return ɵɵsyntheticHostListener;\n}\n/**\n * A utility function that checks if a given element has already an event handler registered for an\n * event with a specified name. The TView.cleanup data structure is used to find out which events\n * are registered for a given element.\n */\n\n\nfunction findExistingListener(tView, lView, eventName, tNodeIdx) {\n  const tCleanup = tView.cleanup;\n\n  if (tCleanup != null) {\n    for (let i = 0; i < tCleanup.length - 1; i += 2) {\n      const cleanupEventName = tCleanup[i];\n\n      if (cleanupEventName === eventName && tCleanup[i + 1] === tNodeIdx) {\n        // We have found a matching event name on the same node but it might not have been\n        // registered yet, so we must explicitly verify entries in the LView cleanup data\n        // structures.\n        const lCleanup = lView[CLEANUP];\n        const listenerIdxInLCleanup = tCleanup[i + 2];\n        return lCleanup.length > listenerIdxInLCleanup ? lCleanup[listenerIdxInLCleanup] : null;\n      } // TView.cleanup can have a mix of 4-elements entries (for event handler cleanups) or\n      // 2-element entries (for directive and queries destroy hooks). As such we can encounter\n      // blocks of 4 or 2 items in the tView.cleanup and this is why we iterate over 2 elements\n      // first and jump another 2 elements if we detect listeners cleanup (4 elements). Also check\n      // documentation of TView.cleanup for more details of this data structure layout.\n\n\n      if (typeof cleanupEventName === 'string') {\n        i += 2;\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn, useCapture, eventTargetResolver) {\n  const isTNodeDirectiveHost = isDirectiveHost(tNode);\n  const firstCreatePass = tView.firstCreatePass;\n  const tCleanup = firstCreatePass && getOrCreateTViewCleanup(tView);\n  const context = lView[CONTEXT]; // When the ɵɵlistener instruction was generated and is executed we know that there is either a\n  // native listener or a directive output on this element. As such we we know that we will have to\n  // register a listener and store its cleanup function on LView.\n\n  const lCleanup = getOrCreateLViewCleanup(lView);\n  ngDevMode && assertTNodeType(tNode, 3\n  /* TNodeType.AnyRNode */\n  | 12\n  /* TNodeType.AnyContainer */\n  );\n  let processOutputs = true; // Adding a native event listener is applicable when:\n  // - The corresponding TNode represents a DOM element.\n  // - The event target has a resolver (usually resulting in a global object,\n  //   such as `window` or `document`).\n\n  if (tNode.type & 3\n  /* TNodeType.AnyRNode */\n  || eventTargetResolver) {\n    const native = getNativeByTNode(tNode, lView);\n    const target = eventTargetResolver ? eventTargetResolver(native) : native;\n    const lCleanupIndex = lCleanup.length;\n    const idxOrTargetGetter = eventTargetResolver ? _lView => eventTargetResolver(unwrapRNode(_lView[tNode.index])) : tNode.index; // In order to match current behavior, native DOM event listeners must be added for all\n    // events (including outputs).\n\n    if (isProceduralRenderer(renderer)) {\n      // There might be cases where multiple directives on the same element try to register an event\n      // handler function for the same event. In this situation we want to avoid registration of\n      // several native listeners as each registration would be intercepted by NgZone and\n      // trigger change detection. This would mean that a single user action would result in several\n      // change detections being invoked. To avoid this situation we want to have only one call to\n      // native handler registration (for the same element and same type of event).\n      //\n      // In order to have just one native event handler in presence of multiple handler functions,\n      // we just register a first handler function as a native event listener and then chain\n      // (coalesce) other handler functions on top of the first native handler function.\n      let existingListener = null; // Please note that the coalescing described here doesn't happen for events specifying an\n      // alternative target (ex. (document:click)) - this is to keep backward compatibility with the\n      // view engine.\n      // Also, we don't have to search for existing listeners is there are no directives\n      // matching on a given node as we can't register multiple event handlers for the same event in\n      // a template (this would mean having duplicate attributes).\n\n      if (!eventTargetResolver && isTNodeDirectiveHost) {\n        existingListener = findExistingListener(tView, lView, eventName, tNode.index);\n      }\n\n      if (existingListener !== null) {\n        // Attach a new listener to coalesced listeners list, maintaining the order in which\n        // listeners are registered. For performance reasons, we keep a reference to the last\n        // listener in that list (in `__ngLastListenerFn__` field), so we can avoid going through\n        // the entire set each time we need to add a new listener.\n        const lastListenerFn = existingListener.__ngLastListenerFn__ || existingListener;\n        lastListenerFn.__ngNextListenerFn__ = listenerFn;\n        existingListener.__ngLastListenerFn__ = listenerFn;\n        processOutputs = false;\n      } else {\n        listenerFn = wrapListener(tNode, lView, context, listenerFn, false\n        /** preventDefault */\n        );\n        const cleanupFn = renderer.listen(target, eventName, listenerFn);\n        ngDevMode && ngDevMode.rendererAddEventListener++;\n        lCleanup.push(listenerFn, cleanupFn);\n        tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, lCleanupIndex + 1);\n      }\n    } else {\n      listenerFn = wrapListener(tNode, lView, context, listenerFn, true\n      /** preventDefault */\n      );\n      target.addEventListener(eventName, listenerFn, useCapture);\n      ngDevMode && ngDevMode.rendererAddEventListener++;\n      lCleanup.push(listenerFn);\n      tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, useCapture);\n    }\n  } else {\n    // Even if there is no native listener to add, we still need to wrap the listener so that OnPush\n    // ancestors are marked dirty when an event occurs.\n    listenerFn = wrapListener(tNode, lView, context, listenerFn, false\n    /** preventDefault */\n    );\n  } // subscribe to directive outputs\n\n\n  const outputs = tNode.outputs;\n  let props;\n\n  if (processOutputs && outputs !== null && (props = outputs[eventName])) {\n    const propsLength = props.length;\n\n    if (propsLength) {\n      for (let i = 0; i < propsLength; i += 2) {\n        const index = props[i];\n        ngDevMode && assertIndexInRange(lView, index);\n        const minifiedName = props[i + 1];\n        const directiveInstance = lView[index];\n        const output = directiveInstance[minifiedName];\n\n        if (ngDevMode && !isObservable(output)) {\n          throw new Error(`@Output ${minifiedName} not initialized in '${directiveInstance.constructor.name}'.`);\n        }\n\n        const subscription = output.subscribe(listenerFn);\n        const idx = lCleanup.length;\n        lCleanup.push(listenerFn, subscription);\n        tCleanup && tCleanup.push(eventName, tNode.index, idx, -(idx + 1));\n      }\n    }\n  }\n}\n\nfunction executeListenerWithErrorHandling(lView, context, listenerFn, e) {\n  try {\n    profiler(6\n    /* ProfilerEvent.OutputStart */\n    , context, listenerFn); // Only explicitly returning false from a listener should preventDefault\n\n    return listenerFn(e) !== false;\n  } catch (error) {\n    handleError(lView, error);\n    return false;\n  } finally {\n    profiler(7\n    /* ProfilerEvent.OutputEnd */\n    , context, listenerFn);\n  }\n}\n/**\n * Wraps an event listener with a function that marks ancestors dirty and prevents default behavior,\n * if applicable.\n *\n * @param tNode The TNode associated with this listener\n * @param lView The LView that contains this listener\n * @param listenerFn The listener function to call\n * @param wrapWithPreventDefault Whether or not to prevent default behavior\n * (the procedural renderer does this already, so in those cases, we should skip)\n */\n\n\nfunction wrapListener(tNode, lView, context, listenerFn, wrapWithPreventDefault) {\n  // Note: we are performing most of the work in the listener function itself\n  // to optimize listener registration.\n  return function wrapListenerIn_markDirtyAndPreventDefault(e) {\n    // Ivy uses `Function` as a special token that allows us to unwrap the function\n    // so that it can be invoked programmatically by `DebugNode.triggerEventHandler`.\n    if (e === Function) {\n      return listenerFn;\n    } // In order to be backwards compatible with View Engine, events on component host nodes\n    // must also mark the component view itself dirty (i.e. the view that it owns).\n\n\n    const startView = tNode.flags & 2\n    /* TNodeFlags.isComponentHost */\n    ? getComponentLViewByIndex(tNode.index, lView) : lView;\n    markViewDirty(startView);\n    let result = executeListenerWithErrorHandling(lView, context, listenerFn, e); // A just-invoked listener function might have coalesced listeners so we need to check for\n    // their presence and invoke as needed.\n\n    let nextListenerFn = wrapListenerIn_markDirtyAndPreventDefault.__ngNextListenerFn__;\n\n    while (nextListenerFn) {\n      // We should prevent default if any of the listeners explicitly return false\n      result = executeListenerWithErrorHandling(lView, context, nextListenerFn, e) && result;\n      nextListenerFn = nextListenerFn.__ngNextListenerFn__;\n    }\n\n    if (wrapWithPreventDefault && result === false) {\n      e.preventDefault(); // Necessary for legacy browsers that don't support preventDefault (e.g. IE)\n\n      e.returnValue = false;\n    }\n\n    return result;\n  };\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Retrieves a context at the level specified and saves it as the global, contextViewData.\n * Will get the next level up if level is not specified.\n *\n * This is used to save contexts of parent views so they can be bound in embedded views, or\n * in conjunction with reference() to bind a ref from a parent view.\n *\n * @param level The relative level of the view from which to grab context compared to contextVewData\n * @returns context\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵnextContext(level = 1) {\n  return nextContextImpl(level);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Checks a given node against matching projection slots and returns the\n * determined slot index. Returns \"null\" if no slot matched the given node.\n *\n * This function takes into account the parsed ngProjectAs selector from the\n * node's attributes. If present, it will check whether the ngProjectAs selector\n * matches any of the projection slot selectors.\n */\n\n\nfunction matchingProjectionSlotIndex(tNode, projectionSlots) {\n  let wildcardNgContentIndex = null;\n  const ngProjectAsAttrVal = getProjectAsAttrValue(tNode);\n\n  for (let i = 0; i < projectionSlots.length; i++) {\n    const slotValue = projectionSlots[i]; // The last wildcard projection slot should match all nodes which aren't matching\n    // any selector. This is necessary to be backwards compatible with view engine.\n\n    if (slotValue === '*') {\n      wildcardNgContentIndex = i;\n      continue;\n    } // If we ran into an `ngProjectAs` attribute, we should match its parsed selector\n    // to the list of selectors, otherwise we fall back to matching against the node.\n\n\n    if (ngProjectAsAttrVal === null ? isNodeMatchingSelectorList(tNode, slotValue,\n    /* isProjectionMode */\n    true) : isSelectorInSelectorList(ngProjectAsAttrVal, slotValue)) {\n      return i; // first matching selector \"captures\" a given node\n    }\n  }\n\n  return wildcardNgContentIndex;\n}\n/**\n * Instruction to distribute projectable nodes among <ng-content> occurrences in a given template.\n * It takes all the selectors from the entire component's template and decides where\n * each projected node belongs (it re-distributes nodes among \"buckets\" where each \"bucket\" is\n * backed by a selector).\n *\n * This function requires CSS selectors to be provided in 2 forms: parsed (by a compiler) and text,\n * un-parsed form.\n *\n * The parsed form is needed for efficient matching of a node against a given CSS selector.\n * The un-parsed, textual form is needed for support of the ngProjectAs attribute.\n *\n * Having a CSS selector in 2 different formats is not ideal, but alternatives have even more\n * drawbacks:\n * - having only a textual form would require runtime parsing of CSS selectors;\n * - we can't have only a parsed as we can't re-construct textual form from it (as entered by a\n * template author).\n *\n * @param projectionSlots? A collection of projection slots. A projection slot can be based\n *        on a parsed CSS selectors or set to the wildcard selector (\"*\") in order to match\n *        all nodes which do not match any selector. If not specified, a single wildcard\n *        selector projection slot will be defined.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵprojectionDef(projectionSlots) {\n  const componentNode = getLView()[DECLARATION_COMPONENT_VIEW][T_HOST];\n\n  if (!componentNode.projection) {\n    // If no explicit projection slots are defined, fall back to a single\n    // projection slot with the wildcard selector.\n    const numProjectionSlots = projectionSlots ? projectionSlots.length : 1;\n    const projectionHeads = componentNode.projection = newArray(numProjectionSlots, null);\n    const tails = projectionHeads.slice();\n    let componentChild = componentNode.child;\n\n    while (componentChild !== null) {\n      const slotIndex = projectionSlots ? matchingProjectionSlotIndex(componentChild, projectionSlots) : 0;\n\n      if (slotIndex !== null) {\n        if (tails[slotIndex]) {\n          tails[slotIndex].projectionNext = componentChild;\n        } else {\n          projectionHeads[slotIndex] = componentChild;\n        }\n\n        tails[slotIndex] = componentChild;\n      }\n\n      componentChild = componentChild.next;\n    }\n  }\n}\n/**\n * Inserts previously re-distributed projected nodes. This instruction must be preceded by a call\n * to the projectionDef instruction.\n *\n * @param nodeIndex\n * @param selectorIndex:\n *        - 0 when the selector is `*` (or unspecified as this is the default value),\n *        - 1 based index of the selector from the {@link projectionDef}\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵprojection(nodeIndex, selectorIndex = 0, attrs) {\n  const lView = getLView();\n  const tView = getTView();\n  const tProjectionNode = getOrCreateTNode(tView, HEADER_OFFSET + nodeIndex, 16\n  /* TNodeType.Projection */\n  , null, attrs || null); // We can't use viewData[HOST_NODE] because projection nodes can be nested in embedded views.\n\n  if (tProjectionNode.projection === null) tProjectionNode.projection = selectorIndex; // `<ng-content>` has no content\n\n  setCurrentTNodeAsNotParent();\n\n  if ((tProjectionNode.flags & 64\n  /* TNodeFlags.isDetached */\n  ) !== 64\n  /* TNodeFlags.isDetached */\n  ) {\n    // re-distribution of projectable nodes is stored on a component's view level\n    applyProjection(tView, lView, tProjectionNode);\n  }\n}\n/**\n *\n * Update an interpolated property on an element with a lone bound value\n *\n * Used when the value passed to a property has 1 interpolated value in it, an no additional text\n * surrounds that interpolated value:\n *\n * ```html\n * <div title=\"{{v0}}\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate('title', v0);\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\n\n\nfunction ɵɵpropertyInterpolate(propName, v0, sanitizer) {\n  ɵɵpropertyInterpolate1(propName, '', v0, '', sanitizer);\n  return ɵɵpropertyInterpolate;\n}\n/**\n *\n * Update an interpolated property on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate1('title', 'prefix', v0, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\n\n\nfunction ɵɵpropertyInterpolate1(propName, prefix, v0, suffix, sanitizer) {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 1, prefix, suffix);\n  }\n\n  return ɵɵpropertyInterpolate1;\n}\n/**\n *\n * Update an interpolated property on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate2('title', 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\n\n\nfunction ɵɵpropertyInterpolate2(propName, prefix, v0, i0, v1, suffix, sanitizer) {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 2, prefix, i0, suffix);\n  }\n\n  return ɵɵpropertyInterpolate2;\n}\n/**\n *\n * Update an interpolated property on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate3(\n * 'title', 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\n\n\nfunction ɵɵpropertyInterpolate3(propName, prefix, v0, i0, v1, i1, v2, suffix, sanitizer) {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 3, prefix, i0, i1, suffix);\n  }\n\n  return ɵɵpropertyInterpolate3;\n}\n/**\n *\n * Update an interpolated property on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate4(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\n\n\nfunction ɵɵpropertyInterpolate4(propName, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, sanitizer) {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 4, prefix, i0, i1, i2, suffix);\n  }\n\n  return ɵɵpropertyInterpolate4;\n}\n/**\n *\n * Update an interpolated property on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate5(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\n\n\nfunction ɵɵpropertyInterpolate5(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, sanitizer) {\n  const lView = getLView();\n  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 5, prefix, i0, i1, i2, i3, suffix);\n  }\n\n  return ɵɵpropertyInterpolate5;\n}\n/**\n *\n * Update an interpolated property on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate6(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\n\n\nfunction ɵɵpropertyInterpolate6(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, sanitizer) {\n  const lView = getLView();\n  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 6, prefix, i0, i1, i2, i3, i4, suffix);\n  }\n\n  return ɵɵpropertyInterpolate6;\n}\n/**\n *\n * Update an interpolated property on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate7(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\n\n\nfunction ɵɵpropertyInterpolate7(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer) {\n  const lView = getLView();\n  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 7, prefix, i0, i1, i2, i3, i4, i5, suffix);\n  }\n\n  return ɵɵpropertyInterpolate7;\n}\n/**\n *\n * Update an interpolated property on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate8(\n *  'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\n\n\nfunction ɵɵpropertyInterpolate8(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer) {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 8, prefix, i0, i1, i2, i3, i4, i5, i6, suffix);\n  }\n\n  return ɵɵpropertyInterpolate8;\n}\n/**\n * Update an interpolated property on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolateV(\n *  'title', ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update.\n * @param values The collection of values and the strings inbetween those values, beginning with a\n * string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\n\n\nfunction ɵɵpropertyInterpolateV(propName, values, sanitizer) {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n\n    if (ngDevMode) {\n      const interpolationInBetween = [values[0]]; // prefix\n\n      for (let i = 2; i < values.length; i += 2) {\n        interpolationInBetween.push(values[i]);\n      }\n\n      storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);\n    }\n  }\n\n  return ɵɵpropertyInterpolateV;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * NOTE: The word `styling` is used interchangeably as style or class styling.\n *\n * This file contains code to link styling instructions together so that they can be replayed in\n * priority order. The file exists because Ivy styling instruction execution order does not match\n * that of the priority order. The purpose of this code is to create a linked list so that the\n * instructions can be traversed in priority order when computing the styles.\n *\n * Assume we are dealing with the following code:\n * ```\n * @Component({\n *   template: `\n *     <my-cmp [style]=\" {color: '#001'} \"\n *             [style.color]=\" #002 \"\n *             dir-style-color-1\n *             dir-style-color-2> `\n * })\n * class ExampleComponent {\n *   static ngComp = ... {\n *     ...\n *     // Compiler ensures that `ɵɵstyleProp` is after `ɵɵstyleMap`\n *     ɵɵstyleMap({color: '#001'});\n *     ɵɵstyleProp('color', '#002');\n *     ...\n *   }\n * }\n *\n * @Directive({\n *   selector: `[dir-style-color-1]',\n * })\n * class Style1Directive {\n *   @HostBinding('style') style = {color: '#005'};\n *   @HostBinding('style.color') color = '#006';\n *\n *   static ngDir = ... {\n *     ...\n *     // Compiler ensures that `ɵɵstyleProp` is after `ɵɵstyleMap`\n *     ɵɵstyleMap({color: '#005'});\n *     ɵɵstyleProp('color', '#006');\n *     ...\n *   }\n * }\n *\n * @Directive({\n *   selector: `[dir-style-color-2]',\n * })\n * class Style2Directive {\n *   @HostBinding('style') style = {color: '#007'};\n *   @HostBinding('style.color') color = '#008';\n *\n *   static ngDir = ... {\n *     ...\n *     // Compiler ensures that `ɵɵstyleProp` is after `ɵɵstyleMap`\n *     ɵɵstyleMap({color: '#007'});\n *     ɵɵstyleProp('color', '#008');\n *     ...\n *   }\n * }\n *\n * @Directive({\n *   selector: `my-cmp',\n * })\n * class MyComponent {\n *   @HostBinding('style') style = {color: '#003'};\n *   @HostBinding('style.color') color = '#004';\n *\n *   static ngComp = ... {\n *     ...\n *     // Compiler ensures that `ɵɵstyleProp` is after `ɵɵstyleMap`\n *     ɵɵstyleMap({color: '#003'});\n *     ɵɵstyleProp('color', '#004');\n *     ...\n *   }\n * }\n * ```\n *\n * The Order of instruction execution is:\n *\n * NOTE: the comment binding location is for illustrative purposes only.\n *\n * ```\n * // Template: (ExampleComponent)\n *     ɵɵstyleMap({color: '#001'});   // Binding index: 10\n *     ɵɵstyleProp('color', '#002');  // Binding index: 12\n * // MyComponent\n *     ɵɵstyleMap({color: '#003'});   // Binding index: 20\n *     ɵɵstyleProp('color', '#004');  // Binding index: 22\n * // Style1Directive\n *     ɵɵstyleMap({color: '#005'});   // Binding index: 24\n *     ɵɵstyleProp('color', '#006');  // Binding index: 26\n * // Style2Directive\n *     ɵɵstyleMap({color: '#007'});   // Binding index: 28\n *     ɵɵstyleProp('color', '#008');  // Binding index: 30\n * ```\n *\n * The correct priority order of concatenation is:\n *\n * ```\n * // MyComponent\n *     ɵɵstyleMap({color: '#003'});   // Binding index: 20\n *     ɵɵstyleProp('color', '#004');  // Binding index: 22\n * // Style1Directive\n *     ɵɵstyleMap({color: '#005'});   // Binding index: 24\n *     ɵɵstyleProp('color', '#006');  // Binding index: 26\n * // Style2Directive\n *     ɵɵstyleMap({color: '#007'});   // Binding index: 28\n *     ɵɵstyleProp('color', '#008');  // Binding index: 30\n * // Template: (ExampleComponent)\n *     ɵɵstyleMap({color: '#001'});   // Binding index: 10\n *     ɵɵstyleProp('color', '#002');  // Binding index: 12\n * ```\n *\n * What color should be rendered?\n *\n * Once the items are correctly sorted in the list, the answer is simply the last item in the\n * concatenation list which is `#002`.\n *\n * To do so we keep a linked list of all of the bindings which pertain to this element.\n * Notice that the bindings are inserted in the order of execution, but the `TView.data` allows\n * us to traverse them in the order of priority.\n *\n * |Idx|`TView.data`|`LView`          | Notes\n * |---|------------|-----------------|--------------\n * |...|            |                 |\n * |10 |`null`      |`{color: '#001'}`| `ɵɵstyleMap('color', {color: '#001'})`\n * |11 |`30 | 12`   | ...             |\n * |12 |`color`     |`'#002'`         | `ɵɵstyleProp('color', '#002')`\n * |13 |`10 | 0`    | ...             |\n * |...|            |                 |\n * |20 |`null`      |`{color: '#003'}`| `ɵɵstyleMap('color', {color: '#003'})`\n * |21 |`0 | 22`    | ...             |\n * |22 |`color`     |`'#004'`         | `ɵɵstyleProp('color', '#004')`\n * |23 |`20 | 24`   | ...             |\n * |24 |`null`      |`{color: '#005'}`| `ɵɵstyleMap('color', {color: '#005'})`\n * |25 |`22 | 26`   | ...             |\n * |26 |`color`     |`'#006'`         | `ɵɵstyleProp('color', '#006')`\n * |27 |`24 | 28`   | ...             |\n * |28 |`null`      |`{color: '#007'}`| `ɵɵstyleMap('color', {color: '#007'})`\n * |29 |`26 | 30`   | ...             |\n * |30 |`color`     |`'#008'`         | `ɵɵstyleProp('color', '#008')`\n * |31 |`28 | 10`   | ...             |\n *\n * The above data structure allows us to re-concatenate the styling no matter which data binding\n * changes.\n *\n * NOTE: in addition to keeping track of next/previous index the `TView.data` also stores prev/next\n * duplicate bit. The duplicate bit if true says there either is a binding with the same name or\n * there is a map (which may contain the name). This information is useful in knowing if other\n * styles with higher priority need to be searched for overwrites.\n *\n * NOTE: See `should support example in 'tnode_linked_list.ts' documentation` in\n * `tnode_linked_list_spec.ts` for working example.\n */\n\n\nlet __unused_const_as_closure_does_not_like_standalone_comment_blocks__;\n/**\n * Insert new `tStyleValue` at `TData` and link existing style bindings such that we maintain linked\n * list of styles and compute the duplicate flag.\n *\n * Note: this function is executed during `firstUpdatePass` only to populate the `TView.data`.\n *\n * The function works by keeping track of `tStylingRange` which contains two pointers pointing to\n * the head/tail of the template portion of the styles.\n *  - if `isHost === false` (we are template) then insertion is at tail of `TStylingRange`\n *  - if `isHost === true` (we are host binding) then insertion is at head of `TStylingRange`\n *\n * @param tData The `TData` to insert into.\n * @param tNode `TNode` associated with the styling element.\n * @param tStylingKey See `TStylingKey`.\n * @param index location of where `tStyleValue` should be stored (and linked into list.)\n * @param isHostBinding `true` if the insertion is for a `hostBinding`. (insertion is in front of\n *               template.)\n * @param isClassBinding True if the associated `tStylingKey` as a `class` styling.\n *                       `tNode.classBindings` should be used (or `tNode.styleBindings` otherwise.)\n */\n\n\nfunction insertTStylingBinding(tData, tNode, tStylingKeyWithStatic, index, isHostBinding, isClassBinding) {\n  ngDevMode && assertFirstUpdatePass(getTView());\n  let tBindings = isClassBinding ? tNode.classBindings : tNode.styleBindings;\n  let tmplHead = getTStylingRangePrev(tBindings);\n  let tmplTail = getTStylingRangeNext(tBindings);\n  tData[index] = tStylingKeyWithStatic;\n  let isKeyDuplicateOfStatic = false;\n  let tStylingKey;\n\n  if (Array.isArray(tStylingKeyWithStatic)) {\n    // We are case when the `TStylingKey` contains static fields as well.\n    const staticKeyValueArray = tStylingKeyWithStatic;\n    tStylingKey = staticKeyValueArray[1]; // unwrap.\n    // We need to check if our key is present in the static so that we can mark it as duplicate.\n\n    if (tStylingKey === null || keyValueArrayIndexOf(staticKeyValueArray, tStylingKey) > 0) {\n      // tStylingKey is present in the statics, need to mark it as duplicate.\n      isKeyDuplicateOfStatic = true;\n    }\n  } else {\n    tStylingKey = tStylingKeyWithStatic;\n  }\n\n  if (isHostBinding) {\n    // We are inserting host bindings\n    // If we don't have template bindings then `tail` is 0.\n    const hasTemplateBindings = tmplTail !== 0; // This is important to know because that means that the `head` can't point to the first\n    // template bindings (there are none.) Instead the head points to the tail of the template.\n\n    if (hasTemplateBindings) {\n      // template head's \"prev\" will point to last host binding or to 0 if no host bindings yet\n      const previousNode = getTStylingRangePrev(tData[tmplHead + 1]);\n      tData[index + 1] = toTStylingRange(previousNode, tmplHead); // if a host binding has already been registered, we need to update the next of that host\n      // binding to point to this one\n\n      if (previousNode !== 0) {\n        // We need to update the template-tail value to point to us.\n        tData[previousNode + 1] = setTStylingRangeNext(tData[previousNode + 1], index);\n      } // The \"previous\" of the template binding head should point to this host binding\n\n\n      tData[tmplHead + 1] = setTStylingRangePrev(tData[tmplHead + 1], index);\n    } else {\n      tData[index + 1] = toTStylingRange(tmplHead, 0); // if a host binding has already been registered, we need to update the next of that host\n      // binding to point to this one\n\n      if (tmplHead !== 0) {\n        // We need to update the template-tail value to point to us.\n        tData[tmplHead + 1] = setTStylingRangeNext(tData[tmplHead + 1], index);\n      } // if we don't have template, the head points to template-tail, and needs to be advanced.\n\n\n      tmplHead = index;\n    }\n  } else {\n    // We are inserting in template section.\n    // We need to set this binding's \"previous\" to the current template tail\n    tData[index + 1] = toTStylingRange(tmplTail, 0);\n    ngDevMode && assertEqual(tmplHead !== 0 && tmplTail === 0, false, 'Adding template bindings after hostBindings is not allowed.');\n\n    if (tmplHead === 0) {\n      tmplHead = index;\n    } else {\n      // We need to update the previous value \"next\" to point to this binding\n      tData[tmplTail + 1] = setTStylingRangeNext(tData[tmplTail + 1], index);\n    }\n\n    tmplTail = index;\n  } // Now we need to update / compute the duplicates.\n  // Starting with our location search towards head (least priority)\n\n\n  if (isKeyDuplicateOfStatic) {\n    tData[index + 1] = setTStylingRangePrevDuplicate(tData[index + 1]);\n  }\n\n  markDuplicates(tData, tStylingKey, index, true, isClassBinding);\n  markDuplicates(tData, tStylingKey, index, false, isClassBinding);\n  markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding);\n  tBindings = toTStylingRange(tmplHead, tmplTail);\n\n  if (isClassBinding) {\n    tNode.classBindings = tBindings;\n  } else {\n    tNode.styleBindings = tBindings;\n  }\n}\n/**\n * Look into the residual styling to see if the current `tStylingKey` is duplicate of residual.\n *\n * @param tNode `TNode` where the residual is stored.\n * @param tStylingKey `TStylingKey` to store.\n * @param tData `TData` associated with the current `LView`.\n * @param index location of where `tStyleValue` should be stored (and linked into list.)\n * @param isClassBinding True if the associated `tStylingKey` as a `class` styling.\n *                       `tNode.classBindings` should be used (or `tNode.styleBindings` otherwise.)\n */\n\n\nfunction markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding) {\n  const residual = isClassBinding ? tNode.residualClasses : tNode.residualStyles;\n\n  if (residual != null\n  /* or undefined */\n  && typeof tStylingKey == 'string' && keyValueArrayIndexOf(residual, tStylingKey) >= 0) {\n    // We have duplicate in the residual so mark ourselves as duplicate.\n    tData[index + 1] = setTStylingRangeNextDuplicate(tData[index + 1]);\n  }\n}\n/**\n * Marks `TStyleValue`s as duplicates if another style binding in the list has the same\n * `TStyleValue`.\n *\n * NOTE: this function is intended to be called twice once with `isPrevDir` set to `true` and once\n * with it set to `false` to search both the previous as well as next items in the list.\n *\n * No duplicate case\n * ```\n *   [style.color]\n *   [style.width.px] <<- index\n *   [style.height.px]\n * ```\n *\n * In the above case adding `[style.width.px]` to the existing `[style.color]` produces no\n * duplicates because `width` is not found in any other part of the linked list.\n *\n * Duplicate case\n * ```\n *   [style.color]\n *   [style.width.em]\n *   [style.width.px] <<- index\n * ```\n * In the above case adding `[style.width.px]` will produce a duplicate with `[style.width.em]`\n * because `width` is found in the chain.\n *\n * Map case 1\n * ```\n *   [style.width.px]\n *   [style.color]\n *   [style]  <<- index\n * ```\n * In the above case adding `[style]` will produce a duplicate with any other bindings because\n * `[style]` is a Map and as such is fully dynamic and could produce `color` or `width`.\n *\n * Map case 2\n * ```\n *   [style]\n *   [style.width.px]\n *   [style.color]  <<- index\n * ```\n * In the above case adding `[style.color]` will produce a duplicate because there is already a\n * `[style]` binding which is a Map and as such is fully dynamic and could produce `color` or\n * `width`.\n *\n * NOTE: Once `[style]` (Map) is added into the system all things are mapped as duplicates.\n * NOTE: We use `style` as example, but same logic is applied to `class`es as well.\n *\n * @param tData `TData` where the linked list is stored.\n * @param tStylingKey `TStylingKeyPrimitive` which contains the value to compare to other keys in\n *        the linked list.\n * @param index Starting location in the linked list to search from\n * @param isPrevDir Direction.\n *        - `true` for previous (lower priority);\n *        - `false` for next (higher priority).\n */\n\n\nfunction markDuplicates(tData, tStylingKey, index, isPrevDir, isClassBinding) {\n  const tStylingAtIndex = tData[index + 1];\n  const isMap = tStylingKey === null;\n  let cursor = isPrevDir ? getTStylingRangePrev(tStylingAtIndex) : getTStylingRangeNext(tStylingAtIndex);\n  let foundDuplicate = false; // We keep iterating as long as we have a cursor\n  // AND either:\n  // - we found what we are looking for, OR\n  // - we are a map in which case we have to continue searching even after we find what we were\n  //   looking for since we are a wild card and everything needs to be flipped to duplicate.\n\n  while (cursor !== 0 && (foundDuplicate === false || isMap)) {\n    ngDevMode && assertIndexInRange(tData, cursor);\n    const tStylingValueAtCursor = tData[cursor];\n    const tStyleRangeAtCursor = tData[cursor + 1];\n\n    if (isStylingMatch(tStylingValueAtCursor, tStylingKey)) {\n      foundDuplicate = true;\n      tData[cursor + 1] = isPrevDir ? setTStylingRangeNextDuplicate(tStyleRangeAtCursor) : setTStylingRangePrevDuplicate(tStyleRangeAtCursor);\n    }\n\n    cursor = isPrevDir ? getTStylingRangePrev(tStyleRangeAtCursor) : getTStylingRangeNext(tStyleRangeAtCursor);\n  }\n\n  if (foundDuplicate) {\n    // if we found a duplicate, than mark ourselves.\n    tData[index + 1] = isPrevDir ? setTStylingRangePrevDuplicate(tStylingAtIndex) : setTStylingRangeNextDuplicate(tStylingAtIndex);\n  }\n}\n/**\n * Determines if two `TStylingKey`s are a match.\n *\n * When computing whether a binding contains a duplicate, we need to compare if the instruction\n * `TStylingKey` has a match.\n *\n * Here are examples of `TStylingKey`s which match given `tStylingKeyCursor` is:\n * - `color`\n *    - `color`    // Match another color\n *    - `null`     // That means that `tStylingKey` is a `classMap`/`styleMap` instruction\n *    - `['', 'color', 'other', true]` // wrapped `color` so match\n *    - `['', null, 'other', true]`       // wrapped `null` so match\n *    - `['', 'width', 'color', 'value']` // wrapped static value contains a match on `'color'`\n * - `null`       // `tStylingKeyCursor` always match as it is `classMap`/`styleMap` instruction\n *\n * @param tStylingKeyCursor\n * @param tStylingKey\n */\n\n\nfunction isStylingMatch(tStylingKeyCursor, tStylingKey) {\n  ngDevMode && assertNotEqual(Array.isArray(tStylingKey), true, 'Expected that \\'tStylingKey\\' has been unwrapped');\n\n  if (tStylingKeyCursor === null || // If the cursor is `null` it means that we have map at that\n  // location so we must assume that we have a match.\n  tStylingKey == null || // If `tStylingKey` is `null` then it is a map therefor assume that it\n  // contains a match.\n  (Array.isArray(tStylingKeyCursor) ? tStylingKeyCursor[1] : tStylingKeyCursor) === tStylingKey // If the keys match explicitly than we are a match.\n  ) {\n    return true;\n  } else if (Array.isArray(tStylingKeyCursor) && typeof tStylingKey === 'string') {\n    // if we did not find a match, but `tStylingKeyCursor` is `KeyValueArray` that means cursor has\n    // statics and we need to check those as well.\n    return keyValueArrayIndexOf(tStylingKeyCursor, tStylingKey) >= 0; // see if we are matching the key\n  }\n\n  return false;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Global state of the parser. (This makes parser non-reentrant, but that is not an issue)\n\n\nconst parserState = {\n  textEnd: 0,\n  key: 0,\n  keyEnd: 0,\n  value: 0,\n  valueEnd: 0\n};\n/**\n * Retrieves the last parsed `key` of style.\n * @param text the text to substring the key from.\n */\n\nfunction getLastParsedKey(text) {\n  return text.substring(parserState.key, parserState.keyEnd);\n}\n/**\n * Retrieves the last parsed `value` of style.\n * @param text the text to substring the key from.\n */\n\n\nfunction getLastParsedValue(text) {\n  return text.substring(parserState.value, parserState.valueEnd);\n}\n/**\n * Initializes `className` string for parsing and parses the first token.\n *\n * This function is intended to be used in this format:\n * ```\n * for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {\n *   const key = getLastParsedKey();\n *   ...\n * }\n * ```\n * @param text `className` to parse\n * @returns index where the next invocation of `parseClassNameNext` should resume.\n */\n\n\nfunction parseClassName(text) {\n  resetParserState(text);\n  return parseClassNameNext(text, consumeWhitespace(text, 0, parserState.textEnd));\n}\n/**\n * Parses next `className` token.\n *\n * This function is intended to be used in this format:\n * ```\n * for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {\n *   const key = getLastParsedKey();\n *   ...\n * }\n * ```\n *\n * @param text `className` to parse\n * @param index where the parsing should resume.\n * @returns index where the next invocation of `parseClassNameNext` should resume.\n */\n\n\nfunction parseClassNameNext(text, index) {\n  const end = parserState.textEnd;\n\n  if (end === index) {\n    return -1;\n  }\n\n  index = parserState.keyEnd = consumeClassToken(text, parserState.key = index, end);\n  return consumeWhitespace(text, index, end);\n}\n/**\n * Initializes `cssText` string for parsing and parses the first key/values.\n *\n * This function is intended to be used in this format:\n * ```\n * for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i))) {\n *   const key = getLastParsedKey();\n *   const value = getLastParsedValue();\n *   ...\n * }\n * ```\n * @param text `cssText` to parse\n * @returns index where the next invocation of `parseStyleNext` should resume.\n */\n\n\nfunction parseStyle(text) {\n  resetParserState(text);\n  return parseStyleNext(text, consumeWhitespace(text, 0, parserState.textEnd));\n}\n/**\n * Parses the next `cssText` key/values.\n *\n * This function is intended to be used in this format:\n * ```\n * for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i))) {\n *   const key = getLastParsedKey();\n *   const value = getLastParsedValue();\n *   ...\n * }\n *\n * @param text `cssText` to parse\n * @param index where the parsing should resume.\n * @returns index where the next invocation of `parseStyleNext` should resume.\n */\n\n\nfunction parseStyleNext(text, startIndex) {\n  const end = parserState.textEnd;\n  let index = parserState.key = consumeWhitespace(text, startIndex, end);\n\n  if (end === index) {\n    // we reached an end so just quit\n    return -1;\n  }\n\n  index = parserState.keyEnd = consumeStyleKey(text, index, end);\n  index = consumeSeparator(text, index, end, 58\n  /* CharCode.COLON */\n  );\n  index = parserState.value = consumeWhitespace(text, index, end);\n  index = parserState.valueEnd = consumeStyleValue(text, index, end);\n  return consumeSeparator(text, index, end, 59\n  /* CharCode.SEMI_COLON */\n  );\n}\n/**\n * Reset the global state of the styling parser.\n * @param text The styling text to parse.\n */\n\n\nfunction resetParserState(text) {\n  parserState.key = 0;\n  parserState.keyEnd = 0;\n  parserState.value = 0;\n  parserState.valueEnd = 0;\n  parserState.textEnd = text.length;\n}\n/**\n * Returns index of next non-whitespace character.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index of next non-whitespace character (May be the same as `start` if no whitespace at\n *          that location.)\n */\n\n\nfunction consumeWhitespace(text, startIndex, endIndex) {\n  while (startIndex < endIndex && text.charCodeAt(startIndex) <= 32\n  /* CharCode.SPACE */\n  ) {\n    startIndex++;\n  }\n\n  return startIndex;\n}\n/**\n * Returns index of last char in class token.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after last char in class token.\n */\n\n\nfunction consumeClassToken(text, startIndex, endIndex) {\n  while (startIndex < endIndex && text.charCodeAt(startIndex) > 32\n  /* CharCode.SPACE */\n  ) {\n    startIndex++;\n  }\n\n  return startIndex;\n}\n/**\n * Consumes all of the characters belonging to style key and token.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after last style key character.\n */\n\n\nfunction consumeStyleKey(text, startIndex, endIndex) {\n  let ch;\n\n  while (startIndex < endIndex && ((ch = text.charCodeAt(startIndex)) === 45\n  /* CharCode.DASH */\n  || ch === 95\n  /* CharCode.UNDERSCORE */\n  || (ch & -33\n  /* CharCode.UPPER_CASE */\n  ) >= 65\n  /* CharCode.A */\n  && (ch & -33\n  /* CharCode.UPPER_CASE */\n  ) <= 90\n  /* CharCode.Z */\n  || ch >= 48\n  /* CharCode.ZERO */\n  && ch <= 57\n  /* CharCode.NINE */\n  )) {\n    startIndex++;\n  }\n\n  return startIndex;\n}\n/**\n * Consumes all whitespace and the separator `:` after the style key.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after separator and surrounding whitespace.\n */\n\n\nfunction consumeSeparator(text, startIndex, endIndex, separator) {\n  startIndex = consumeWhitespace(text, startIndex, endIndex);\n\n  if (startIndex < endIndex) {\n    if (ngDevMode && text.charCodeAt(startIndex) !== separator) {\n      malformedStyleError(text, String.fromCharCode(separator), startIndex);\n    }\n\n    startIndex++;\n  }\n\n  return startIndex;\n}\n/**\n * Consumes style value honoring `url()` and `\"\"` text.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after last style value character.\n */\n\n\nfunction consumeStyleValue(text, startIndex, endIndex) {\n  let ch1 = -1; // 1st previous character\n\n  let ch2 = -1; // 2nd previous character\n\n  let ch3 = -1; // 3rd previous character\n\n  let i = startIndex;\n  let lastChIndex = i;\n\n  while (i < endIndex) {\n    const ch = text.charCodeAt(i++);\n\n    if (ch === 59\n    /* CharCode.SEMI_COLON */\n    ) {\n      return lastChIndex;\n    } else if (ch === 34\n    /* CharCode.DOUBLE_QUOTE */\n    || ch === 39\n    /* CharCode.SINGLE_QUOTE */\n    ) {\n      lastChIndex = i = consumeQuotedText(text, ch, i, endIndex);\n    } else if (startIndex === i - 4 && // We have seen only 4 characters so far \"URL(\" (Ignore \"foo_URL()\")\n    ch3 === 85\n    /* CharCode.U */\n    && ch2 === 82\n    /* CharCode.R */\n    && ch1 === 76\n    /* CharCode.L */\n    && ch === 40\n    /* CharCode.OPEN_PAREN */\n    ) {\n      lastChIndex = i = consumeQuotedText(text, 41\n      /* CharCode.CLOSE_PAREN */\n      , i, endIndex);\n    } else if (ch > 32\n    /* CharCode.SPACE */\n    ) {\n      // if we have a non-whitespace character then capture its location\n      lastChIndex = i;\n    }\n\n    ch3 = ch2;\n    ch2 = ch1;\n    ch1 = ch & -33\n    /* CharCode.UPPER_CASE */\n    ;\n  }\n\n  return lastChIndex;\n}\n/**\n * Consumes all of the quoted characters.\n *\n * @param text Text to scan\n * @param quoteCharCode CharCode of either `\"` or `'` quote or `)` for `url(...)`.\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after quoted characters.\n */\n\n\nfunction consumeQuotedText(text, quoteCharCode, startIndex, endIndex) {\n  let ch1 = -1; // 1st previous character\n\n  let index = startIndex;\n\n  while (index < endIndex) {\n    const ch = text.charCodeAt(index++);\n\n    if (ch == quoteCharCode && ch1 !== 92\n    /* CharCode.BACK_SLASH */\n    ) {\n      return index;\n    }\n\n    if (ch == 92\n    /* CharCode.BACK_SLASH */\n    && ch1 === 92\n    /* CharCode.BACK_SLASH */\n    ) {\n      // two back slashes cancel each other out. For example `\"\\\\\"` should properly end the\n      // quotation. (It should not assume that the last `\"` is escaped.)\n      ch1 = 0;\n    } else {\n      ch1 = ch;\n    }\n  }\n\n  throw ngDevMode ? malformedStyleError(text, String.fromCharCode(quoteCharCode), endIndex) : new Error();\n}\n\nfunction malformedStyleError(text, expecting, index) {\n  ngDevMode && assertEqual(typeof text === 'string', true, 'String expected here');\n  throw throwError(`Malformed style at location ${index} in string '` + text.substring(0, index) + '[>>' + text.substring(index, index + 1) + '<<]' + text.slice(index + 1) + `'. Expecting '${expecting}'.`);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Update a style binding on an element with the provided value.\n *\n * If the style value is falsy then it will be removed from the element\n * (or assigned a different value depending if there are any styles placed\n * on the element with `styleMap` or any static styles that are\n * present from when the element was created with `styling`).\n *\n * Note that the styling element is updated as part of `stylingApply`.\n *\n * @param prop A valid CSS property.\n * @param value New value to write (`null` or an empty string to remove).\n * @param suffix Optional suffix. Used with scalar values to add unit such as `px`.\n *\n * Note that this will apply the provided style value to the host element if this function is called\n * within a host binding function.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵstyleProp(prop, value, suffix) {\n  checkStylingProperty(prop, value, suffix, false);\n  return ɵɵstyleProp;\n}\n/**\n * Update a class binding on an element with the provided value.\n *\n * This instruction is meant to handle the `[class.foo]=\"exp\"` case and,\n * therefore, the class binding itself must already be allocated using\n * `styling` within the creation block.\n *\n * @param prop A valid CSS class (only one).\n * @param value A true/false value which will turn the class on or off.\n *\n * Note that this will apply the provided class value to the host element if this function\n * is called within a host binding function.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵclassProp(className, value) {\n  checkStylingProperty(className, value, null, true);\n  return ɵɵclassProp;\n}\n/**\n * Update style bindings using an object literal on an element.\n *\n * This instruction is meant to apply styling via the `[style]=\"exp\"` template bindings.\n * When styles are applied to the element they will then be updated with respect to\n * any styles/classes set via `styleProp`. If any styles are set to falsy\n * then they will be removed from the element.\n *\n * Note that the styling instruction will not be applied until `stylingApply` is called.\n *\n * @param styles A key/value style map of the styles that will be applied to the given element.\n *        Any missing styles (that have already been applied to the element beforehand) will be\n *        removed (unset) from the element's styling.\n *\n * Note that this will apply the provided styleMap value to the host element if this function\n * is called within a host binding.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵstyleMap(styles) {\n  checkStylingMap(styleKeyValueArraySet, styleStringParser, styles, false);\n}\n/**\n * Parse text as style and add values to KeyValueArray.\n *\n * This code is pulled out to a separate function so that it can be tree shaken away if it is not\n * needed. It is only referenced from `ɵɵstyleMap`.\n *\n * @param keyValueArray KeyValueArray to add parsed values to.\n * @param text text to parse.\n */\n\n\nfunction styleStringParser(keyValueArray, text) {\n  for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i)) {\n    styleKeyValueArraySet(keyValueArray, getLastParsedKey(text), getLastParsedValue(text));\n  }\n}\n/**\n * Update class bindings using an object literal or class-string on an element.\n *\n * This instruction is meant to apply styling via the `[class]=\"exp\"` template bindings.\n * When classes are applied to the element they will then be updated with\n * respect to any styles/classes set via `classProp`. If any\n * classes are set to falsy then they will be removed from the element.\n *\n * Note that the styling instruction will not be applied until `stylingApply` is called.\n * Note that this will the provided classMap value to the host element if this function is called\n * within a host binding.\n *\n * @param classes A key/value map or string of CSS classes that will be added to the\n *        given element. Any missing classes (that have already been applied to the element\n *        beforehand) will be removed (unset) from the element's list of CSS classes.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵclassMap(classes) {\n  checkStylingMap(keyValueArraySet, classStringParser, classes, true);\n}\n/**\n * Parse text as class and add values to KeyValueArray.\n *\n * This code is pulled out to a separate function so that it can be tree shaken away if it is not\n * needed. It is only referenced from `ɵɵclassMap`.\n *\n * @param keyValueArray KeyValueArray to add parsed values to.\n * @param text text to parse.\n */\n\n\nfunction classStringParser(keyValueArray, text) {\n  for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {\n    keyValueArraySet(keyValueArray, getLastParsedKey(text), true);\n  }\n}\n/**\n * Common code between `ɵɵclassProp` and `ɵɵstyleProp`.\n *\n * @param prop property name.\n * @param value binding value.\n * @param suffix suffix for the property (e.g. `em` or `px`)\n * @param isClassBased `true` if `class` change (`false` if `style`)\n */\n\n\nfunction checkStylingProperty(prop, value, suffix, isClassBased) {\n  const lView = getLView();\n  const tView = getTView(); // Styling instructions use 2 slots per binding.\n  // 1. one for the value / TStylingKey\n  // 2. one for the intermittent-value / TStylingRange\n\n  const bindingIndex = incrementBindingIndex(2);\n\n  if (tView.firstUpdatePass) {\n    stylingFirstUpdatePass(tView, prop, bindingIndex, isClassBased);\n  }\n\n  if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {\n    const tNode = tView.data[getSelectedIndex()];\n    updateStyling(tView, tNode, lView, lView[RENDERER], prop, lView[bindingIndex + 1] = normalizeSuffix(value, suffix), isClassBased, bindingIndex);\n  }\n}\n/**\n * Common code between `ɵɵclassMap` and `ɵɵstyleMap`.\n *\n * @param keyValueArraySet (See `keyValueArraySet` in \"util/array_utils\") Gets passed in as a\n *        function so that `style` can be processed. This is done for tree shaking purposes.\n * @param stringParser Parser used to parse `value` if `string`. (Passed in as `style` and `class`\n *        have different parsers.)\n * @param value bound value from application\n * @param isClassBased `true` if `class` change (`false` if `style`)\n */\n\n\nfunction checkStylingMap(keyValueArraySet, stringParser, value, isClassBased) {\n  const tView = getTView();\n  const bindingIndex = incrementBindingIndex(2);\n\n  if (tView.firstUpdatePass) {\n    stylingFirstUpdatePass(tView, null, bindingIndex, isClassBased);\n  }\n\n  const lView = getLView();\n\n  if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {\n    // `getSelectedIndex()` should be here (rather than in instruction) so that it is guarded by the\n    // if so as not to read unnecessarily.\n    const tNode = tView.data[getSelectedIndex()];\n\n    if (hasStylingInputShadow(tNode, isClassBased) && !isInHostBindings(tView, bindingIndex)) {\n      if (ngDevMode) {\n        // verify that if we are shadowing then `TData` is appropriately marked so that we skip\n        // processing this binding in styling resolution.\n        const tStylingKey = tView.data[bindingIndex];\n        assertEqual(Array.isArray(tStylingKey) ? tStylingKey[1] : tStylingKey, false, 'Styling linked list shadow input should be marked as \\'false\\'');\n      } // VE does not concatenate the static portion like we are doing here.\n      // Instead VE just ignores the static completely if dynamic binding is present.\n      // Because of locality we have already set the static portion because we don't know if there\n      // is a dynamic portion until later. If we would ignore the static portion it would look like\n      // the binding has removed it. This would confuse `[ngStyle]`/`[ngClass]` to do the wrong\n      // thing as it would think that the static portion was removed. For this reason we\n      // concatenate it so that `[ngStyle]`/`[ngClass]`  can continue to work on changed.\n\n\n      let staticPrefix = isClassBased ? tNode.classesWithoutHost : tNode.stylesWithoutHost;\n      ngDevMode && isClassBased === false && staticPrefix !== null && assertEqual(staticPrefix.endsWith(';'), true, 'Expecting static portion to end with \\';\\'');\n\n      if (staticPrefix !== null) {\n        // We want to make sure that falsy values of `value` become empty strings.\n        value = concatStringsWithSpace(staticPrefix, value ? value : '');\n      } // Given `<div [style] my-dir>` such that `my-dir` has `@Input('style')`.\n      // This takes over the `[style]` binding. (Same for `[class]`)\n\n\n      setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased);\n    } else {\n      updateStylingMap(tView, tNode, lView, lView[RENDERER], lView[bindingIndex + 1], lView[bindingIndex + 1] = toStylingKeyValueArray(keyValueArraySet, stringParser, value), isClassBased, bindingIndex);\n    }\n  }\n}\n/**\n * Determines when the binding is in `hostBindings` section\n *\n * @param tView Current `TView`\n * @param bindingIndex index of binding which we would like if it is in `hostBindings`\n */\n\n\nfunction isInHostBindings(tView, bindingIndex) {\n  // All host bindings are placed after the expando section.\n  return bindingIndex >= tView.expandoStartIndex;\n}\n/**\n * Collects the necessary information to insert the binding into a linked list of style bindings\n * using `insertTStylingBinding`.\n *\n * @param tView `TView` where the binding linked list will be stored.\n * @param tStylingKey Property/key of the binding.\n * @param bindingIndex Index of binding associated with the `prop`\n * @param isClassBased `true` if `class` change (`false` if `style`)\n */\n\n\nfunction stylingFirstUpdatePass(tView, tStylingKey, bindingIndex, isClassBased) {\n  ngDevMode && assertFirstUpdatePass(tView);\n  const tData = tView.data;\n\n  if (tData[bindingIndex + 1] === null) {\n    // The above check is necessary because we don't clear first update pass until first successful\n    // (no exception) template execution. This prevents the styling instruction from double adding\n    // itself to the list.\n    // `getSelectedIndex()` should be here (rather than in instruction) so that it is guarded by the\n    // if so as not to read unnecessarily.\n    const tNode = tData[getSelectedIndex()];\n    ngDevMode && assertDefined(tNode, 'TNode expected');\n    const isHostBindings = isInHostBindings(tView, bindingIndex);\n\n    if (hasStylingInputShadow(tNode, isClassBased) && tStylingKey === null && !isHostBindings) {\n      // `tStylingKey === null` implies that we are either `[style]` or `[class]` binding.\n      // If there is a directive which uses `@Input('style')` or `@Input('class')` than\n      // we need to neutralize this binding since that directive is shadowing it.\n      // We turn this into a noop by setting the key to `false`\n      tStylingKey = false;\n    }\n\n    tStylingKey = wrapInStaticStylingKey(tData, tNode, tStylingKey, isClassBased);\n    insertTStylingBinding(tData, tNode, tStylingKey, bindingIndex, isHostBindings, isClassBased);\n  }\n}\n/**\n * Adds static styling information to the binding if applicable.\n *\n * The linked list of styles not only stores the list and keys, but also stores static styling\n * information on some of the keys. This function determines if the key should contain the styling\n * information and computes it.\n *\n * See `TStylingStatic` for more details.\n *\n * @param tData `TData` where the linked list is stored.\n * @param tNode `TNode` for which the styling is being computed.\n * @param stylingKey `TStylingKeyPrimitive` which may need to be wrapped into `TStylingKey`\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\n\n\nfunction wrapInStaticStylingKey(tData, tNode, stylingKey, isClassBased) {\n  const hostDirectiveDef = getCurrentDirectiveDef(tData);\n  let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;\n\n  if (hostDirectiveDef === null) {\n    // We are in template node.\n    // If template node already had styling instruction then it has already collected the static\n    // styling and there is no need to collect them again. We know that we are the first styling\n    // instruction because the `TNode.*Bindings` points to 0 (nothing has been inserted yet).\n    const isFirstStylingInstructionInTemplate = (isClassBased ? tNode.classBindings : tNode.styleBindings) === 0;\n\n    if (isFirstStylingInstructionInTemplate) {\n      // It would be nice to be able to get the statics from `mergeAttrs`, however, at this point\n      // they are already merged and it would not be possible to figure which property belongs where\n      // in the priority.\n      stylingKey = collectStylingFromDirectives(null, tData, tNode, stylingKey, isClassBased);\n      stylingKey = collectStylingFromTAttrs(stylingKey, tNode.attrs, isClassBased); // We know that if we have styling binding in template we can't have residual.\n\n      residual = null;\n    }\n  } else {\n    // We are in host binding node and there was no binding instruction in template node.\n    // This means that we need to compute the residual.\n    const directiveStylingLast = tNode.directiveStylingLast;\n    const isFirstStylingInstructionInHostBinding = directiveStylingLast === -1 || tData[directiveStylingLast] !== hostDirectiveDef;\n\n    if (isFirstStylingInstructionInHostBinding) {\n      stylingKey = collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased);\n\n      if (residual === null) {\n        // - If `null` than either:\n        //    - Template styling instruction already ran and it has consumed the static\n        //      styling into its `TStylingKey` and so there is no need to update residual. Instead\n        //      we need to update the `TStylingKey` associated with the first template node\n        //      instruction. OR\n        //    - Some other styling instruction ran and determined that there are no residuals\n        let templateStylingKey = getTemplateHeadTStylingKey(tData, tNode, isClassBased);\n\n        if (templateStylingKey !== undefined && Array.isArray(templateStylingKey)) {\n          // Only recompute if `templateStylingKey` had static values. (If no static value found\n          // then there is nothing to do since this operation can only produce less static keys, not\n          // more.)\n          templateStylingKey = collectStylingFromDirectives(null, tData, tNode, templateStylingKey[1]\n          /* unwrap previous statics */\n          , isClassBased);\n          templateStylingKey = collectStylingFromTAttrs(templateStylingKey, tNode.attrs, isClassBased);\n          setTemplateHeadTStylingKey(tData, tNode, isClassBased, templateStylingKey);\n        }\n      } else {\n        // We only need to recompute residual if it is not `null`.\n        // - If existing residual (implies there was no template styling). This means that some of\n        //   the statics may have moved from the residual to the `stylingKey` and so we have to\n        //   recompute.\n        // - If `undefined` this is the first time we are running.\n        residual = collectResidual(tData, tNode, isClassBased);\n      }\n    }\n  }\n\n  if (residual !== undefined) {\n    isClassBased ? tNode.residualClasses = residual : tNode.residualStyles = residual;\n  }\n\n  return stylingKey;\n}\n/**\n * Retrieve the `TStylingKey` for the template styling instruction.\n *\n * This is needed since `hostBinding` styling instructions are inserted after the template\n * instruction. While the template instruction needs to update the residual in `TNode` the\n * `hostBinding` instructions need to update the `TStylingKey` of the template instruction because\n * the template instruction is downstream from the `hostBindings` instructions.\n *\n * @param tData `TData` where the linked list is stored.\n * @param tNode `TNode` for which the styling is being computed.\n * @param isClassBased `true` if `class` (`false` if `style`)\n * @return `TStylingKey` if found or `undefined` if not found.\n */\n\n\nfunction getTemplateHeadTStylingKey(tData, tNode, isClassBased) {\n  const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;\n\n  if (getTStylingRangeNext(bindings) === 0) {\n    // There does not seem to be a styling instruction in the `template`.\n    return undefined;\n  }\n\n  return tData[getTStylingRangePrev(bindings)];\n}\n/**\n * Update the `TStylingKey` of the first template instruction in `TNode`.\n *\n * Logically `hostBindings` styling instructions are of lower priority than that of the template.\n * However, they execute after the template styling instructions. This means that they get inserted\n * in front of the template styling instructions.\n *\n * If we have a template styling instruction and a new `hostBindings` styling instruction is\n * executed it means that it may need to steal static fields from the template instruction. This\n * method allows us to update the first template instruction `TStylingKey` with a new value.\n *\n * Assume:\n * ```\n * <div my-dir style=\"color: red\" [style.color]=\"tmplExp\"></div>\n *\n * @Directive({\n *   host: {\n *     'style': 'width: 100px',\n *     '[style.color]': 'dirExp',\n *   }\n * })\n * class MyDir {}\n * ```\n *\n * when `[style.color]=\"tmplExp\"` executes it creates this data structure.\n * ```\n *  ['', 'color', 'color', 'red', 'width', '100px'],\n * ```\n *\n * The reason for this is that the template instruction does not know if there are styling\n * instructions and must assume that there are none and must collect all of the static styling.\n * (both\n * `color' and 'width`)\n *\n * When `'[style.color]': 'dirExp',` executes we need to insert a new data into the linked list.\n * ```\n *  ['', 'color', 'width', '100px'],  // newly inserted\n *  ['', 'color', 'color', 'red', 'width', '100px'], // this is wrong\n * ```\n *\n * Notice that the template statics is now wrong as it incorrectly contains `width` so we need to\n * update it like so:\n * ```\n *  ['', 'color', 'width', '100px'],\n *  ['', 'color', 'color', 'red'],    // UPDATE\n * ```\n *\n * @param tData `TData` where the linked list is stored.\n * @param tNode `TNode` for which the styling is being computed.\n * @param isClassBased `true` if `class` (`false` if `style`)\n * @param tStylingKey New `TStylingKey` which is replacing the old one.\n */\n\n\nfunction setTemplateHeadTStylingKey(tData, tNode, isClassBased, tStylingKey) {\n  const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;\n  ngDevMode && assertNotEqual(getTStylingRangeNext(bindings), 0, 'Expecting to have at least one template styling binding.');\n  tData[getTStylingRangePrev(bindings)] = tStylingKey;\n}\n/**\n * Collect all static values after the current `TNode.directiveStylingLast` index.\n *\n * Collect the remaining styling information which has not yet been collected by an existing\n * styling instruction.\n *\n * @param tData `TData` where the `DirectiveDefs` are stored.\n * @param tNode `TNode` which contains the directive range.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\n\n\nfunction collectResidual(tData, tNode, isClassBased) {\n  let residual = undefined;\n  const directiveEnd = tNode.directiveEnd;\n  ngDevMode && assertNotEqual(tNode.directiveStylingLast, -1, 'By the time this function gets called at least one hostBindings-node styling instruction must have executed.'); // We add `1 + tNode.directiveStart` because we need to skip the current directive (as we are\n  // collecting things after the last `hostBindings` directive which had a styling instruction.)\n\n  for (let i = 1 + tNode.directiveStylingLast; i < directiveEnd; i++) {\n    const attrs = tData[i].hostAttrs;\n    residual = collectStylingFromTAttrs(residual, attrs, isClassBased);\n  }\n\n  return collectStylingFromTAttrs(residual, tNode.attrs, isClassBased);\n}\n/**\n * Collect the static styling information with lower priority than `hostDirectiveDef`.\n *\n * (This is opposite of residual styling.)\n *\n * @param hostDirectiveDef `DirectiveDef` for which we want to collect lower priority static\n *        styling. (Or `null` if template styling)\n * @param tData `TData` where the linked list is stored.\n * @param tNode `TNode` for which the styling is being computed.\n * @param stylingKey Existing `TStylingKey` to update or wrap.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\n\n\nfunction collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased) {\n  // We need to loop because there can be directives which have `hostAttrs` but don't have\n  // `hostBindings` so this loop catches up to the current directive..\n  let currentDirective = null;\n  const directiveEnd = tNode.directiveEnd;\n  let directiveStylingLast = tNode.directiveStylingLast;\n\n  if (directiveStylingLast === -1) {\n    directiveStylingLast = tNode.directiveStart;\n  } else {\n    directiveStylingLast++;\n  }\n\n  while (directiveStylingLast < directiveEnd) {\n    currentDirective = tData[directiveStylingLast];\n    ngDevMode && assertDefined(currentDirective, 'expected to be defined');\n    stylingKey = collectStylingFromTAttrs(stylingKey, currentDirective.hostAttrs, isClassBased);\n    if (currentDirective === hostDirectiveDef) break;\n    directiveStylingLast++;\n  }\n\n  if (hostDirectiveDef !== null) {\n    // we only advance the styling cursor if we are collecting data from host bindings.\n    // Template executes before host bindings and so if we would update the index,\n    // host bindings would not get their statics.\n    tNode.directiveStylingLast = directiveStylingLast;\n  }\n\n  return stylingKey;\n}\n/**\n * Convert `TAttrs` into `TStylingStatic`.\n *\n * @param stylingKey existing `TStylingKey` to update or wrap.\n * @param attrs `TAttributes` to process.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\n\n\nfunction collectStylingFromTAttrs(stylingKey, attrs, isClassBased) {\n  const desiredMarker = isClassBased ? 1\n  /* AttributeMarker.Classes */\n  : 2\n  /* AttributeMarker.Styles */\n  ;\n  let currentMarker = -1\n  /* AttributeMarker.ImplicitAttributes */\n  ;\n\n  if (attrs !== null) {\n    for (let i = 0; i < attrs.length; i++) {\n      const item = attrs[i];\n\n      if (typeof item === 'number') {\n        currentMarker = item;\n      } else {\n        if (currentMarker === desiredMarker) {\n          if (!Array.isArray(stylingKey)) {\n            stylingKey = stylingKey === undefined ? [] : ['', stylingKey];\n          }\n\n          keyValueArraySet(stylingKey, item, isClassBased ? true : attrs[++i]);\n        }\n      }\n    }\n  }\n\n  return stylingKey === undefined ? null : stylingKey;\n}\n/**\n * Convert user input to `KeyValueArray`.\n *\n * This function takes user input which could be `string`, Object literal, or iterable and converts\n * it into a consistent representation. The output of this is `KeyValueArray` (which is an array\n * where\n * even indexes contain keys and odd indexes contain values for those keys).\n *\n * The advantage of converting to `KeyValueArray` is that we can perform diff in an input\n * independent\n * way.\n * (ie we can compare `foo bar` to `['bar', 'baz'] and determine a set of changes which need to be\n * applied)\n *\n * The fact that `KeyValueArray` is sorted is very important because it allows us to compute the\n * difference in linear fashion without the need to allocate any additional data.\n *\n * For example if we kept this as a `Map` we would have to iterate over previous `Map` to determine\n * which values need to be deleted, over the new `Map` to determine additions, and we would have to\n * keep additional `Map` to keep track of duplicates or items which have not yet been visited.\n *\n * @param keyValueArraySet (See `keyValueArraySet` in \"util/array_utils\") Gets passed in as a\n *        function so that `style` can be processed. This is done\n *        for tree shaking purposes.\n * @param stringParser The parser is passed in so that it will be tree shakable. See\n *        `styleStringParser` and `classStringParser`\n * @param value The value to parse/convert to `KeyValueArray`\n */\n\n\nfunction toStylingKeyValueArray(keyValueArraySet, stringParser, value) {\n  if (value == null\n  /*|| value === undefined */\n  || value === '') return EMPTY_ARRAY;\n  const styleKeyValueArray = [];\n  const unwrappedValue = unwrapSafeValue(value);\n\n  if (Array.isArray(unwrappedValue)) {\n    for (let i = 0; i < unwrappedValue.length; i++) {\n      keyValueArraySet(styleKeyValueArray, unwrappedValue[i], true);\n    }\n  } else if (typeof unwrappedValue === 'object') {\n    for (const key in unwrappedValue) {\n      if (unwrappedValue.hasOwnProperty(key)) {\n        keyValueArraySet(styleKeyValueArray, key, unwrappedValue[key]);\n      }\n    }\n  } else if (typeof unwrappedValue === 'string') {\n    stringParser(styleKeyValueArray, unwrappedValue);\n  } else {\n    ngDevMode && throwError('Unsupported styling type ' + typeof unwrappedValue + ': ' + unwrappedValue);\n  }\n\n  return styleKeyValueArray;\n}\n/**\n * Set a `value` for a `key`.\n *\n * See: `keyValueArraySet` for details\n *\n * @param keyValueArray KeyValueArray to add to.\n * @param key Style key to add.\n * @param value The value to set.\n */\n\n\nfunction styleKeyValueArraySet(keyValueArray, key, value) {\n  keyValueArraySet(keyValueArray, key, unwrapSafeValue(value));\n}\n/**\n * Update map based styling.\n *\n * Map based styling could be anything which contains more than one binding. For example `string`,\n * or object literal. Dealing with all of these types would complicate the logic so\n * instead this function expects that the complex input is first converted into normalized\n * `KeyValueArray`. The advantage of normalization is that we get the values sorted, which makes it\n * very cheap to compute deltas between the previous and current value.\n *\n * @param tView Associated `TView.data` contains the linked list of binding priorities.\n * @param tNode `TNode` where the binding is located.\n * @param lView `LView` contains the values associated with other styling binding at this `TNode`.\n * @param renderer Renderer to use if any updates.\n * @param oldKeyValueArray Previous value represented as `KeyValueArray`\n * @param newKeyValueArray Current value represented as `KeyValueArray`\n * @param isClassBased `true` if `class` (`false` if `style`)\n * @param bindingIndex Binding index of the binding.\n */\n\n\nfunction updateStylingMap(tView, tNode, lView, renderer, oldKeyValueArray, newKeyValueArray, isClassBased, bindingIndex) {\n  if (oldKeyValueArray === NO_CHANGE) {\n    // On first execution the oldKeyValueArray is NO_CHANGE => treat it as empty KeyValueArray.\n    oldKeyValueArray = EMPTY_ARRAY;\n  }\n\n  let oldIndex = 0;\n  let newIndex = 0;\n  let oldKey = 0 < oldKeyValueArray.length ? oldKeyValueArray[0] : null;\n  let newKey = 0 < newKeyValueArray.length ? newKeyValueArray[0] : null;\n\n  while (oldKey !== null || newKey !== null) {\n    ngDevMode && assertLessThan(oldIndex, 999, 'Are we stuck in infinite loop?');\n    ngDevMode && assertLessThan(newIndex, 999, 'Are we stuck in infinite loop?');\n    const oldValue = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex + 1] : undefined;\n    const newValue = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex + 1] : undefined;\n    let setKey = null;\n    let setValue = undefined;\n\n    if (oldKey === newKey) {\n      // UPDATE: Keys are equal => new value is overwriting old value.\n      oldIndex += 2;\n      newIndex += 2;\n\n      if (oldValue !== newValue) {\n        setKey = newKey;\n        setValue = newValue;\n      }\n    } else if (newKey === null || oldKey !== null && oldKey < newKey) {\n      // DELETE: oldKey key is missing or we did not find the oldKey in the newValue\n      // (because the keyValueArray is sorted and `newKey` is found later alphabetically).\n      // `\"background\" < \"color\"` so we need to delete `\"background\"` because it is not found in the\n      // new array.\n      oldIndex += 2;\n      setKey = oldKey;\n    } else {\n      // CREATE: newKey's is earlier alphabetically than oldKey's (or no oldKey) => we have new key.\n      // `\"color\" > \"background\"` so we need to add `color` because it is in new array but not in\n      // old array.\n      ngDevMode && assertDefined(newKey, 'Expecting to have a valid key');\n      newIndex += 2;\n      setKey = newKey;\n      setValue = newValue;\n    }\n\n    if (setKey !== null) {\n      updateStyling(tView, tNode, lView, renderer, setKey, setValue, isClassBased, bindingIndex);\n    }\n\n    oldKey = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex] : null;\n    newKey = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex] : null;\n  }\n}\n/**\n * Update a simple (property name) styling.\n *\n * This function takes `prop` and updates the DOM to that value. The function takes the binding\n * value as well as binding priority into consideration to determine which value should be written\n * to DOM. (For example it may be determined that there is a higher priority overwrite which blocks\n * the DOM write, or if the value goes to `undefined` a lower priority overwrite may be consulted.)\n *\n * @param tView Associated `TView.data` contains the linked list of binding priorities.\n * @param tNode `TNode` where the binding is located.\n * @param lView `LView` contains the values associated with other styling binding at this `TNode`.\n * @param renderer Renderer to use if any updates.\n * @param prop Either style property name or a class name.\n * @param value Either style value for `prop` or `true`/`false` if `prop` is class.\n * @param isClassBased `true` if `class` (`false` if `style`)\n * @param bindingIndex Binding index of the binding.\n */\n\n\nfunction updateStyling(tView, tNode, lView, renderer, prop, value, isClassBased, bindingIndex) {\n  if (!(tNode.type & 3\n  /* TNodeType.AnyRNode */\n  )) {\n    // It is possible to have styling on non-elements (such as ng-container).\n    // This is rare, but it does happen. In such a case, just ignore the binding.\n    return;\n  }\n\n  const tData = tView.data;\n  const tRange = tData[bindingIndex + 1];\n  const higherPriorityValue = getTStylingRangeNextDuplicate(tRange) ? findStylingValue(tData, tNode, lView, prop, getTStylingRangeNext(tRange), isClassBased) : undefined;\n\n  if (!isStylingValuePresent(higherPriorityValue)) {\n    // We don't have a next duplicate, or we did not find a duplicate value.\n    if (!isStylingValuePresent(value)) {\n      // We should delete current value or restore to lower priority value.\n      if (getTStylingRangePrevDuplicate(tRange)) {\n        // We have a possible prev duplicate, let's retrieve it.\n        value = findStylingValue(tData, null, lView, prop, bindingIndex, isClassBased);\n      }\n    }\n\n    const rNode = getNativeByIndex(getSelectedIndex(), lView);\n    applyStyling(renderer, isClassBased, rNode, prop, value);\n  }\n}\n/**\n * Search for styling value with higher priority which is overwriting current value, or a\n * value of lower priority to which we should fall back if the value is `undefined`.\n *\n * When value is being applied at a location, related values need to be consulted.\n * - If there is a higher priority binding, we should be using that one instead.\n *   For example `<div  [style]=\"{color:exp1}\" [style.color]=\"exp2\">` change to `exp1`\n *   requires that we check `exp2` to see if it is set to value other than `undefined`.\n * - If there is a lower priority binding and we are changing to `undefined`\n *   For example `<div  [style]=\"{color:exp1}\" [style.color]=\"exp2\">` change to `exp2` to\n *   `undefined` requires that we check `exp1` (and static values) and use that as new value.\n *\n * NOTE: The styling stores two values.\n * 1. The raw value which came from the application is stored at `index + 0` location. (This value\n *    is used for dirty checking).\n * 2. The normalized value is stored at `index + 1`.\n *\n * @param tData `TData` used for traversing the priority.\n * @param tNode `TNode` to use for resolving static styling. Also controls search direction.\n *   - `TNode` search next and quit as soon as `isStylingValuePresent(value)` is true.\n *      If no value found consult `tNode.residualStyle`/`tNode.residualClass` for default value.\n *   - `null` search prev and go all the way to end. Return last value where\n *     `isStylingValuePresent(value)` is true.\n * @param lView `LView` used for retrieving the actual values.\n * @param prop Property which we are interested in.\n * @param index Starting index in the linked list of styling bindings where the search should start.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\n\n\nfunction findStylingValue(tData, tNode, lView, prop, index, isClassBased) {\n  // `TNode` to use for resolving static styling. Also controls search direction.\n  //   - `TNode` search next and quit as soon as `isStylingValuePresent(value)` is true.\n  //      If no value found consult `tNode.residualStyle`/`tNode.residualClass` for default value.\n  //   - `null` search prev and go all the way to end. Return last value where\n  //     `isStylingValuePresent(value)` is true.\n  const isPrevDirection = tNode === null;\n  let value = undefined;\n\n  while (index > 0) {\n    const rawKey = tData[index];\n    const containsStatics = Array.isArray(rawKey); // Unwrap the key if we contain static values.\n\n    const key = containsStatics ? rawKey[1] : rawKey;\n    const isStylingMap = key === null;\n    let valueAtLViewIndex = lView[index + 1];\n\n    if (valueAtLViewIndex === NO_CHANGE) {\n      // In firstUpdatePass the styling instructions create a linked list of styling.\n      // On subsequent passes it is possible for a styling instruction to try to read a binding\n      // which\n      // has not yet executed. In that case we will find `NO_CHANGE` and we should assume that\n      // we have `undefined` (or empty array in case of styling-map instruction) instead. This\n      // allows the resolution to apply the value (which may later be overwritten when the\n      // binding actually executes.)\n      valueAtLViewIndex = isStylingMap ? EMPTY_ARRAY : undefined;\n    }\n\n    let currentValue = isStylingMap ? keyValueArrayGet(valueAtLViewIndex, prop) : key === prop ? valueAtLViewIndex : undefined;\n\n    if (containsStatics && !isStylingValuePresent(currentValue)) {\n      currentValue = keyValueArrayGet(rawKey, prop);\n    }\n\n    if (isStylingValuePresent(currentValue)) {\n      value = currentValue;\n\n      if (isPrevDirection) {\n        return value;\n      }\n    }\n\n    const tRange = tData[index + 1];\n    index = isPrevDirection ? getTStylingRangePrev(tRange) : getTStylingRangeNext(tRange);\n  }\n\n  if (tNode !== null) {\n    // in case where we are going in next direction AND we did not find anything, we need to\n    // consult residual styling\n    let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;\n\n    if (residual != null\n    /** OR residual !=== undefined */\n    ) {\n      value = keyValueArrayGet(residual, prop);\n    }\n  }\n\n  return value;\n}\n/**\n * Determines if the binding value should be used (or if the value is 'undefined' and hence priority\n * resolution should be used.)\n *\n * @param value Binding style value.\n */\n\n\nfunction isStylingValuePresent(value) {\n  // Currently only `undefined` value is considered non-binding. That is `undefined` says I don't\n  // have an opinion as to what this binding should be and you should consult other bindings by\n  // priority to determine the valid value.\n  // This is extracted into a single function so that we have a single place to control this.\n  return value !== undefined;\n}\n/**\n * Normalizes and/or adds a suffix to the value.\n *\n * If value is `null`/`undefined` no suffix is added\n * @param value\n * @param suffix\n */\n\n\nfunction normalizeSuffix(value, suffix) {\n  if (value == null\n  /** || value === undefined */\n  ) {// do nothing\n  } else if (typeof suffix === 'string') {\n    value = value + suffix;\n  } else if (typeof value === 'object') {\n    value = stringify(unwrapSafeValue(value));\n  }\n\n  return value;\n}\n/**\n * Tests if the `TNode` has input shadow.\n *\n * An input shadow is when a directive steals (shadows) the input by using `@Input('style')` or\n * `@Input('class')` as input.\n *\n * @param tNode `TNode` which we would like to see if it has shadow.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\n\n\nfunction hasStylingInputShadow(tNode, isClassBased) {\n  return (tNode.flags & (isClassBased ? 16\n  /* TNodeFlags.hasClassInput */\n  : 32\n  /* TNodeFlags.hasStyleInput */\n  )) !== 0;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Create static text node\n *\n * @param index Index of the node in the data array\n * @param value Static string value to write.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵtext(index, value = '') {\n  const lView = getLView();\n  const tView = getTView();\n  const adjustedIndex = index + HEADER_OFFSET;\n  ngDevMode && assertEqual(getBindingIndex(), tView.bindingStartIndex, 'text nodes should be created before any bindings');\n  ngDevMode && assertIndexInRange(lView, adjustedIndex);\n  const tNode = tView.firstCreatePass ? getOrCreateTNode(tView, adjustedIndex, 1\n  /* TNodeType.Text */\n  , value, null) : tView.data[adjustedIndex];\n  const textNative = lView[adjustedIndex] = createTextNode(lView[RENDERER], value);\n  appendChild(tView, lView, textNative, tNode); // Text nodes are self closing.\n\n  setCurrentTNode(tNode, false);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n *\n * Update text content with a lone bound value\n *\n * Used when a text node has 1 interpolated value in it, an no additional text\n * surrounds that interpolated value:\n *\n * ```html\n * <div>{{v0}}</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate(v0);\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\n\n\nfunction ɵɵtextInterpolate(v0) {\n  ɵɵtextInterpolate1('', v0, '');\n  return ɵɵtextInterpolate;\n}\n/**\n *\n * Update text content with single bound value surrounded by other text.\n *\n * Used when a text node has 1 interpolated value in it:\n *\n * ```html\n * <div>prefix{{v0}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate1('prefix', v0, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\n\n\nfunction ɵɵtextInterpolate1(prefix, v0, suffix) {\n  const lView = getLView();\n  const interpolated = interpolation1(lView, prefix, v0, suffix);\n\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated);\n  }\n\n  return ɵɵtextInterpolate1;\n}\n/**\n *\n * Update text content with 2 bound values surrounded by other text.\n *\n * Used when a text node has 2 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate2('prefix', v0, '-', v1, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\n\n\nfunction ɵɵtextInterpolate2(prefix, v0, i0, v1, suffix) {\n  const lView = getLView();\n  const interpolated = interpolation2(lView, prefix, v0, i0, v1, suffix);\n\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated);\n  }\n\n  return ɵɵtextInterpolate2;\n}\n/**\n *\n * Update text content with 3 bound values surrounded by other text.\n *\n * Used when a text node has 3 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate3(\n * 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\n\n\nfunction ɵɵtextInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {\n  const lView = getLView();\n  const interpolated = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated);\n  }\n\n  return ɵɵtextInterpolate3;\n}\n/**\n *\n * Update text content with 4 bound values surrounded by other text.\n *\n * Used when a text node has 4 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate4(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see ɵɵtextInterpolateV\n * @codeGenApi\n */\n\n\nfunction ɵɵtextInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {\n  const lView = getLView();\n  const interpolated = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated);\n  }\n\n  return ɵɵtextInterpolate4;\n}\n/**\n *\n * Update text content with 5 bound values surrounded by other text.\n *\n * Used when a text node has 5 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate5(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\n\n\nfunction ɵɵtextInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {\n  const lView = getLView();\n  const interpolated = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated);\n  }\n\n  return ɵɵtextInterpolate5;\n}\n/**\n *\n * Update text content with 6 bound values surrounded by other text.\n *\n * Used when a text node has 6 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate6(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change. @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\n\n\nfunction ɵɵtextInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {\n  const lView = getLView();\n  const interpolated = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated);\n  }\n\n  return ɵɵtextInterpolate6;\n}\n/**\n *\n * Update text content with 7 bound values surrounded by other text.\n *\n * Used when a text node has 7 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate7(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\n\n\nfunction ɵɵtextInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {\n  const lView = getLView();\n  const interpolated = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated);\n  }\n\n  return ɵɵtextInterpolate7;\n}\n/**\n *\n * Update text content with 8 bound values surrounded by other text.\n *\n * Used when a text node has 8 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate8(\n *  'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\n\n\nfunction ɵɵtextInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {\n  const lView = getLView();\n  const interpolated = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated);\n  }\n\n  return ɵɵtextInterpolate8;\n}\n/**\n * Update text content with 9 or more bound values other surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolateV(\n *  ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *.\n * @param values The collection of values and the strings in between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n *\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\n\n\nfunction ɵɵtextInterpolateV(values) {\n  const lView = getLView();\n  const interpolated = interpolationV(lView, values);\n\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated);\n  }\n\n  return ɵɵtextInterpolateV;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n *\n * Update an interpolated class on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate1('prefix', v0, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\n\n\nfunction ɵɵclassMapInterpolate1(prefix, v0, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate2('prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\n\n\nfunction ɵɵclassMapInterpolate2(prefix, v0, i0, v1, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate3(\n * 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\n\n\nfunction ɵɵclassMapInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate4(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\n\n\nfunction ɵɵclassMapInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate5(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\n\n\nfunction ɵɵclassMapInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate6(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\n\n\nfunction ɵɵclassMapInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate7(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\n\n\nfunction ɵɵclassMapInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate8(\n *  'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\n\n\nfunction ɵɵclassMapInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n * Update an interpolated class on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolateV(\n *  ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @codeGenApi\n */\n\n\nfunction ɵɵclassMapInterpolateV(values) {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n *\n * Update an interpolated style on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div style=\"key: {{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate1('key: ', v0, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\n\n\nfunction ɵɵstyleMapInterpolate1(prefix, v0, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate2('key: ', v0, '; key1: ', v1, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\n\n\nfunction ɵɵstyleMapInterpolate2(prefix, v0, i0, v1, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key2: {{v1}}; key2: {{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate3(\n *     'key: ', v0, '; key1: ', v1, '; key2: ', v2, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\n\n\nfunction ɵɵstyleMapInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate4(\n *     'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\n\n\nfunction ɵɵstyleMapInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate5(\n *     'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\n\n\nfunction ɵɵstyleMapInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}};\n *             key5: {{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate6(\n *    'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *    'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\n\n\nfunction ɵɵstyleMapInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}; key5: {{v5}};\n *             key6: {{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate7(\n *    'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *    '; key6: ', v6, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\n\n\nfunction ɵɵstyleMapInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}; key5: {{v5}};\n *             key6: {{v6}}; key7: {{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate8(\n *    'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *    '; key6: ', v6, '; key7: ', v7, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\n\n\nfunction ɵɵstyleMapInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  ɵɵstyleMap(interpolatedValue);\n}\n/**\n * Update an interpolated style on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  class=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}; key5: {{v5}};\n *         key6: {{v6}}; key7: {{v7}}; key8: {{v8}}; key9: {{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolateV(\n *    ['key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *     '; key6: ', v6, '; key7: ', v7, '; key8: ', v8, '; key9: ', v9, 'suffix']);\n * ```\n *.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '; key2: ', value1, '; key2: ', value2, ..., value99, 'suffix']`)\n * @codeGenApi\n */\n\n\nfunction ɵɵstyleMapInterpolateV(values) {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  ɵɵstyleMap(interpolatedValue);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n *\n * Update an interpolated style property on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate1(0, 'prefix', v0, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\n\n\nfunction ɵɵstylePropInterpolate1(prop, prefix, v0, suffix, valueSuffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate1;\n}\n/**\n *\n * Update an interpolated style property on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate2(0, 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\n\n\nfunction ɵɵstylePropInterpolate2(prop, prefix, v0, i0, v1, suffix, valueSuffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate2;\n}\n/**\n *\n * Update an interpolated style property on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate3(0, 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\n\n\nfunction ɵɵstylePropInterpolate3(prop, prefix, v0, i0, v1, i1, v2, suffix, valueSuffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate3;\n}\n/**\n *\n * Update an interpolated style property on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate4(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\n\n\nfunction ɵɵstylePropInterpolate4(prop, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, valueSuffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate4;\n}\n/**\n *\n * Update an interpolated style property on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate5(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\n\n\nfunction ɵɵstylePropInterpolate5(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, valueSuffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate5;\n}\n/**\n *\n * Update an interpolated style property on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate6(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\n\n\nfunction ɵɵstylePropInterpolate6(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, valueSuffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate6;\n}\n/**\n *\n * Update an interpolated style property on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate7(\n *    0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\n\n\nfunction ɵɵstylePropInterpolate7(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, valueSuffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate7;\n}\n/**\n *\n * Update an interpolated style property on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate8(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6,\n * '-', v7, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\n\n\nfunction ɵɵstylePropInterpolate8(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, valueSuffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolate8;\n}\n/**\n * Update an interpolated style property on an element with 9 or more bound values surrounded by\n * text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\">\n * </div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolateV(\n *  0, ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`..\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\n\n\nfunction ɵɵstylePropInterpolateV(prop, values, valueSuffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return ɵɵstylePropInterpolateV;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Update a property on a host element. Only applies to native node properties, not inputs.\n *\n * Operates on the element selected by index via the {@link select} instruction.\n *\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n * @returns This function returns itself so that it may be chained\n * (e.g. `property('name', ctx.name)('title', ctx.title)`)\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵhostProperty(propName, value, sanitizer) {\n  const lView = getLView();\n  const bindingIndex = nextBindingIndex();\n\n  if (bindingUpdated(lView, bindingIndex, value)) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, true);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);\n  }\n\n  return ɵɵhostProperty;\n}\n/**\n * Updates a synthetic host binding (e.g. `[@foo]`) on a component or directive.\n *\n * This instruction is for compatibility purposes and is designed to ensure that a\n * synthetic host binding (e.g. `@HostBinding('@foo')`) properly gets rendered in\n * the component's renderer. Normally all host bindings are evaluated with the parent\n * component's renderer, but, in the case of animation @triggers, they need to be\n * evaluated with the sub component's renderer (because that's where the animation\n * triggers are defined).\n *\n * Do not use this instruction as a replacement for `elementProperty`. This instruction\n * only exists to ensure compatibility with the ViewEngine's host binding behavior.\n *\n * @param index The index of the element to update in the data array\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵsyntheticHostProperty(propName, value, sanitizer) {\n  const lView = getLView();\n  const bindingIndex = nextBindingIndex();\n\n  if (bindingUpdated(lView, bindingIndex, value)) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    const currentDef = getCurrentDirectiveDef(tView.data);\n    const renderer = loadComponentRenderer(currentDef, tNode, lView);\n    elementPropertyInternal(tView, tNode, lView, propName, value, renderer, sanitizer, true);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);\n  }\n\n  return ɵɵsyntheticHostProperty;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * NOTE: changes to the `ngI18nClosureMode` name must be synced with `compiler-cli/src/tooling.ts`.\n */\n\n\nif (typeof ngI18nClosureMode === 'undefined') {\n  // These property accesses can be ignored because ngI18nClosureMode will be set to false\n  // when optimizing code and the whole if statement will be dropped.\n  // Make sure to refer to ngI18nClosureMode as ['ngI18nClosureMode'] for closure.\n  // NOTE: we need to have it in IIFE so that the tree-shaker is happy.\n  (function () {\n    // tslint:disable-next-line:no-toplevel-property-access\n    _global$1['ngI18nClosureMode'] = // TODO(FW-1250): validate that this actually, you know, works.\n    // tslint:disable-next-line:no-toplevel-property-access\n    typeof goog !== 'undefined' && typeof goog.getMsg === 'function';\n  })();\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// THIS CODE IS GENERATED - DO NOT MODIFY.\n\n\nconst u = undefined;\n\nfunction plural(val) {\n  const n = val,\n        i = Math.floor(Math.abs(val)),\n        v = val.toString().replace(/^[^.]*\\.?/, '').length;\n  if (i === 1 && v === 0) return 1;\n  return 5;\n}\n\nvar localeEn = [\"en\", [[\"a\", \"p\"], [\"AM\", \"PM\"], u], [[\"AM\", \"PM\"], u, u], [[\"S\", \"M\", \"T\", \"W\", \"T\", \"F\", \"S\"], [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"], [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"], [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\"]], u, [[\"J\", \"F\", \"M\", \"A\", \"M\", \"J\", \"J\", \"A\", \"S\", \"O\", \"N\", \"D\"], [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"], [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"]], u, [[\"B\", \"A\"], [\"BC\", \"AD\"], [\"Before Christ\", \"Anno Domini\"]], 0, [6, 0], [\"M/d/yy\", \"MMM d, y\", \"MMMM d, y\", \"EEEE, MMMM d, y\"], [\"h:mm a\", \"h:mm:ss a\", \"h:mm:ss a z\", \"h:mm:ss a zzzz\"], [\"{1}, {0}\", u, \"{1} 'at' {0}\", u], [\".\", \",\", \";\", \"%\", \"+\", \"-\", \"E\", \"×\", \"‰\", \"∞\", \"NaN\", \":\"], [\"#,##0.###\", \"#,##0%\", \"¤#,##0.00\", \"#E0\"], \"USD\", \"$\", \"US Dollar\", {}, \"ltr\", plural];\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * This const is used to store the locale data registered with `registerLocaleData`\n */\n\nlet LOCALE_DATA = {};\n/**\n * Register locale data to be used internally by Angular. See the\n * [\"I18n guide\"](guide/i18n-common-format-data-locale) to know how to import additional locale\n * data.\n *\n * The signature `registerLocaleData(data: any, extraData?: any)` is deprecated since v5.1\n */\n\nfunction registerLocaleData(data, localeId, extraData) {\n  if (typeof localeId !== 'string') {\n    extraData = localeId;\n    localeId = data[LocaleDataIndex.LocaleId];\n  }\n\n  localeId = localeId.toLowerCase().replace(/_/g, '-');\n  LOCALE_DATA[localeId] = data;\n\n  if (extraData) {\n    LOCALE_DATA[localeId][LocaleDataIndex.ExtraData] = extraData;\n  }\n}\n/**\n * Finds the locale data for a given locale.\n *\n * @param locale The locale code.\n * @returns The locale data.\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n-overview)\n */\n\n\nfunction findLocaleData(locale) {\n  const normalizedLocale = normalizeLocale(locale);\n  let match = getLocaleData(normalizedLocale);\n\n  if (match) {\n    return match;\n  } // let's try to find a parent locale\n\n\n  const parentLocale = normalizedLocale.split('-')[0];\n  match = getLocaleData(parentLocale);\n\n  if (match) {\n    return match;\n  }\n\n  if (parentLocale === 'en') {\n    return localeEn;\n  }\n\n  throw new Error(`Missing locale data for the locale \"${locale}\".`);\n}\n/**\n * Retrieves the default currency code for the given locale.\n *\n * The default is defined as the first currency which is still in use.\n *\n * @param locale The code of the locale whose currency code we want.\n * @returns The code of the default currency for the given locale.\n *\n */\n\n\nfunction getLocaleCurrencyCode(locale) {\n  const data = findLocaleData(locale);\n  return data[LocaleDataIndex.CurrencyCode] || null;\n}\n/**\n * Retrieves the plural function used by ICU expressions to determine the plural case to use\n * for a given locale.\n * @param locale A locale code for the locale format rules to use.\n * @returns The plural function for the locale.\n * @see `NgPlural`\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n-overview)\n */\n\n\nfunction getLocalePluralCase(locale) {\n  const data = findLocaleData(locale);\n  return data[LocaleDataIndex.PluralCase];\n}\n/**\n * Helper function to get the given `normalizedLocale` from `LOCALE_DATA`\n * or from the global `ng.common.locale`.\n */\n\n\nfunction getLocaleData(normalizedLocale) {\n  if (!(normalizedLocale in LOCALE_DATA)) {\n    LOCALE_DATA[normalizedLocale] = _global$1.ng && _global$1.ng.common && _global$1.ng.common.locales && _global$1.ng.common.locales[normalizedLocale];\n  }\n\n  return LOCALE_DATA[normalizedLocale];\n}\n/**\n * Helper function to remove all the locale data from `LOCALE_DATA`.\n */\n\n\nfunction unregisterAllLocaleData() {\n  LOCALE_DATA = {};\n}\n/**\n * Index of each type of locale data from the locale data array\n */\n\n\nvar LocaleDataIndex;\n\n(function (LocaleDataIndex) {\n  LocaleDataIndex[LocaleDataIndex[\"LocaleId\"] = 0] = \"LocaleId\";\n  LocaleDataIndex[LocaleDataIndex[\"DayPeriodsFormat\"] = 1] = \"DayPeriodsFormat\";\n  LocaleDataIndex[LocaleDataIndex[\"DayPeriodsStandalone\"] = 2] = \"DayPeriodsStandalone\";\n  LocaleDataIndex[LocaleDataIndex[\"DaysFormat\"] = 3] = \"DaysFormat\";\n  LocaleDataIndex[LocaleDataIndex[\"DaysStandalone\"] = 4] = \"DaysStandalone\";\n  LocaleDataIndex[LocaleDataIndex[\"MonthsFormat\"] = 5] = \"MonthsFormat\";\n  LocaleDataIndex[LocaleDataIndex[\"MonthsStandalone\"] = 6] = \"MonthsStandalone\";\n  LocaleDataIndex[LocaleDataIndex[\"Eras\"] = 7] = \"Eras\";\n  LocaleDataIndex[LocaleDataIndex[\"FirstDayOfWeek\"] = 8] = \"FirstDayOfWeek\";\n  LocaleDataIndex[LocaleDataIndex[\"WeekendRange\"] = 9] = \"WeekendRange\";\n  LocaleDataIndex[LocaleDataIndex[\"DateFormat\"] = 10] = \"DateFormat\";\n  LocaleDataIndex[LocaleDataIndex[\"TimeFormat\"] = 11] = \"TimeFormat\";\n  LocaleDataIndex[LocaleDataIndex[\"DateTimeFormat\"] = 12] = \"DateTimeFormat\";\n  LocaleDataIndex[LocaleDataIndex[\"NumberSymbols\"] = 13] = \"NumberSymbols\";\n  LocaleDataIndex[LocaleDataIndex[\"NumberFormats\"] = 14] = \"NumberFormats\";\n  LocaleDataIndex[LocaleDataIndex[\"CurrencyCode\"] = 15] = \"CurrencyCode\";\n  LocaleDataIndex[LocaleDataIndex[\"CurrencySymbol\"] = 16] = \"CurrencySymbol\";\n  LocaleDataIndex[LocaleDataIndex[\"CurrencyName\"] = 17] = \"CurrencyName\";\n  LocaleDataIndex[LocaleDataIndex[\"Currencies\"] = 18] = \"Currencies\";\n  LocaleDataIndex[LocaleDataIndex[\"Directionality\"] = 19] = \"Directionality\";\n  LocaleDataIndex[LocaleDataIndex[\"PluralCase\"] = 20] = \"PluralCase\";\n  LocaleDataIndex[LocaleDataIndex[\"ExtraData\"] = 21] = \"ExtraData\";\n})(LocaleDataIndex || (LocaleDataIndex = {}));\n/**\n * Returns the canonical form of a locale name - lowercase with `_` replaced with `-`.\n */\n\n\nfunction normalizeLocale(locale) {\n  return locale.toLowerCase().replace(/_/g, '-');\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nconst pluralMapping = ['zero', 'one', 'two', 'few', 'many'];\n/**\n * Returns the plural case based on the locale\n */\n\nfunction getPluralCase(value, locale) {\n  const plural = getLocalePluralCase(locale)(parseInt(value, 10));\n  const result = pluralMapping[plural];\n  return result !== undefined ? result : 'other';\n}\n/**\n * The locale id that the application is using by default (for translations and ICU expressions).\n */\n\n\nconst DEFAULT_LOCALE_ID = 'en-US';\n/**\n * USD currency code that the application uses by default for CurrencyPipe when no\n * DEFAULT_CURRENCY_CODE is provided.\n */\n\nconst USD_CURRENCY_CODE = 'USD';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Marks that the next string is an element name.\n *\n * See `I18nMutateOpCodes` documentation.\n */\n\nconst ELEMENT_MARKER = {\n  marker: 'element'\n};\n/**\n * Marks that the next string is comment text need for ICU.\n *\n * See `I18nMutateOpCodes` documentation.\n */\n\nconst ICU_MARKER = {\n  marker: 'ICU'\n};\n/**\n * See `I18nCreateOpCodes`\n */\n\nvar I18nCreateOpCode;\n\n(function (I18nCreateOpCode) {\n  /**\n   * Number of bits to shift index so that it can be combined with the `APPEND_EAGERLY` and\n   * `COMMENT`.\n   */\n  I18nCreateOpCode[I18nCreateOpCode[\"SHIFT\"] = 2] = \"SHIFT\";\n  /**\n   * Should the node be appended to parent imedditatly after creation.\n   */\n\n  I18nCreateOpCode[I18nCreateOpCode[\"APPEND_EAGERLY\"] = 1] = \"APPEND_EAGERLY\";\n  /**\n   * If set the node should be comment (rather than a text) node.\n   */\n\n  I18nCreateOpCode[I18nCreateOpCode[\"COMMENT\"] = 2] = \"COMMENT\";\n})(I18nCreateOpCode || (I18nCreateOpCode = {})); // Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\n\n\nconst unusedValueExportToPlacateAjd$2 = 1;\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * The locale id that the application is currently using (for translations and ICU expressions).\n * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine\n * but is now defined as a global value.\n */\n\nlet LOCALE_ID = DEFAULT_LOCALE_ID;\n/**\n * Sets the locale id that will be used for translations and ICU expressions.\n * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine\n * but is now defined as a global value.\n *\n * @param localeId\n */\n\nfunction setLocaleId(localeId) {\n  assertDefined(localeId, `Expected localeId to be defined`);\n\n  if (typeof localeId === 'string') {\n    LOCALE_ID = localeId.toLowerCase().replace(/_/g, '-');\n  }\n}\n/**\n * Gets the locale id that will be used for translations and ICU expressions.\n * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine\n * but is now defined as a global value.\n */\n\n\nfunction getLocaleId() {\n  return LOCALE_ID;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Find a node in front of which `currentTNode` should be inserted (takes i18n into account).\n *\n * This method determines the `RNode` in front of which we should insert the `currentRNode`. This\n * takes `TNode.insertBeforeIndex` into account.\n *\n * @param parentTNode parent `TNode`\n * @param currentTNode current `TNode` (The node which we would like to insert into the DOM)\n * @param lView current `LView`\n */\n\n\nfunction getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView) {\n  const tNodeInsertBeforeIndex = currentTNode.insertBeforeIndex;\n  const insertBeforeIndex = Array.isArray(tNodeInsertBeforeIndex) ? tNodeInsertBeforeIndex[0] : tNodeInsertBeforeIndex;\n\n  if (insertBeforeIndex === null) {\n    return getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView);\n  } else {\n    ngDevMode && assertIndexInRange(lView, insertBeforeIndex);\n    return unwrapRNode(lView[insertBeforeIndex]);\n  }\n}\n/**\n * Process `TNode.insertBeforeIndex` by adding i18n text nodes.\n *\n * See `TNode.insertBeforeIndex`\n */\n\n\nfunction processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRElement) {\n  const tNodeInsertBeforeIndex = childTNode.insertBeforeIndex;\n\n  if (Array.isArray(tNodeInsertBeforeIndex)) {\n    // An array indicates that there are i18n nodes that need to be added as children of this\n    // `childRNode`. These i18n nodes were created before this `childRNode` was available and so\n    // only now can be added. The first element of the array is the normal index where we should\n    // insert the `childRNode`. Additional elements are the extra nodes to be added as children of\n    // `childRNode`.\n    ngDevMode && assertDomNode(childRNode);\n    let i18nParent = childRNode;\n    let anchorRNode = null;\n\n    if (!(childTNode.type & 3\n    /* TNodeType.AnyRNode */\n    )) {\n      anchorRNode = i18nParent;\n      i18nParent = parentRElement;\n    }\n\n    if (i18nParent !== null && (childTNode.flags & 2\n    /* TNodeFlags.isComponentHost */\n    ) === 0) {\n      for (let i = 1; i < tNodeInsertBeforeIndex.length; i++) {\n        // No need to `unwrapRNode` because all of the indexes point to i18n text nodes.\n        // see `assertDomNode` below.\n        const i18nChild = lView[tNodeInsertBeforeIndex[i]];\n        nativeInsertBefore(renderer, i18nParent, i18nChild, anchorRNode, false);\n      }\n    }\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Add `tNode` to `previousTNodes` list and update relevant `TNode`s in `previousTNodes` list\n * `tNode.insertBeforeIndex`.\n *\n * Things to keep in mind:\n * 1. All i18n text nodes are encoded as `TNodeType.Element` and are created eagerly by the\n *    `ɵɵi18nStart` instruction.\n * 2. All `TNodeType.Placeholder` `TNodes` are elements which will be created later by\n *    `ɵɵelementStart` instruction.\n * 3. `ɵɵelementStart` instruction will create `TNode`s in the ascending `TNode.index` order. (So a\n *    smaller index `TNode` is guaranteed to be created before a larger one)\n *\n * We use the above three invariants to determine `TNode.insertBeforeIndex`.\n *\n * In an ideal world `TNode.insertBeforeIndex` would always be `TNode.next.index`. However,\n * this will not work because `TNode.next.index` may be larger than `TNode.index` which means that\n * the next node is not yet created and therefore we can't insert in front of it.\n *\n * Rule1: `TNode.insertBeforeIndex = null` if `TNode.next === null` (Initial condition, as we don't\n *        know if there will be further `TNode`s inserted after.)\n * Rule2: If `previousTNode` is created after the `tNode` being inserted, then\n *        `previousTNode.insertBeforeNode = tNode.index` (So when a new `tNode` is added we check\n *        previous to see if we can update its `insertBeforeTNode`)\n *\n * See `TNode.insertBeforeIndex` for more context.\n *\n * @param previousTNodes A list of previous TNodes so that we can easily traverse `TNode`s in\n *     reverse order. (If `TNode` would have `previous` this would not be necessary.)\n * @param newTNode A TNode to add to the `previousTNodes` list.\n */\n\n\nfunction addTNodeAndUpdateInsertBeforeIndex(previousTNodes, newTNode) {\n  // Start with Rule1\n  ngDevMode && assertEqual(newTNode.insertBeforeIndex, null, 'We expect that insertBeforeIndex is not set');\n  previousTNodes.push(newTNode);\n\n  if (previousTNodes.length > 1) {\n    for (let i = previousTNodes.length - 2; i >= 0; i--) {\n      const existingTNode = previousTNodes[i]; // Text nodes are created eagerly and so they don't need their `indexBeforeIndex` updated.\n      // It is safe to ignore them.\n\n      if (!isI18nText(existingTNode)) {\n        if (isNewTNodeCreatedBefore(existingTNode, newTNode) && getInsertBeforeIndex(existingTNode) === null) {\n          // If it was created before us in time, (and it does not yet have `insertBeforeIndex`)\n          // then add the `insertBeforeIndex`.\n          setInsertBeforeIndex(existingTNode, newTNode.index);\n        }\n      }\n    }\n  }\n}\n\nfunction isI18nText(tNode) {\n  return !(tNode.type & 64\n  /* TNodeType.Placeholder */\n  );\n}\n\nfunction isNewTNodeCreatedBefore(existingTNode, newTNode) {\n  return isI18nText(newTNode) || existingTNode.index > newTNode.index;\n}\n\nfunction getInsertBeforeIndex(tNode) {\n  const index = tNode.insertBeforeIndex;\n  return Array.isArray(index) ? index[0] : index;\n}\n\nfunction setInsertBeforeIndex(tNode, value) {\n  const index = tNode.insertBeforeIndex;\n\n  if (Array.isArray(index)) {\n    // Array is stored if we have to insert child nodes. See `TNode.insertBeforeIndex`\n    index[0] = value;\n  } else {\n    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);\n    tNode.insertBeforeIndex = value;\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Retrieve `TIcu` at a given `index`.\n *\n * The `TIcu` can be stored either directly (if it is nested ICU) OR\n * it is stored inside tho `TIcuContainer` if it is top level ICU.\n *\n * The reason for this is that the top level ICU need a `TNode` so that they are part of the render\n * tree, but nested ICU's have no TNode, because we don't know ahead of time if the nested ICU is\n * expressed (parent ICU may have selected a case which does not contain it.)\n *\n * @param tView Current `TView`.\n * @param index Index where the value should be read from.\n */\n\n\nfunction getTIcu(tView, index) {\n  const value = tView.data[index];\n  if (value === null || typeof value === 'string') return null;\n\n  if (ngDevMode && !(value.hasOwnProperty('tViews') || value.hasOwnProperty('currentCaseLViewIndex'))) {\n    throwError('We expect to get \\'null\\'|\\'TIcu\\'|\\'TIcuContainer\\', but got: ' + value);\n  } // Here the `value.hasOwnProperty('currentCaseLViewIndex')` is a polymorphic read as it can be\n  // either TIcu or TIcuContainerNode. This is not ideal, but we still think it is OK because it\n  // will be just two cases which fits into the browser inline cache (inline cache can take up to\n  // 4)\n\n\n  const tIcu = value.hasOwnProperty('currentCaseLViewIndex') ? value : value.value;\n  ngDevMode && assertTIcu(tIcu);\n  return tIcu;\n}\n/**\n * Store `TIcu` at a give `index`.\n *\n * The `TIcu` can be stored either directly (if it is nested ICU) OR\n * it is stored inside tho `TIcuContainer` if it is top level ICU.\n *\n * The reason for this is that the top level ICU need a `TNode` so that they are part of the render\n * tree, but nested ICU's have no TNode, because we don't know ahead of time if the nested ICU is\n * expressed (parent ICU may have selected a case which does not contain it.)\n *\n * @param tView Current `TView`.\n * @param index Index where the value should be stored at in `Tview.data`\n * @param tIcu The TIcu to store.\n */\n\n\nfunction setTIcu(tView, index, tIcu) {\n  const tNode = tView.data[index];\n  ngDevMode && assertEqual(tNode === null || tNode.hasOwnProperty('tViews'), true, 'We expect to get \\'null\\'|\\'TIcuContainer\\'');\n\n  if (tNode === null) {\n    tView.data[index] = tIcu;\n  } else {\n    ngDevMode && assertTNodeType(tNode, 32\n    /* TNodeType.Icu */\n    );\n    tNode.value = tIcu;\n  }\n}\n/**\n * Set `TNode.insertBeforeIndex` taking the `Array` into account.\n *\n * See `TNode.insertBeforeIndex`\n */\n\n\nfunction setTNodeInsertBeforeIndex(tNode, index) {\n  ngDevMode && assertTNode(tNode);\n  let insertBeforeIndex = tNode.insertBeforeIndex;\n\n  if (insertBeforeIndex === null) {\n    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);\n    insertBeforeIndex = tNode.insertBeforeIndex = [null\n    /* may be updated to number later */\n    , index];\n  } else {\n    assertEqual(Array.isArray(insertBeforeIndex), true, 'Expecting array here');\n    insertBeforeIndex.push(index);\n  }\n}\n/**\n * Create `TNode.type=TNodeType.Placeholder` node.\n *\n * See `TNodeType.Placeholder` for more information.\n */\n\n\nfunction createTNodePlaceholder(tView, previousTNodes, index) {\n  const tNode = createTNodeAtIndex(tView, index, 64\n  /* TNodeType.Placeholder */\n  , null, null);\n  addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tNode);\n  return tNode;\n}\n/**\n * Returns current ICU case.\n *\n * ICU cases are stored as index into the `TIcu.cases`.\n * At times it is necessary to communicate that the ICU case just switched and that next ICU update\n * should update all bindings regardless of the mask. In such a case the we store negative numbers\n * for cases which have just been switched. This function removes the negative flag.\n */\n\n\nfunction getCurrentICUCaseIndex(tIcu, lView) {\n  const currentCase = lView[tIcu.currentCaseLViewIndex];\n  return currentCase === null ? currentCase : currentCase < 0 ? ~currentCase : currentCase;\n}\n\nfunction getParentFromIcuCreateOpCode(mergedCode) {\n  return mergedCode >>> 17\n  /* IcuCreateOpCode.SHIFT_PARENT */\n  ;\n}\n\nfunction getRefFromIcuCreateOpCode(mergedCode) {\n  return (mergedCode & 131070\n  /* IcuCreateOpCode.MASK_REF */\n  ) >>> 1\n  /* IcuCreateOpCode.SHIFT_REF */\n  ;\n}\n\nfunction getInstructionFromIcuCreateOpCode(mergedCode) {\n  return mergedCode & 1\n  /* IcuCreateOpCode.MASK_INSTRUCTION */\n  ;\n}\n\nfunction icuCreateOpCode(opCode, parentIdx, refIdx) {\n  ngDevMode && assertGreaterThanOrEqual(parentIdx, 0, 'Missing parent index');\n  ngDevMode && assertGreaterThan(refIdx, 0, 'Missing ref index');\n  return opCode | parentIdx << 17\n  /* IcuCreateOpCode.SHIFT_PARENT */\n  | refIdx << 1\n  /* IcuCreateOpCode.SHIFT_REF */\n  ;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Keep track of which input bindings in `ɵɵi18nExp` have changed.\n *\n * This is used to efficiently update expressions in i18n only when the corresponding input has\n * changed.\n *\n * 1) Each bit represents which of the `ɵɵi18nExp` has changed.\n * 2) There are 32 bits allowed in JS.\n * 3) Bit 32 is special as it is shared for all changes past 32. (In other words if you have more\n * than 32 `ɵɵi18nExp` then all changes past 32nd `ɵɵi18nExp` will be mapped to same bit. This means\n * that we may end up changing more than we need to. But i18n expressions with 32 bindings is rare\n * so in practice it should not be an issue.)\n */\n\n\nlet changeMask = 0b0;\n/**\n * Keeps track of which bit needs to be updated in `changeMask`\n *\n * This value gets incremented on every call to `ɵɵi18nExp`\n */\n\nlet changeMaskCounter = 0;\n/**\n * Keep track of which input bindings in `ɵɵi18nExp` have changed.\n *\n * `setMaskBit` gets invoked by each call to `ɵɵi18nExp`.\n *\n * @param hasChange did `ɵɵi18nExp` detect a change.\n */\n\nfunction setMaskBit(hasChange) {\n  if (hasChange) {\n    changeMask = changeMask | 1 << Math.min(changeMaskCounter, 31);\n  }\n\n  changeMaskCounter++;\n}\n\nfunction applyI18n(tView, lView, index) {\n  if (changeMaskCounter > 0) {\n    ngDevMode && assertDefined(tView, `tView should be defined`);\n    const tI18n = tView.data[index]; // When `index` points to an `ɵɵi18nAttributes` then we have an array otherwise `TI18n`\n\n    const updateOpCodes = Array.isArray(tI18n) ? tI18n : tI18n.update;\n    const bindingsStartIndex = getBindingIndex() - changeMaskCounter - 1;\n    applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask);\n  } // Reset changeMask & maskBit to default for the next update cycle\n\n\n  changeMask = 0b0;\n  changeMaskCounter = 0;\n}\n/**\n * Apply `I18nCreateOpCodes` op-codes as stored in `TI18n.create`.\n *\n * Creates text (and comment) nodes which are internationalized.\n *\n * @param lView Current lView\n * @param createOpCodes Set of op-codes to apply\n * @param parentRNode Parent node (so that direct children can be added eagerly) or `null` if it is\n *     a root node.\n * @param insertInFrontOf DOM node that should be used as an anchor.\n */\n\n\nfunction applyCreateOpCodes(lView, createOpCodes, parentRNode, insertInFrontOf) {\n  const renderer = lView[RENDERER];\n\n  for (let i = 0; i < createOpCodes.length; i++) {\n    const opCode = createOpCodes[i++];\n    const text = createOpCodes[i];\n    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;\n    const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;\n    const index = opCode >>> I18nCreateOpCode.SHIFT;\n    let rNode = lView[index];\n\n    if (rNode === null) {\n      // We only create new DOM nodes if they don't already exist: If ICU switches case back to a\n      // case which was already instantiated, no need to create new DOM nodes.\n      rNode = lView[index] = isComment ? renderer.createComment(text) : createTextNode(renderer, text);\n    }\n\n    if (appendNow && parentRNode !== null) {\n      nativeInsertBefore(renderer, parentRNode, rNode, insertInFrontOf, false);\n    }\n  }\n}\n/**\n * Apply `I18nMutateOpCodes` OpCodes.\n *\n * @param tView Current `TView`\n * @param mutableOpCodes Mutable OpCodes to process\n * @param lView Current `LView`\n * @param anchorRNode place where the i18n node should be inserted.\n */\n\n\nfunction applyMutableOpCodes(tView, mutableOpCodes, lView, anchorRNode) {\n  ngDevMode && assertDomNode(anchorRNode);\n  const renderer = lView[RENDERER]; // `rootIdx` represents the node into which all inserts happen.\n\n  let rootIdx = null; // `rootRNode` represents the real node into which we insert. This can be different from\n  // `lView[rootIdx]` if we have projection.\n  //  - null we don't have a parent (as can be the case in when we are inserting into a root of\n  //    LView which has no parent.)\n  //  - `RElement` The element representing the root after taking projection into account.\n\n  let rootRNode;\n\n  for (let i = 0; i < mutableOpCodes.length; i++) {\n    const opCode = mutableOpCodes[i];\n\n    if (typeof opCode == 'string') {\n      const textNodeIndex = mutableOpCodes[++i];\n\n      if (lView[textNodeIndex] === null) {\n        ngDevMode && ngDevMode.rendererCreateTextNode++;\n        ngDevMode && assertIndexInRange(lView, textNodeIndex);\n        lView[textNodeIndex] = createTextNode(renderer, opCode);\n      }\n    } else if (typeof opCode == 'number') {\n      switch (opCode & 1\n      /* IcuCreateOpCode.MASK_INSTRUCTION */\n      ) {\n        case 0\n        /* IcuCreateOpCode.AppendChild */\n        :\n          const parentIdx = getParentFromIcuCreateOpCode(opCode);\n\n          if (rootIdx === null) {\n            // The first operation should save the `rootIdx` because the first operation\n            // must insert into the root. (Only subsequent operations can insert into a dynamic\n            // parent)\n            rootIdx = parentIdx;\n            rootRNode = nativeParentNode(renderer, anchorRNode);\n          }\n\n          let insertInFrontOf;\n          let parentRNode;\n\n          if (parentIdx === rootIdx) {\n            insertInFrontOf = anchorRNode;\n            parentRNode = rootRNode;\n          } else {\n            insertInFrontOf = null;\n            parentRNode = unwrapRNode(lView[parentIdx]);\n          } // FIXME(misko): Refactor with `processI18nText`\n\n\n          if (parentRNode !== null) {\n            // This can happen if the `LView` we are adding to is not attached to a parent `LView`.\n            // In such a case there is no \"root\" we can attach to. This is fine, as we still need to\n            // create the elements. When the `LView` gets later added to a parent these \"root\" nodes\n            // get picked up and added.\n            ngDevMode && assertDomNode(parentRNode);\n            const refIdx = getRefFromIcuCreateOpCode(opCode);\n            ngDevMode && assertGreaterThan(refIdx, HEADER_OFFSET, 'Missing ref'); // `unwrapRNode` is not needed here as all of these point to RNodes as part of the i18n\n            // which can't have components.\n\n            const child = lView[refIdx];\n            ngDevMode && assertDomNode(child);\n            nativeInsertBefore(renderer, parentRNode, child, insertInFrontOf, false);\n            const tIcu = getTIcu(tView, refIdx);\n\n            if (tIcu !== null && typeof tIcu === 'object') {\n              // If we just added a comment node which has ICU then that ICU may have already been\n              // rendered and therefore we need to re-add it here.\n              ngDevMode && assertTIcu(tIcu);\n              const caseIndex = getCurrentICUCaseIndex(tIcu, lView);\n\n              if (caseIndex !== null) {\n                applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, lView[tIcu.anchorIdx]);\n              }\n            }\n          }\n\n          break;\n\n        case 1\n        /* IcuCreateOpCode.Attr */\n        :\n          const elementNodeIndex = opCode >>> 1\n          /* IcuCreateOpCode.SHIFT_REF */\n          ;\n          const attrName = mutableOpCodes[++i];\n          const attrValue = mutableOpCodes[++i]; // This code is used for ICU expressions only, since we don't support\n          // directives/components in ICUs, we don't need to worry about inputs here\n\n          setElementAttribute(renderer, getNativeByIndex(elementNodeIndex, lView), null, null, attrName, attrValue, null);\n          break;\n\n        default:\n          if (ngDevMode) {\n            throw new RuntimeError(700\n            /* RuntimeErrorCode.INVALID_I18N_STRUCTURE */\n            , `Unable to determine the type of mutate operation for \"${opCode}\"`);\n          }\n\n      }\n    } else {\n      switch (opCode) {\n        case ICU_MARKER:\n          const commentValue = mutableOpCodes[++i];\n          const commentNodeIndex = mutableOpCodes[++i];\n\n          if (lView[commentNodeIndex] === null) {\n            ngDevMode && assertEqual(typeof commentValue, 'string', `Expected \"${commentValue}\" to be a comment node value`);\n            ngDevMode && ngDevMode.rendererCreateComment++;\n            ngDevMode && assertIndexInExpandoRange(lView, commentNodeIndex);\n            const commentRNode = lView[commentNodeIndex] = createCommentNode(renderer, commentValue); // FIXME(misko): Attaching patch data is only needed for the root (Also add tests)\n\n            attachPatchData(commentRNode, lView);\n          }\n\n          break;\n\n        case ELEMENT_MARKER:\n          const tagName = mutableOpCodes[++i];\n          const elementNodeIndex = mutableOpCodes[++i];\n\n          if (lView[elementNodeIndex] === null) {\n            ngDevMode && assertEqual(typeof tagName, 'string', `Expected \"${tagName}\" to be an element node tag name`);\n            ngDevMode && ngDevMode.rendererCreateElement++;\n            ngDevMode && assertIndexInExpandoRange(lView, elementNodeIndex);\n            const elementRNode = lView[elementNodeIndex] = createElementNode(renderer, tagName, null); // FIXME(misko): Attaching patch data is only needed for the root (Also add tests)\n\n            attachPatchData(elementRNode, lView);\n          }\n\n          break;\n\n        default:\n          ngDevMode && throwError(`Unable to determine the type of mutate operation for \"${opCode}\"`);\n      }\n    }\n  }\n}\n/**\n * Apply `I18nUpdateOpCodes` OpCodes\n *\n * @param tView Current `TView`\n * @param lView Current `LView`\n * @param updateOpCodes OpCodes to process\n * @param bindingsStartIndex Location of the first `ɵɵi18nApply`\n * @param changeMask Each bit corresponds to a `ɵɵi18nExp` (Counting backwards from\n *     `bindingsStartIndex`)\n */\n\n\nfunction applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask) {\n  for (let i = 0; i < updateOpCodes.length; i++) {\n    // bit code to check if we should apply the next update\n    const checkBit = updateOpCodes[i]; // Number of opCodes to skip until next set of update codes\n\n    const skipCodes = updateOpCodes[++i];\n\n    if (checkBit & changeMask) {\n      // The value has been updated since last checked\n      let value = '';\n\n      for (let j = i + 1; j <= i + skipCodes; j++) {\n        const opCode = updateOpCodes[j];\n\n        if (typeof opCode == 'string') {\n          value += opCode;\n        } else if (typeof opCode == 'number') {\n          if (opCode < 0) {\n            // Negative opCode represent `i18nExp` values offset.\n            value += renderStringify(lView[bindingsStartIndex - opCode]);\n          } else {\n            const nodeIndex = opCode >>> 2\n            /* I18nUpdateOpCode.SHIFT_REF */\n            ;\n\n            switch (opCode & 3\n            /* I18nUpdateOpCode.MASK_OPCODE */\n            ) {\n              case 1\n              /* I18nUpdateOpCode.Attr */\n              :\n                const propName = updateOpCodes[++j];\n                const sanitizeFn = updateOpCodes[++j];\n                const tNodeOrTagName = tView.data[nodeIndex];\n                ngDevMode && assertDefined(tNodeOrTagName, 'Experting TNode or string');\n\n                if (typeof tNodeOrTagName === 'string') {\n                  // IF we don't have a `TNode`, then we are an element in ICU (as ICU content does\n                  // not have TNode), in which case we know that there are no directives, and hence\n                  // we use attribute setting.\n                  setElementAttribute(lView[RENDERER], lView[nodeIndex], null, tNodeOrTagName, propName, value, sanitizeFn);\n                } else {\n                  elementPropertyInternal(tView, tNodeOrTagName, lView, propName, value, lView[RENDERER], sanitizeFn, false);\n                }\n\n                break;\n\n              case 0\n              /* I18nUpdateOpCode.Text */\n              :\n                const rText = lView[nodeIndex];\n                rText !== null && updateTextNode(lView[RENDERER], rText, value);\n                break;\n\n              case 2\n              /* I18nUpdateOpCode.IcuSwitch */\n              :\n                applyIcuSwitchCase(tView, getTIcu(tView, nodeIndex), lView, value);\n                break;\n\n              case 3\n              /* I18nUpdateOpCode.IcuUpdate */\n              :\n                applyIcuUpdateCase(tView, getTIcu(tView, nodeIndex), bindingsStartIndex, lView);\n                break;\n            }\n          }\n        }\n      }\n    } else {\n      const opCode = updateOpCodes[i + 1];\n\n      if (opCode > 0 && (opCode & 3\n      /* I18nUpdateOpCode.MASK_OPCODE */\n      ) === 3\n      /* I18nUpdateOpCode.IcuUpdate */\n      ) {\n        // Special case for the `icuUpdateCase`. It could be that the mask did not match, but\n        // we still need to execute `icuUpdateCase` because the case has changed recently due to\n        // previous `icuSwitchCase` instruction. (`icuSwitchCase` and `icuUpdateCase` always come in\n        // pairs.)\n        const nodeIndex = opCode >>> 2\n        /* I18nUpdateOpCode.SHIFT_REF */\n        ;\n        const tIcu = getTIcu(tView, nodeIndex);\n        const currentIndex = lView[tIcu.currentCaseLViewIndex];\n\n        if (currentIndex < 0) {\n          applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView);\n        }\n      }\n    }\n\n    i += skipCodes;\n  }\n}\n/**\n * Apply OpCodes associated with updating an existing ICU.\n *\n * @param tView Current `TView`\n * @param tIcu Current `TIcu`\n * @param bindingsStartIndex Location of the first `ɵɵi18nApply`\n * @param lView Current `LView`\n */\n\n\nfunction applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView) {\n  ngDevMode && assertIndexInRange(lView, tIcu.currentCaseLViewIndex);\n  let activeCaseIndex = lView[tIcu.currentCaseLViewIndex];\n\n  if (activeCaseIndex !== null) {\n    let mask = changeMask;\n\n    if (activeCaseIndex < 0) {\n      // Clear the flag.\n      // Negative number means that the ICU was freshly created and we need to force the update.\n      activeCaseIndex = lView[tIcu.currentCaseLViewIndex] = ~activeCaseIndex; // -1 is same as all bits on, which simulates creation since it marks all bits dirty\n\n      mask = -1;\n    }\n\n    applyUpdateOpCodes(tView, lView, tIcu.update[activeCaseIndex], bindingsStartIndex, mask);\n  }\n}\n/**\n * Apply OpCodes associated with switching a case on ICU.\n *\n * This involves tearing down existing case and than building up a new case.\n *\n * @param tView Current `TView`\n * @param tIcu Current `TIcu`\n * @param lView Current `LView`\n * @param value Value of the case to update to.\n */\n\n\nfunction applyIcuSwitchCase(tView, tIcu, lView, value) {\n  // Rebuild a new case for this ICU\n  const caseIndex = getCaseIndex(tIcu, value);\n  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);\n\n  if (activeCaseIndex !== caseIndex) {\n    applyIcuSwitchCaseRemove(tView, tIcu, lView);\n    lView[tIcu.currentCaseLViewIndex] = caseIndex === null ? null : ~caseIndex;\n\n    if (caseIndex !== null) {\n      // Add the nodes for the new case\n      const anchorRNode = lView[tIcu.anchorIdx];\n\n      if (anchorRNode) {\n        ngDevMode && assertDomNode(anchorRNode);\n        applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, anchorRNode);\n      }\n    }\n  }\n}\n/**\n * Apply OpCodes associated with tearing ICU case.\n *\n * This involves tearing down existing case and than building up a new case.\n *\n * @param tView Current `TView`\n * @param tIcu Current `TIcu`\n * @param lView Current `LView`\n */\n\n\nfunction applyIcuSwitchCaseRemove(tView, tIcu, lView) {\n  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);\n\n  if (activeCaseIndex !== null) {\n    const removeCodes = tIcu.remove[activeCaseIndex];\n\n    for (let i = 0; i < removeCodes.length; i++) {\n      const nodeOrIcuIndex = removeCodes[i];\n\n      if (nodeOrIcuIndex > 0) {\n        // Positive numbers are `RNode`s.\n        const rNode = getNativeByIndex(nodeOrIcuIndex, lView);\n        rNode !== null && nativeRemoveNode(lView[RENDERER], rNode);\n      } else {\n        // Negative numbers are ICUs\n        applyIcuSwitchCaseRemove(tView, getTIcu(tView, ~nodeOrIcuIndex), lView);\n      }\n    }\n  }\n}\n/**\n * Returns the index of the current case of an ICU expression depending on the main binding value\n *\n * @param icuExpression\n * @param bindingValue The value of the main binding used by this ICU expression\n */\n\n\nfunction getCaseIndex(icuExpression, bindingValue) {\n  let index = icuExpression.cases.indexOf(bindingValue);\n\n  if (index === -1) {\n    switch (icuExpression.type) {\n      case 1\n      /* IcuType.plural */\n      :\n        {\n          const resolvedCase = getPluralCase(bindingValue, getLocaleId());\n          index = icuExpression.cases.indexOf(resolvedCase);\n\n          if (index === -1 && resolvedCase !== 'other') {\n            index = icuExpression.cases.indexOf('other');\n          }\n\n          break;\n        }\n\n      case 0\n      /* IcuType.select */\n      :\n        {\n          index = icuExpression.cases.indexOf('other');\n          break;\n        }\n    }\n  }\n\n  return index === -1 ? null : index;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction loadIcuContainerVisitor() {\n  const _stack = [];\n\n  let _index = -1;\n\n  let _lView;\n\n  let _removes;\n  /**\n   * Retrieves a set of root nodes from `TIcu.remove`. Used by `TNodeType.ICUContainer`\n   * to determine which root belong to the ICU.\n   *\n   * Example of usage.\n   * ```\n   * const nextRNode = icuContainerIteratorStart(tIcuContainerNode, lView);\n   * let rNode: RNode|null;\n   * while(rNode = nextRNode()) {\n   *   console.log(rNode);\n   * }\n   * ```\n   *\n   * @param tIcuContainerNode Current `TIcuContainerNode`\n   * @param lView `LView` where the `RNode`s should be looked up.\n   */\n\n\n  function icuContainerIteratorStart(tIcuContainerNode, lView) {\n    _lView = lView;\n\n    while (_stack.length) _stack.pop();\n\n    ngDevMode && assertTNodeForLView(tIcuContainerNode, lView);\n    enterIcu(tIcuContainerNode.value, lView);\n    return icuContainerIteratorNext;\n  }\n\n  function enterIcu(tIcu, lView) {\n    _index = 0;\n    const currentCase = getCurrentICUCaseIndex(tIcu, lView);\n\n    if (currentCase !== null) {\n      ngDevMode && assertNumberInRange(currentCase, 0, tIcu.cases.length - 1);\n      _removes = tIcu.remove[currentCase];\n    } else {\n      _removes = EMPTY_ARRAY;\n    }\n  }\n\n  function icuContainerIteratorNext() {\n    if (_index < _removes.length) {\n      const removeOpCode = _removes[_index++];\n      ngDevMode && assertNumber(removeOpCode, 'Expecting OpCode number');\n\n      if (removeOpCode > 0) {\n        const rNode = _lView[removeOpCode];\n        ngDevMode && assertDomNode(rNode);\n        return rNode;\n      } else {\n        _stack.push(_index, _removes); // ICUs are represented by negative indices\n\n\n        const tIcuIndex = ~removeOpCode;\n        const tIcu = _lView[TVIEW].data[tIcuIndex];\n        ngDevMode && assertTIcu(tIcu);\n        enterIcu(tIcu, _lView);\n        return icuContainerIteratorNext();\n      }\n    } else {\n      if (_stack.length === 0) {\n        return null;\n      } else {\n        _removes = _stack.pop();\n        _index = _stack.pop();\n        return icuContainerIteratorNext();\n      }\n    }\n  }\n\n  return icuContainerIteratorStart;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Converts `I18nCreateOpCodes` array into a human readable format.\n *\n * This function is attached to the `I18nCreateOpCodes.debug` property if `ngDevMode` is enabled.\n * This function provides a human readable view of the opcodes. This is useful when debugging the\n * application as well as writing more readable tests.\n *\n * @param this `I18nCreateOpCodes` if attached as a method.\n * @param opcodes `I18nCreateOpCodes` if invoked as a function.\n */\n\n\nfunction i18nCreateOpCodesToString(opcodes) {\n  const createOpCodes = opcodes || (Array.isArray(this) ? this : []);\n  let lines = [];\n\n  for (let i = 0; i < createOpCodes.length; i++) {\n    const opCode = createOpCodes[i++];\n    const text = createOpCodes[i];\n    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;\n    const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;\n    const index = opCode >>> I18nCreateOpCode.SHIFT;\n    lines.push(`lView[${index}] = document.${isComment ? 'createComment' : 'createText'}(${JSON.stringify(text)});`);\n\n    if (appendNow) {\n      lines.push(`parent.appendChild(lView[${index}]);`);\n    }\n  }\n\n  return lines;\n}\n/**\n * Converts `I18nUpdateOpCodes` array into a human readable format.\n *\n * This function is attached to the `I18nUpdateOpCodes.debug` property if `ngDevMode` is enabled.\n * This function provides a human readable view of the opcodes. This is useful when debugging the\n * application as well as writing more readable tests.\n *\n * @param this `I18nUpdateOpCodes` if attached as a method.\n * @param opcodes `I18nUpdateOpCodes` if invoked as a function.\n */\n\n\nfunction i18nUpdateOpCodesToString(opcodes) {\n  const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));\n  let lines = [];\n\n  function consumeOpCode(value) {\n    const ref = value >>> 2\n    /* I18nUpdateOpCode.SHIFT_REF */\n    ;\n    const opCode = value & 3\n    /* I18nUpdateOpCode.MASK_OPCODE */\n    ;\n\n    switch (opCode) {\n      case 0\n      /* I18nUpdateOpCode.Text */\n      :\n        return `(lView[${ref}] as Text).textContent = $$$`;\n\n      case 1\n      /* I18nUpdateOpCode.Attr */\n      :\n        const attrName = parser.consumeString();\n        const sanitizationFn = parser.consumeFunction();\n        const value = sanitizationFn ? `(${sanitizationFn})($$$)` : '$$$';\n        return `(lView[${ref}] as Element).setAttribute('${attrName}', ${value})`;\n\n      case 2\n      /* I18nUpdateOpCode.IcuSwitch */\n      :\n        return `icuSwitchCase(${ref}, $$$)`;\n\n      case 3\n      /* I18nUpdateOpCode.IcuUpdate */\n      :\n        return `icuUpdateCase(${ref})`;\n    }\n\n    throw new Error('unexpected OpCode');\n  }\n\n  while (parser.hasMore()) {\n    let mask = parser.consumeNumber();\n    let size = parser.consumeNumber();\n    const end = parser.i + size;\n    const statements = [];\n    let statement = '';\n\n    while (parser.i < end) {\n      let value = parser.consumeNumberOrString();\n\n      if (typeof value === 'string') {\n        statement += value;\n      } else if (value < 0) {\n        // Negative numbers are ref indexes\n        // Here `i` refers to current binding index. It is to signify that the value is relative,\n        // rather than absolute.\n        statement += '${lView[i' + value + ']}';\n      } else {\n        // Positive numbers are operations.\n        const opCodeText = consumeOpCode(value);\n        statements.push(opCodeText.replace('$$$', '`' + statement + '`') + ';');\n        statement = '';\n      }\n    }\n\n    lines.push(`if (mask & 0b${mask.toString(2)}) { ${statements.join(' ')} }`);\n  }\n\n  return lines;\n}\n/**\n * Converts `I18nCreateOpCodes` array into a human readable format.\n *\n * This function is attached to the `I18nCreateOpCodes.debug` if `ngDevMode` is enabled. This\n * function provides a human readable view of the opcodes. This is useful when debugging the\n * application as well as writing more readable tests.\n *\n * @param this `I18nCreateOpCodes` if attached as a method.\n * @param opcodes `I18nCreateOpCodes` if invoked as a function.\n */\n\n\nfunction icuCreateOpCodesToString(opcodes) {\n  const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));\n  let lines = [];\n\n  function consumeOpCode(opCode) {\n    const parent = getParentFromIcuCreateOpCode(opCode);\n    const ref = getRefFromIcuCreateOpCode(opCode);\n\n    switch (getInstructionFromIcuCreateOpCode(opCode)) {\n      case 0\n      /* IcuCreateOpCode.AppendChild */\n      :\n        return `(lView[${parent}] as Element).appendChild(lView[${lastRef}])`;\n\n      case 1\n      /* IcuCreateOpCode.Attr */\n      :\n        return `(lView[${ref}] as Element).setAttribute(\"${parser.consumeString()}\", \"${parser.consumeString()}\")`;\n    }\n\n    throw new Error('Unexpected OpCode: ' + getInstructionFromIcuCreateOpCode(opCode));\n  }\n\n  let lastRef = -1;\n\n  while (parser.hasMore()) {\n    let value = parser.consumeNumberStringOrMarker();\n\n    if (value === ICU_MARKER) {\n      const text = parser.consumeString();\n      lastRef = parser.consumeNumber();\n      lines.push(`lView[${lastRef}] = document.createComment(\"${text}\")`);\n    } else if (value === ELEMENT_MARKER) {\n      const text = parser.consumeString();\n      lastRef = parser.consumeNumber();\n      lines.push(`lView[${lastRef}] = document.createElement(\"${text}\")`);\n    } else if (typeof value === 'string') {\n      lastRef = parser.consumeNumber();\n      lines.push(`lView[${lastRef}] = document.createTextNode(\"${value}\")`);\n    } else if (typeof value === 'number') {\n      const line = consumeOpCode(value);\n      line && lines.push(line);\n    } else {\n      throw new Error('Unexpected value');\n    }\n  }\n\n  return lines;\n}\n/**\n * Converts `I18nRemoveOpCodes` array into a human readable format.\n *\n * This function is attached to the `I18nRemoveOpCodes.debug` if `ngDevMode` is enabled. This\n * function provides a human readable view of the opcodes. This is useful when debugging the\n * application as well as writing more readable tests.\n *\n * @param this `I18nRemoveOpCodes` if attached as a method.\n * @param opcodes `I18nRemoveOpCodes` if invoked as a function.\n */\n\n\nfunction i18nRemoveOpCodesToString(opcodes) {\n  const removeCodes = opcodes || (Array.isArray(this) ? this : []);\n  let lines = [];\n\n  for (let i = 0; i < removeCodes.length; i++) {\n    const nodeOrIcuIndex = removeCodes[i];\n\n    if (nodeOrIcuIndex > 0) {\n      // Positive numbers are `RNode`s.\n      lines.push(`remove(lView[${nodeOrIcuIndex}])`);\n    } else {\n      // Negative numbers are ICUs\n      lines.push(`removeNestedICU(${~nodeOrIcuIndex})`);\n    }\n  }\n\n  return lines;\n}\n\nclass OpCodeParser {\n  constructor(codes) {\n    this.i = 0;\n    this.codes = codes;\n  }\n\n  hasMore() {\n    return this.i < this.codes.length;\n  }\n\n  consumeNumber() {\n    let value = this.codes[this.i++];\n    assertNumber(value, 'expecting number in OpCode');\n    return value;\n  }\n\n  consumeString() {\n    let value = this.codes[this.i++];\n    assertString(value, 'expecting string in OpCode');\n    return value;\n  }\n\n  consumeFunction() {\n    let value = this.codes[this.i++];\n\n    if (value === null || typeof value === 'function') {\n      return value;\n    }\n\n    throw new Error('expecting function in OpCode');\n  }\n\n  consumeNumberOrString() {\n    let value = this.codes[this.i++];\n\n    if (typeof value === 'string') {\n      return value;\n    }\n\n    assertNumber(value, 'expecting number or string in OpCode');\n    return value;\n  }\n\n  consumeNumberStringOrMarker() {\n    let value = this.codes[this.i++];\n\n    if (typeof value === 'string' || typeof value === 'number' || value == ICU_MARKER || value == ELEMENT_MARKER) {\n      return value;\n    }\n\n    assertNumber(value, 'expecting number, string, ICU_MARKER or ELEMENT_MARKER in OpCode');\n    return value;\n  }\n\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nconst BINDING_REGEXP = /�(\\d+):?\\d*�/gi;\nconst ICU_REGEXP = /({\\s*�\\d+:?\\d*�\\s*,\\s*\\S{6}\\s*,[\\s\\S]*})/gi;\nconst NESTED_ICU = /�(\\d+)�/;\nconst ICU_BLOCK_REGEXP = /^\\s*(�\\d+:?\\d*�)\\s*,\\s*(select|plural)\\s*,/;\nconst MARKER = `�`;\nconst SUBTEMPLATE_REGEXP = /�\\/?\\*(\\d+:\\d+)�/gi;\nconst PH_REGEXP = /�(\\/?[#*]\\d+):?\\d*�/gi;\n/**\n * Angular Dart introduced &ngsp; as a placeholder for non-removable space, see:\n * https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart#L25-L32\n * In Angular Dart &ngsp; is converted to the 0xE500 PUA (Private Use Areas) unicode character\n * and later on replaced by a space. We are re-implementing the same idea here, since translations\n * might contain this special character.\n */\n\nconst NGSP_UNICODE_REGEXP = /\\uE500/g;\n\nfunction replaceNgsp(value) {\n  return value.replace(NGSP_UNICODE_REGEXP, ' ');\n}\n/**\n * Create dynamic nodes from i18n translation block.\n *\n * - Text nodes are created synchronously\n * - TNodes are linked into tree lazily\n *\n * @param tView Current `TView`\n * @parentTNodeIndex index to the parent TNode of this i18n block\n * @param lView Current `LView`\n * @param index Index of `ɵɵi18nStart` instruction.\n * @param message Message to translate.\n * @param subTemplateIndex Index into the sub template of message translation. (ie in case of\n *     `ngIf`) (-1 otherwise)\n */\n\n\nfunction i18nStartFirstCreatePass(tView, parentTNodeIndex, lView, index, message, subTemplateIndex) {\n  const rootTNode = getCurrentParentTNode();\n  const createOpCodes = [];\n  const updateOpCodes = [];\n  const existingTNodeStack = [[]];\n\n  if (ngDevMode) {\n    attachDebugGetter(createOpCodes, i18nCreateOpCodesToString);\n    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n  }\n\n  message = getTranslationForTemplate(message, subTemplateIndex);\n  const msgParts = replaceNgsp(message).split(PH_REGEXP);\n\n  for (let i = 0; i < msgParts.length; i++) {\n    let value = msgParts[i];\n\n    if ((i & 1) === 0) {\n      // Even indexes are text (including bindings & ICU expressions)\n      const parts = i18nParseTextIntoPartsAndICU(value);\n\n      for (let j = 0; j < parts.length; j++) {\n        let part = parts[j];\n\n        if ((j & 1) === 0) {\n          // `j` is odd therefore `part` is string\n          const text = part;\n          ngDevMode && assertString(text, 'Parsed ICU part should be string');\n\n          if (text !== '') {\n            i18nStartFirstCreatePassProcessTextNode(tView, rootTNode, existingTNodeStack[0], createOpCodes, updateOpCodes, lView, text);\n          }\n        } else {\n          // `j` is Even therefor `part` is an `ICUExpression`\n          const icuExpression = part; // Verify that ICU expression has the right shape. Translations might contain invalid\n          // constructions (while original messages were correct), so ICU parsing at runtime may\n          // not succeed (thus `icuExpression` remains a string).\n          // Note: we intentionally retain the error here by not using `ngDevMode`, because\n          // the value can change based on the locale and users aren't guaranteed to hit\n          // an invalid string while they're developing.\n\n          if (typeof icuExpression !== 'object') {\n            throw new Error(`Unable to parse ICU expression in \"${message}\" message.`);\n          }\n\n          const icuContainerTNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodeStack[0], lView, createOpCodes, ngDevMode ? `ICU ${index}:${icuExpression.mainBinding}` : '', true);\n          const icuNodeIndex = icuContainerTNode.index;\n          ngDevMode && assertGreaterThanOrEqual(icuNodeIndex, HEADER_OFFSET, 'Index must be in absolute LView offset');\n          icuStart(tView, lView, updateOpCodes, parentTNodeIndex, icuExpression, icuNodeIndex);\n        }\n      }\n    } else {\n      // Odd indexes are placeholders (elements and sub-templates)\n      // At this point value is something like: '/#1:2' (originally coming from '�/#1:2�')\n      const isClosing = value.charCodeAt(0) === 47\n      /* CharCode.SLASH */\n      ;\n      const type = value.charCodeAt(isClosing ? 1 : 0);\n      ngDevMode && assertOneOf(type, 42\n      /* CharCode.STAR */\n      , 35\n      /* CharCode.HASH */\n      );\n      const index = HEADER_OFFSET + Number.parseInt(value.substring(isClosing ? 2 : 1));\n\n      if (isClosing) {\n        existingTNodeStack.shift();\n        setCurrentTNode(getCurrentParentTNode(), false);\n      } else {\n        const tNode = createTNodePlaceholder(tView, existingTNodeStack[0], index);\n        existingTNodeStack.unshift([]);\n        setCurrentTNode(tNode, true);\n      }\n    }\n  }\n\n  tView.data[index] = {\n    create: createOpCodes,\n    update: updateOpCodes\n  };\n}\n/**\n * Allocate space in i18n Range add create OpCode instruction to create a text or comment node.\n *\n * @param tView Current `TView` needed to allocate space in i18n range.\n * @param rootTNode Root `TNode` of the i18n block. This node determines if the new TNode will be\n *     added as part of the `i18nStart` instruction or as part of the `TNode.insertBeforeIndex`.\n * @param existingTNodes internal state for `addTNodeAndUpdateInsertBeforeIndex`.\n * @param lView Current `LView` needed to allocate space in i18n range.\n * @param createOpCodes Array storing `I18nCreateOpCodes` where new opCodes will be added.\n * @param text Text to be added when the `Text` or `Comment` node will be created.\n * @param isICU true if a `Comment` node for ICU (instead of `Text`) node should be created.\n */\n\n\nfunction createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, text, isICU) {\n  const i18nNodeIdx = allocExpando(tView, lView, 1, null);\n  let opCode = i18nNodeIdx << I18nCreateOpCode.SHIFT;\n  let parentTNode = getCurrentParentTNode();\n\n  if (rootTNode === parentTNode) {\n    // FIXME(misko): A null `parentTNode` should represent when we fall of the `LView` boundary.\n    // (there is no parent), but in some circumstances (because we are inconsistent about how we set\n    // `previousOrParentTNode`) it could point to `rootTNode` So this is a work around.\n    parentTNode = null;\n  }\n\n  if (parentTNode === null) {\n    // If we don't have a parent that means that we can eagerly add nodes.\n    // If we have a parent than these nodes can't be added now (as the parent has not been created\n    // yet) and instead the `parentTNode` is responsible for adding it. See\n    // `TNode.insertBeforeIndex`\n    opCode |= I18nCreateOpCode.APPEND_EAGERLY;\n  }\n\n  if (isICU) {\n    opCode |= I18nCreateOpCode.COMMENT;\n    ensureIcuContainerVisitorLoaded(loadIcuContainerVisitor);\n  }\n\n  createOpCodes.push(opCode, text === null ? '' : text); // We store `{{?}}` so that when looking at debug `TNodeType.template` we can see where the\n  // bindings are.\n\n  const tNode = createTNodeAtIndex(tView, i18nNodeIdx, isICU ? 32\n  /* TNodeType.Icu */\n  : 1\n  /* TNodeType.Text */\n  , text === null ? ngDevMode ? '{{?}}' : '' : text, null);\n  addTNodeAndUpdateInsertBeforeIndex(existingTNodes, tNode);\n  const tNodeIdx = tNode.index;\n  setCurrentTNode(tNode, false\n  /* Text nodes are self closing */\n  );\n\n  if (parentTNode !== null && rootTNode !== parentTNode) {\n    // We are a child of deeper node (rather than a direct child of `i18nStart` instruction.)\n    // We have to make sure to add ourselves to the parent.\n    setTNodeInsertBeforeIndex(parentTNode, tNodeIdx);\n  }\n\n  return tNode;\n}\n/**\n * Processes text node in i18n block.\n *\n * Text nodes can have:\n * - Create instruction in `createOpCodes` for creating the text node.\n * - Allocate spec for text node in i18n range of `LView`\n * - If contains binding:\n *    - bindings => allocate space in i18n range of `LView` to store the binding value.\n *    - populate `updateOpCodes` with update instructions.\n *\n * @param tView Current `TView`\n * @param rootTNode Root `TNode` of the i18n block. This node determines if the new TNode will\n *     be added as part of the `i18nStart` instruction or as part of the\n *     `TNode.insertBeforeIndex`.\n * @param existingTNodes internal state for `addTNodeAndUpdateInsertBeforeIndex`.\n * @param createOpCodes Location where the creation OpCodes will be stored.\n * @param lView Current `LView`\n * @param text The translated text (which may contain binding)\n */\n\n\nfunction i18nStartFirstCreatePassProcessTextNode(tView, rootTNode, existingTNodes, createOpCodes, updateOpCodes, lView, text) {\n  const hasBinding = text.match(BINDING_REGEXP);\n  const tNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, hasBinding ? null : text, false);\n\n  if (hasBinding) {\n    generateBindingUpdateOpCodes(updateOpCodes, text, tNode.index, null, 0, null);\n  }\n}\n/**\n * See `i18nAttributes` above.\n */\n\n\nfunction i18nAttributesFirstPass(tView, index, values) {\n  const previousElement = getCurrentTNode();\n  const previousElementIndex = previousElement.index;\n  const updateOpCodes = [];\n\n  if (ngDevMode) {\n    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n  }\n\n  if (tView.firstCreatePass && tView.data[index] === null) {\n    for (let i = 0; i < values.length; i += 2) {\n      const attrName = values[i];\n      const message = values[i + 1];\n\n      if (message !== '') {\n        // Check if attribute value contains an ICU and throw an error if that's the case.\n        // ICUs in element attributes are not supported.\n        // Note: we intentionally retain the error here by not using `ngDevMode`, because\n        // the `value` can change based on the locale and users aren't guaranteed to hit\n        // an invalid string while they're developing.\n        if (ICU_REGEXP.test(message)) {\n          throw new Error(`ICU expressions are not supported in attributes. Message: \"${message}\".`);\n        } // i18n attributes that hit this code path are guaranteed to have bindings, because\n        // the compiler treats static i18n attributes as regular attribute bindings.\n        // Since this may not be the first i18n attribute on this element we need to pass in how\n        // many previous bindings there have already been.\n\n\n        generateBindingUpdateOpCodes(updateOpCodes, message, previousElementIndex, attrName, countBindings(updateOpCodes), null);\n      }\n    }\n\n    tView.data[index] = updateOpCodes;\n  }\n}\n/**\n * Generate the OpCodes to update the bindings of a string.\n *\n * @param updateOpCodes Place where the update opcodes will be stored.\n * @param str The string containing the bindings.\n * @param destinationNode Index of the destination node which will receive the binding.\n * @param attrName Name of the attribute, if the string belongs to an attribute.\n * @param sanitizeFn Sanitization function used to sanitize the string after update, if necessary.\n * @param bindingStart The lView index of the next expression that can be bound via an opCode.\n * @returns The mask value for these bindings\n */\n\n\nfunction generateBindingUpdateOpCodes(updateOpCodes, str, destinationNode, attrName, bindingStart, sanitizeFn) {\n  ngDevMode && assertGreaterThanOrEqual(destinationNode, HEADER_OFFSET, 'Index must be in absolute LView offset');\n  const maskIndex = updateOpCodes.length; // Location of mask\n\n  const sizeIndex = maskIndex + 1; // location of size for skipping\n\n  updateOpCodes.push(null, null); // Alloc space for mask and size\n\n  const startIndex = maskIndex + 2; // location of first allocation.\n\n  if (ngDevMode) {\n    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n  }\n\n  const textParts = str.split(BINDING_REGEXP);\n  let mask = 0;\n\n  for (let j = 0; j < textParts.length; j++) {\n    const textValue = textParts[j];\n\n    if (j & 1) {\n      // Odd indexes are bindings\n      const bindingIndex = bindingStart + parseInt(textValue, 10);\n      updateOpCodes.push(-1 - bindingIndex);\n      mask = mask | toMaskBit(bindingIndex);\n    } else if (textValue !== '') {\n      // Even indexes are text\n      updateOpCodes.push(textValue);\n    }\n  }\n\n  updateOpCodes.push(destinationNode << 2\n  /* I18nUpdateOpCode.SHIFT_REF */\n  | (attrName ? 1\n  /* I18nUpdateOpCode.Attr */\n  : 0\n  /* I18nUpdateOpCode.Text */\n  ));\n\n  if (attrName) {\n    updateOpCodes.push(attrName, sanitizeFn);\n  }\n\n  updateOpCodes[maskIndex] = mask;\n  updateOpCodes[sizeIndex] = updateOpCodes.length - startIndex;\n  return mask;\n}\n/**\n * Count the number of bindings in the given `opCodes`.\n *\n * It could be possible to speed this up, by passing the number of bindings found back from\n * `generateBindingUpdateOpCodes()` to `i18nAttributesFirstPass()` but this would then require more\n * complexity in the code and/or transient objects to be created.\n *\n * Since this function is only called once when the template is instantiated, is trivial in the\n * first instance (since `opCodes` will be an empty array), and it is not common for elements to\n * contain multiple i18n bound attributes, it seems like this is a reasonable compromise.\n */\n\n\nfunction countBindings(opCodes) {\n  let count = 0;\n\n  for (let i = 0; i < opCodes.length; i++) {\n    const opCode = opCodes[i]; // Bindings are negative numbers.\n\n    if (typeof opCode === 'number' && opCode < 0) {\n      count++;\n    }\n  }\n\n  return count;\n}\n/**\n * Convert binding index to mask bit.\n *\n * Each index represents a single bit on the bit-mask. Because bit-mask only has 32 bits, we make\n * the 32nd bit share all masks for all bindings higher than 32. Since it is extremely rare to\n * have more than 32 bindings this will be hit very rarely. The downside of hitting this corner\n * case is that we will execute binding code more often than necessary. (penalty of performance)\n */\n\n\nfunction toMaskBit(bindingIndex) {\n  return 1 << Math.min(bindingIndex, 31);\n}\n\nfunction isRootTemplateMessage(subTemplateIndex) {\n  return subTemplateIndex === -1;\n}\n/**\n * Removes everything inside the sub-templates of a message.\n */\n\n\nfunction removeInnerTemplateTranslation(message) {\n  let match;\n  let res = '';\n  let index = 0;\n  let inTemplate = false;\n  let tagMatched;\n\n  while ((match = SUBTEMPLATE_REGEXP.exec(message)) !== null) {\n    if (!inTemplate) {\n      res += message.substring(index, match.index + match[0].length);\n      tagMatched = match[1];\n      inTemplate = true;\n    } else {\n      if (match[0] === `${MARKER}/*${tagMatched}${MARKER}`) {\n        index = match.index;\n        inTemplate = false;\n      }\n    }\n  }\n\n  ngDevMode && assertEqual(inTemplate, false, `Tag mismatch: unable to find the end of the sub-template in the translation \"${message}\"`);\n  res += message.slice(index);\n  return res;\n}\n/**\n * Extracts a part of a message and removes the rest.\n *\n * This method is used for extracting a part of the message associated with a template. A\n * translated message can span multiple templates.\n *\n * Example:\n * ```\n * <div i18n>Translate <span *ngIf>me</span>!</div>\n * ```\n *\n * @param message The message to crop\n * @param subTemplateIndex Index of the sub-template to extract. If undefined it returns the\n * external template and removes all sub-templates.\n */\n\n\nfunction getTranslationForTemplate(message, subTemplateIndex) {\n  if (isRootTemplateMessage(subTemplateIndex)) {\n    // We want the root template message, ignore all sub-templates\n    return removeInnerTemplateTranslation(message);\n  } else {\n    // We want a specific sub-template\n    const start = message.indexOf(`:${subTemplateIndex}${MARKER}`) + 2 + subTemplateIndex.toString().length;\n    const end = message.search(new RegExp(`${MARKER}\\\\/\\\\*\\\\d+:${subTemplateIndex}${MARKER}`));\n    return removeInnerTemplateTranslation(message.substring(start, end));\n  }\n}\n/**\n * Generate the OpCodes for ICU expressions.\n *\n * @param icuExpression\n * @param index Index where the anchor is stored and an optional `TIcuContainerNode`\n *   - `lView[anchorIdx]` points to a `Comment` node representing the anchor for the ICU.\n *   - `tView.data[anchorIdx]` points to the `TIcuContainerNode` if ICU is root (`null` otherwise)\n */\n\n\nfunction icuStart(tView, lView, updateOpCodes, parentIdx, icuExpression, anchorIdx) {\n  ngDevMode && assertDefined(icuExpression, 'ICU expression must be defined');\n  let bindingMask = 0;\n  const tIcu = {\n    type: icuExpression.type,\n    currentCaseLViewIndex: allocExpando(tView, lView, 1, null),\n    anchorIdx,\n    cases: [],\n    create: [],\n    remove: [],\n    update: []\n  };\n  addUpdateIcuSwitch(updateOpCodes, icuExpression, anchorIdx);\n  setTIcu(tView, anchorIdx, tIcu);\n  const values = icuExpression.values;\n\n  for (let i = 0; i < values.length; i++) {\n    // Each value is an array of strings & other ICU expressions\n    const valueArr = values[i];\n    const nestedIcus = [];\n\n    for (let j = 0; j < valueArr.length; j++) {\n      const value = valueArr[j];\n\n      if (typeof value !== 'string') {\n        // It is an nested ICU expression\n        const icuIndex = nestedIcus.push(value) - 1; // Replace nested ICU expression by a comment node\n\n        valueArr[j] = `<!--�${icuIndex}�-->`;\n      }\n    }\n\n    bindingMask = parseIcuCase(tView, tIcu, lView, updateOpCodes, parentIdx, icuExpression.cases[i], valueArr.join(''), nestedIcus) | bindingMask;\n  }\n\n  if (bindingMask) {\n    addUpdateIcuUpdate(updateOpCodes, bindingMask, anchorIdx);\n  }\n}\n/**\n * Parses text containing an ICU expression and produces a JSON object for it.\n * Original code from closure library, modified for Angular.\n *\n * @param pattern Text containing an ICU expression that needs to be parsed.\n *\n */\n\n\nfunction parseICUBlock(pattern) {\n  const cases = [];\n  const values = [];\n  let icuType = 1\n  /* IcuType.plural */\n  ;\n  let mainBinding = 0;\n  pattern = pattern.replace(ICU_BLOCK_REGEXP, function (str, binding, type) {\n    if (type === 'select') {\n      icuType = 0\n      /* IcuType.select */\n      ;\n    } else {\n      icuType = 1\n      /* IcuType.plural */\n      ;\n    }\n\n    mainBinding = parseInt(binding.slice(1), 10);\n    return '';\n  });\n  const parts = i18nParseTextIntoPartsAndICU(pattern); // Looking for (key block)+ sequence. One of the keys has to be \"other\".\n\n  for (let pos = 0; pos < parts.length;) {\n    let key = parts[pos++].trim();\n\n    if (icuType === 1\n    /* IcuType.plural */\n    ) {\n      // Key can be \"=x\", we just want \"x\"\n      key = key.replace(/\\s*(?:=)?(\\w+)\\s*/, '$1');\n    }\n\n    if (key.length) {\n      cases.push(key);\n    }\n\n    const blocks = i18nParseTextIntoPartsAndICU(parts[pos++]);\n\n    if (cases.length > values.length) {\n      values.push(blocks);\n    }\n  } // TODO(ocombe): support ICU expressions in attributes, see #21615\n\n\n  return {\n    type: icuType,\n    mainBinding: mainBinding,\n    cases,\n    values\n  };\n}\n/**\n * Breaks pattern into strings and top level {...} blocks.\n * Can be used to break a message into text and ICU expressions, or to break an ICU expression\n * into keys and cases. Original code from closure library, modified for Angular.\n *\n * @param pattern (sub)Pattern to be broken.\n * @returns An `Array<string|IcuExpression>` where:\n *   - odd positions: `string` => text between ICU expressions\n *   - even positions: `ICUExpression` => ICU expression parsed into `ICUExpression` record.\n */\n\n\nfunction i18nParseTextIntoPartsAndICU(pattern) {\n  if (!pattern) {\n    return [];\n  }\n\n  let prevPos = 0;\n  const braceStack = [];\n  const results = [];\n  const braces = /[{}]/g; // lastIndex doesn't get set to 0 so we have to.\n\n  braces.lastIndex = 0;\n  let match;\n\n  while (match = braces.exec(pattern)) {\n    const pos = match.index;\n\n    if (match[0] == '}') {\n      braceStack.pop();\n\n      if (braceStack.length == 0) {\n        // End of the block.\n        const block = pattern.substring(prevPos, pos);\n\n        if (ICU_BLOCK_REGEXP.test(block)) {\n          results.push(parseICUBlock(block));\n        } else {\n          results.push(block);\n        }\n\n        prevPos = pos + 1;\n      }\n    } else {\n      if (braceStack.length == 0) {\n        const substring = pattern.substring(prevPos, pos);\n        results.push(substring);\n        prevPos = pos + 1;\n      }\n\n      braceStack.push('{');\n    }\n  }\n\n  const substring = pattern.substring(prevPos);\n  results.push(substring);\n  return results;\n}\n/**\n * Parses a node, its children and its siblings, and generates the mutate & update OpCodes.\n *\n */\n\n\nfunction parseIcuCase(tView, tIcu, lView, updateOpCodes, parentIdx, caseName, unsafeCaseHtml, nestedIcus) {\n  const create = [];\n  const remove = [];\n  const update = [];\n\n  if (ngDevMode) {\n    attachDebugGetter(create, icuCreateOpCodesToString);\n    attachDebugGetter(remove, i18nRemoveOpCodesToString);\n    attachDebugGetter(update, i18nUpdateOpCodesToString);\n  }\n\n  tIcu.cases.push(caseName);\n  tIcu.create.push(create);\n  tIcu.remove.push(remove);\n  tIcu.update.push(update);\n  const inertBodyHelper = getInertBodyHelper(getDocument());\n  const inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeCaseHtml);\n  ngDevMode && assertDefined(inertBodyElement, 'Unable to generate inert body element');\n  const inertRootNode = getTemplateContent(inertBodyElement) || inertBodyElement;\n\n  if (inertRootNode) {\n    return walkIcuTree(tView, tIcu, lView, updateOpCodes, create, remove, update, inertRootNode, parentIdx, nestedIcus, 0);\n  } else {\n    return 0;\n  }\n}\n\nfunction walkIcuTree(tView, tIcu, lView, sharedUpdateOpCodes, create, remove, update, parentNode, parentIdx, nestedIcus, depth) {\n  let bindingMask = 0;\n  let currentNode = parentNode.firstChild;\n\n  while (currentNode) {\n    const newIndex = allocExpando(tView, lView, 1, null);\n\n    switch (currentNode.nodeType) {\n      case Node.ELEMENT_NODE:\n        const element = currentNode;\n        const tagName = element.tagName.toLowerCase();\n\n        if (VALID_ELEMENTS.hasOwnProperty(tagName)) {\n          addCreateNodeAndAppend(create, ELEMENT_MARKER, tagName, parentIdx, newIndex);\n          tView.data[newIndex] = tagName;\n          const elAttrs = element.attributes;\n\n          for (let i = 0; i < elAttrs.length; i++) {\n            const attr = elAttrs.item(i);\n            const lowerAttrName = attr.name.toLowerCase();\n            const hasBinding = !!attr.value.match(BINDING_REGEXP); // we assume the input string is safe, unless it's using a binding\n\n            if (hasBinding) {\n              if (VALID_ATTRS.hasOwnProperty(lowerAttrName)) {\n                if (URI_ATTRS[lowerAttrName]) {\n                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, _sanitizeUrl);\n                } else if (SRCSET_ATTRS[lowerAttrName]) {\n                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, sanitizeSrcset);\n                } else {\n                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, null);\n                }\n              } else {\n                ngDevMode && console.warn(`WARNING: ignoring unsafe attribute value ` + `${lowerAttrName} on element ${tagName} ` + `(see https://g.co/ng/security#xss)`);\n              }\n            } else {\n              addCreateAttribute(create, newIndex, attr);\n            }\n          } // Parse the children of this node (if any)\n\n\n          bindingMask = walkIcuTree(tView, tIcu, lView, sharedUpdateOpCodes, create, remove, update, currentNode, newIndex, nestedIcus, depth + 1) | bindingMask;\n          addRemoveNode(remove, newIndex, depth);\n        }\n\n        break;\n\n      case Node.TEXT_NODE:\n        const value = currentNode.textContent || '';\n        const hasBinding = value.match(BINDING_REGEXP);\n        addCreateNodeAndAppend(create, null, hasBinding ? '' : value, parentIdx, newIndex);\n        addRemoveNode(remove, newIndex, depth);\n\n        if (hasBinding) {\n          bindingMask = generateBindingUpdateOpCodes(update, value, newIndex, null, 0, null) | bindingMask;\n        }\n\n        break;\n\n      case Node.COMMENT_NODE:\n        // Check if the comment node is a placeholder for a nested ICU\n        const isNestedIcu = NESTED_ICU.exec(currentNode.textContent || '');\n\n        if (isNestedIcu) {\n          const nestedIcuIndex = parseInt(isNestedIcu[1], 10);\n          const icuExpression = nestedIcus[nestedIcuIndex]; // Create the comment node that will anchor the ICU expression\n\n          addCreateNodeAndAppend(create, ICU_MARKER, ngDevMode ? `nested ICU ${nestedIcuIndex}` : '', parentIdx, newIndex);\n          icuStart(tView, lView, sharedUpdateOpCodes, parentIdx, icuExpression, newIndex);\n          addRemoveNestedIcu(remove, newIndex, depth);\n        }\n\n        break;\n    }\n\n    currentNode = currentNode.nextSibling;\n  }\n\n  return bindingMask;\n}\n\nfunction addRemoveNode(remove, index, depth) {\n  if (depth === 0) {\n    remove.push(index);\n  }\n}\n\nfunction addRemoveNestedIcu(remove, index, depth) {\n  if (depth === 0) {\n    remove.push(~index); // remove ICU at `index`\n\n    remove.push(index); // remove ICU comment at `index`\n  }\n}\n\nfunction addUpdateIcuSwitch(update, icuExpression, index) {\n  update.push(toMaskBit(icuExpression.mainBinding), 2, -1 - icuExpression.mainBinding, index << 2\n  /* I18nUpdateOpCode.SHIFT_REF */\n  | 2\n  /* I18nUpdateOpCode.IcuSwitch */\n  );\n}\n\nfunction addUpdateIcuUpdate(update, bindingMask, index) {\n  update.push(bindingMask, 1, index << 2\n  /* I18nUpdateOpCode.SHIFT_REF */\n  | 3\n  /* I18nUpdateOpCode.IcuUpdate */\n  );\n}\n\nfunction addCreateNodeAndAppend(create, marker, text, appendToParentIdx, createAtIdx) {\n  if (marker !== null) {\n    create.push(marker);\n  }\n\n  create.push(text, createAtIdx, icuCreateOpCode(0\n  /* IcuCreateOpCode.AppendChild */\n  , appendToParentIdx, createAtIdx));\n}\n\nfunction addCreateAttribute(create, newIndex, attr) {\n  create.push(newIndex << 1\n  /* IcuCreateOpCode.SHIFT_REF */\n  | 1\n  /* IcuCreateOpCode.Attr */\n  , attr.name, attr.value);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// i18nPostprocess consts\n\n\nconst ROOT_TEMPLATE_ID = 0;\nconst PP_MULTI_VALUE_PLACEHOLDERS_REGEXP = /\\[(�.+?�?)\\]/;\nconst PP_PLACEHOLDERS_REGEXP = /\\[(�.+?�?)\\]|(�\\/?\\*\\d+:\\d+�)/g;\nconst PP_ICU_VARS_REGEXP = /({\\s*)(VAR_(PLURAL|SELECT)(_\\d+)?)(\\s*,)/g;\nconst PP_ICU_PLACEHOLDERS_REGEXP = /{([A-Z0-9_]+)}/g;\nconst PP_ICUS_REGEXP = /�I18N_EXP_(ICU(_\\d+)?)�/g;\nconst PP_CLOSE_TEMPLATE_REGEXP = /\\/\\*/;\nconst PP_TEMPLATE_ID_REGEXP = /\\d+\\:(\\d+)/;\n/**\n * Handles message string post-processing for internationalization.\n *\n * Handles message string post-processing by transforming it from intermediate\n * format (that might contain some markers that we need to replace) to the final\n * form, consumable by i18nStart instruction. Post processing steps include:\n *\n * 1. Resolve all multi-value cases (like [�*1:1��#2:1�|�#4:1�|�5�])\n * 2. Replace all ICU vars (like \"VAR_PLURAL\")\n * 3. Replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n * 4. Replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�)\n *    in case multiple ICUs have the same placeholder name\n *\n * @param message Raw translation string for post processing\n * @param replacements Set of replacements that should be applied\n *\n * @returns Transformed string that can be consumed by i18nStart instruction\n *\n * @codeGenApi\n */\n\nfunction i18nPostprocess(message, replacements = {}) {\n  /**\n   * Step 1: resolve all multi-value placeholders like [�#5�|�*1:1��#2:1�|�#4:1�]\n   *\n   * Note: due to the way we process nested templates (BFS), multi-value placeholders are typically\n   * grouped by templates, for example: [�#5�|�#6�|�#1:1�|�#3:2�] where �#5� and �#6� belong to root\n   * template, �#1:1� belong to nested template with index 1 and �#1:2� - nested template with index\n   * 3. However in real templates the order might be different: i.e. �#1:1� and/or �#3:2� may go in\n   * front of �#6�. The post processing step restores the right order by keeping track of the\n   * template id stack and looks for placeholders that belong to the currently active template.\n   */\n  let result = message;\n\n  if (PP_MULTI_VALUE_PLACEHOLDERS_REGEXP.test(message)) {\n    const matches = {};\n    const templateIdsStack = [ROOT_TEMPLATE_ID];\n    result = result.replace(PP_PLACEHOLDERS_REGEXP, (m, phs, tmpl) => {\n      const content = phs || tmpl;\n      const placeholders = matches[content] || [];\n\n      if (!placeholders.length) {\n        content.split('|').forEach(placeholder => {\n          const match = placeholder.match(PP_TEMPLATE_ID_REGEXP);\n          const templateId = match ? parseInt(match[1], 10) : ROOT_TEMPLATE_ID;\n          const isCloseTemplateTag = PP_CLOSE_TEMPLATE_REGEXP.test(placeholder);\n          placeholders.push([templateId, isCloseTemplateTag, placeholder]);\n        });\n        matches[content] = placeholders;\n      }\n\n      if (!placeholders.length) {\n        throw new Error(`i18n postprocess: unmatched placeholder - ${content}`);\n      }\n\n      const currentTemplateId = templateIdsStack[templateIdsStack.length - 1];\n      let idx = 0; // find placeholder index that matches current template id\n\n      for (let i = 0; i < placeholders.length; i++) {\n        if (placeholders[i][0] === currentTemplateId) {\n          idx = i;\n          break;\n        }\n      } // update template id stack based on the current tag extracted\n\n\n      const [templateId, isCloseTemplateTag, placeholder] = placeholders[idx];\n\n      if (isCloseTemplateTag) {\n        templateIdsStack.pop();\n      } else if (currentTemplateId !== templateId) {\n        templateIdsStack.push(templateId);\n      } // remove processed tag from the list\n\n\n      placeholders.splice(idx, 1);\n      return placeholder;\n    });\n  } // return current result if no replacements specified\n\n\n  if (!Object.keys(replacements).length) {\n    return result;\n  }\n  /**\n   * Step 2: replace all ICU vars (like \"VAR_PLURAL\")\n   */\n\n\n  result = result.replace(PP_ICU_VARS_REGEXP, (match, start, key, _type, _idx, end) => {\n    return replacements.hasOwnProperty(key) ? `${start}${replacements[key]}${end}` : match;\n  });\n  /**\n   * Step 3: replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n   */\n\n  result = result.replace(PP_ICU_PLACEHOLDERS_REGEXP, (match, key) => {\n    return replacements.hasOwnProperty(key) ? replacements[key] : match;\n  });\n  /**\n   * Step 4: replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�) in case\n   * multiple ICUs have the same placeholder name\n   */\n\n  result = result.replace(PP_ICUS_REGEXP, (match, key) => {\n    if (replacements.hasOwnProperty(key)) {\n      const list = replacements[key];\n\n      if (!list.length) {\n        throw new Error(`i18n postprocess: unmatched ICU - ${match} with key: ${key}`);\n      }\n\n      return list.shift();\n    }\n\n    return match;\n  });\n  return result;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Marks a block of text as translatable.\n *\n * The instructions `i18nStart` and `i18nEnd` mark the translation block in the template.\n * The translation `message` is the value which is locale specific. The translation string may\n * contain placeholders which associate inner elements and sub-templates within the translation.\n *\n * The translation `message` placeholders are:\n * - `�{index}(:{block})�`: *Binding Placeholder*: Marks a location where an expression will be\n *   interpolated into. The placeholder `index` points to the expression binding index. An optional\n *   `block` that matches the sub-template in which it was declared.\n * - `�#{index}(:{block})�`/`�/#{index}(:{block})�`: *Element Placeholder*:  Marks the beginning\n *   and end of DOM element that were embedded in the original translation block. The placeholder\n *   `index` points to the element index in the template instructions set. An optional `block` that\n *   matches the sub-template in which it was declared.\n * - `�*{index}:{block}�`/`�/*{index}:{block}�`: *Sub-template Placeholder*: Sub-templates must be\n *   split up and translated separately in each angular template function. The `index` points to the\n *   `template` instruction index. A `block` that matches the sub-template in which it was declared.\n *\n * @param index A unique index of the translation in the static block.\n * @param messageIndex An index of the translation message from the `def.consts` array.\n * @param subTemplateIndex Optional sub-template index in the `message`.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵi18nStart(index, messageIndex, subTemplateIndex = -1) {\n  const tView = getTView();\n  const lView = getLView();\n  const adjustedIndex = HEADER_OFFSET + index;\n  ngDevMode && assertDefined(tView, `tView should be defined`);\n  const message = getConstant(tView.consts, messageIndex);\n  const parentTNode = getCurrentParentTNode();\n\n  if (tView.firstCreatePass) {\n    i18nStartFirstCreatePass(tView, parentTNode === null ? 0 : parentTNode.index, lView, adjustedIndex, message, subTemplateIndex);\n  }\n\n  const tI18n = tView.data[adjustedIndex];\n  const sameViewParentTNode = parentTNode === lView[T_HOST] ? null : parentTNode;\n  const parentRNode = getClosestRElement(tView, sameViewParentTNode, lView); // If `parentTNode` is an `ElementContainer` than it has `<!--ng-container--->`.\n  // When we do inserts we have to make sure to insert in front of `<!--ng-container--->`.\n\n  const insertInFrontOf = parentTNode && parentTNode.type & 8\n  /* TNodeType.ElementContainer */\n  ? lView[parentTNode.index] : null;\n  applyCreateOpCodes(lView, tI18n.create, parentRNode, insertInFrontOf);\n  setInI18nBlock(true);\n}\n/**\n * Translates a translation block marked by `i18nStart` and `i18nEnd`. It inserts the text/ICU nodes\n * into the render tree, moves the placeholder nodes and removes the deleted nodes.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵi18nEnd() {\n  setInI18nBlock(false);\n}\n/**\n *\n * Use this instruction to create a translation block that doesn't contain any placeholder.\n * It calls both {@link i18nStart} and {@link i18nEnd} in one instruction.\n *\n * The translation `message` is the value which is locale specific. The translation string may\n * contain placeholders which associate inner elements and sub-templates within the translation.\n *\n * The translation `message` placeholders are:\n * - `�{index}(:{block})�`: *Binding Placeholder*: Marks a location where an expression will be\n *   interpolated into. The placeholder `index` points to the expression binding index. An optional\n *   `block` that matches the sub-template in which it was declared.\n * - `�#{index}(:{block})�`/`�/#{index}(:{block})�`: *Element Placeholder*:  Marks the beginning\n *   and end of DOM element that were embedded in the original translation block. The placeholder\n *   `index` points to the element index in the template instructions set. An optional `block` that\n *   matches the sub-template in which it was declared.\n * - `�*{index}:{block}�`/`�/*{index}:{block}�`: *Sub-template Placeholder*: Sub-templates must be\n *   split up and translated separately in each angular template function. The `index` points to the\n *   `template` instruction index. A `block` that matches the sub-template in which it was declared.\n *\n * @param index A unique index of the translation in the static block.\n * @param messageIndex An index of the translation message from the `def.consts` array.\n * @param subTemplateIndex Optional sub-template index in the `message`.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵi18n(index, messageIndex, subTemplateIndex) {\n  ɵɵi18nStart(index, messageIndex, subTemplateIndex);\n  ɵɵi18nEnd();\n}\n/**\n * Marks a list of attributes as translatable.\n *\n * @param index A unique index in the static block\n * @param values\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵi18nAttributes(index, attrsIndex) {\n  const tView = getTView();\n  ngDevMode && assertDefined(tView, `tView should be defined`);\n  const attrs = getConstant(tView.consts, attrsIndex);\n  i18nAttributesFirstPass(tView, index + HEADER_OFFSET, attrs);\n}\n/**\n * Stores the values of the bindings during each update cycle in order to determine if we need to\n * update the translated nodes.\n *\n * @param value The binding's value\n * @returns This function returns itself so that it may be chained\n * (e.g. `i18nExp(ctx.name)(ctx.title)`)\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵi18nExp(value) {\n  const lView = getLView();\n  setMaskBit(bindingUpdated(lView, nextBindingIndex(), value));\n  return ɵɵi18nExp;\n}\n/**\n * Updates a translation block or an i18n attribute when the bindings have changed.\n *\n * @param index Index of either {@link i18nStart} (translation block) or {@link i18nAttributes}\n * (i18n attribute) on which it should update the content.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵi18nApply(index) {\n  applyI18n(getTView(), getLView(), index + HEADER_OFFSET);\n}\n/**\n * Handles message string post-processing for internationalization.\n *\n * Handles message string post-processing by transforming it from intermediate\n * format (that might contain some markers that we need to replace) to the final\n * form, consumable by i18nStart instruction. Post processing steps include:\n *\n * 1. Resolve all multi-value cases (like [�*1:1��#2:1�|�#4:1�|�5�])\n * 2. Replace all ICU vars (like \"VAR_PLURAL\")\n * 3. Replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n * 4. Replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�)\n *    in case multiple ICUs have the same placeholder name\n *\n * @param message Raw translation string for post processing\n * @param replacements Set of replacements that should be applied\n *\n * @returns Transformed string that can be consumed by i18nStart instruction\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵi18nPostprocess(message, replacements = {}) {\n  return i18nPostprocess(message, replacements);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Resolves the providers which are defined in the DirectiveDef.\n *\n * When inserting the tokens and the factories in their respective arrays, we can assume that\n * this method is called first for the component (if any), and then for other directives on the same\n * node.\n * As a consequence,the providers are always processed in that order:\n * 1) The view providers of the component\n * 2) The providers of the component\n * 3) The providers of the other directives\n * This matches the structure of the injectables arrays of a view (for each node).\n * So the tokens and the factories can be pushed at the end of the arrays, except\n * in one case for multi providers.\n *\n * @param def the directive definition\n * @param providers: Array of `providers`.\n * @param viewProviders: Array of `viewProviders`.\n */\n\n\nfunction providersResolver(def, providers, viewProviders) {\n  const tView = getTView();\n\n  if (tView.firstCreatePass) {\n    const isComponent = isComponentDef(def); // The list of view providers is processed first, and the flags are updated\n\n    resolveProvider(viewProviders, tView.data, tView.blueprint, isComponent, true); // Then, the list of providers is processed, and the flags are updated\n\n    resolveProvider(providers, tView.data, tView.blueprint, isComponent, false);\n  }\n}\n/**\n * Resolves a provider and publishes it to the DI system.\n */\n\n\nfunction resolveProvider(provider, tInjectables, lInjectablesBlueprint, isComponent, isViewProvider) {\n  provider = resolveForwardRef(provider);\n\n  if (Array.isArray(provider)) {\n    // Recursively call `resolveProvider`\n    // Recursion is OK in this case because this code will not be in hot-path once we implement\n    // cloning of the initial state.\n    for (let i = 0; i < provider.length; i++) {\n      resolveProvider(provider[i], tInjectables, lInjectablesBlueprint, isComponent, isViewProvider);\n    }\n  } else {\n    const tView = getTView();\n    const lView = getLView();\n    let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider.provide);\n    let providerFactory = providerToFactory(provider);\n    const tNode = getCurrentTNode();\n    const beginIndex = tNode.providerIndexes & 1048575\n    /* TNodeProviderIndexes.ProvidersStartIndexMask */\n    ;\n    const endIndex = tNode.directiveStart;\n    const cptViewProvidersCount = tNode.providerIndexes >> 20\n    /* TNodeProviderIndexes.CptViewProvidersCountShift */\n    ;\n\n    if (isTypeProvider(provider) || !provider.multi) {\n      // Single provider case: the factory is created and pushed immediately\n      const factory = new NodeInjectorFactory(providerFactory, isViewProvider, ɵɵdirectiveInject);\n      const existingFactoryIndex = indexOf(token, tInjectables, isViewProvider ? beginIndex : beginIndex + cptViewProvidersCount, endIndex);\n\n      if (existingFactoryIndex === -1) {\n        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);\n        registerDestroyHooksIfSupported(tView, provider, tInjectables.length);\n        tInjectables.push(token);\n        tNode.directiveStart++;\n        tNode.directiveEnd++;\n\n        if (isViewProvider) {\n          tNode.providerIndexes += 1048576\n          /* TNodeProviderIndexes.CptViewProvidersCountShifter */\n          ;\n        }\n\n        lInjectablesBlueprint.push(factory);\n        lView.push(factory);\n      } else {\n        lInjectablesBlueprint[existingFactoryIndex] = factory;\n        lView[existingFactoryIndex] = factory;\n      }\n    } else {\n      // Multi provider case:\n      // We create a multi factory which is going to aggregate all the values.\n      // Since the output of such a factory depends on content or view injection,\n      // we create two of them, which are linked together.\n      //\n      // The first one (for view providers) is always in the first block of the injectables array,\n      // and the second one (for providers) is always in the second block.\n      // This is important because view providers have higher priority. When a multi token\n      // is being looked up, the view providers should be found first.\n      // Note that it is not possible to have a multi factory in the third block (directive block).\n      //\n      // The algorithm to process multi providers is as follows:\n      // 1) If the multi provider comes from the `viewProviders` of the component:\n      //   a) If the special view providers factory doesn't exist, it is created and pushed.\n      //   b) Else, the multi provider is added to the existing multi factory.\n      // 2) If the multi provider comes from the `providers` of the component or of another\n      // directive:\n      //   a) If the multi factory doesn't exist, it is created and provider pushed into it.\n      //      It is also linked to the multi factory for view providers, if it exists.\n      //   b) Else, the multi provider is added to the existing multi factory.\n      const existingProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex + cptViewProvidersCount, endIndex);\n      const existingViewProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex, beginIndex + cptViewProvidersCount);\n      const doesProvidersFactoryExist = existingProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingProvidersFactoryIndex];\n      const doesViewProvidersFactoryExist = existingViewProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingViewProvidersFactoryIndex];\n\n      if (isViewProvider && !doesViewProvidersFactoryExist || !isViewProvider && !doesProvidersFactoryExist) {\n        // Cases 1.a and 2.a\n        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);\n        const factory = multiFactory(isViewProvider ? multiViewProvidersFactoryResolver : multiProvidersFactoryResolver, lInjectablesBlueprint.length, isViewProvider, isComponent, providerFactory);\n\n        if (!isViewProvider && doesViewProvidersFactoryExist) {\n          lInjectablesBlueprint[existingViewProvidersFactoryIndex].providerFactory = factory;\n        }\n\n        registerDestroyHooksIfSupported(tView, provider, tInjectables.length, 0);\n        tInjectables.push(token);\n        tNode.directiveStart++;\n        tNode.directiveEnd++;\n\n        if (isViewProvider) {\n          tNode.providerIndexes += 1048576\n          /* TNodeProviderIndexes.CptViewProvidersCountShifter */\n          ;\n        }\n\n        lInjectablesBlueprint.push(factory);\n        lView.push(factory);\n      } else {\n        // Cases 1.b and 2.b\n        const indexInFactory = multiFactoryAdd(lInjectablesBlueprint[isViewProvider ? existingViewProvidersFactoryIndex : existingProvidersFactoryIndex], providerFactory, !isViewProvider && isComponent);\n        registerDestroyHooksIfSupported(tView, provider, existingProvidersFactoryIndex > -1 ? existingProvidersFactoryIndex : existingViewProvidersFactoryIndex, indexInFactory);\n      }\n\n      if (!isViewProvider && isComponent && doesViewProvidersFactoryExist) {\n        lInjectablesBlueprint[existingViewProvidersFactoryIndex].componentProviders++;\n      }\n    }\n  }\n}\n/**\n * Registers the `ngOnDestroy` hook of a provider, if the provider supports destroy hooks.\n * @param tView `TView` in which to register the hook.\n * @param provider Provider whose hook should be registered.\n * @param contextIndex Index under which to find the context for the hook when it's being invoked.\n * @param indexInFactory Only required for `multi` providers. Index of the provider in the multi\n * provider factory.\n */\n\n\nfunction registerDestroyHooksIfSupported(tView, provider, contextIndex, indexInFactory) {\n  const providerIsTypeProvider = isTypeProvider(provider);\n  const providerIsClassProvider = isClassProvider(provider);\n\n  if (providerIsTypeProvider || providerIsClassProvider) {\n    // Resolve forward references as `useClass` can hold a forward reference.\n    const classToken = providerIsClassProvider ? resolveForwardRef(provider.useClass) : provider;\n    const prototype = classToken.prototype;\n    const ngOnDestroy = prototype.ngOnDestroy;\n\n    if (ngOnDestroy) {\n      const hooks = tView.destroyHooks || (tView.destroyHooks = []);\n\n      if (!providerIsTypeProvider && provider.multi) {\n        ngDevMode && assertDefined(indexInFactory, 'indexInFactory when registering multi factory destroy hook');\n        const existingCallbacksIndex = hooks.indexOf(contextIndex);\n\n        if (existingCallbacksIndex === -1) {\n          hooks.push(contextIndex, [indexInFactory, ngOnDestroy]);\n        } else {\n          hooks[existingCallbacksIndex + 1].push(indexInFactory, ngOnDestroy);\n        }\n      } else {\n        hooks.push(contextIndex, ngOnDestroy);\n      }\n    }\n  }\n}\n/**\n * Add a factory in a multi factory.\n * @returns Index at which the factory was inserted.\n */\n\n\nfunction multiFactoryAdd(multiFactory, factory, isComponentProvider) {\n  if (isComponentProvider) {\n    multiFactory.componentProviders++;\n  }\n\n  return multiFactory.multi.push(factory) - 1;\n}\n/**\n * Returns the index of item in the array, but only in the begin to end range.\n */\n\n\nfunction indexOf(item, arr, begin, end) {\n  for (let i = begin; i < end; i++) {\n    if (arr[i] === item) return i;\n  }\n\n  return -1;\n}\n/**\n * Use this with `multi` `providers`.\n */\n\n\nfunction multiProvidersFactoryResolver(_, tData, lData, tNode) {\n  return multiResolve(this.multi, []);\n}\n/**\n * Use this with `multi` `viewProviders`.\n *\n * This factory knows how to concatenate itself with the existing `multi` `providers`.\n */\n\n\nfunction multiViewProvidersFactoryResolver(_, tData, lView, tNode) {\n  const factories = this.multi;\n  let result;\n\n  if (this.providerFactory) {\n    const componentCount = this.providerFactory.componentProviders;\n    const multiProviders = getNodeInjectable(lView, lView[TVIEW], this.providerFactory.index, tNode); // Copy the section of the array which contains `multi` `providers` from the component\n\n    result = multiProviders.slice(0, componentCount); // Insert the `viewProvider` instances.\n\n    multiResolve(factories, result); // Copy the section of the array which contains `multi` `providers` from other directives\n\n    for (let i = componentCount; i < multiProviders.length; i++) {\n      result.push(multiProviders[i]);\n    }\n  } else {\n    result = []; // Insert the `viewProvider` instances.\n\n    multiResolve(factories, result);\n  }\n\n  return result;\n}\n/**\n * Maps an array of factories into an array of values.\n */\n\n\nfunction multiResolve(factories, result) {\n  for (let i = 0; i < factories.length; i++) {\n    const factory = factories[i];\n    result.push(factory());\n  }\n\n  return result;\n}\n/**\n * Creates a multi factory.\n */\n\n\nfunction multiFactory(factoryFn, index, isViewProvider, isComponent, f) {\n  const factory = new NodeInjectorFactory(factoryFn, isViewProvider, ɵɵdirectiveInject);\n  factory.multi = [];\n  factory.index = index;\n  factory.componentProviders = 0;\n  multiFactoryAdd(factory, f, isComponent && !isViewProvider);\n  return factory;\n}\n/**\n * This feature resolves the providers of a directive (or component),\n * and publish them into the DI system, making it visible to others for injection.\n *\n * For example:\n * ```ts\n * class ComponentWithProviders {\n *   constructor(private greeter: GreeterDE) {}\n *\n *   static ɵcmp = defineComponent({\n *     type: ComponentWithProviders,\n *     selectors: [['component-with-providers']],\n *    factory: () => new ComponentWithProviders(directiveInject(GreeterDE as any)),\n *    decls: 1,\n *    vars: 1,\n *    template: function(fs: RenderFlags, ctx: ComponentWithProviders) {\n *      if (fs & RenderFlags.Create) {\n *        ɵɵtext(0);\n *      }\n *      if (fs & RenderFlags.Update) {\n *        ɵɵtextInterpolate(ctx.greeter.greet());\n *      }\n *    },\n *    features: [ɵɵProvidersFeature([GreeterDE])]\n *  });\n * }\n * ```\n *\n * @param definition\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵProvidersFeature(providers, viewProviders = []) {\n  return definition => {\n    definition.providersResolver = (def, processProvidersFn) => {\n      return providersResolver(def, //\n      processProvidersFn ? processProvidersFn(providers) : providers, //\n      viewProviders);\n    };\n  };\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction noComponentFactoryError(component) {\n  const error = Error(`No component factory found for ${stringify(component)}. Did you add it to @NgModule.entryComponents?`);\n  error[ERROR_COMPONENT] = component;\n  return error;\n}\n\nconst ERROR_COMPONENT = 'ngComponent';\n\nfunction getComponent(error) {\n  return error[ERROR_COMPONENT];\n}\n\nclass _NullComponentFactoryResolver {\n  resolveComponentFactory(component) {\n    throw noComponentFactoryError(component);\n  }\n\n}\n/**\n * A simple registry that maps `Components` to generated `ComponentFactory` classes\n * that can be used to create instances of components.\n * Use to obtain the factory for a given component type,\n * then use the factory's `create()` method to create a component of that type.\n *\n * Note: since v13, dynamic component creation via\n * [`ViewContainerRef.createComponent`](api/core/ViewContainerRef#createComponent)\n * does **not** require resolving component factory: component class can be used directly.\n *\n * @publicApi\n *\n * @deprecated Angular no longer requires Component factories. Please use other APIs where\n *     Component class can be used directly.\n */\n\n\nclass ComponentFactoryResolver$1 {}\n\nComponentFactoryResolver$1.NULL = /* @__PURE__ */new _NullComponentFactoryResolver();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Represents an instance of an `NgModule` created by an `NgModuleFactory`.\n * Provides access to the `NgModule` instance and related objects.\n *\n * @publicApi\n */\n\nclass NgModuleRef$1 {}\n/**\n * @publicApi\n *\n * @deprecated\n * This class was mostly used as a part of ViewEngine-based JIT API and is no longer needed in Ivy\n * JIT mode. See [JIT API changes due to ViewEngine deprecation](guide/deprecations#jit-api-changes)\n * for additional context. Angular provides APIs that accept NgModule classes directly (such as\n * [PlatformRef.bootstrapModule](api/core/PlatformRef#bootstrapModule) and\n * [createNgModuleRef](api/core/createNgModuleRef)), consider switching to those APIs instead of\n * using factory-based ones.\n */\n\n\nclass NgModuleFactory$1 {}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Represents a component created by a `ComponentFactory`.\n * Provides access to the component instance and related objects,\n * and provides the means of destroying the instance.\n *\n * @publicApi\n */\n\n\nclass ComponentRef$1 {}\n/**\n * Base class for a factory that can create a component dynamically.\n * Instantiate a factory for a given type of component with `resolveComponentFactory()`.\n * Use the resulting `ComponentFactory.create()` method to create a component of that type.\n *\n * @see [Dynamic Components](guide/dynamic-component-loader)\n *\n * @publicApi\n *\n * @deprecated Angular no longer requires Component factories. Please use other APIs where\n *     Component class can be used directly.\n */\n\n\nclass ComponentFactory$1 {}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Creates an ElementRef from the most recent node.\n *\n * @returns The ElementRef instance to use\n */\n\n\nfunction injectElementRef() {\n  return createElementRef(getCurrentTNode(), getLView());\n}\n/**\n * Creates an ElementRef given a node.\n *\n * @param tNode The node for which you'd like an ElementRef\n * @param lView The view to which the node belongs\n * @returns The ElementRef instance to use\n */\n\n\nfunction createElementRef(tNode, lView) {\n  return new ElementRef(getNativeByTNode(tNode, lView));\n}\n/**\n * A wrapper around a native element inside of a View.\n *\n * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM\n * element.\n *\n * @security Permitting direct access to the DOM can make your application more vulnerable to\n * XSS attacks. Carefully review any use of `ElementRef` in your code. For more detail, see the\n * [Security Guide](https://g.co/ng/security).\n *\n * @publicApi\n */\n// Note: We don't expose things like `Injector`, `ViewContainer`, ... here,\n// i.e. users have to ask for what they need. With that, we can build better analysis tools\n// and could do better codegen in the future.\n\n\nclass ElementRef {\n  constructor(nativeElement) {\n    this.nativeElement = nativeElement;\n  }\n\n}\n/**\n * @internal\n * @nocollapse\n */\n\n\nElementRef.__NG_ELEMENT_ID__ = injectElementRef;\n/**\n * Unwraps `ElementRef` and return the `nativeElement`.\n *\n * @param value value to unwrap\n * @returns `nativeElement` if `ElementRef` otherwise returns value as is.\n */\n\nfunction unwrapElementRef(value) {\n  return value instanceof ElementRef ? value.nativeElement : value;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nconst Renderer2Interceptor = new InjectionToken('Renderer2Interceptor');\n/**\n * Creates and initializes a custom renderer that implements the `Renderer2` base class.\n *\n * @publicApi\n */\n\nclass RendererFactory2 {}\n/**\n * Extend this base class to implement custom rendering. By default, Angular\n * renders a template into DOM. You can use custom rendering to intercept\n * rendering calls, or to render to something other than DOM.\n *\n * Create your custom renderer using `RendererFactory2`.\n *\n * Use a custom renderer to bypass Angular's templating and\n * make custom UI changes that can't be expressed declaratively.\n * For example if you need to set a property or an attribute whose name is\n * not statically known, use the `setProperty()` or\n * `setAttribute()` method.\n *\n * @publicApi\n */\n\n\nclass Renderer2 {}\n/**\n * @internal\n * @nocollapse\n */\n\n\nRenderer2.__NG_ELEMENT_ID__ = () => injectRenderer2();\n/** Returns a Renderer2 (or throws when application was bootstrapped with Renderer3) */\n\n\nfunction getOrCreateRenderer2(lView) {\n  const renderer = lView[RENDERER];\n\n  if (ngDevMode && !isProceduralRenderer(renderer)) {\n    throw new Error('Cannot inject Renderer2 when the application uses Renderer3!');\n  }\n\n  return renderer;\n}\n/** Injects a Renderer2 for the current component. */\n\n\nfunction injectRenderer2() {\n  // We need the Renderer to be based on the component that it's being injected into, however since\n  // DI happens before we've entered its view, `getLView` will return the parent view instead.\n  const lView = getLView();\n  const tNode = getCurrentTNode();\n  const nodeAtIndex = getComponentLViewByIndex(tNode.index, lView);\n  return getOrCreateRenderer2(isLView(nodeAtIndex) ? nodeAtIndex : lView);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Sanitizer is used by the views to sanitize potentially dangerous values.\n *\n * @publicApi\n */\n\n\nclass Sanitizer {}\n/** @nocollapse */\n\n\nSanitizer.ɵprov = ɵɵdefineInjectable({\n  token: Sanitizer,\n  providedIn: 'root',\n  factory: () => null\n});\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @description Represents the version of Angular\n *\n * @publicApi\n */\n\nclass Version {\n  constructor(full) {\n    this.full = full;\n    this.major = full.split('.')[0];\n    this.minor = full.split('.')[1];\n    this.patch = full.split('.').slice(2).join('.');\n  }\n\n}\n/**\n * @publicApi\n */\n\n\nconst VERSION = new Version('14.0.3');\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// This default value is when checking the hierarchy for a token.\n//\n// It means both:\n// - the token is not provided by the current injector,\n// - only the element injectors should be checked (ie do not check module injectors\n//\n//          mod1\n//         /\n//       el1   mod2\n//         \\  /\n//         el2\n//\n// When requesting el2.injector.get(token), we should check in the following order and return the\n// first found value:\n// - el2.injector.get(token, default)\n// - el1.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) -> do not check the module\n// - mod2.injector.get(token, default)\n\nconst NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nfunction collectNativeNodes(tView, lView, tNode, result, isProjection = false) {\n  while (tNode !== null) {\n    ngDevMode && assertTNodeType(tNode, 3\n    /* TNodeType.AnyRNode */\n    | 12\n    /* TNodeType.AnyContainer */\n    | 16\n    /* TNodeType.Projection */\n    | 32\n    /* TNodeType.Icu */\n    );\n    const lNode = lView[tNode.index];\n\n    if (lNode !== null) {\n      result.push(unwrapRNode(lNode));\n    } // A given lNode can represent either a native node or a LContainer (when it is a host of a\n    // ViewContainerRef). When we find a LContainer we need to descend into it to collect root nodes\n    // from the views in this container.\n\n\n    if (isLContainer(lNode)) {\n      for (let i = CONTAINER_HEADER_OFFSET; i < lNode.length; i++) {\n        const lViewInAContainer = lNode[i];\n        const lViewFirstChildTNode = lViewInAContainer[TVIEW].firstChild;\n\n        if (lViewFirstChildTNode !== null) {\n          collectNativeNodes(lViewInAContainer[TVIEW], lViewInAContainer, lViewFirstChildTNode, result);\n        }\n      }\n    }\n\n    const tNodeType = tNode.type;\n\n    if (tNodeType & 8\n    /* TNodeType.ElementContainer */\n    ) {\n      collectNativeNodes(tView, lView, tNode.child, result);\n    } else if (tNodeType & 32\n    /* TNodeType.Icu */\n    ) {\n      const nextRNode = icuContainerIterate(tNode, lView);\n      let rNode;\n\n      while (rNode = nextRNode()) {\n        result.push(rNode);\n      }\n    } else if (tNodeType & 16\n    /* TNodeType.Projection */\n    ) {\n      const nodesInSlot = getProjectionNodes(lView, tNode);\n\n      if (Array.isArray(nodesInSlot)) {\n        result.push(...nodesInSlot);\n      } else {\n        const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);\n        ngDevMode && assertParentView(parentView);\n        collectNativeNodes(parentView[TVIEW], parentView, nodesInSlot, result, true);\n      }\n    }\n\n    tNode = isProjection ? tNode.projectionNext : tNode.next;\n  }\n\n  return result;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nclass ViewRef {\n  constructor(\n  /**\n   * This represents `LView` associated with the component when ViewRef is a ChangeDetectorRef.\n   *\n   * When ViewRef is created for a dynamic component, this also represents the `LView` for the\n   * component.\n   *\n   * For a \"regular\" ViewRef created for an embedded view, this is the `LView` for the embedded\n   * view.\n   *\n   * @internal\n   */\n  _lView,\n  /**\n   * This represents the `LView` associated with the point where `ChangeDetectorRef` was\n   * requested.\n   *\n   * This may be different from `_lView` if the `_cdRefInjectingView` is an embedded view.\n   */\n  _cdRefInjectingView) {\n    this._lView = _lView;\n    this._cdRefInjectingView = _cdRefInjectingView;\n    this._appRef = null;\n    this._attachedToViewContainer = false;\n  }\n\n  get rootNodes() {\n    const lView = this._lView;\n    const tView = lView[TVIEW];\n    return collectNativeNodes(tView, lView, tView.firstChild, []);\n  }\n\n  get context() {\n    return this._lView[CONTEXT];\n  }\n\n  set context(value) {\n    this._lView[CONTEXT] = value;\n  }\n\n  get destroyed() {\n    return (this._lView[FLAGS] & 128\n    /* LViewFlags.Destroyed */\n    ) === 128\n    /* LViewFlags.Destroyed */\n    ;\n  }\n\n  destroy() {\n    if (this._appRef) {\n      this._appRef.detachView(this);\n    } else if (this._attachedToViewContainer) {\n      const parent = this._lView[PARENT];\n\n      if (isLContainer(parent)) {\n        const viewRefs = parent[VIEW_REFS];\n        const index = viewRefs ? viewRefs.indexOf(this) : -1;\n\n        if (index > -1) {\n          ngDevMode && assertEqual(index, parent.indexOf(this._lView) - CONTAINER_HEADER_OFFSET, 'An attached view should be in the same position within its container as its ViewRef in the VIEW_REFS array.');\n          detachView(parent, index);\n          removeFromArray(viewRefs, index);\n        }\n      }\n\n      this._attachedToViewContainer = false;\n    }\n\n    destroyLView(this._lView[TVIEW], this._lView);\n  }\n\n  onDestroy(callback) {\n    storeCleanupWithContext(this._lView[TVIEW], this._lView, null, callback);\n  }\n  /**\n   * Marks a view and all of its ancestors dirty.\n   *\n   * This can be used to ensure an {@link ChangeDetectionStrategy#OnPush OnPush} component is\n   * checked when it needs to be re-rendered but the two normal triggers haven't marked it\n   * dirty (i.e. inputs haven't changed and events haven't fired in the view).\n   *\n   * <!-- TODO: Add a link to a chapter on OnPush components -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Component({\n   *   selector: 'app-root',\n   *   template: `Number of ticks: {{numberOfTicks}}`\n   *   changeDetection: ChangeDetectionStrategy.OnPush,\n   * })\n   * class AppComponent {\n   *   numberOfTicks = 0;\n   *\n   *   constructor(private ref: ChangeDetectorRef) {\n   *     setInterval(() => {\n   *       this.numberOfTicks++;\n   *       // the following is required, otherwise the view will not be updated\n   *       this.ref.markForCheck();\n   *     }, 1000);\n   *   }\n   * }\n   * ```\n   */\n\n\n  markForCheck() {\n    markViewDirty(this._cdRefInjectingView || this._lView);\n  }\n  /**\n   * Detaches the view from the change detection tree.\n   *\n   * Detached views will not be checked during change detection runs until they are\n   * re-attached, even if they are dirty. `detach` can be used in combination with\n   * {@link ChangeDetectorRef#detectChanges detectChanges} to implement local change\n   * detection checks.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example defines a component with a large list of readonly data.\n   * Imagine the data changes constantly, many times per second. For performance reasons,\n   * we want to check and update the list every five seconds. We can do that by detaching\n   * the component's change detector and doing a local check every five seconds.\n   *\n   * ```typescript\n   * class DataProvider {\n   *   // in a real application the returned data will be different every time\n   *   get data() {\n   *     return [1,2,3,4,5];\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'giant-list',\n   *   template: `\n   *     <li *ngFor=\"let d of dataProvider.data\">Data {{d}}</li>\n   *   `,\n   * })\n   * class GiantList {\n   *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {\n   *     ref.detach();\n   *     setInterval(() => {\n   *       this.ref.detectChanges();\n   *     }, 5000);\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'app',\n   *   providers: [DataProvider],\n   *   template: `\n   *     <giant-list><giant-list>\n   *   `,\n   * })\n   * class App {\n   * }\n   * ```\n   */\n\n\n  detach() {\n    this._lView[FLAGS] &= ~64\n    /* LViewFlags.Attached */\n    ;\n  }\n  /**\n   * Re-attaches a view to the change detection tree.\n   *\n   * This can be used to re-attach views that were previously detached from the tree\n   * using {@link ChangeDetectorRef#detach detach}. Views are attached to the tree by default.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example creates a component displaying `live` data. The component will detach\n   * its change detector from the main change detector tree when the component's live property\n   * is set to false.\n   *\n   * ```typescript\n   * class DataProvider {\n   *   data = 1;\n   *\n   *   constructor() {\n   *     setInterval(() => {\n   *       this.data = this.data * 2;\n   *     }, 500);\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'live-data',\n   *   inputs: ['live'],\n   *   template: 'Data: {{dataProvider.data}}'\n   * })\n   * class LiveData {\n   *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {}\n   *\n   *   set live(value) {\n   *     if (value) {\n   *       this.ref.reattach();\n   *     } else {\n   *       this.ref.detach();\n   *     }\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'app-root',\n   *   providers: [DataProvider],\n   *   template: `\n   *     Live Update: <input type=\"checkbox\" [(ngModel)]=\"live\">\n   *     <live-data [live]=\"live\"><live-data>\n   *   `,\n   * })\n   * class AppComponent {\n   *   live = true;\n   * }\n   * ```\n   */\n\n\n  reattach() {\n    this._lView[FLAGS] |= 64\n    /* LViewFlags.Attached */\n    ;\n  }\n  /**\n   * Checks the view and its children.\n   *\n   * This can also be used in combination with {@link ChangeDetectorRef#detach detach} to implement\n   * local change detection checks.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example defines a component with a large list of readonly data.\n   * Imagine, the data changes constantly, many times per second. For performance reasons,\n   * we want to check and update the list every five seconds.\n   *\n   * We can do that by detaching the component's change detector and doing a local change detection\n   * check every five seconds.\n   *\n   * See {@link ChangeDetectorRef#detach detach} for more information.\n   */\n\n\n  detectChanges() {\n    detectChangesInternal(this._lView[TVIEW], this._lView, this.context);\n  }\n  /**\n   * Checks the change detector and its children, and throws if any changes are detected.\n   *\n   * This is used in development mode to verify that running change detection doesn't\n   * introduce other changes.\n   */\n\n\n  checkNoChanges() {\n    if (ngDevMode) {\n      checkNoChangesInternal(this._lView[TVIEW], this._lView, this.context);\n    }\n  }\n\n  attachToViewContainerRef() {\n    if (this._appRef) {\n      throw new RuntimeError(902\n      /* RuntimeErrorCode.VIEW_ALREADY_ATTACHED */\n      , ngDevMode && 'This view is already attached directly to the ApplicationRef!');\n    }\n\n    this._attachedToViewContainer = true;\n  }\n\n  detachFromAppRef() {\n    this._appRef = null;\n    renderDetachView(this._lView[TVIEW], this._lView);\n  }\n\n  attachToAppRef(appRef) {\n    if (this._attachedToViewContainer) {\n      throw new RuntimeError(902\n      /* RuntimeErrorCode.VIEW_ALREADY_ATTACHED */\n      , ngDevMode && 'This view is already attached to a ViewContainer!');\n    }\n\n    this._appRef = appRef;\n  }\n\n}\n/** @internal */\n\n\nclass RootViewRef extends ViewRef {\n  constructor(_view) {\n    super(_view);\n    this._view = _view;\n  }\n\n  detectChanges() {\n    detectChangesInRootView(this._view);\n  }\n\n  checkNoChanges() {\n    if (ngDevMode) {\n      checkNoChangesInRootView(this._view);\n    }\n  }\n\n  get context() {\n    return null;\n  }\n\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nclass ComponentFactoryResolver extends ComponentFactoryResolver$1 {\n  /**\n   * @param ngModule The NgModuleRef to which all resolved factories are bound.\n   */\n  constructor(ngModule) {\n    super();\n    this.ngModule = ngModule;\n  }\n\n  resolveComponentFactory(component) {\n    ngDevMode && assertComponentType(component);\n    const componentDef = getComponentDef$1(component);\n    return new ComponentFactory(componentDef, this.ngModule);\n  }\n\n}\n\nfunction toRefArray(map) {\n  const array = [];\n\n  for (let nonMinified in map) {\n    if (map.hasOwnProperty(nonMinified)) {\n      const minified = map[nonMinified];\n      array.push({\n        propName: minified,\n        templateName: nonMinified\n      });\n    }\n  }\n\n  return array;\n}\n\nfunction getNamespace(elementName) {\n  const name = elementName.toLowerCase();\n  return name === 'svg' ? SVG_NAMESPACE : name === 'math' ? MATH_ML_NAMESPACE : null;\n}\n/**\n * Injector that looks up a value using a specific injector, before falling back to the module\n * injector. Used primarily when creating components or embedded views dynamically.\n */\n\n\nclass ChainedInjector {\n  constructor(injector, parentInjector) {\n    this.injector = injector;\n    this.parentInjector = parentInjector;\n  }\n\n  get(token, notFoundValue, flags) {\n    const value = this.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, flags);\n\n    if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR || notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {\n      // Return the value from the root element injector when\n      // - it provides it\n      //   (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)\n      // - the module injector should not be checked\n      //   (notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)\n      return value;\n    }\n\n    return this.parentInjector.get(token, notFoundValue, flags);\n  }\n\n}\n/**\n * Render3 implementation of {@link viewEngine_ComponentFactory}.\n */\n\n\nclass ComponentFactory extends ComponentFactory$1 {\n  /**\n   * @param componentDef The component definition.\n   * @param ngModule The NgModuleRef to which the factory is bound.\n   */\n  constructor(componentDef, ngModule) {\n    super();\n    this.componentDef = componentDef;\n    this.ngModule = ngModule;\n    this.componentType = componentDef.type;\n    this.selector = stringifyCSSSelectorList(componentDef.selectors);\n    this.ngContentSelectors = componentDef.ngContentSelectors ? componentDef.ngContentSelectors : [];\n    this.isBoundToModule = !!ngModule;\n  }\n\n  get inputs() {\n    return toRefArray(this.componentDef.inputs);\n  }\n\n  get outputs() {\n    return toRefArray(this.componentDef.outputs);\n  }\n\n  create(injector, projectableNodes, rootSelectorOrNode, environmentInjector) {\n    environmentInjector = environmentInjector || this.ngModule;\n    let realEnvironmentInjector = environmentInjector instanceof EnvironmentInjector ? environmentInjector : environmentInjector === null || environmentInjector === void 0 ? void 0 : environmentInjector.injector;\n\n    if (realEnvironmentInjector && this.componentDef.getStandaloneInjector !== null) {\n      realEnvironmentInjector = this.componentDef.getStandaloneInjector(realEnvironmentInjector) || realEnvironmentInjector;\n    }\n\n    const rootViewInjector = realEnvironmentInjector ? new ChainedInjector(injector, realEnvironmentInjector) : injector;\n    const rendererFactory = rootViewInjector.get(RendererFactory2, domRendererFactory3);\n    const sanitizer = rootViewInjector.get(Sanitizer, null);\n    const hostRenderer = rendererFactory.createRenderer(null, this.componentDef); // Determine a tag name used for creating host elements when this component is created\n    // dynamically. Default to 'div' if this component did not specify any tag name in its selector.\n\n    const elementName = this.componentDef.selectors[0][0] || 'div';\n    const hostRNode = rootSelectorOrNode ? locateHostElement(hostRenderer, rootSelectorOrNode, this.componentDef.encapsulation) : createElementNode(rendererFactory.createRenderer(null, this.componentDef), elementName, getNamespace(elementName));\n    const rootFlags = this.componentDef.onPush ? 32\n    /* LViewFlags.Dirty */\n    | 256\n    /* LViewFlags.IsRoot */\n    : 16\n    /* LViewFlags.CheckAlways */\n    | 256\n    /* LViewFlags.IsRoot */\n    ;\n    const rootContext = createRootContext(); // Create the root view. Uses empty TView and ContentTemplate.\n\n    const rootTView = createTView(0\n    /* TViewType.Root */\n    , null, null, 1, 0, null, null, null, null, null);\n    const rootLView = createLView(null, rootTView, rootContext, rootFlags, null, null, rendererFactory, hostRenderer, sanitizer, rootViewInjector, null); // rootView is the parent when bootstrapping\n    // TODO(misko): it looks like we are entering view here but we don't really need to as\n    // `renderView` does that. However as the code is written it is needed because\n    // `createRootComponentView` and `createRootComponent` both read global state. Fixing those\n    // issues would allow us to drop this.\n\n    enterView(rootLView);\n    let component;\n    let tElementNode;\n\n    try {\n      const componentView = createRootComponentView(hostRNode, this.componentDef, rootLView, rendererFactory, hostRenderer);\n\n      if (hostRNode) {\n        if (rootSelectorOrNode) {\n          setUpAttributes(hostRenderer, hostRNode, ['ng-version', VERSION.full]);\n        } else {\n          // If host element is created as a part of this function call (i.e. `rootSelectorOrNode`\n          // is not defined), also apply attributes and classes extracted from component selector.\n          // Extract attributes and classes from the first selector only to match VE behavior.\n          const {\n            attrs,\n            classes\n          } = extractAttrsAndClassesFromSelector(this.componentDef.selectors[0]);\n\n          if (attrs) {\n            setUpAttributes(hostRenderer, hostRNode, attrs);\n          }\n\n          if (classes && classes.length > 0) {\n            writeDirectClass(hostRenderer, hostRNode, classes.join(' '));\n          }\n        }\n      }\n\n      tElementNode = getTNode(rootTView, HEADER_OFFSET);\n\n      if (projectableNodes !== undefined) {\n        const projection = tElementNode.projection = [];\n\n        for (let i = 0; i < this.ngContentSelectors.length; i++) {\n          const nodesforSlot = projectableNodes[i]; // Projectable nodes can be passed as array of arrays or an array of iterables (ngUpgrade\n          // case). Here we do normalize passed data structure to be an array of arrays to avoid\n          // complex checks down the line.\n          // We also normalize the length of the passed in projectable nodes (to match the number of\n          // <ng-container> slots defined by a component).\n\n          projection.push(nodesforSlot != null ? Array.from(nodesforSlot) : null);\n        }\n      } // TODO: should LifecycleHooksFeature and other host features be generated by the compiler and\n      // executed here?\n      // Angular 5 reference: https://stackblitz.com/edit/lifecycle-hooks-vcref\n\n\n      component = createRootComponent(componentView, this.componentDef, rootLView, rootContext, [LifecycleHooksFeature]);\n      renderView(rootTView, rootLView, null);\n    } finally {\n      leaveView();\n    }\n\n    return new ComponentRef(this.componentType, component, createElementRef(tElementNode, rootLView), rootLView, tElementNode);\n  }\n\n}\n\nconst componentFactoryResolver = new ComponentFactoryResolver();\n/**\n * Creates a ComponentFactoryResolver and stores it on the injector. Or, if the\n * ComponentFactoryResolver\n * already exists, retrieves the existing ComponentFactoryResolver.\n *\n * @returns The ComponentFactoryResolver instance to use\n */\n\nfunction injectComponentFactoryResolver() {\n  return componentFactoryResolver;\n}\n/**\n * Represents an instance of a Component created via a {@link ComponentFactory}.\n *\n * `ComponentRef` provides access to the Component Instance as well other objects related to this\n * Component Instance and allows you to destroy the Component Instance via the {@link #destroy}\n * method.\n *\n */\n\n\nclass ComponentRef extends ComponentRef$1 {\n  constructor(componentType, instance, location, _rootLView, _tNode) {\n    super();\n    this.location = location;\n    this._rootLView = _rootLView;\n    this._tNode = _tNode;\n    this.instance = instance;\n    this.hostView = this.changeDetectorRef = new RootViewRef(_rootLView);\n    this.componentType = componentType;\n  }\n\n  get injector() {\n    return new NodeInjector(this._tNode, this._rootLView);\n  }\n\n  destroy() {\n    this.hostView.destroy();\n  }\n\n  onDestroy(callback) {\n    this.hostView.onDestroy(callback);\n  }\n\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Returns a new NgModuleRef instance based on the NgModule class and parent injector provided.\n * @param ngModule NgModule class.\n * @param parentInjector Optional injector instance to use as a parent for the module injector. If\n *     not provided, `NullInjector` will be used instead.\n * @publicApi\n */\n\n\nfunction createNgModuleRef(ngModule, parentInjector) {\n  return new NgModuleRef(ngModule, parentInjector !== null && parentInjector !== void 0 ? parentInjector : null);\n}\n\nclass NgModuleRef extends NgModuleRef$1 {\n  constructor(ngModuleType, _parent) {\n    super();\n    this._parent = _parent; // tslint:disable-next-line:require-internal-with-underscore\n\n    this._bootstrapComponents = [];\n    this.injector = this;\n    this.destroyCbs = []; // When bootstrapping a module we have a dependency graph that looks like this:\n    // ApplicationRef -> ComponentFactoryResolver -> NgModuleRef. The problem is that if the\n    // module being resolved tries to inject the ComponentFactoryResolver, it'll create a\n    // circular dependency which will result in a runtime error, because the injector doesn't\n    // exist yet. We work around the issue by creating the ComponentFactoryResolver ourselves\n    // and providing it, rather than letting the injector resolve it.\n\n    this.componentFactoryResolver = new ComponentFactoryResolver(this);\n    const ngModuleDef = getNgModuleDef(ngModuleType);\n    ngDevMode && assertDefined(ngModuleDef, `NgModule '${stringify(ngModuleType)}' is not a subtype of 'NgModuleType'.`);\n    this._bootstrapComponents = maybeUnwrapFn$1(ngModuleDef.bootstrap);\n    this._r3Injector = createInjectorWithoutInjectorInstances(ngModuleType, _parent, [{\n      provide: NgModuleRef$1,\n      useValue: this\n    }, {\n      provide: ComponentFactoryResolver$1,\n      useValue: this.componentFactoryResolver\n    }], stringify(ngModuleType), new Set(['environment'])); // We need to resolve the injector types separately from the injector creation, because\n    // the module might be trying to use this ref in its constructor for DI which will cause a\n    // circular error that will eventually error out, because the injector isn't created yet.\n\n    this._r3Injector.resolveInjectorInitializers();\n\n    this.instance = this.get(ngModuleType);\n  }\n\n  get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, injectFlags = InjectFlags.Default) {\n    if (token === Injector || token === NgModuleRef$1 || token === INJECTOR) {\n      return this;\n    }\n\n    return this._r3Injector.get(token, notFoundValue, injectFlags);\n  }\n\n  destroy() {\n    ngDevMode && assertDefined(this.destroyCbs, 'NgModule already destroyed');\n    const injector = this._r3Injector;\n    !injector.destroyed && injector.destroy();\n    this.destroyCbs.forEach(fn => fn());\n    this.destroyCbs = null;\n  }\n\n  onDestroy(callback) {\n    ngDevMode && assertDefined(this.destroyCbs, 'NgModule already destroyed');\n    this.destroyCbs.push(callback);\n  }\n\n}\n\nclass NgModuleFactory extends NgModuleFactory$1 {\n  constructor(moduleType) {\n    super();\n    this.moduleType = moduleType;\n  }\n\n  create(parentInjector) {\n    return new NgModuleRef(this.moduleType, parentInjector);\n  }\n\n}\n\nclass EnvironmentNgModuleRefAdapter extends NgModuleRef$1 {\n  constructor(providers, parent, source) {\n    super();\n    this.componentFactoryResolver = new ComponentFactoryResolver(this);\n    this.instance = null;\n    const injector = new R3Injector([...providers, {\n      provide: NgModuleRef$1,\n      useValue: this\n    }, {\n      provide: ComponentFactoryResolver$1,\n      useValue: this.componentFactoryResolver\n    }], parent || getNullInjector(), source, new Set(['environment']));\n    this.injector = injector;\n    injector.resolveInjectorInitializers();\n  }\n\n  destroy() {\n    this.injector.destroy();\n  }\n\n  onDestroy(callback) {\n    this.injector.onDestroy(callback);\n  }\n\n}\n/**\n * Create a new environment injector.\n *\n * @publicApi\n * @developerPreview\n */\n\n\nfunction createEnvironmentInjector(providers, parent = null, debugName = null) {\n  const adapter = new EnvironmentNgModuleRefAdapter(providers, parent, debugName);\n  return adapter.injector;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A service used by the framework to create instances of standalone injectors. Those injectors are\n * created on demand in case of dynamic component instantiation and contain ambient providers\n * collected from the imports graph rooted at a given standalone component.\n */\n\n\nclass StandaloneService {\n  constructor(_injector) {\n    this._injector = _injector;\n    this.cachedInjectors = new Map();\n  }\n\n  getOrCreateStandaloneInjector(componentDef) {\n    if (!componentDef.standalone) {\n      return null;\n    }\n\n    if (!this.cachedInjectors.has(componentDef.id)) {\n      const providers = internalImportProvidersFrom(false, componentDef.type);\n      const standaloneInjector = providers.length > 0 ? createEnvironmentInjector([providers], this._injector, `Standalone[${componentDef.type.name}]`) : null;\n      this.cachedInjectors.set(componentDef.id, standaloneInjector);\n    }\n\n    return this.cachedInjectors.get(componentDef.id);\n  }\n\n  ngOnDestroy() {\n    try {\n      for (const injector of this.cachedInjectors.values()) {\n        if (injector !== null) {\n          injector.destroy();\n        }\n      }\n    } finally {\n      this.cachedInjectors.clear();\n    }\n  }\n\n}\n/** @nocollapse */\n\n\nStandaloneService.ɵprov = ɵɵdefineInjectable({\n  token: StandaloneService,\n  providedIn: 'environment',\n  factory: () => new StandaloneService(ɵɵinject(EnvironmentInjector))\n});\n/**\n * A feature that acts as a setup code for the {@link StandaloneService}.\n *\n * The most important responsaibility of this feature is to expose the \"getStandaloneInjector\"\n * function (an entry points to a standalone injector creation) on a component definition object. We\n * go through the features infrastructure to make sure that the standalone injector creation logic\n * is tree-shakable and not included in applications that don't use standalone components.\n *\n * @codeGenApi\n */\n\nfunction ɵɵStandaloneFeature(definition) {\n  definition.getStandaloneInjector = parentInjector => {\n    return parentInjector.get(StandaloneService).getOrCreateStandaloneInjector(definition);\n  };\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Adds decorator, constructor, and property metadata to a given type via static metadata fields\n * on the type.\n *\n * These metadata fields can later be read with Angular's `ReflectionCapabilities` API.\n *\n * Calls to `setClassMetadata` can be guarded by ngDevMode, resulting in the metadata assignments\n * being tree-shaken away during production builds.\n */\n\n\nfunction setClassMetadata(type, decorators, ctorParameters, propDecorators) {\n  return noSideEffects(() => {\n    const clazz = type;\n\n    if (decorators !== null) {\n      if (clazz.hasOwnProperty('decorators') && clazz.decorators !== undefined) {\n        clazz.decorators.push(...decorators);\n      } else {\n        clazz.decorators = decorators;\n      }\n    }\n\n    if (ctorParameters !== null) {\n      // Rather than merging, clobber the existing parameters. If other projects exist which\n      // use tsickle-style annotations and reflect over them in the same way, this could\n      // cause issues, but that is vanishingly unlikely.\n      clazz.ctorParameters = ctorParameters;\n    }\n\n    if (propDecorators !== null) {\n      // The property decorator objects are merged as it is possible different fields have\n      // different decorator types. Decorators on individual fields are not merged, as it's\n      // also incredibly unlikely that a field will be decorated both with an Angular\n      // decorator and a non-Angular decorator that's also been downleveled.\n      if (clazz.hasOwnProperty('propDecorators') && clazz.propDecorators !== undefined) {\n        clazz.propDecorators = Object.assign(Object.assign({}, clazz.propDecorators), propDecorators);\n      } else {\n        clazz.propDecorators = propDecorators;\n      }\n    }\n  });\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Bindings for pure functions are stored after regular bindings.\n *\n * |-------decls------|---------vars---------|                 |----- hostVars (dir1) ------|\n * ------------------------------------------------------------------------------------------\n * | nodes/refs/pipes | bindings | fn slots  | injector | dir1 | host bindings | host slots |\n * ------------------------------------------------------------------------------------------\n *                    ^                      ^\n *      TView.bindingStartIndex      TView.expandoStartIndex\n *\n * Pure function instructions are given an offset from the binding root. Adding the offset to the\n * binding root gives the first index where the bindings are stored. In component views, the binding\n * root is the bindingStartIndex. In host bindings, the binding root is the expandoStartIndex +\n * any directive instances + any hostVars in directives evaluated before it.\n *\n * See VIEW_DATA.md for more information about host binding resolution.\n */\n\n/**\n * If the value hasn't been saved, calls the pure function to store and return the\n * value. If it has been saved, returns the saved value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn Function that returns a value\n * @param thisArg Optional calling context of pureFn\n * @returns value\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵpureFunction0(slotOffset, pureFn, thisArg) {\n  const bindingIndex = getBindingRoot() + slotOffset;\n  const lView = getLView();\n  return lView[bindingIndex] === NO_CHANGE ? updateBinding(lView, bindingIndex, thisArg ? pureFn.call(thisArg) : pureFn()) : getBinding(lView, bindingIndex);\n}\n/**\n * If the value of the provided exp has changed, calls the pure function to return\n * an updated value. Or if the value has not changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn Function that returns an updated value\n * @param exp Updated expression value\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵpureFunction1(slotOffset, pureFn, exp, thisArg) {\n  return pureFunction1Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp, thisArg);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵpureFunction2(slotOffset, pureFn, exp1, exp2, thisArg) {\n  return pureFunction2Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, thisArg);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵpureFunction3(slotOffset, pureFn, exp1, exp2, exp3, thisArg) {\n  return pureFunction3Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, thisArg);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵpureFunction4(slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {\n  return pureFunction4Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵpureFunction5(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, thisArg) {\n  const bindingIndex = getBindingRoot() + slotOffset;\n  const lView = getLView();\n  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n  return bindingUpdated(lView, bindingIndex + 4, exp5) || different ? updateBinding(lView, bindingIndex + 5, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5) : pureFn(exp1, exp2, exp3, exp4, exp5)) : getBinding(lView, bindingIndex + 5);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param exp6\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵpureFunction6(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, thisArg) {\n  const bindingIndex = getBindingRoot() + slotOffset;\n  const lView = getLView();\n  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n  return bindingUpdated2(lView, bindingIndex + 4, exp5, exp6) || different ? updateBinding(lView, bindingIndex + 6, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6)) : getBinding(lView, bindingIndex + 6);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param exp6\n * @param exp7\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵpureFunction7(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, thisArg) {\n  const bindingIndex = getBindingRoot() + slotOffset;\n  const lView = getLView();\n  let different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n  return bindingUpdated3(lView, bindingIndex + 4, exp5, exp6, exp7) || different ? updateBinding(lView, bindingIndex + 7, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7)) : getBinding(lView, bindingIndex + 7);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param exp6\n * @param exp7\n * @param exp8\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵpureFunction8(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8, thisArg) {\n  const bindingIndex = getBindingRoot() + slotOffset;\n  const lView = getLView();\n  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n  return bindingUpdated4(lView, bindingIndex + 4, exp5, exp6, exp7, exp8) || different ? updateBinding(lView, bindingIndex + 8, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8)) : getBinding(lView, bindingIndex + 8);\n}\n/**\n * pureFunction instruction that can support any number of bindings.\n *\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn A pure function that takes binding values and builds an object or array\n * containing those values.\n * @param exps An array of binding values\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵpureFunctionV(slotOffset, pureFn, exps, thisArg) {\n  return pureFunctionVInternal(getLView(), getBindingRoot(), slotOffset, pureFn, exps, thisArg);\n}\n/**\n * Results of a pure function invocation are stored in LView in a dedicated slot that is initialized\n * to NO_CHANGE. In rare situations a pure pipe might throw an exception on the very first\n * invocation and not produce any valid results. In this case LView would keep holding the NO_CHANGE\n * value. The NO_CHANGE is not something that we can use in expressions / bindings thus we convert\n * it to `undefined`.\n */\n\n\nfunction getPureFunctionReturnValue(lView, returnValueIndex) {\n  ngDevMode && assertIndexInRange(lView, returnValueIndex);\n  const lastReturnValue = lView[returnValueIndex];\n  return lastReturnValue === NO_CHANGE ? undefined : lastReturnValue;\n}\n/**\n * If the value of the provided exp has changed, calls the pure function to return\n * an updated value. Or if the value has not changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn Function that returns an updated value\n * @param exp Updated expression value\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\n\n\nfunction pureFunction1Internal(lView, bindingRoot, slotOffset, pureFn, exp, thisArg) {\n  const bindingIndex = bindingRoot + slotOffset;\n  return bindingUpdated(lView, bindingIndex, exp) ? updateBinding(lView, bindingIndex + 1, thisArg ? pureFn.call(thisArg, exp) : pureFn(exp)) : getPureFunctionReturnValue(lView, bindingIndex + 1);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\n\n\nfunction pureFunction2Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, thisArg) {\n  const bindingIndex = bindingRoot + slotOffset;\n  return bindingUpdated2(lView, bindingIndex, exp1, exp2) ? updateBinding(lView, bindingIndex + 2, thisArg ? pureFn.call(thisArg, exp1, exp2) : pureFn(exp1, exp2)) : getPureFunctionReturnValue(lView, bindingIndex + 2);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\n\n\nfunction pureFunction3Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, thisArg) {\n  const bindingIndex = bindingRoot + slotOffset;\n  return bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) ? updateBinding(lView, bindingIndex + 3, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3) : pureFn(exp1, exp2, exp3)) : getPureFunctionReturnValue(lView, bindingIndex + 3);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n */\n\n\nfunction pureFunction4Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {\n  const bindingIndex = bindingRoot + slotOffset;\n  return bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) ? updateBinding(lView, bindingIndex + 4, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4) : pureFn(exp1, exp2, exp3, exp4)) : getPureFunctionReturnValue(lView, bindingIndex + 4);\n}\n/**\n * pureFunction instruction that can support any number of bindings.\n *\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn A pure function that takes binding values and builds an object or array\n * containing those values.\n * @param exps An array of binding values\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\n\n\nfunction pureFunctionVInternal(lView, bindingRoot, slotOffset, pureFn, exps, thisArg) {\n  let bindingIndex = bindingRoot + slotOffset;\n  let different = false;\n\n  for (let i = 0; i < exps.length; i++) {\n    bindingUpdated(lView, bindingIndex++, exps[i]) && (different = true);\n  }\n\n  return different ? updateBinding(lView, bindingIndex, pureFn.apply(thisArg, exps)) : getPureFunctionReturnValue(lView, bindingIndex);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Create a pipe.\n *\n * @param index Pipe index where the pipe will be stored.\n * @param pipeName The name of the pipe\n * @returns T the instance of the pipe.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵpipe(index, pipeName) {\n  const tView = getTView();\n  let pipeDef;\n  const adjustedIndex = index + HEADER_OFFSET;\n\n  if (tView.firstCreatePass) {\n    // The `getPipeDef` throws if a pipe with a given name is not found\n    // (so we use non-null assertion below).\n    pipeDef = getPipeDef(pipeName, tView.pipeRegistry);\n    tView.data[adjustedIndex] = pipeDef;\n\n    if (pipeDef.onDestroy) {\n      (tView.destroyHooks || (tView.destroyHooks = [])).push(adjustedIndex, pipeDef.onDestroy);\n    }\n  } else {\n    pipeDef = tView.data[adjustedIndex];\n  }\n\n  const pipeFactory = pipeDef.factory || (pipeDef.factory = getFactoryDef(pipeDef.type, true));\n  const previousInjectImplementation = setInjectImplementation(ɵɵdirectiveInject);\n\n  try {\n    // DI for pipes is supposed to behave like directives when placed on a component\n    // host node, which means that we have to disable access to `viewProviders`.\n    const previousIncludeViewProviders = setIncludeViewProviders(false);\n    const pipeInstance = pipeFactory();\n    setIncludeViewProviders(previousIncludeViewProviders);\n    store(tView, getLView(), adjustedIndex, pipeInstance);\n    return pipeInstance;\n  } finally {\n    // we have to restore the injector implementation in finally, just in case the creation of the\n    // pipe throws an error.\n    setInjectImplementation(previousInjectImplementation);\n  }\n}\n/**\n * Searches the pipe registry for a pipe with the given name. If one is found,\n * returns the pipe. Otherwise, an error is thrown because the pipe cannot be resolved.\n *\n * @param name Name of pipe to resolve\n * @param registry Full list of available pipes\n * @returns Matching PipeDef\n */\n\n\nfunction getPipeDef(name, registry) {\n  if (registry) {\n    for (let i = registry.length - 1; i >= 0; i--) {\n      const pipeDef = registry[i];\n\n      if (name === pipeDef.name) {\n        return pipeDef;\n      }\n    }\n  }\n\n  if (ngDevMode) {\n    throw new RuntimeError(-302\n    /* RuntimeErrorCode.PIPE_NOT_FOUND */\n    , getPipeNotFoundErrorMessage(name));\n  }\n}\n/**\n * Generates a helpful error message for the user when a pipe is not found.\n *\n * @param name Name of the missing pipe\n * @returns The error message\n */\n\n\nfunction getPipeNotFoundErrorMessage(name) {\n  const lView = getLView();\n  const declarationLView = lView[DECLARATION_COMPONENT_VIEW];\n  const context = declarationLView[CONTEXT];\n  const hostIsStandalone = isHostComponentStandalone(lView);\n  const componentInfoMessage = context ? ` in the '${context.constructor.name}' component` : '';\n  const verifyMessage = `Verify that it is ${hostIsStandalone ? 'included in the \\'@Component.imports\\' of this component' : 'declared or imported in this module'}`;\n  const errorMessage = `The pipe '${name}' could not be found${componentInfoMessage}. ${verifyMessage}`;\n  return errorMessage;\n}\n/**\n * Invokes a pipe with 1 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵpipeBind1(index, slotOffset, v1) {\n  const adjustedIndex = index + HEADER_OFFSET;\n  const lView = getLView();\n  const pipeInstance = load(lView, adjustedIndex);\n  return isPure(lView, adjustedIndex) ? pureFunction1Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, pipeInstance) : pipeInstance.transform(v1);\n}\n/**\n * Invokes a pipe with 2 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵpipeBind2(index, slotOffset, v1, v2) {\n  const adjustedIndex = index + HEADER_OFFSET;\n  const lView = getLView();\n  const pipeInstance = load(lView, adjustedIndex);\n  return isPure(lView, adjustedIndex) ? pureFunction2Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, pipeInstance) : pipeInstance.transform(v1, v2);\n}\n/**\n * Invokes a pipe with 3 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n * @param v3 4rd argument to {@link PipeTransform#transform}.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵpipeBind3(index, slotOffset, v1, v2, v3) {\n  const adjustedIndex = index + HEADER_OFFSET;\n  const lView = getLView();\n  const pipeInstance = load(lView, adjustedIndex);\n  return isPure(lView, adjustedIndex) ? pureFunction3Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, pipeInstance) : pipeInstance.transform(v1, v2, v3);\n}\n/**\n * Invokes a pipe with 4 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n * @param v3 3rd argument to {@link PipeTransform#transform}.\n * @param v4 4th argument to {@link PipeTransform#transform}.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵpipeBind4(index, slotOffset, v1, v2, v3, v4) {\n  const adjustedIndex = index + HEADER_OFFSET;\n  const lView = getLView();\n  const pipeInstance = load(lView, adjustedIndex);\n  return isPure(lView, adjustedIndex) ? pureFunction4Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, v4, pipeInstance) : pipeInstance.transform(v1, v2, v3, v4);\n}\n/**\n * Invokes a pipe with variable number of arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param values Array of arguments to pass to {@link PipeTransform#transform} method.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵpipeBindV(index, slotOffset, values) {\n  const adjustedIndex = index + HEADER_OFFSET;\n  const lView = getLView();\n  const pipeInstance = load(lView, adjustedIndex);\n  return isPure(lView, adjustedIndex) ? pureFunctionVInternal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, values, pipeInstance) : pipeInstance.transform.apply(pipeInstance, values);\n}\n\nfunction isPure(lView, index) {\n  return lView[TVIEW].data[index].pure;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nclass EventEmitter_ extends Subject {\n  constructor(isAsync = false) {\n    super();\n    this.__isAsync = isAsync;\n  }\n\n  emit(value) {\n    super.next(value);\n  }\n\n  subscribe(observerOrNext, error, complete) {\n    var _a, _b, _c;\n\n    let nextFn = observerOrNext;\n\n    let errorFn = error || (() => null);\n\n    let completeFn = complete;\n\n    if (observerOrNext && typeof observerOrNext === 'object') {\n      const observer = observerOrNext;\n      nextFn = (_a = observer.next) === null || _a === void 0 ? void 0 : _a.bind(observer);\n      errorFn = (_b = observer.error) === null || _b === void 0 ? void 0 : _b.bind(observer);\n      completeFn = (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.bind(observer);\n    }\n\n    if (this.__isAsync) {\n      errorFn = _wrapInTimeout(errorFn);\n\n      if (nextFn) {\n        nextFn = _wrapInTimeout(nextFn);\n      }\n\n      if (completeFn) {\n        completeFn = _wrapInTimeout(completeFn);\n      }\n    }\n\n    const sink = super.subscribe({\n      next: nextFn,\n      error: errorFn,\n      complete: completeFn\n    });\n\n    if (observerOrNext instanceof Subscription) {\n      observerOrNext.add(sink);\n    }\n\n    return sink;\n  }\n\n}\n\nfunction _wrapInTimeout(fn) {\n  return value => {\n    setTimeout(fn, undefined, value);\n  };\n}\n/**\n * @publicApi\n */\n\n\nconst EventEmitter = EventEmitter_;\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nfunction symbolIterator() {\n  return this._results[getSymbolIterator()]();\n}\n/**\n * An unmodifiable list of items that Angular keeps up to date when the state\n * of the application changes.\n *\n * The type of object that {@link ViewChildren}, {@link ContentChildren}, and {@link QueryList}\n * provide.\n *\n * Implements an iterable interface, therefore it can be used in both ES6\n * javascript `for (var i of items)` loops as well as in Angular templates with\n * `*ngFor=\"let i of myList\"`.\n *\n * Changes can be observed by subscribing to the changes `Observable`.\n *\n * NOTE: In the future this class will implement an `Observable` interface.\n *\n * @usageNotes\n * ### Example\n * ```typescript\n * @Component({...})\n * class Container {\n *   @ViewChildren(Item) items:QueryList<Item>;\n * }\n * ```\n *\n * @publicApi\n */\n\n\nclass QueryList {\n  /**\n   * @param emitDistinctChangesOnly Whether `QueryList.changes` should fire only when actual change\n   *     has occurred. Or if it should fire when query is recomputed. (recomputing could resolve in\n   *     the same result)\n   */\n  constructor(_emitDistinctChangesOnly = false) {\n    this._emitDistinctChangesOnly = _emitDistinctChangesOnly;\n    this.dirty = true;\n    this._results = [];\n    this._changesDetected = false;\n    this._changes = null;\n    this.length = 0;\n    this.first = undefined;\n    this.last = undefined; // This function should be declared on the prototype, but doing so there will cause the class\n    // declaration to have side-effects and become not tree-shakable. For this reason we do it in\n    // the constructor.\n    // [getSymbolIterator()](): Iterator<T> { ... }\n\n    const symbol = getSymbolIterator();\n    const proto = QueryList.prototype;\n    if (!proto[symbol]) proto[symbol] = symbolIterator;\n  }\n  /**\n   * Returns `Observable` of `QueryList` notifying the subscriber of changes.\n   */\n\n\n  get changes() {\n    return this._changes || (this._changes = new EventEmitter());\n  }\n  /**\n   * Returns the QueryList entry at `index`.\n   */\n\n\n  get(index) {\n    return this._results[index];\n  }\n  /**\n   * See\n   * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\n   */\n\n\n  map(fn) {\n    return this._results.map(fn);\n  }\n  /**\n   * See\n   * [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)\n   */\n\n\n  filter(fn) {\n    return this._results.filter(fn);\n  }\n  /**\n   * See\n   * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)\n   */\n\n\n  find(fn) {\n    return this._results.find(fn);\n  }\n  /**\n   * See\n   * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)\n   */\n\n\n  reduce(fn, init) {\n    return this._results.reduce(fn, init);\n  }\n  /**\n   * See\n   * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)\n   */\n\n\n  forEach(fn) {\n    this._results.forEach(fn);\n  }\n  /**\n   * See\n   * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)\n   */\n\n\n  some(fn) {\n    return this._results.some(fn);\n  }\n  /**\n   * Returns a copy of the internal results list as an Array.\n   */\n\n\n  toArray() {\n    return this._results.slice();\n  }\n\n  toString() {\n    return this._results.toString();\n  }\n  /**\n   * Updates the stored data of the query list, and resets the `dirty` flag to `false`, so that\n   * on change detection, it will not notify of changes to the queries, unless a new change\n   * occurs.\n   *\n   * @param resultsTree The query results to store\n   * @param identityAccessor Optional function for extracting stable object identity from a value\n   *    in the array. This function is executed for each element of the query result list while\n   *    comparing current query list with the new one (provided as a first argument of the `reset`\n   *    function) to detect if the lists are different. If the function is not provided, elements\n   *    are compared as is (without any pre-processing).\n   */\n\n\n  reset(resultsTree, identityAccessor) {\n    // Cast to `QueryListInternal` so that we can mutate fields which are readonly for the usage of\n    // QueryList (but not for QueryList itself.)\n    const self = this;\n    self.dirty = false;\n    const newResultFlat = flatten$1(resultsTree);\n\n    if (this._changesDetected = !arrayEquals(self._results, newResultFlat, identityAccessor)) {\n      self._results = newResultFlat;\n      self.length = newResultFlat.length;\n      self.last = newResultFlat[this.length - 1];\n      self.first = newResultFlat[0];\n    }\n  }\n  /**\n   * Triggers a change event by emitting on the `changes` {@link EventEmitter}.\n   */\n\n\n  notifyOnChanges() {\n    if (this._changes && (this._changesDetected || !this._emitDistinctChangesOnly)) this._changes.emit(this);\n  }\n  /** internal */\n\n\n  setDirty() {\n    this.dirty = true;\n  }\n  /** internal */\n\n\n  destroy() {\n    this.changes.complete();\n    this.changes.unsubscribe();\n  }\n\n}\n\nSymbol.iterator;\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Represents an embedded template that can be used to instantiate embedded views.\n * To instantiate embedded views based on a template, use the `ViewContainerRef`\n * method `createEmbeddedView()`.\n *\n * Access a `TemplateRef` instance by placing a directive on an `<ng-template>`\n * element (or directive prefixed with `*`). The `TemplateRef` for the embedded view\n * is injected into the constructor of the directive,\n * using the `TemplateRef` token.\n *\n * You can also use a `Query` to find a `TemplateRef` associated with\n * a component or a directive.\n *\n * @see `ViewContainerRef`\n * @see [Navigate the Component Tree with DI](guide/dependency-injection-navtree)\n *\n * @publicApi\n */\n\nclass TemplateRef {}\n/**\n * @internal\n * @nocollapse\n */\n\n\nTemplateRef.__NG_ELEMENT_ID__ = injectTemplateRef;\nconst ViewEngineTemplateRef = TemplateRef; // TODO(alxhub): combine interface and implementation. Currently this is challenging since something\n// in g3 depends on them being separate.\n\nconst R3TemplateRef = class TemplateRef extends ViewEngineTemplateRef {\n  constructor(_declarationLView, _declarationTContainer, elementRef) {\n    super();\n    this._declarationLView = _declarationLView;\n    this._declarationTContainer = _declarationTContainer;\n    this.elementRef = elementRef;\n  }\n\n  createEmbeddedView(context, injector) {\n    const embeddedTView = this._declarationTContainer.tViews;\n    const embeddedLView = createLView(this._declarationLView, embeddedTView, context, 16\n    /* LViewFlags.CheckAlways */\n    , null, embeddedTView.declTNode, null, null, null, null, injector || null);\n    const declarationLContainer = this._declarationLView[this._declarationTContainer.index];\n    ngDevMode && assertLContainer(declarationLContainer);\n    embeddedLView[DECLARATION_LCONTAINER] = declarationLContainer;\n    const declarationViewLQueries = this._declarationLView[QUERIES];\n\n    if (declarationViewLQueries !== null) {\n      embeddedLView[QUERIES] = declarationViewLQueries.createEmbeddedView(embeddedTView);\n    }\n\n    renderView(embeddedTView, embeddedLView, context);\n    return new ViewRef(embeddedLView);\n  }\n\n};\n/**\n * Creates a TemplateRef given a node.\n *\n * @returns The TemplateRef instance to use\n */\n\nfunction injectTemplateRef() {\n  return createTemplateRef(getCurrentTNode(), getLView());\n}\n/**\n * Creates a TemplateRef and stores it on the injector.\n *\n * @param hostTNode The node on which a TemplateRef is requested\n * @param hostLView The `LView` to which the node belongs\n * @returns The TemplateRef instance or null if we can't create a TemplateRef on a given node type\n */\n\n\nfunction createTemplateRef(hostTNode, hostLView) {\n  if (hostTNode.type & 4\n  /* TNodeType.Container */\n  ) {\n    ngDevMode && assertDefined(hostTNode.tViews, 'TView must be allocated');\n    return new R3TemplateRef(hostLView, hostTNode, createElementRef(hostTNode, hostLView));\n  }\n\n  return null;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Represents a container where one or more views can be attached to a component.\n *\n * Can contain *host views* (created by instantiating a\n * component with the `createComponent()` method), and *embedded views*\n * (created by instantiating a `TemplateRef` with the `createEmbeddedView()` method).\n *\n * A view container instance can contain other view containers,\n * creating a [view hierarchy](guide/glossary#view-tree).\n *\n * @see `ComponentRef`\n * @see `EmbeddedViewRef`\n *\n * @publicApi\n */\n\n\nclass ViewContainerRef {}\n/**\n * @internal\n * @nocollapse\n */\n\n\nViewContainerRef.__NG_ELEMENT_ID__ = injectViewContainerRef;\n/**\n * Creates a ViewContainerRef and stores it on the injector. Or, if the ViewContainerRef\n * already exists, retrieves the existing ViewContainerRef.\n *\n * @returns The ViewContainerRef instance to use\n */\n\nfunction injectViewContainerRef() {\n  const previousTNode = getCurrentTNode();\n  return createContainerRef(previousTNode, getLView());\n}\n\nconst VE_ViewContainerRef = ViewContainerRef; // TODO(alxhub): cleaning up this indirection triggers a subtle bug in Closure in g3. Once the fix\n// for that lands, this can be cleaned up.\n\nconst R3ViewContainerRef = class ViewContainerRef extends VE_ViewContainerRef {\n  constructor(_lContainer, _hostTNode, _hostLView) {\n    super();\n    this._lContainer = _lContainer;\n    this._hostTNode = _hostTNode;\n    this._hostLView = _hostLView;\n  }\n\n  get element() {\n    return createElementRef(this._hostTNode, this._hostLView);\n  }\n\n  get injector() {\n    return new NodeInjector(this._hostTNode, this._hostLView);\n  }\n  /** @deprecated No replacement */\n\n\n  get parentInjector() {\n    const parentLocation = getParentInjectorLocation(this._hostTNode, this._hostLView);\n\n    if (hasParentInjector(parentLocation)) {\n      const parentView = getParentInjectorView(parentLocation, this._hostLView);\n      const injectorIndex = getParentInjectorIndex(parentLocation);\n      ngDevMode && assertNodeInjector(parentView, injectorIndex);\n      const parentTNode = parentView[TVIEW].data[injectorIndex + 8\n      /* NodeInjectorOffset.TNODE */\n      ];\n      return new NodeInjector(parentTNode, parentView);\n    } else {\n      return new NodeInjector(null, this._hostLView);\n    }\n  }\n\n  clear() {\n    while (this.length > 0) {\n      this.remove(this.length - 1);\n    }\n  }\n\n  get(index) {\n    const viewRefs = getViewRefs(this._lContainer);\n    return viewRefs !== null && viewRefs[index] || null;\n  }\n\n  get length() {\n    return this._lContainer.length - CONTAINER_HEADER_OFFSET;\n  }\n\n  createEmbeddedView(templateRef, context, indexOrOptions) {\n    let index;\n    let injector;\n\n    if (typeof indexOrOptions === 'number') {\n      index = indexOrOptions;\n    } else if (indexOrOptions != null) {\n      index = indexOrOptions.index;\n      injector = indexOrOptions.injector;\n    }\n\n    const viewRef = templateRef.createEmbeddedView(context || {}, injector);\n    this.insert(viewRef, index);\n    return viewRef;\n  }\n\n  createComponent(componentFactoryOrType, indexOrOptions, injector, projectableNodes, environmentInjector) {\n    const isComponentFactory = componentFactoryOrType && !isType(componentFactoryOrType);\n    let index; // This function supports 2 signatures and we need to handle options correctly for both:\n    //   1. When first argument is a Component type. This signature also requires extra\n    //      options to be provided as as object (more ergonomic option).\n    //   2. First argument is a Component factory. In this case extra options are represented as\n    //      positional arguments. This signature is less ergonomic and will be deprecated.\n\n    if (isComponentFactory) {\n      if (ngDevMode) {\n        assertEqual(typeof indexOrOptions !== 'object', true, 'It looks like Component factory was provided as the first argument ' + 'and an options object as the second argument. This combination of arguments ' + 'is incompatible. You can either change the first argument to provide Component ' + 'type or change the second argument to be a number (representing an index at ' + 'which to insert the new component\\'s host view into this container)');\n      }\n\n      index = indexOrOptions;\n    } else {\n      if (ngDevMode) {\n        assertDefined(getComponentDef$1(componentFactoryOrType), `Provided Component class doesn't contain Component definition. ` + `Please check whether provided class has @Component decorator.`);\n        assertEqual(typeof indexOrOptions !== 'number', true, 'It looks like Component type was provided as the first argument ' + 'and a number (representing an index at which to insert the new component\\'s ' + 'host view into this container as the second argument. This combination of arguments ' + 'is incompatible. Please use an object as the second argument instead.');\n      }\n\n      const options = indexOrOptions || {};\n\n      if (ngDevMode && options.environmentInjector && options.ngModuleRef) {\n        throwError(`Cannot pass both environmentInjector and ngModuleRef options to createComponent().`);\n      }\n\n      index = options.index;\n      injector = options.injector;\n      projectableNodes = options.projectableNodes;\n      environmentInjector = options.environmentInjector || options.ngModuleRef;\n    }\n\n    const componentFactory = isComponentFactory ? componentFactoryOrType : new ComponentFactory(getComponentDef$1(componentFactoryOrType));\n    const contextInjector = injector || this.parentInjector; // If an `NgModuleRef` is not provided explicitly, try retrieving it from the DI tree.\n\n    if (!environmentInjector && componentFactory.ngModule == null) {\n      // For the `ComponentFactory` case, entering this logic is very unlikely, since we expect that\n      // an instance of a `ComponentFactory`, resolved via `ComponentFactoryResolver` would have an\n      // `ngModule` field. This is possible in some test scenarios and potentially in some JIT-based\n      // use-cases. For the `ComponentFactory` case we preserve backwards-compatibility and try\n      // using a provided injector first, then fall back to the parent injector of this\n      // `ViewContainerRef` instance.\n      //\n      // For the factory-less case, it's critical to establish a connection with the module\n      // injector tree (by retrieving an instance of an `NgModuleRef` and accessing its injector),\n      // so that a component can use DI tokens provided in MgModules. For this reason, we can not\n      // rely on the provided injector, since it might be detached from the DI tree (for example, if\n      // it was created via `Injector.create` without specifying a parent injector, or if an\n      // injector is retrieved from an `NgModuleRef` created via `createNgModuleRef` using an\n      // NgModule outside of a module tree). Instead, we always use `ViewContainerRef`'s parent\n      // injector, which is normally connected to the DI tree, which includes module injector\n      // subtree.\n      const _injector = isComponentFactory ? contextInjector : this.parentInjector; // DO NOT REFACTOR. The code here used to have a `injector.get(NgModuleRef, null) ||\n      // undefined` expression which seems to cause internal google apps to fail. This is documented\n      // in the following internal bug issue: go/b/142967802\n\n\n      const result = _injector.get(EnvironmentInjector, null);\n\n      if (result) {\n        environmentInjector = result;\n      }\n    }\n\n    const componentRef = componentFactory.create(contextInjector, projectableNodes, undefined, environmentInjector);\n    this.insert(componentRef.hostView, index);\n    return componentRef;\n  }\n\n  insert(viewRef, index) {\n    const lView = viewRef._lView;\n    const tView = lView[TVIEW];\n\n    if (ngDevMode && viewRef.destroyed) {\n      throw new Error('Cannot insert a destroyed View in a ViewContainer!');\n    }\n\n    if (viewAttachedToContainer(lView)) {\n      // If view is already attached, detach it first so we clean up references appropriately.\n      const prevIdx = this.indexOf(viewRef); // A view might be attached either to this or a different container. The `prevIdx` for\n      // those cases will be:\n      // equal to -1 for views attached to this ViewContainerRef\n      // >= 0 for views attached to a different ViewContainerRef\n\n      if (prevIdx !== -1) {\n        this.detach(prevIdx);\n      } else {\n        const prevLContainer = lView[PARENT];\n        ngDevMode && assertEqual(isLContainer(prevLContainer), true, 'An attached view should have its PARENT point to a container.'); // We need to re-create a R3ViewContainerRef instance since those are not stored on\n        // LView (nor anywhere else).\n\n        const prevVCRef = new R3ViewContainerRef(prevLContainer, prevLContainer[T_HOST], prevLContainer[PARENT]);\n        prevVCRef.detach(prevVCRef.indexOf(viewRef));\n      }\n    } // Logical operation of adding `LView` to `LContainer`\n\n\n    const adjustedIdx = this._adjustIndex(index);\n\n    const lContainer = this._lContainer;\n    insertView(tView, lView, lContainer, adjustedIdx); // Physical operation of adding the DOM nodes.\n\n    const beforeNode = getBeforeNodeForView(adjustedIdx, lContainer);\n    const renderer = lView[RENDERER];\n    const parentRNode = nativeParentNode(renderer, lContainer[NATIVE]);\n\n    if (parentRNode !== null) {\n      addViewToContainer(tView, lContainer[T_HOST], renderer, lView, parentRNode, beforeNode);\n    }\n\n    viewRef.attachToViewContainerRef();\n    addToArray(getOrCreateViewRefs(lContainer), adjustedIdx, viewRef);\n    return viewRef;\n  }\n\n  move(viewRef, newIndex) {\n    if (ngDevMode && viewRef.destroyed) {\n      throw new Error('Cannot move a destroyed View in a ViewContainer!');\n    }\n\n    return this.insert(viewRef, newIndex);\n  }\n\n  indexOf(viewRef) {\n    const viewRefsArr = getViewRefs(this._lContainer);\n    return viewRefsArr !== null ? viewRefsArr.indexOf(viewRef) : -1;\n  }\n\n  remove(index) {\n    const adjustedIdx = this._adjustIndex(index, -1);\n\n    const detachedView = detachView(this._lContainer, adjustedIdx);\n\n    if (detachedView) {\n      // Before destroying the view, remove it from the container's array of `ViewRef`s.\n      // This ensures the view container length is updated before calling\n      // `destroyLView`, which could recursively call view container methods that\n      // rely on an accurate container length.\n      // (e.g. a method on this view container being called by a child directive's OnDestroy\n      // lifecycle hook)\n      removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx);\n      destroyLView(detachedView[TVIEW], detachedView);\n    }\n  }\n\n  detach(index) {\n    const adjustedIdx = this._adjustIndex(index, -1);\n\n    const view = detachView(this._lContainer, adjustedIdx);\n    const wasDetached = view && removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx) != null;\n    return wasDetached ? new ViewRef(view) : null;\n  }\n\n  _adjustIndex(index, shift = 0) {\n    if (index == null) {\n      return this.length + shift;\n    }\n\n    if (ngDevMode) {\n      assertGreaterThan(index, -1, `ViewRef index must be positive, got ${index}`); // +1 because it's legal to insert at the end.\n\n      assertLessThan(index, this.length + 1 + shift, 'index');\n    }\n\n    return index;\n  }\n\n};\n\nfunction getViewRefs(lContainer) {\n  return lContainer[VIEW_REFS];\n}\n\nfunction getOrCreateViewRefs(lContainer) {\n  return lContainer[VIEW_REFS] || (lContainer[VIEW_REFS] = []);\n}\n/**\n * Creates a ViewContainerRef and stores it on the injector.\n *\n * @param ViewContainerRefToken The ViewContainerRef type\n * @param ElementRefToken The ElementRef type\n * @param hostTNode The node that is requesting a ViewContainerRef\n * @param hostLView The view to which the node belongs\n * @returns The ViewContainerRef instance to use\n */\n\n\nfunction createContainerRef(hostTNode, hostLView) {\n  ngDevMode && assertTNodeType(hostTNode, 12\n  /* TNodeType.AnyContainer */\n  | 3\n  /* TNodeType.AnyRNode */\n  );\n  let lContainer;\n  const slotValue = hostLView[hostTNode.index];\n\n  if (isLContainer(slotValue)) {\n    // If the host is a container, we don't need to create a new LContainer\n    lContainer = slotValue;\n  } else {\n    let commentNode; // If the host is an element container, the native host element is guaranteed to be a\n    // comment and we can reuse that comment as anchor element for the new LContainer.\n    // The comment node in question is already part of the DOM structure so we don't need to append\n    // it again.\n\n    if (hostTNode.type & 8\n    /* TNodeType.ElementContainer */\n    ) {\n      commentNode = unwrapRNode(slotValue);\n    } else {\n      // If the host is a regular element, we have to insert a comment node manually which will\n      // be used as an anchor when inserting elements. In this specific case we use low-level DOM\n      // manipulation to insert it.\n      const renderer = hostLView[RENDERER];\n      ngDevMode && ngDevMode.rendererCreateComment++;\n      commentNode = renderer.createComment(ngDevMode ? 'container' : '');\n      const hostNative = getNativeByTNode(hostTNode, hostLView);\n      const parentOfHostNative = nativeParentNode(renderer, hostNative);\n      nativeInsertBefore(renderer, parentOfHostNative, commentNode, nativeNextSibling(renderer, hostNative), false);\n    }\n\n    hostLView[hostTNode.index] = lContainer = createLContainer(slotValue, hostLView, commentNode, hostTNode);\n    addToViewTree(hostLView, lContainer);\n  }\n\n  return new R3ViewContainerRef(lContainer, hostTNode, hostLView);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\n\n\nconst unusedValueExportToPlacateAjd$1 = 1;\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\n\nconst unusedValueExportToPlacateAjd = 1;\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nconst unusedValueToPlacateAjd = unusedValueExportToPlacateAjd$1 + unusedValueExportToPlacateAjd$5 + unusedValueExportToPlacateAjd$4 + unusedValueExportToPlacateAjd;\n\nclass LQuery_ {\n  constructor(queryList) {\n    this.queryList = queryList;\n    this.matches = null;\n  }\n\n  clone() {\n    return new LQuery_(this.queryList);\n  }\n\n  setDirty() {\n    this.queryList.setDirty();\n  }\n\n}\n\nclass LQueries_ {\n  constructor(queries = []) {\n    this.queries = queries;\n  }\n\n  createEmbeddedView(tView) {\n    const tQueries = tView.queries;\n\n    if (tQueries !== null) {\n      const noOfInheritedQueries = tView.contentQueries !== null ? tView.contentQueries[0] : tQueries.length;\n      const viewLQueries = []; // An embedded view has queries propagated from a declaration view at the beginning of the\n      // TQueries collection and up until a first content query declared in the embedded view. Only\n      // propagated LQueries are created at this point (LQuery corresponding to declared content\n      // queries will be instantiated from the content query instructions for each directive).\n\n      for (let i = 0; i < noOfInheritedQueries; i++) {\n        const tQuery = tQueries.getByIndex(i);\n        const parentLQuery = this.queries[tQuery.indexInDeclarationView];\n        viewLQueries.push(parentLQuery.clone());\n      }\n\n      return new LQueries_(viewLQueries);\n    }\n\n    return null;\n  }\n\n  insertView(tView) {\n    this.dirtyQueriesWithMatches(tView);\n  }\n\n  detachView(tView) {\n    this.dirtyQueriesWithMatches(tView);\n  }\n\n  dirtyQueriesWithMatches(tView) {\n    for (let i = 0; i < this.queries.length; i++) {\n      if (getTQuery(tView, i).matches !== null) {\n        this.queries[i].setDirty();\n      }\n    }\n  }\n\n}\n\nclass TQueryMetadata_ {\n  constructor(predicate, flags, read = null) {\n    this.predicate = predicate;\n    this.flags = flags;\n    this.read = read;\n  }\n\n}\n\nclass TQueries_ {\n  constructor(queries = []) {\n    this.queries = queries;\n  }\n\n  elementStart(tView, tNode) {\n    ngDevMode && assertFirstCreatePass(tView, 'Queries should collect results on the first template pass only');\n\n    for (let i = 0; i < this.queries.length; i++) {\n      this.queries[i].elementStart(tView, tNode);\n    }\n  }\n\n  elementEnd(tNode) {\n    for (let i = 0; i < this.queries.length; i++) {\n      this.queries[i].elementEnd(tNode);\n    }\n  }\n\n  embeddedTView(tNode) {\n    let queriesForTemplateRef = null;\n\n    for (let i = 0; i < this.length; i++) {\n      const childQueryIndex = queriesForTemplateRef !== null ? queriesForTemplateRef.length : 0;\n      const tqueryClone = this.getByIndex(i).embeddedTView(tNode, childQueryIndex);\n\n      if (tqueryClone) {\n        tqueryClone.indexInDeclarationView = i;\n\n        if (queriesForTemplateRef !== null) {\n          queriesForTemplateRef.push(tqueryClone);\n        } else {\n          queriesForTemplateRef = [tqueryClone];\n        }\n      }\n    }\n\n    return queriesForTemplateRef !== null ? new TQueries_(queriesForTemplateRef) : null;\n  }\n\n  template(tView, tNode) {\n    ngDevMode && assertFirstCreatePass(tView, 'Queries should collect results on the first template pass only');\n\n    for (let i = 0; i < this.queries.length; i++) {\n      this.queries[i].template(tView, tNode);\n    }\n  }\n\n  getByIndex(index) {\n    ngDevMode && assertIndexInRange(this.queries, index);\n    return this.queries[index];\n  }\n\n  get length() {\n    return this.queries.length;\n  }\n\n  track(tquery) {\n    this.queries.push(tquery);\n  }\n\n}\n\nclass TQuery_ {\n  constructor(metadata, nodeIndex = -1) {\n    this.metadata = metadata;\n    this.matches = null;\n    this.indexInDeclarationView = -1;\n    this.crossesNgTemplate = false;\n    /**\n     * A flag indicating if a given query still applies to nodes it is crossing. We use this flag\n     * (alongside with _declarationNodeIndex) to know when to stop applying content queries to\n     * elements in a template.\n     */\n\n    this._appliesToNextNode = true;\n    this._declarationNodeIndex = nodeIndex;\n  }\n\n  elementStart(tView, tNode) {\n    if (this.isApplyingToNode(tNode)) {\n      this.matchTNode(tView, tNode);\n    }\n  }\n\n  elementEnd(tNode) {\n    if (this._declarationNodeIndex === tNode.index) {\n      this._appliesToNextNode = false;\n    }\n  }\n\n  template(tView, tNode) {\n    this.elementStart(tView, tNode);\n  }\n\n  embeddedTView(tNode, childQueryIndex) {\n    if (this.isApplyingToNode(tNode)) {\n      this.crossesNgTemplate = true; // A marker indicating a `<ng-template>` element (a placeholder for query results from\n      // embedded views created based on this `<ng-template>`).\n\n      this.addMatch(-tNode.index, childQueryIndex);\n      return new TQuery_(this.metadata);\n    }\n\n    return null;\n  }\n\n  isApplyingToNode(tNode) {\n    if (this._appliesToNextNode && (this.metadata.flags & 1\n    /* QueryFlags.descendants */\n    ) !== 1\n    /* QueryFlags.descendants */\n    ) {\n      const declarationNodeIdx = this._declarationNodeIndex;\n      let parent = tNode.parent; // Determine if a given TNode is a \"direct\" child of a node on which a content query was\n      // declared (only direct children of query's host node can match with the descendants: false\n      // option). There are 3 main use-case / conditions to consider here:\n      // - <needs-target><i #target></i></needs-target>: here <i #target> parent node is a query\n      // host node;\n      // - <needs-target><ng-template [ngIf]=\"true\"><i #target></i></ng-template></needs-target>:\n      // here <i #target> parent node is null;\n      // - <needs-target><ng-container><i #target></i></ng-container></needs-target>: here we need\n      // to go past `<ng-container>` to determine <i #target> parent node (but we shouldn't traverse\n      // up past the query's host node!).\n\n      while (parent !== null && parent.type & 8\n      /* TNodeType.ElementContainer */\n      && parent.index !== declarationNodeIdx) {\n        parent = parent.parent;\n      }\n\n      return declarationNodeIdx === (parent !== null ? parent.index : -1);\n    }\n\n    return this._appliesToNextNode;\n  }\n\n  matchTNode(tView, tNode) {\n    const predicate = this.metadata.predicate;\n\n    if (Array.isArray(predicate)) {\n      for (let i = 0; i < predicate.length; i++) {\n        const name = predicate[i];\n        this.matchTNodeWithReadOption(tView, tNode, getIdxOfMatchingSelector(tNode, name)); // Also try matching the name to a provider since strings can be used as DI tokens too.\n\n        this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, name, false, false));\n      }\n    } else {\n      if (predicate === TemplateRef) {\n        if (tNode.type & 4\n        /* TNodeType.Container */\n        ) {\n          this.matchTNodeWithReadOption(tView, tNode, -1);\n        }\n      } else {\n        this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, predicate, false, false));\n      }\n    }\n  }\n\n  matchTNodeWithReadOption(tView, tNode, nodeMatchIdx) {\n    if (nodeMatchIdx !== null) {\n      const read = this.metadata.read;\n\n      if (read !== null) {\n        if (read === ElementRef || read === ViewContainerRef || read === TemplateRef && tNode.type & 4\n        /* TNodeType.Container */\n        ) {\n          this.addMatch(tNode.index, -2);\n        } else {\n          const directiveOrProviderIdx = locateDirectiveOrProvider(tNode, tView, read, false, false);\n\n          if (directiveOrProviderIdx !== null) {\n            this.addMatch(tNode.index, directiveOrProviderIdx);\n          }\n        }\n      } else {\n        this.addMatch(tNode.index, nodeMatchIdx);\n      }\n    }\n  }\n\n  addMatch(tNodeIdx, matchIdx) {\n    if (this.matches === null) {\n      this.matches = [tNodeIdx, matchIdx];\n    } else {\n      this.matches.push(tNodeIdx, matchIdx);\n    }\n  }\n\n}\n/**\n * Iterates over local names for a given node and returns directive index\n * (or -1 if a local name points to an element).\n *\n * @param tNode static data of a node to check\n * @param selector selector to match\n * @returns directive index, -1 or null if a selector didn't match any of the local names\n */\n\n\nfunction getIdxOfMatchingSelector(tNode, selector) {\n  const localNames = tNode.localNames;\n\n  if (localNames !== null) {\n    for (let i = 0; i < localNames.length; i += 2) {\n      if (localNames[i] === selector) {\n        return localNames[i + 1];\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction createResultByTNodeType(tNode, currentView) {\n  if (tNode.type & (3\n  /* TNodeType.AnyRNode */\n  | 8\n  /* TNodeType.ElementContainer */\n  )) {\n    return createElementRef(tNode, currentView);\n  } else if (tNode.type & 4\n  /* TNodeType.Container */\n  ) {\n    return createTemplateRef(tNode, currentView);\n  }\n\n  return null;\n}\n\nfunction createResultForNode(lView, tNode, matchingIdx, read) {\n  if (matchingIdx === -1) {\n    // if read token and / or strategy is not specified, detect it using appropriate tNode type\n    return createResultByTNodeType(tNode, lView);\n  } else if (matchingIdx === -2) {\n    // read a special token from a node injector\n    return createSpecialToken(lView, tNode, read);\n  } else {\n    // read a token\n    return getNodeInjectable(lView, lView[TVIEW], matchingIdx, tNode);\n  }\n}\n\nfunction createSpecialToken(lView, tNode, read) {\n  if (read === ElementRef) {\n    return createElementRef(tNode, lView);\n  } else if (read === TemplateRef) {\n    return createTemplateRef(tNode, lView);\n  } else if (read === ViewContainerRef) {\n    ngDevMode && assertTNodeType(tNode, 3\n    /* TNodeType.AnyRNode */\n    | 12\n    /* TNodeType.AnyContainer */\n    );\n    return createContainerRef(tNode, lView);\n  } else {\n    ngDevMode && throwError(`Special token to read should be one of ElementRef, TemplateRef or ViewContainerRef but got ${stringify(read)}.`);\n  }\n}\n/**\n * A helper function that creates query results for a given view. This function is meant to do the\n * processing once and only once for a given view instance (a set of results for a given view\n * doesn't change).\n */\n\n\nfunction materializeViewResults(tView, lView, tQuery, queryIndex) {\n  const lQuery = lView[QUERIES].queries[queryIndex];\n\n  if (lQuery.matches === null) {\n    const tViewData = tView.data;\n    const tQueryMatches = tQuery.matches;\n    const result = [];\n\n    for (let i = 0; i < tQueryMatches.length; i += 2) {\n      const matchedNodeIdx = tQueryMatches[i];\n\n      if (matchedNodeIdx < 0) {\n        // we at the <ng-template> marker which might have results in views created based on this\n        // <ng-template> - those results will be in separate views though, so here we just leave\n        // null as a placeholder\n        result.push(null);\n      } else {\n        ngDevMode && assertIndexInRange(tViewData, matchedNodeIdx);\n        const tNode = tViewData[matchedNodeIdx];\n        result.push(createResultForNode(lView, tNode, tQueryMatches[i + 1], tQuery.metadata.read));\n      }\n    }\n\n    lQuery.matches = result;\n  }\n\n  return lQuery.matches;\n}\n/**\n * A helper function that collects (already materialized) query results from a tree of views,\n * starting with a provided LView.\n */\n\n\nfunction collectQueryResults(tView, lView, queryIndex, result) {\n  const tQuery = tView.queries.getByIndex(queryIndex);\n  const tQueryMatches = tQuery.matches;\n\n  if (tQueryMatches !== null) {\n    const lViewResults = materializeViewResults(tView, lView, tQuery, queryIndex);\n\n    for (let i = 0; i < tQueryMatches.length; i += 2) {\n      const tNodeIdx = tQueryMatches[i];\n\n      if (tNodeIdx > 0) {\n        result.push(lViewResults[i / 2]);\n      } else {\n        const childQueryIndex = tQueryMatches[i + 1];\n        const declarationLContainer = lView[-tNodeIdx];\n        ngDevMode && assertLContainer(declarationLContainer); // collect matches for views inserted in this container\n\n        for (let i = CONTAINER_HEADER_OFFSET; i < declarationLContainer.length; i++) {\n          const embeddedLView = declarationLContainer[i];\n\n          if (embeddedLView[DECLARATION_LCONTAINER] === embeddedLView[PARENT]) {\n            collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);\n          }\n        } // collect matches for views created from this declaration container and inserted into\n        // different containers\n\n\n        if (declarationLContainer[MOVED_VIEWS] !== null) {\n          const embeddedLViews = declarationLContainer[MOVED_VIEWS];\n\n          for (let i = 0; i < embeddedLViews.length; i++) {\n            const embeddedLView = embeddedLViews[i];\n            collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);\n          }\n        }\n      }\n    }\n  }\n\n  return result;\n}\n/**\n * Refreshes a query by combining matches from all active views and removing matches from deleted\n * views.\n *\n * @returns `true` if a query got dirty during change detection or if this is a static query\n * resolving in creation mode, `false` otherwise.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵqueryRefresh(queryList) {\n  const lView = getLView();\n  const tView = getTView();\n  const queryIndex = getCurrentQueryIndex();\n  setCurrentQueryIndex(queryIndex + 1);\n  const tQuery = getTQuery(tView, queryIndex);\n\n  if (queryList.dirty && isCreationMode(lView) === ((tQuery.metadata.flags & 2\n  /* QueryFlags.isStatic */\n  ) === 2\n  /* QueryFlags.isStatic */\n  )) {\n    if (tQuery.matches === null) {\n      queryList.reset([]);\n    } else {\n      const result = tQuery.crossesNgTemplate ? collectQueryResults(tView, lView, queryIndex, []) : materializeViewResults(tView, lView, tQuery, queryIndex);\n      queryList.reset(result, unwrapElementRef);\n      queryList.notifyOnChanges();\n    }\n\n    return true;\n  }\n\n  return false;\n}\n/**\n * Creates new QueryList, stores the reference in LView and returns QueryList.\n *\n * @param predicate The type for which the query will search\n * @param flags Flags associated with the query\n * @param read What to save in the query\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵviewQuery(predicate, flags, read) {\n  ngDevMode && assertNumber(flags, 'Expecting flags');\n  const tView = getTView();\n\n  if (tView.firstCreatePass) {\n    createTQuery(tView, new TQueryMetadata_(predicate, flags, read), -1);\n\n    if ((flags & 2\n    /* QueryFlags.isStatic */\n    ) === 2\n    /* QueryFlags.isStatic */\n    ) {\n      tView.staticViewQueries = true;\n    }\n  }\n\n  createLQuery(tView, getLView(), flags);\n}\n/**\n * Registers a QueryList, associated with a content query, for later refresh (part of a view\n * refresh).\n *\n * @param directiveIndex Current directive index\n * @param predicate The type for which the query will search\n * @param flags Flags associated with the query\n * @param read What to save in the query\n * @returns QueryList<T>\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵcontentQuery(directiveIndex, predicate, flags, read) {\n  ngDevMode && assertNumber(flags, 'Expecting flags');\n  const tView = getTView();\n\n  if (tView.firstCreatePass) {\n    const tNode = getCurrentTNode();\n    createTQuery(tView, new TQueryMetadata_(predicate, flags, read), tNode.index);\n    saveContentQueryAndDirectiveIndex(tView, directiveIndex);\n\n    if ((flags & 2\n    /* QueryFlags.isStatic */\n    ) === 2\n    /* QueryFlags.isStatic */\n    ) {\n      tView.staticContentQueries = true;\n    }\n  }\n\n  createLQuery(tView, getLView(), flags);\n}\n/**\n * Loads a QueryList corresponding to the current view or content query.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵloadQuery() {\n  return loadQueryInternal(getLView(), getCurrentQueryIndex());\n}\n\nfunction loadQueryInternal(lView, queryIndex) {\n  ngDevMode && assertDefined(lView[QUERIES], 'LQueries should be defined when trying to load a query');\n  ngDevMode && assertIndexInRange(lView[QUERIES].queries, queryIndex);\n  return lView[QUERIES].queries[queryIndex].queryList;\n}\n\nfunction createLQuery(tView, lView, flags) {\n  const queryList = new QueryList((flags & 4\n  /* QueryFlags.emitDistinctChangesOnly */\n  ) === 4\n  /* QueryFlags.emitDistinctChangesOnly */\n  );\n  storeCleanupWithContext(tView, lView, queryList, queryList.destroy);\n  if (lView[QUERIES] === null) lView[QUERIES] = new LQueries_();\n  lView[QUERIES].queries.push(new LQuery_(queryList));\n}\n\nfunction createTQuery(tView, metadata, nodeIndex) {\n  if (tView.queries === null) tView.queries = new TQueries_();\n  tView.queries.track(new TQuery_(metadata, nodeIndex));\n}\n\nfunction saveContentQueryAndDirectiveIndex(tView, directiveIndex) {\n  const tViewContentQueries = tView.contentQueries || (tView.contentQueries = []);\n  const lastSavedDirectiveIndex = tViewContentQueries.length ? tViewContentQueries[tViewContentQueries.length - 1] : -1;\n\n  if (directiveIndex !== lastSavedDirectiveIndex) {\n    tViewContentQueries.push(tView.queries.length - 1, directiveIndex);\n  }\n}\n\nfunction getTQuery(tView, index) {\n  ngDevMode && assertDefined(tView.queries, 'TQueries must be defined to retrieve a TQuery');\n  return tView.queries.getByIndex(index);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Retrieves `TemplateRef` instance from `Injector` when a local reference is placed on the\n * `<ng-template>` element.\n *\n * @codeGenApi\n */\n\n\nfunction ɵɵtemplateRefExtractor(tNode, lView) {\n  return createTemplateRef(tNode, lView);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A mapping of the @angular/core API surface used in generated expressions to the actual symbols.\n *\n * This should be kept up to date with the public exports of @angular/core.\n */\n\n\nconst angularCoreEnv = (() => ({\n  'ɵɵattribute': ɵɵattribute,\n  'ɵɵattributeInterpolate1': ɵɵattributeInterpolate1,\n  'ɵɵattributeInterpolate2': ɵɵattributeInterpolate2,\n  'ɵɵattributeInterpolate3': ɵɵattributeInterpolate3,\n  'ɵɵattributeInterpolate4': ɵɵattributeInterpolate4,\n  'ɵɵattributeInterpolate5': ɵɵattributeInterpolate5,\n  'ɵɵattributeInterpolate6': ɵɵattributeInterpolate6,\n  'ɵɵattributeInterpolate7': ɵɵattributeInterpolate7,\n  'ɵɵattributeInterpolate8': ɵɵattributeInterpolate8,\n  'ɵɵattributeInterpolateV': ɵɵattributeInterpolateV,\n  'ɵɵdefineComponent': ɵɵdefineComponent,\n  'ɵɵdefineDirective': ɵɵdefineDirective,\n  'ɵɵdefineInjectable': ɵɵdefineInjectable,\n  'ɵɵdefineInjector': ɵɵdefineInjector,\n  'ɵɵdefineNgModule': ɵɵdefineNgModule,\n  'ɵɵdefinePipe': ɵɵdefinePipe,\n  'ɵɵdirectiveInject': ɵɵdirectiveInject,\n  'ɵɵgetInheritedFactory': ɵɵgetInheritedFactory,\n  'ɵɵinject': ɵɵinject,\n  'ɵɵinjectAttribute': ɵɵinjectAttribute,\n  'ɵɵinvalidFactory': ɵɵinvalidFactory,\n  'ɵɵinvalidFactoryDep': ɵɵinvalidFactoryDep,\n  'ɵɵtemplateRefExtractor': ɵɵtemplateRefExtractor,\n  'ɵɵresetView': ɵɵresetView,\n  'ɵɵNgOnChangesFeature': ɵɵNgOnChangesFeature,\n  'ɵɵProvidersFeature': ɵɵProvidersFeature,\n  'ɵɵCopyDefinitionFeature': ɵɵCopyDefinitionFeature,\n  'ɵɵInheritDefinitionFeature': ɵɵInheritDefinitionFeature,\n  'ɵɵStandaloneFeature': ɵɵStandaloneFeature,\n  'ɵɵnextContext': ɵɵnextContext,\n  'ɵɵnamespaceHTML': ɵɵnamespaceHTML,\n  'ɵɵnamespaceMathML': ɵɵnamespaceMathML,\n  'ɵɵnamespaceSVG': ɵɵnamespaceSVG,\n  'ɵɵenableBindings': ɵɵenableBindings,\n  'ɵɵdisableBindings': ɵɵdisableBindings,\n  'ɵɵelementStart': ɵɵelementStart,\n  'ɵɵelementEnd': ɵɵelementEnd,\n  'ɵɵelement': ɵɵelement,\n  'ɵɵelementContainerStart': ɵɵelementContainerStart,\n  'ɵɵelementContainerEnd': ɵɵelementContainerEnd,\n  'ɵɵelementContainer': ɵɵelementContainer,\n  'ɵɵpureFunction0': ɵɵpureFunction0,\n  'ɵɵpureFunction1': ɵɵpureFunction1,\n  'ɵɵpureFunction2': ɵɵpureFunction2,\n  'ɵɵpureFunction3': ɵɵpureFunction3,\n  'ɵɵpureFunction4': ɵɵpureFunction4,\n  'ɵɵpureFunction5': ɵɵpureFunction5,\n  'ɵɵpureFunction6': ɵɵpureFunction6,\n  'ɵɵpureFunction7': ɵɵpureFunction7,\n  'ɵɵpureFunction8': ɵɵpureFunction8,\n  'ɵɵpureFunctionV': ɵɵpureFunctionV,\n  'ɵɵgetCurrentView': ɵɵgetCurrentView,\n  'ɵɵrestoreView': ɵɵrestoreView,\n  'ɵɵlistener': ɵɵlistener,\n  'ɵɵprojection': ɵɵprojection,\n  'ɵɵsyntheticHostProperty': ɵɵsyntheticHostProperty,\n  'ɵɵsyntheticHostListener': ɵɵsyntheticHostListener,\n  'ɵɵpipeBind1': ɵɵpipeBind1,\n  'ɵɵpipeBind2': ɵɵpipeBind2,\n  'ɵɵpipeBind3': ɵɵpipeBind3,\n  'ɵɵpipeBind4': ɵɵpipeBind4,\n  'ɵɵpipeBindV': ɵɵpipeBindV,\n  'ɵɵprojectionDef': ɵɵprojectionDef,\n  'ɵɵhostProperty': ɵɵhostProperty,\n  'ɵɵproperty': ɵɵproperty,\n  'ɵɵpropertyInterpolate': ɵɵpropertyInterpolate,\n  'ɵɵpropertyInterpolate1': ɵɵpropertyInterpolate1,\n  'ɵɵpropertyInterpolate2': ɵɵpropertyInterpolate2,\n  'ɵɵpropertyInterpolate3': ɵɵpropertyInterpolate3,\n  'ɵɵpropertyInterpolate4': ɵɵpropertyInterpolate4,\n  'ɵɵpropertyInterpolate5': ɵɵpropertyInterpolate5,\n  'ɵɵpropertyInterpolate6': ɵɵpropertyInterpolate6,\n  'ɵɵpropertyInterpolate7': ɵɵpropertyInterpolate7,\n  'ɵɵpropertyInterpolate8': ɵɵpropertyInterpolate8,\n  'ɵɵpropertyInterpolateV': ɵɵpropertyInterpolateV,\n  'ɵɵpipe': ɵɵpipe,\n  'ɵɵqueryRefresh': ɵɵqueryRefresh,\n  'ɵɵviewQuery': ɵɵviewQuery,\n  'ɵɵloadQuery': ɵɵloadQuery,\n  'ɵɵcontentQuery': ɵɵcontentQuery,\n  'ɵɵreference': ɵɵreference,\n  'ɵɵclassMap': ɵɵclassMap,\n  'ɵɵclassMapInterpolate1': ɵɵclassMapInterpolate1,\n  'ɵɵclassMapInterpolate2': ɵɵclassMapInterpolate2,\n  'ɵɵclassMapInterpolate3': ɵɵclassMapInterpolate3,\n  'ɵɵclassMapInterpolate4': ɵɵclassMapInterpolate4,\n  'ɵɵclassMapInterpolate5': ɵɵclassMapInterpolate5,\n  'ɵɵclassMapInterpolate6': ɵɵclassMapInterpolate6,\n  'ɵɵclassMapInterpolate7': ɵɵclassMapInterpolate7,\n  'ɵɵclassMapInterpolate8': ɵɵclassMapInterpolate8,\n  'ɵɵclassMapInterpolateV': ɵɵclassMapInterpolateV,\n  'ɵɵstyleMap': ɵɵstyleMap,\n  'ɵɵstyleMapInterpolate1': ɵɵstyleMapInterpolate1,\n  'ɵɵstyleMapInterpolate2': ɵɵstyleMapInterpolate2,\n  'ɵɵstyleMapInterpolate3': ɵɵstyleMapInterpolate3,\n  'ɵɵstyleMapInterpolate4': ɵɵstyleMapInterpolate4,\n  'ɵɵstyleMapInterpolate5': ɵɵstyleMapInterpolate5,\n  'ɵɵstyleMapInterpolate6': ɵɵstyleMapInterpolate6,\n  'ɵɵstyleMapInterpolate7': ɵɵstyleMapInterpolate7,\n  'ɵɵstyleMapInterpolate8': ɵɵstyleMapInterpolate8,\n  'ɵɵstyleMapInterpolateV': ɵɵstyleMapInterpolateV,\n  'ɵɵstyleProp': ɵɵstyleProp,\n  'ɵɵstylePropInterpolate1': ɵɵstylePropInterpolate1,\n  'ɵɵstylePropInterpolate2': ɵɵstylePropInterpolate2,\n  'ɵɵstylePropInterpolate3': ɵɵstylePropInterpolate3,\n  'ɵɵstylePropInterpolate4': ɵɵstylePropInterpolate4,\n  'ɵɵstylePropInterpolate5': ɵɵstylePropInterpolate5,\n  'ɵɵstylePropInterpolate6': ɵɵstylePropInterpolate6,\n  'ɵɵstylePropInterpolate7': ɵɵstylePropInterpolate7,\n  'ɵɵstylePropInterpolate8': ɵɵstylePropInterpolate8,\n  'ɵɵstylePropInterpolateV': ɵɵstylePropInterpolateV,\n  'ɵɵclassProp': ɵɵclassProp,\n  'ɵɵadvance': ɵɵadvance,\n  'ɵɵtemplate': ɵɵtemplate,\n  'ɵɵtext': ɵɵtext,\n  'ɵɵtextInterpolate': ɵɵtextInterpolate,\n  'ɵɵtextInterpolate1': ɵɵtextInterpolate1,\n  'ɵɵtextInterpolate2': ɵɵtextInterpolate2,\n  'ɵɵtextInterpolate3': ɵɵtextInterpolate3,\n  'ɵɵtextInterpolate4': ɵɵtextInterpolate4,\n  'ɵɵtextInterpolate5': ɵɵtextInterpolate5,\n  'ɵɵtextInterpolate6': ɵɵtextInterpolate6,\n  'ɵɵtextInterpolate7': ɵɵtextInterpolate7,\n  'ɵɵtextInterpolate8': ɵɵtextInterpolate8,\n  'ɵɵtextInterpolateV': ɵɵtextInterpolateV,\n  'ɵɵi18n': ɵɵi18n,\n  'ɵɵi18nAttributes': ɵɵi18nAttributes,\n  'ɵɵi18nExp': ɵɵi18nExp,\n  'ɵɵi18nStart': ɵɵi18nStart,\n  'ɵɵi18nEnd': ɵɵi18nEnd,\n  'ɵɵi18nApply': ɵɵi18nApply,\n  'ɵɵi18nPostprocess': ɵɵi18nPostprocess,\n  'ɵɵresolveWindow': ɵɵresolveWindow,\n  'ɵɵresolveDocument': ɵɵresolveDocument,\n  'ɵɵresolveBody': ɵɵresolveBody,\n  'ɵɵsetComponentScope': ɵɵsetComponentScope,\n  'ɵɵsetNgModuleScope': ɵɵsetNgModuleScope,\n  'ɵɵregisterNgModuleType': registerNgModuleType,\n  'ɵɵsanitizeHtml': ɵɵsanitizeHtml,\n  'ɵɵsanitizeStyle': ɵɵsanitizeStyle,\n  'ɵɵsanitizeResourceUrl': ɵɵsanitizeResourceUrl,\n  'ɵɵsanitizeScript': ɵɵsanitizeScript,\n  'ɵɵsanitizeUrl': ɵɵsanitizeUrl,\n  'ɵɵsanitizeUrlOrResourceUrl': ɵɵsanitizeUrlOrResourceUrl,\n  'ɵɵtrustConstantHtml': ɵɵtrustConstantHtml,\n  'ɵɵtrustConstantResourceUrl': ɵɵtrustConstantResourceUrl,\n  'forwardRef': forwardRef,\n  'resolveForwardRef': resolveForwardRef\n}))();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction patchModuleCompilation() {// Does nothing, but exists as a target for patching.\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction isModuleWithProviders$1(value) {\n  return value.ngModule !== undefined;\n}\n\nfunction isNgModule$1(value) {\n  return !!getNgModuleDef(value);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nconst moduleQueue = [];\n/**\n * Enqueues moduleDef to be checked later to see if scope can be set on its\n * component declarations.\n */\n\nfunction enqueueModuleForDelayedScoping(moduleType, ngModule) {\n  moduleQueue.push({\n    moduleType,\n    ngModule\n  });\n}\n\nlet flushingModuleQueue = false;\n/**\n * Loops over queued module definitions, if a given module definition has all of its\n * declarations resolved, it dequeues that module definition and sets the scope on\n * its declarations.\n */\n\nfunction flushModuleScopingQueueAsMuchAsPossible() {\n  if (!flushingModuleQueue) {\n    flushingModuleQueue = true;\n\n    try {\n      for (let i = moduleQueue.length - 1; i >= 0; i--) {\n        const {\n          moduleType,\n          ngModule\n        } = moduleQueue[i];\n\n        if (ngModule.declarations && ngModule.declarations.every(isResolvedDeclaration)) {\n          // dequeue\n          moduleQueue.splice(i, 1);\n          setScopeOnDeclaredComponents(moduleType, ngModule);\n        }\n      }\n    } finally {\n      flushingModuleQueue = false;\n    }\n  }\n}\n/**\n * Returns truthy if a declaration has resolved. If the declaration happens to be\n * an array of declarations, it will recurse to check each declaration in that array\n * (which may also be arrays).\n */\n\n\nfunction isResolvedDeclaration(declaration) {\n  if (Array.isArray(declaration)) {\n    return declaration.every(isResolvedDeclaration);\n  }\n\n  return !!resolveForwardRef(declaration);\n}\n/**\n * Compiles a module in JIT mode.\n *\n * This function automatically gets called when a class has a `@NgModule` decorator.\n */\n\n\nfunction compileNgModule(moduleType, ngModule = {}) {\n  patchModuleCompilation();\n  compileNgModuleDefs(moduleType, ngModule);\n\n  if (ngModule.id !== undefined) {\n    registerNgModuleType(moduleType, ngModule.id);\n  } // Because we don't know if all declarations have resolved yet at the moment the\n  // NgModule decorator is executing, we're enqueueing the setting of module scope\n  // on its declarations to be run at a later time when all declarations for the module,\n  // including forward refs, have resolved.\n\n\n  enqueueModuleForDelayedScoping(moduleType, ngModule);\n}\n/**\n * Compiles and adds the `ɵmod`, `ɵfac` and `ɵinj` properties to the module class.\n *\n * It's possible to compile a module via this API which will allow duplicate declarations in its\n * root.\n */\n\n\nfunction compileNgModuleDefs(moduleType, ngModule, allowDuplicateDeclarationsInRoot = false) {\n  ngDevMode && assertDefined(moduleType, 'Required value moduleType');\n  ngDevMode && assertDefined(ngModule, 'Required value ngModule');\n  const declarations = flatten$1(ngModule.declarations || EMPTY_ARRAY);\n  let ngModuleDef = null;\n  Object.defineProperty(moduleType, NG_MOD_DEF, {\n    configurable: true,\n    get: () => {\n      if (ngModuleDef === null) {\n        if (ngDevMode && ngModule.imports && ngModule.imports.indexOf(moduleType) > -1) {\n          // We need to assert this immediately, because allowing it to continue will cause it to\n          // go into an infinite loop before we've reached the point where we throw all the errors.\n          throw new Error(`'${stringifyForError(moduleType)}' module can't import itself`);\n        }\n\n        const compiler = getCompilerFacade({\n          usage: 0\n          /* JitCompilerUsage.Decorator */\n          ,\n          kind: 'NgModule',\n          type: moduleType\n        });\n        ngModuleDef = compiler.compileNgModule(angularCoreEnv, `ng:///${moduleType.name}/ɵmod.js`, {\n          type: moduleType,\n          bootstrap: flatten$1(ngModule.bootstrap || EMPTY_ARRAY).map(resolveForwardRef),\n          declarations: declarations.map(resolveForwardRef),\n          imports: flatten$1(ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef).map(expandModuleWithProviders),\n          exports: flatten$1(ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef).map(expandModuleWithProviders),\n          schemas: ngModule.schemas ? flatten$1(ngModule.schemas) : null,\n          id: ngModule.id || null\n        }); // Set `schemas` on ngModuleDef to an empty array in JIT mode to indicate that runtime\n        // should verify that there are no unknown elements in a template. In AOT mode, that check\n        // happens at compile time and `schemas` information is not present on Component and Module\n        // defs after compilation (so the check doesn't happen the second time at runtime).\n\n        if (!ngModuleDef.schemas) {\n          ngModuleDef.schemas = [];\n        }\n      }\n\n      return ngModuleDef;\n    }\n  });\n  let ngFactoryDef = null;\n  Object.defineProperty(moduleType, NG_FACTORY_DEF, {\n    get: () => {\n      if (ngFactoryDef === null) {\n        const compiler = getCompilerFacade({\n          usage: 0\n          /* JitCompilerUsage.Decorator */\n          ,\n          kind: 'NgModule',\n          type: moduleType\n        });\n        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${moduleType.name}/ɵfac.js`, {\n          name: moduleType.name,\n          type: moduleType,\n          deps: reflectDependencies(moduleType),\n          target: compiler.FactoryTarget.NgModule,\n          typeArgumentCount: 0\n        });\n      }\n\n      return ngFactoryDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode\n  });\n  let ngInjectorDef = null;\n  Object.defineProperty(moduleType, NG_INJ_DEF, {\n    get: () => {\n      if (ngInjectorDef === null) {\n        ngDevMode && verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot);\n        const meta = {\n          name: moduleType.name,\n          type: moduleType,\n          providers: ngModule.providers || EMPTY_ARRAY,\n          imports: [(ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef), (ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef)]\n        };\n        const compiler = getCompilerFacade({\n          usage: 0\n          /* JitCompilerUsage.Decorator */\n          ,\n          kind: 'NgModule',\n          type: moduleType\n        });\n        ngInjectorDef = compiler.compileInjector(angularCoreEnv, `ng:///${moduleType.name}/ɵinj.js`, meta);\n      }\n\n      return ngInjectorDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode\n  });\n}\n\nfunction isStandalone(type) {\n  const def = getComponentDef$1(type) || getDirectiveDef(type) || getPipeDef$1(type);\n  return def !== null ? def.standalone : false;\n}\n\nfunction generateStandaloneInDeclarationsError(type, location) {\n  const prefix = `Unexpected \"${stringifyForError(type)}\" found in the \"declarations\" array of the`;\n  const suffix = `\"${stringifyForError(type)}\" is marked as standalone and can't be declared ` + 'in any NgModule - did you intend to import it instead (by adding it to the \"imports\" array)?';\n  return `${prefix} ${location}, ${suffix}`;\n}\n\nfunction verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot, importingModule) {\n  if (verifiedNgModule.get(moduleType)) return; // skip verifications of standalone components, directives and pipes\n\n  if (isStandalone(moduleType)) return;\n  verifiedNgModule.set(moduleType, true);\n  moduleType = resolveForwardRef(moduleType);\n  let ngModuleDef;\n\n  if (importingModule) {\n    ngModuleDef = getNgModuleDef(moduleType);\n\n    if (!ngModuleDef) {\n      throw new Error(`Unexpected value '${moduleType.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);\n    }\n  } else {\n    ngModuleDef = getNgModuleDef(moduleType, true);\n  }\n\n  const errors = [];\n  const declarations = maybeUnwrapFn$1(ngModuleDef.declarations);\n  const imports = maybeUnwrapFn$1(ngModuleDef.imports);\n  flatten$1(imports).map(unwrapModuleWithProvidersImports).forEach(modOrStandaloneCmpt => {\n    verifySemanticsOfNgModuleImport(modOrStandaloneCmpt, moduleType);\n    verifySemanticsOfNgModuleDef(modOrStandaloneCmpt, false, moduleType);\n  });\n  const exports = maybeUnwrapFn$1(ngModuleDef.exports);\n  declarations.forEach(verifyDeclarationsHaveDefinitions);\n  declarations.forEach(verifyDirectivesHaveSelector);\n  declarations.forEach(declarationType => verifyNotStandalone(declarationType, moduleType));\n  const combinedDeclarations = [...declarations.map(resolveForwardRef), ...flatten$1(imports.map(computeCombinedExports)).map(resolveForwardRef)];\n  exports.forEach(verifyExportsAreDeclaredOrReExported);\n  declarations.forEach(decl => verifyDeclarationIsUnique(decl, allowDuplicateDeclarationsInRoot));\n  declarations.forEach(verifyComponentEntryComponentsIsPartOfNgModule);\n  const ngModule = getAnnotation(moduleType, 'NgModule');\n\n  if (ngModule) {\n    ngModule.imports && flatten$1(ngModule.imports).map(unwrapModuleWithProvidersImports).forEach(mod => {\n      verifySemanticsOfNgModuleImport(mod, moduleType);\n      verifySemanticsOfNgModuleDef(mod, false, moduleType);\n    });\n    ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyCorrectBootstrapType);\n    ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyComponentIsPartOfNgModule);\n    ngModule.entryComponents && deepForEach(ngModule.entryComponents, verifyComponentIsPartOfNgModule);\n  } // Throw Error if any errors were detected.\n\n\n  if (errors.length) {\n    throw new Error(errors.join('\\n'));\n  } ////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n  function verifyDeclarationsHaveDefinitions(type) {\n    type = resolveForwardRef(type);\n    const def = getComponentDef$1(type) || getDirectiveDef(type) || getPipeDef$1(type);\n\n    if (!def) {\n      errors.push(`Unexpected value '${stringifyForError(type)}' declared by the module '${stringifyForError(moduleType)}'. Please add a @Pipe/@Directive/@Component annotation.`);\n    }\n  }\n\n  function verifyDirectivesHaveSelector(type) {\n    type = resolveForwardRef(type);\n    const def = getDirectiveDef(type);\n\n    if (!getComponentDef$1(type) && def && def.selectors.length == 0) {\n      errors.push(`Directive ${stringifyForError(type)} has no selector, please add it!`);\n    }\n  }\n\n  function verifyNotStandalone(type, moduleType) {\n    type = resolveForwardRef(type);\n    const def = getComponentDef$1(type) || getDirectiveDef(type) || getPipeDef$1(type);\n\n    if (def === null || def === void 0 ? void 0 : def.standalone) {\n      const location = `\"${stringifyForError(moduleType)}\" NgModule`;\n      errors.push(generateStandaloneInDeclarationsError(type, location));\n    }\n  }\n\n  function verifyExportsAreDeclaredOrReExported(type) {\n    type = resolveForwardRef(type);\n    const kind = getComponentDef$1(type) && 'component' || getDirectiveDef(type) && 'directive' || getPipeDef$1(type) && 'pipe';\n\n    if (kind) {\n      // only checked if we are declared as Component, Directive, or Pipe\n      // Modules don't need to be declared or imported.\n      if (combinedDeclarations.lastIndexOf(type) === -1) {\n        // We are exporting something which we don't explicitly declare or import.\n        errors.push(`Can't export ${kind} ${stringifyForError(type)} from ${stringifyForError(moduleType)} as it was neither declared nor imported!`);\n      }\n    }\n  }\n\n  function verifyDeclarationIsUnique(type, suppressErrors) {\n    type = resolveForwardRef(type);\n    const existingModule = ownerNgModule.get(type);\n\n    if (existingModule && existingModule !== moduleType) {\n      if (!suppressErrors) {\n        const modules = [existingModule, moduleType].map(stringifyForError).sort();\n        errors.push(`Type ${stringifyForError(type)} is part of the declarations of 2 modules: ${modules[0]} and ${modules[1]}! ` + `Please consider moving ${stringifyForError(type)} to a higher module that imports ${modules[0]} and ${modules[1]}. ` + `You can also create a new NgModule that exports and includes ${stringifyForError(type)} then import that NgModule in ${modules[0]} and ${modules[1]}.`);\n      }\n    } else {\n      // Mark type as having owner.\n      ownerNgModule.set(type, moduleType);\n    }\n  }\n\n  function verifyComponentIsPartOfNgModule(type) {\n    type = resolveForwardRef(type);\n    const existingModule = ownerNgModule.get(type);\n\n    if (!existingModule && !isStandalone(type)) {\n      errors.push(`Component ${stringifyForError(type)} is not part of any NgModule or the module has not been imported into your module.`);\n    }\n  }\n\n  function verifyCorrectBootstrapType(type) {\n    type = resolveForwardRef(type);\n\n    if (!getComponentDef$1(type)) {\n      errors.push(`${stringifyForError(type)} cannot be used as an entry component.`);\n    }\n\n    if (isStandalone(type)) {\n      // Note: this error should be the same as the\n      // `NGMODULE_BOOTSTRAP_IS_STANDALONE` one in AOT compiler.\n      errors.push(`The \\`${stringifyForError(type)}\\` class is a standalone component, which can ` + `not be used in the \\`@NgModule.bootstrap\\` array. Use the \\`bootstrapApplication\\` ` + `function for bootstrap instead.`);\n    }\n  }\n\n  function verifyComponentEntryComponentsIsPartOfNgModule(type) {\n    type = resolveForwardRef(type);\n\n    if (getComponentDef$1(type)) {\n      // We know we are component\n      const component = getAnnotation(type, 'Component');\n\n      if (component && component.entryComponents) {\n        deepForEach(component.entryComponents, verifyComponentIsPartOfNgModule);\n      }\n    }\n  }\n\n  function verifySemanticsOfNgModuleImport(type, importingModule) {\n    type = resolveForwardRef(type);\n    const directiveDef = getComponentDef$1(type) || getDirectiveDef(type);\n\n    if (directiveDef !== null && !directiveDef.standalone) {\n      throw new Error(`Unexpected directive '${type.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);\n    }\n\n    const pipeDef = getPipeDef$1(type);\n\n    if (pipeDef !== null && !pipeDef.standalone) {\n      throw new Error(`Unexpected pipe '${type.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);\n    }\n  }\n}\n\nfunction unwrapModuleWithProvidersImports(typeOrWithProviders) {\n  typeOrWithProviders = resolveForwardRef(typeOrWithProviders);\n  return typeOrWithProviders.ngModule || typeOrWithProviders;\n}\n\nfunction getAnnotation(type, name) {\n  let annotation = null;\n  collect(type.__annotations__);\n  collect(type.decorators);\n  return annotation;\n\n  function collect(annotations) {\n    if (annotations) {\n      annotations.forEach(readAnnotation);\n    }\n  }\n\n  function readAnnotation(decorator) {\n    if (!annotation) {\n      const proto = Object.getPrototypeOf(decorator);\n\n      if (proto.ngMetadataName == name) {\n        annotation = decorator;\n      } else if (decorator.type) {\n        const proto = Object.getPrototypeOf(decorator.type);\n\n        if (proto.ngMetadataName == name) {\n          annotation = decorator.args[0];\n        }\n      }\n    }\n  }\n}\n/**\n * Keep track of compiled components. This is needed because in tests we often want to compile the\n * same component with more than one NgModule. This would cause an error unless we reset which\n * NgModule the component belongs to. We keep the list of compiled components here so that the\n * TestBed can reset it later.\n */\n\n\nlet ownerNgModule = new WeakMap();\nlet verifiedNgModule = new WeakMap();\n\nfunction resetCompiledComponents() {\n  ownerNgModule = new WeakMap();\n  verifiedNgModule = new WeakMap();\n  moduleQueue.length = 0;\n}\n/**\n * Computes the combined declarations of explicit declarations, as well as declarations inherited by\n * traversing the exports of imported modules.\n * @param type\n */\n\n\nfunction computeCombinedExports(type) {\n  type = resolveForwardRef(type);\n  const ngModuleDef = getNgModuleDef(type); // a standalone component, directive or pipe\n\n  if (ngModuleDef === null) {\n    return [type];\n  }\n\n  return [...flatten$1(maybeUnwrapFn$1(ngModuleDef.exports).map(type => {\n    const ngModuleDef = getNgModuleDef(type);\n\n    if (ngModuleDef) {\n      verifySemanticsOfNgModuleDef(type, false);\n      return computeCombinedExports(type);\n    } else {\n      return type;\n    }\n  }))];\n}\n/**\n * Some declared components may be compiled asynchronously, and thus may not have their\n * ɵcmp set yet. If this is the case, then a reference to the module is written into\n * the `ngSelectorScope` property of the declared type.\n */\n\n\nfunction setScopeOnDeclaredComponents(moduleType, ngModule) {\n  const declarations = flatten$1(ngModule.declarations || EMPTY_ARRAY);\n  const transitiveScopes = transitiveScopesFor(moduleType);\n  declarations.forEach(declaration => {\n    declaration = resolveForwardRef(declaration);\n\n    if (declaration.hasOwnProperty(NG_COMP_DEF)) {\n      // A `ɵcmp` field exists - go ahead and patch the component directly.\n      const component = declaration;\n      const componentDef = getComponentDef$1(component);\n      patchComponentDefWithScope(componentDef, transitiveScopes);\n    } else if (!declaration.hasOwnProperty(NG_DIR_DEF) && !declaration.hasOwnProperty(NG_PIPE_DEF)) {\n      // Set `ngSelectorScope` for future reference when the component compilation finishes.\n      declaration.ngSelectorScope = moduleType;\n    }\n  });\n}\n/**\n * Patch the definition of a component with directives and pipes from the compilation scope of\n * a given module.\n */\n\n\nfunction patchComponentDefWithScope(componentDef, transitiveScopes) {\n  componentDef.directiveDefs = () => Array.from(transitiveScopes.compilation.directives).map(dir => dir.hasOwnProperty(NG_COMP_DEF) ? getComponentDef$1(dir) : getDirectiveDef(dir)).filter(def => !!def);\n\n  componentDef.pipeDefs = () => Array.from(transitiveScopes.compilation.pipes).map(pipe => getPipeDef$1(pipe));\n\n  componentDef.schemas = transitiveScopes.schemas; // Since we avoid Components/Directives/Pipes recompiling in case there are no overrides, we\n  // may face a problem where previously compiled defs available to a given Component/Directive\n  // are cached in TView and may become stale (in case any of these defs gets recompiled). In\n  // order to avoid this problem, we force fresh TView to be created.\n\n  componentDef.tView = null;\n}\n/**\n * Compute the pair of transitive scopes (compilation scope and exported scope) for a given type\n * (either a NgModule or a standalone component / directive / pipe).\n */\n\n\nfunction transitiveScopesFor(type) {\n  if (isNgModule$1(type)) {\n    return transitiveScopesForNgModule(type);\n  } else if (isStandalone(type)) {\n    const directiveDef = getComponentDef$1(type) || getDirectiveDef(type);\n\n    if (directiveDef !== null) {\n      return {\n        schemas: null,\n        compilation: {\n          directives: new Set(),\n          pipes: new Set()\n        },\n        exported: {\n          directives: new Set([type]),\n          pipes: new Set()\n        }\n      };\n    }\n\n    const pipeDef = getPipeDef$1(type);\n\n    if (pipeDef !== null) {\n      return {\n        schemas: null,\n        compilation: {\n          directives: new Set(),\n          pipes: new Set()\n        },\n        exported: {\n          directives: new Set(),\n          pipes: new Set([type])\n        }\n      };\n    }\n  } // TODO: change the error message to be more user-facing and take standalone into account\n\n\n  throw new Error(`${type.name} does not have a module def (ɵmod property)`);\n}\n/**\n * Compute the pair of transitive scopes (compilation scope and exported scope) for a given module.\n *\n * This operation is memoized and the result is cached on the module's definition. This function can\n * be called on modules with components that have not fully compiled yet, but the result should not\n * be used until they have.\n *\n * @param moduleType module that transitive scope should be calculated for.\n */\n\n\nfunction transitiveScopesForNgModule(moduleType) {\n  const def = getNgModuleDef(moduleType, true);\n\n  if (def.transitiveCompileScopes !== null) {\n    return def.transitiveCompileScopes;\n  }\n\n  const scopes = {\n    schemas: def.schemas || null,\n    compilation: {\n      directives: new Set(),\n      pipes: new Set()\n    },\n    exported: {\n      directives: new Set(),\n      pipes: new Set()\n    }\n  };\n  maybeUnwrapFn$1(def.imports).forEach(imported => {\n    // When this module imports another, the imported module's exported directives and pipes are\n    // added to the compilation scope of this module.\n    const importedScope = transitiveScopesFor(imported);\n    importedScope.exported.directives.forEach(entry => scopes.compilation.directives.add(entry));\n    importedScope.exported.pipes.forEach(entry => scopes.compilation.pipes.add(entry));\n  });\n  maybeUnwrapFn$1(def.declarations).forEach(declared => {\n    const declaredWithDefs = declared;\n\n    if (getPipeDef$1(declaredWithDefs)) {\n      scopes.compilation.pipes.add(declared);\n    } else {\n      // Either declared has a ɵcmp or ɵdir, or it's a component which hasn't\n      // had its template compiled yet. In either case, it gets added to the compilation's\n      // directives.\n      scopes.compilation.directives.add(declared);\n    }\n  });\n  maybeUnwrapFn$1(def.exports).forEach(exported => {\n    const exportedType = exported; // Either the type is a module, a pipe, or a component/directive (which may not have a\n    // ɵcmp as it might be compiled asynchronously).\n\n    if (isNgModule$1(exportedType)) {\n      // When this module exports another, the exported module's exported directives and pipes are\n      // added to both the compilation and exported scopes of this module.\n      const exportedScope = transitiveScopesFor(exportedType);\n      exportedScope.exported.directives.forEach(entry => {\n        scopes.compilation.directives.add(entry);\n        scopes.exported.directives.add(entry);\n      });\n      exportedScope.exported.pipes.forEach(entry => {\n        scopes.compilation.pipes.add(entry);\n        scopes.exported.pipes.add(entry);\n      });\n    } else if (getPipeDef$1(exportedType)) {\n      scopes.exported.pipes.add(exportedType);\n    } else {\n      scopes.exported.directives.add(exportedType);\n    }\n  });\n  def.transitiveCompileScopes = scopes;\n  return scopes;\n}\n\nfunction expandModuleWithProviders(value) {\n  if (isModuleWithProviders$1(value)) {\n    return value.ngModule;\n  }\n\n  return value;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nlet _nextReferenceId = 0;\n\nclass MetadataOverrider {\n  constructor() {\n    this._references = new Map();\n  }\n  /**\n   * Creates a new instance for the given metadata class\n   * based on an old instance and overrides.\n   */\n\n\n  overrideMetadata(metadataClass, oldMetadata, override) {\n    const props = {};\n\n    if (oldMetadata) {\n      _valueProps(oldMetadata).forEach(prop => props[prop] = oldMetadata[prop]);\n    }\n\n    if (override.set) {\n      if (override.remove || override.add) {\n        throw new Error(`Cannot set and add/remove ${ɵstringify(metadataClass)} at the same time!`);\n      }\n\n      setMetadata(props, override.set);\n    }\n\n    if (override.remove) {\n      removeMetadata(props, override.remove, this._references);\n    }\n\n    if (override.add) {\n      addMetadata(props, override.add);\n    }\n\n    return new metadataClass(props);\n  }\n\n}\n\nfunction removeMetadata(metadata, remove, references) {\n  const removeObjects = new Set();\n\n  for (const prop in remove) {\n    const removeValue = remove[prop];\n\n    if (Array.isArray(removeValue)) {\n      removeValue.forEach(value => {\n        removeObjects.add(_propHashKey(prop, value, references));\n      });\n    } else {\n      removeObjects.add(_propHashKey(prop, removeValue, references));\n    }\n  }\n\n  for (const prop in metadata) {\n    const propValue = metadata[prop];\n\n    if (Array.isArray(propValue)) {\n      metadata[prop] = propValue.filter(value => !removeObjects.has(_propHashKey(prop, value, references)));\n    } else {\n      if (removeObjects.has(_propHashKey(prop, propValue, references))) {\n        metadata[prop] = undefined;\n      }\n    }\n  }\n}\n\nfunction addMetadata(metadata, add) {\n  for (const prop in add) {\n    const addValue = add[prop];\n    const propValue = metadata[prop];\n\n    if (propValue != null && Array.isArray(propValue)) {\n      metadata[prop] = propValue.concat(addValue);\n    } else {\n      metadata[prop] = addValue;\n    }\n  }\n}\n\nfunction setMetadata(metadata, set) {\n  for (const prop in set) {\n    metadata[prop] = set[prop];\n  }\n}\n\nfunction _propHashKey(propName, propValue, references) {\n  let nextObjectId = 0;\n  const objectIds = new Map();\n\n  const replacer = (key, value) => {\n    if (value !== null && typeof value === 'object') {\n      if (objectIds.has(value)) {\n        return objectIds.get(value);\n      } // Record an id for this object such that any later references use the object's id instead\n      // of the object itself, in order to break cyclic pointers in objects.\n\n\n      objectIds.set(value, `ɵobj#${nextObjectId++}`); // The first time an object is seen the object itself is serialized.\n\n      return value;\n    } else if (typeof value === 'function') {\n      value = _serializeReference(value, references);\n    }\n\n    return value;\n  };\n\n  return `${propName}:${JSON.stringify(propValue, replacer)}`;\n}\n\nfunction _serializeReference(ref, references) {\n  let id = references.get(ref);\n\n  if (!id) {\n    id = `${ɵstringify(ref)}${_nextReferenceId++}`;\n    references.set(ref, id);\n  }\n\n  return id;\n}\n\nfunction _valueProps(obj) {\n  const props = []; // regular public props\n\n  Object.keys(obj).forEach(prop => {\n    if (!prop.startsWith('_')) {\n      props.push(prop);\n    }\n  }); // getters\n\n  let proto = obj;\n\n  while (proto = Object.getPrototypeOf(proto)) {\n    Object.keys(proto).forEach(protoProp => {\n      const desc = Object.getOwnPropertyDescriptor(proto, protoProp);\n\n      if (!protoProp.startsWith('_') && desc && 'get' in desc) {\n        props.push(protoProp);\n      }\n    });\n  }\n\n  return props;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nconst reflection = new ɵReflectionCapabilities();\n/**\n * Allows to override ivy metadata for tests (via the `TestBed`).\n */\n\nclass OverrideResolver {\n  constructor() {\n    this.overrides = new Map();\n    this.resolved = new Map();\n  }\n\n  addOverride(type, override) {\n    const overrides = this.overrides.get(type) || [];\n    overrides.push(override);\n    this.overrides.set(type, overrides);\n    this.resolved.delete(type);\n  }\n\n  setOverrides(overrides) {\n    this.overrides.clear();\n    overrides.forEach(([type, override]) => {\n      this.addOverride(type, override);\n    });\n  }\n\n  getAnnotation(type) {\n    const annotations = reflection.annotations(type); // Try to find the nearest known Type annotation and make sure that this annotation is an\n    // instance of the type we are looking for, so we can use it for resolution. Note: there might\n    // be multiple known annotations found due to the fact that Components can extend Directives (so\n    // both Directive and Component annotations would be present), so we always check if the known\n    // annotation has the right type.\n\n    for (let i = annotations.length - 1; i >= 0; i--) {\n      const annotation = annotations[i];\n      const isKnownType = annotation instanceof Directive || annotation instanceof Component || annotation instanceof Pipe || annotation instanceof NgModule;\n\n      if (isKnownType) {\n        return annotation instanceof this.type ? annotation : null;\n      }\n    }\n\n    return null;\n  }\n\n  resolve(type) {\n    let resolved = this.resolved.get(type) || null;\n\n    if (!resolved) {\n      resolved = this.getAnnotation(type);\n\n      if (resolved) {\n        const overrides = this.overrides.get(type);\n\n        if (overrides) {\n          const overrider = new MetadataOverrider();\n          overrides.forEach(override => {\n            resolved = overrider.overrideMetadata(this.type, resolved, override);\n          });\n        }\n      }\n\n      this.resolved.set(type, resolved);\n    }\n\n    return resolved;\n  }\n\n}\n\nclass DirectiveResolver extends OverrideResolver {\n  get type() {\n    return Directive;\n  }\n\n}\n\nclass ComponentResolver extends OverrideResolver {\n  get type() {\n    return Component;\n  }\n\n}\n\nclass PipeResolver extends OverrideResolver {\n  get type() {\n    return Pipe;\n  }\n\n}\n\nclass NgModuleResolver extends OverrideResolver {\n  get type() {\n    return NgModule;\n  }\n\n}\n\nvar TestingModuleOverride;\n\n(function (TestingModuleOverride) {\n  TestingModuleOverride[TestingModuleOverride[\"DECLARATION\"] = 0] = \"DECLARATION\";\n  TestingModuleOverride[TestingModuleOverride[\"OVERRIDE_TEMPLATE\"] = 1] = \"OVERRIDE_TEMPLATE\";\n})(TestingModuleOverride || (TestingModuleOverride = {}));\n\nfunction isTestingModuleOverride(value) {\n  return value === TestingModuleOverride.DECLARATION || value === TestingModuleOverride.OVERRIDE_TEMPLATE;\n}\n\nfunction assertNoStandaloneComponents(types, resolver, location) {\n  types.forEach(type => {\n    const component = resolver.resolve(type);\n\n    if (component && component.standalone) {\n      throw new Error(generateStandaloneInDeclarationsError(type, location));\n    }\n  });\n}\n\nclass R3TestBedCompiler {\n  constructor(platform, additionalModuleTypes) {\n    this.platform = platform;\n    this.additionalModuleTypes = additionalModuleTypes;\n    this.originalComponentResolutionQueue = null; // Testing module configuration\n\n    this.declarations = [];\n    this.imports = [];\n    this.providers = [];\n    this.schemas = []; // Queues of components/directives/pipes that should be recompiled.\n\n    this.pendingComponents = new Set();\n    this.pendingDirectives = new Set();\n    this.pendingPipes = new Set(); // Keep track of all components and directives, so we can patch Providers onto defs later.\n\n    this.seenComponents = new Set();\n    this.seenDirectives = new Set(); // Keep track of overridden modules, so that we can collect all affected ones in the module tree.\n\n    this.overriddenModules = new Set(); // Store resolved styles for Components that have template overrides present and `styleUrls`\n    // defined at the same time.\n\n    this.existingComponentStyles = new Map();\n    this.resolvers = initResolvers();\n    this.componentToModuleScope = new Map(); // Map that keeps initial version of component/directive/pipe defs in case\n    // we compile a Type again, thus overriding respective static fields. This is\n    // required to make sure we restore defs to their initial states between test runs.\n    // Note: one class may have multiple defs (for example: ɵmod and ɵinj in case of an\n    // NgModule), store all of them in a map.\n\n    this.initialNgDefs = new Map(); // Array that keeps cleanup operations for initial versions of component/directive/pipe/module\n    // defs in case TestBed makes changes to the originals.\n\n    this.defCleanupOps = [];\n    this._injector = null;\n    this.compilerProviders = null;\n    this.providerOverrides = [];\n    this.rootProviderOverrides = []; // Overrides for injectables with `{providedIn: SomeModule}` need to be tracked and added to that\n    // module's provider list.\n\n    this.providerOverridesByModule = new Map();\n    this.providerOverridesByToken = new Map();\n    this.scopesWithOverriddenProviders = new Set();\n    this.testModuleRef = null;\n\n    class DynamicTestModule {}\n\n    this.testModuleType = DynamicTestModule;\n  }\n\n  setCompilerProviders(providers) {\n    this.compilerProviders = providers;\n    this._injector = null;\n  }\n\n  configureTestingModule(moduleDef) {\n    // Enqueue any compilation tasks for the directly declared component.\n    if (moduleDef.declarations !== undefined) {\n      // Verify that there are no standalone components\n      assertNoStandaloneComponents(moduleDef.declarations, this.resolvers.component, '\"TestBed.configureTestingModule\" call');\n      this.queueTypeArray(moduleDef.declarations, TestingModuleOverride.DECLARATION);\n      this.declarations.push(...moduleDef.declarations);\n    } // Enqueue any compilation tasks for imported modules.\n\n\n    if (moduleDef.imports !== undefined) {\n      this.queueTypesFromModulesArray(moduleDef.imports);\n      this.imports.push(...moduleDef.imports);\n    }\n\n    if (moduleDef.providers !== undefined) {\n      this.providers.push(...moduleDef.providers);\n    }\n\n    if (moduleDef.schemas !== undefined) {\n      this.schemas.push(...moduleDef.schemas);\n    }\n  }\n\n  overrideModule(ngModule, override) {\n    this.overriddenModules.add(ngModule); // Compile the module right away.\n\n    this.resolvers.module.addOverride(ngModule, override);\n    const metadata = this.resolvers.module.resolve(ngModule);\n\n    if (metadata === null) {\n      throw invalidTypeError(ngModule.name, 'NgModule');\n    }\n\n    this.recompileNgModule(ngModule, metadata); // At this point, the module has a valid module def (ɵmod), but the override may have introduced\n    // new declarations or imported modules. Ingest any possible new types and add them to the\n    // current queue.\n\n    this.queueTypesFromModulesArray([ngModule]);\n  }\n\n  overrideComponent(component, override) {\n    this.verifyNoStandaloneFlagOverrides(component, override);\n    this.resolvers.component.addOverride(component, override);\n    this.pendingComponents.add(component);\n  }\n\n  overrideDirective(directive, override) {\n    this.verifyNoStandaloneFlagOverrides(directive, override);\n    this.resolvers.directive.addOverride(directive, override);\n    this.pendingDirectives.add(directive);\n  }\n\n  overridePipe(pipe, override) {\n    this.verifyNoStandaloneFlagOverrides(pipe, override);\n    this.resolvers.pipe.addOverride(pipe, override);\n    this.pendingPipes.add(pipe);\n  }\n\n  verifyNoStandaloneFlagOverrides(type, override) {\n    var _a, _b, _c;\n\n    if (((_a = override.add) === null || _a === void 0 ? void 0 : _a.hasOwnProperty('standalone')) || ((_b = override.set) === null || _b === void 0 ? void 0 : _b.hasOwnProperty('standalone')) || ((_c = override.remove) === null || _c === void 0 ? void 0 : _c.hasOwnProperty('standalone'))) {\n      throw new Error(`An override for the ${type.name} class has the \\`standalone\\` flag. ` + `Changing the \\`standalone\\` flag via TestBed overrides is not supported.`);\n    }\n  }\n\n  overrideProvider(token, provider) {\n    let providerDef;\n\n    if (provider.useFactory !== undefined) {\n      providerDef = {\n        provide: token,\n        useFactory: provider.useFactory,\n        deps: provider.deps || [],\n        multi: provider.multi\n      };\n    } else if (provider.useValue !== undefined) {\n      providerDef = {\n        provide: token,\n        useValue: provider.useValue,\n        multi: provider.multi\n      };\n    } else {\n      providerDef = {\n        provide: token\n      };\n    }\n\n    const injectableDef = typeof token !== 'string' ? ɵgetInjectableDef(token) : null;\n    const providedIn = injectableDef === null ? null : resolveForwardRef$1(injectableDef.providedIn);\n    const overridesBucket = providedIn === 'root' ? this.rootProviderOverrides : this.providerOverrides;\n    overridesBucket.push(providerDef); // Keep overrides grouped by token as well for fast lookups using token\n\n    this.providerOverridesByToken.set(token, providerDef);\n\n    if (injectableDef !== null && providedIn !== null && typeof providedIn !== 'string') {\n      const existingOverrides = this.providerOverridesByModule.get(providedIn);\n\n      if (existingOverrides !== undefined) {\n        existingOverrides.push(providerDef);\n      } else {\n        this.providerOverridesByModule.set(providedIn, [providerDef]);\n      }\n    }\n  }\n\n  overrideTemplateUsingTestingModule(type, template) {\n    const def = type[ɵNG_COMP_DEF];\n\n    const hasStyleUrls = () => {\n      const metadata = this.resolvers.component.resolve(type);\n      return !!metadata.styleUrls && metadata.styleUrls.length > 0;\n    };\n\n    const overrideStyleUrls = !!def && !isComponentDefPendingResolution(type) && hasStyleUrls(); // In Ivy, compiling a component does not require knowing the module providing the\n    // component's scope, so overrideTemplateUsingTestingModule can be implemented purely via\n    // overrideComponent. Important: overriding template requires full Component re-compilation,\n    // which may fail in case styleUrls are also present (thus Component is considered as required\n    // resolution). In order to avoid this, we preemptively set styleUrls to an empty array,\n    // preserve current styles available on Component def and restore styles back once compilation\n    // is complete.\n\n    const override = overrideStyleUrls ? {\n      template,\n      styles: [],\n      styleUrls: []\n    } : {\n      template\n    };\n    this.overrideComponent(type, {\n      set: override\n    });\n\n    if (overrideStyleUrls && def.styles && def.styles.length > 0) {\n      this.existingComponentStyles.set(type, def.styles);\n    } // Set the component's scope to be the testing module.\n\n\n    this.componentToModuleScope.set(type, TestingModuleOverride.OVERRIDE_TEMPLATE);\n  }\n\n  compileComponents() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.clearComponentResolutionQueue(); // Run compilers for all queued types.\n\n      let needsAsyncResources = this.compileTypesSync(); // compileComponents() should not be async unless it needs to be.\n\n      if (needsAsyncResources) {\n        let resourceLoader;\n\n        let resolver = url => {\n          if (!resourceLoader) {\n            resourceLoader = this.injector.get(ResourceLoader);\n          }\n\n          return Promise.resolve(resourceLoader.get(url));\n        };\n\n        yield resolveComponentResources(resolver);\n      }\n    });\n  }\n\n  finalize() {\n    // One last compile\n    this.compileTypesSync(); // Create the testing module itself.\n\n    this.compileTestModule();\n    this.applyTransitiveScopes();\n    this.applyProviderOverrides(); // Patch previously stored `styles` Component values (taken from ɵcmp), in case these\n    // Components have `styleUrls` fields defined and template override was requested.\n\n    this.patchComponentsWithExistingStyles(); // Clear the componentToModuleScope map, so that future compilations don't reset the scope of\n    // every component.\n\n    this.componentToModuleScope.clear();\n    const parentInjector = this.platform.injector;\n    this.testModuleRef = new ɵRender3NgModuleRef(this.testModuleType, parentInjector); // ApplicationInitStatus.runInitializers() is marked @internal to core.\n    // Cast it to any before accessing it.\n\n    this.testModuleRef.injector.get(ApplicationInitStatus).runInitializers(); // Set locale ID after running app initializers, since locale information might be updated while\n    // running initializers. This is also consistent with the execution order while bootstrapping an\n    // app (see `packages/core/src/application_ref.ts` file).\n\n    const localeId = this.testModuleRef.injector.get(LOCALE_ID$1, ɵDEFAULT_LOCALE_ID);\n    ɵsetLocaleId(localeId);\n    return this.testModuleRef;\n  }\n  /**\n   * @internal\n   */\n\n\n  _compileNgModuleSync(moduleType) {\n    this.queueTypesFromModulesArray([moduleType]);\n    this.compileTypesSync();\n    this.applyProviderOverrides();\n    this.applyProviderOverridesInScope(moduleType);\n    this.applyTransitiveScopes();\n  }\n  /**\n   * @internal\n   */\n\n\n  _compileNgModuleAsync(moduleType) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.queueTypesFromModulesArray([moduleType]);\n      yield this.compileComponents();\n      this.applyProviderOverrides();\n      this.applyProviderOverridesInScope(moduleType);\n      this.applyTransitiveScopes();\n    });\n  }\n  /**\n   * @internal\n   */\n\n\n  _getModuleResolver() {\n    return this.resolvers.module;\n  }\n  /**\n   * @internal\n   */\n\n\n  _getComponentFactories(moduleType) {\n    return maybeUnwrapFn(moduleType.ɵmod.declarations).reduce((factories, declaration) => {\n      const componentDef = declaration.ɵcmp;\n      componentDef && factories.push(new ɵRender3ComponentFactory(componentDef, this.testModuleRef));\n      return factories;\n    }, []);\n  }\n\n  compileTypesSync() {\n    // Compile all queued components, directives, pipes.\n    let needsAsyncResources = false;\n    this.pendingComponents.forEach(declaration => {\n      needsAsyncResources = needsAsyncResources || isComponentDefPendingResolution(declaration);\n      const metadata = this.resolvers.component.resolve(declaration);\n\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Component');\n      }\n\n      this.maybeStoreNgDef(ɵNG_COMP_DEF, declaration);\n      ɵcompileComponent(declaration, metadata);\n    });\n    this.pendingComponents.clear();\n    this.pendingDirectives.forEach(declaration => {\n      const metadata = this.resolvers.directive.resolve(declaration);\n\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Directive');\n      }\n\n      this.maybeStoreNgDef(ɵNG_DIR_DEF, declaration);\n      ɵcompileDirective(declaration, metadata);\n    });\n    this.pendingDirectives.clear();\n    this.pendingPipes.forEach(declaration => {\n      const metadata = this.resolvers.pipe.resolve(declaration);\n\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Pipe');\n      }\n\n      this.maybeStoreNgDef(ɵNG_PIPE_DEF, declaration);\n      ɵcompilePipe(declaration, metadata);\n    });\n    this.pendingPipes.clear();\n    return needsAsyncResources;\n  }\n\n  applyTransitiveScopes() {\n    if (this.overriddenModules.size > 0) {\n      // Module overrides (via `TestBed.overrideModule`) might affect scopes that were previously\n      // calculated and stored in `transitiveCompileScopes`. If module overrides are present,\n      // collect all affected modules and reset scopes to force their re-calculation.\n      const testingModuleDef = this.testModuleType[ɵNG_MOD_DEF];\n      const affectedModules = this.collectModulesAffectedByOverrides(testingModuleDef.imports);\n\n      if (affectedModules.size > 0) {\n        affectedModules.forEach(moduleType => {\n          this.storeFieldOfDefOnType(moduleType, ɵNG_MOD_DEF, 'transitiveCompileScopes');\n          moduleType[ɵNG_MOD_DEF].transitiveCompileScopes = null;\n        });\n      }\n    }\n\n    const moduleToScope = new Map();\n\n    const getScopeOfModule = moduleType => {\n      if (!moduleToScope.has(moduleType)) {\n        const isTestingModule = isTestingModuleOverride(moduleType);\n        const realType = isTestingModule ? this.testModuleType : moduleType;\n        moduleToScope.set(moduleType, ɵtransitiveScopesFor(realType));\n      }\n\n      return moduleToScope.get(moduleType);\n    };\n\n    this.componentToModuleScope.forEach((moduleType, componentType) => {\n      const moduleScope = getScopeOfModule(moduleType);\n      this.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'directiveDefs');\n      this.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'pipeDefs'); // `tView` that is stored on component def contains information about directives and pipes\n      // that are in the scope of this component. Patching component scope will cause `tView` to be\n      // changed. Store original `tView` before patching scope, so the `tView` (including scope\n      // information) is restored back to its previous/original state before running next test.\n\n      this.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'tView');\n      ɵpatchComponentDefWithScope(componentType.ɵcmp, moduleScope);\n    });\n    this.componentToModuleScope.clear();\n  }\n\n  applyProviderOverrides() {\n    const maybeApplyOverrides = field => type => {\n      const resolver = field === ɵNG_COMP_DEF ? this.resolvers.component : this.resolvers.directive;\n      const metadata = resolver.resolve(type);\n\n      if (this.hasProviderOverrides(metadata.providers)) {\n        this.patchDefWithProviderOverrides(type, field);\n      }\n    };\n\n    this.seenComponents.forEach(maybeApplyOverrides(ɵNG_COMP_DEF));\n    this.seenDirectives.forEach(maybeApplyOverrides(ɵNG_DIR_DEF));\n    this.seenComponents.clear();\n    this.seenDirectives.clear();\n  }\n  /**\n   * Applies provider overrides to a given type (either an NgModule or a standalone component)\n   * and all imported NgModules and standalone components recursively.\n   */\n\n\n  applyProviderOverridesInScope(type) {\n    var _a;\n\n    const hasScope = isStandaloneComponent(type) || isNgModule(type); // The function can be re-entered recursively while inspecting dependencies\n    // of an NgModule or a standalone component. Exit early if we come across a\n    // type that can not have a scope (directive or pipe) or the type is already\n    // processed earlier.\n\n    if (!hasScope || this.scopesWithOverriddenProviders.has(type)) {\n      return;\n    }\n\n    this.scopesWithOverriddenProviders.add(type); // NOTE: the line below triggers JIT compilation of the module injector,\n    // which also invokes verification of the NgModule semantics, which produces\n    // detailed error messages. The fact that the code relies on this line being\n    // present here is suspicious and should be refactored in a way that the line\n    // below can be moved (for ex. after an early exit check below).\n\n    const injectorDef = type[ɵNG_INJ_DEF]; // No provider overrides, exit early.\n\n    if (this.providerOverridesByToken.size === 0) return;\n\n    if (isStandaloneComponent(type)) {\n      // Visit all component dependencies and override providers there.\n      const def = getComponentDef(type);\n      const dependencies = maybeUnwrapFn((_a = def.dependencies) !== null && _a !== void 0 ? _a : []);\n\n      for (const dependency of dependencies) {\n        this.applyProviderOverridesInScope(dependency);\n      }\n    } else {\n      const providers = [...injectorDef.providers, ...(this.providerOverridesByModule.get(type) || [])];\n\n      if (this.hasProviderOverrides(providers)) {\n        this.maybeStoreNgDef(ɵNG_INJ_DEF, type);\n        this.storeFieldOfDefOnType(type, ɵNG_INJ_DEF, 'providers');\n        injectorDef.providers = this.getOverriddenProviders(providers);\n      } // Apply provider overrides to imported modules recursively\n\n\n      const moduleDef = type[ɵNG_MOD_DEF];\n      const imports = maybeUnwrapFn(moduleDef.imports);\n\n      for (const importedModule of imports) {\n        this.applyProviderOverridesInScope(importedModule);\n      } // Also override the providers on any ModuleWithProviders imports since those don't appear in\n      // the moduleDef.\n\n\n      for (const importedModule of flatten(injectorDef.imports)) {\n        if (isModuleWithProviders(importedModule)) {\n          this.defCleanupOps.push({\n            object: importedModule,\n            fieldName: 'providers',\n            originalValue: importedModule.providers\n          });\n          importedModule.providers = this.getOverriddenProviders(importedModule.providers);\n        }\n      }\n    }\n  }\n\n  patchComponentsWithExistingStyles() {\n    this.existingComponentStyles.forEach((styles, type) => type[ɵNG_COMP_DEF].styles = styles);\n    this.existingComponentStyles.clear();\n  }\n\n  queueTypeArray(arr, moduleType) {\n    for (const value of arr) {\n      if (Array.isArray(value)) {\n        this.queueTypeArray(value, moduleType);\n      } else {\n        this.queueType(value, moduleType);\n      }\n    }\n  }\n\n  recompileNgModule(ngModule, metadata) {\n    // Cache the initial ngModuleDef as it will be overwritten.\n    this.maybeStoreNgDef(ɵNG_MOD_DEF, ngModule);\n    this.maybeStoreNgDef(ɵNG_INJ_DEF, ngModule);\n    ɵcompileNgModuleDefs(ngModule, metadata);\n  }\n\n  queueType(type, moduleType) {\n    const component = this.resolvers.component.resolve(type);\n\n    if (component) {\n      // Check whether a give Type has respective NG def (ɵcmp) and compile if def is\n      // missing. That might happen in case a class without any Angular decorators extends another\n      // class where Component/Directive/Pipe decorator is defined.\n      if (isComponentDefPendingResolution(type) || !type.hasOwnProperty(ɵNG_COMP_DEF)) {\n        this.pendingComponents.add(type);\n      }\n\n      this.seenComponents.add(type); // Keep track of the module which declares this component, so later the component's scope\n      // can be set correctly. If the component has already been recorded here, then one of several\n      // cases is true:\n      // * the module containing the component was imported multiple times (common).\n      // * the component is declared in multiple modules (which is an error).\n      // * the component was in 'declarations' of the testing module, and also in an imported module\n      //   in which case the module scope will be TestingModuleOverride.DECLARATION.\n      // * overrideTemplateUsingTestingModule was called for the component in which case the module\n      //   scope will be TestingModuleOverride.OVERRIDE_TEMPLATE.\n      //\n      // If the component was previously in the testing module's 'declarations' (meaning the\n      // current value is TestingModuleOverride.DECLARATION), then `moduleType` is the component's\n      // real module, which was imported. This pattern is understood to mean that the component\n      // should use its original scope, but that the testing module should also contain the\n      // component in its scope.\n      //\n      // Note: standalone components have no associated NgModule, so the `moduleType` can be `null`.\n\n      if (moduleType !== null && (!this.componentToModuleScope.has(type) || this.componentToModuleScope.get(type) === TestingModuleOverride.DECLARATION)) {\n        this.componentToModuleScope.set(type, moduleType);\n      }\n\n      return;\n    }\n\n    const directive = this.resolvers.directive.resolve(type);\n\n    if (directive) {\n      if (!type.hasOwnProperty(ɵNG_DIR_DEF)) {\n        this.pendingDirectives.add(type);\n      }\n\n      this.seenDirectives.add(type);\n      return;\n    }\n\n    const pipe = this.resolvers.pipe.resolve(type);\n\n    if (pipe && !type.hasOwnProperty(ɵNG_PIPE_DEF)) {\n      this.pendingPipes.add(type);\n      return;\n    }\n  }\n\n  queueTypesFromModulesArray(arr) {\n    // Because we may encounter the same NgModule while processing the imports and exports of an\n    // NgModule tree, we cache them in this set so we can skip ones that have already been seen\n    // encountered. In some test setups, this caching resulted in 10X runtime improvement.\n    const processedNgModuleDefs = new Set();\n\n    const queueTypesFromModulesArrayRecur = arr => {\n      var _a;\n\n      for (const value of arr) {\n        if (Array.isArray(value)) {\n          queueTypesFromModulesArrayRecur(value);\n        } else if (hasNgModuleDef(value)) {\n          const def = value.ɵmod;\n\n          if (processedNgModuleDefs.has(def)) {\n            continue;\n          }\n\n          processedNgModuleDefs.add(def); // Look through declarations, imports, and exports, and queue\n          // everything found there.\n\n          this.queueTypeArray(maybeUnwrapFn(def.declarations), value);\n          queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.imports));\n          queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.exports));\n        } else if (isModuleWithProviders(value)) {\n          queueTypesFromModulesArrayRecur([value.ngModule]);\n        } else if (isStandaloneComponent(value)) {\n          this.queueType(value, null);\n          const def = getComponentDef(value);\n          const dependencies = maybeUnwrapFn((_a = def.dependencies) !== null && _a !== void 0 ? _a : []);\n          dependencies.forEach(dependency => {\n            // Note: in AOT, the `dependencies` might also contain regular\n            // (NgModule-based) Component, Directive and Pipes, so we handle\n            // them separately and proceed with recursive process for standalone\n            // Components and NgModules only.\n            if (isStandaloneComponent(dependency) || hasNgModuleDef(dependency)) {\n              queueTypesFromModulesArrayRecur([dependency]);\n            } else {\n              this.queueType(dependency, null);\n            }\n          });\n        }\n      }\n    };\n\n    queueTypesFromModulesArrayRecur(arr);\n  } // When module overrides (via `TestBed.overrideModule`) are present, it might affect all modules\n  // that import (even transitively) an overridden one. For all affected modules we need to\n  // recalculate their scopes for a given test run and restore original scopes at the end. The goal\n  // of this function is to collect all affected modules in a set for further processing. Example:\n  // if we have the following module hierarchy: A -> B -> C (where `->` means `imports`) and module\n  // `C` is overridden, we consider `A` and `B` as affected, since their scopes might become\n  // invalidated with the override.\n\n\n  collectModulesAffectedByOverrides(arr) {\n    const seenModules = new Set();\n    const affectedModules = new Set();\n\n    const calcAffectedModulesRecur = (arr, path) => {\n      for (const value of arr) {\n        if (Array.isArray(value)) {\n          // If the value is an array, just flatten it (by invoking this function recursively),\n          // keeping \"path\" the same.\n          calcAffectedModulesRecur(value, path);\n        } else if (hasNgModuleDef(value)) {\n          if (seenModules.has(value)) {\n            // If we've seen this module before and it's included into \"affected modules\" list, mark\n            // the whole path that leads to that module as affected, but do not descend into its\n            // imports, since we already examined them before.\n            if (affectedModules.has(value)) {\n              path.forEach(item => affectedModules.add(item));\n            }\n\n            continue;\n          }\n\n          seenModules.add(value);\n\n          if (this.overriddenModules.has(value)) {\n            path.forEach(item => affectedModules.add(item));\n          } // Examine module imports recursively to look for overridden modules.\n\n\n          const moduleDef = value[ɵNG_MOD_DEF];\n          calcAffectedModulesRecur(maybeUnwrapFn(moduleDef.imports), path.concat(value));\n        }\n      }\n    };\n\n    calcAffectedModulesRecur(arr, []);\n    return affectedModules;\n  }\n  /**\n   * Preserve an original def (such as ɵmod, ɵinj, etc) before applying an override.\n   * Note: one class may have multiple defs (for example: ɵmod and ɵinj in case of\n   * an NgModule). If there is a def in a set already, don't override it, since\n   * an original one should be restored at the end of a test.\n   */\n\n\n  maybeStoreNgDef(prop, type) {\n    if (!this.initialNgDefs.has(type)) {\n      this.initialNgDefs.set(type, new Map());\n    }\n\n    const currentDefs = this.initialNgDefs.get(type);\n\n    if (!currentDefs.has(prop)) {\n      const currentDef = Object.getOwnPropertyDescriptor(type, prop);\n      currentDefs.set(prop, currentDef);\n    }\n  }\n\n  storeFieldOfDefOnType(type, defField, fieldName) {\n    const def = type[defField];\n    const originalValue = def[fieldName];\n    this.defCleanupOps.push({\n      object: def,\n      fieldName,\n      originalValue\n    });\n  }\n  /**\n   * Clears current components resolution queue, but stores the state of the queue, so we can\n   * restore it later. Clearing the queue is required before we try to compile components (via\n   * `TestBed.compileComponents`), so that component defs are in sync with the resolution queue.\n   */\n\n\n  clearComponentResolutionQueue() {\n    if (this.originalComponentResolutionQueue === null) {\n      this.originalComponentResolutionQueue = new Map();\n    }\n\n    clearResolutionOfComponentResourcesQueue().forEach((value, key) => this.originalComponentResolutionQueue.set(key, value));\n  }\n  /*\n   * Restores component resolution queue to the previously saved state. This operation is performed\n   * as a part of restoring the state after completion of the current set of tests (that might\n   * potentially mutate the state).\n   */\n\n\n  restoreComponentResolutionQueue() {\n    if (this.originalComponentResolutionQueue !== null) {\n      restoreComponentResolutionQueue(this.originalComponentResolutionQueue);\n      this.originalComponentResolutionQueue = null;\n    }\n  }\n\n  restoreOriginalState() {\n    // Process cleanup ops in reverse order so the field's original value is restored correctly (in\n    // case there were multiple overrides for the same field).\n    forEachRight(this.defCleanupOps, op => {\n      op.object[op.fieldName] = op.originalValue;\n    }); // Restore initial component/directive/pipe defs\n\n    this.initialNgDefs.forEach((defs, type) => {\n      defs.forEach((descriptor, prop) => {\n        if (!descriptor) {\n          // Delete operations are generally undesirable since they have performance\n          // implications on objects they were applied to. In this particular case, situations\n          // where this code is invoked should be quite rare to cause any noticeable impact,\n          // since it's applied only to some test cases (for example when class with no\n          // annotations extends some @Component) when we need to clear 'ɵcmp' field on a given\n          // class to restore its original state (before applying overrides and running tests).\n          delete type[prop];\n        } else {\n          Object.defineProperty(type, prop, descriptor);\n        }\n      });\n    });\n    this.initialNgDefs.clear();\n    this.scopesWithOverriddenProviders.clear();\n    this.restoreComponentResolutionQueue(); // Restore the locale ID to the default value, this shouldn't be necessary but we never know\n\n    ɵsetLocaleId(ɵDEFAULT_LOCALE_ID);\n  }\n\n  compileTestModule() {\n    class RootScopeModule {}\n\n    ɵcompileNgModuleDefs(RootScopeModule, {\n      providers: [...this.rootProviderOverrides]\n    });\n    const ngZone = new NgZone({\n      enableLongStackTrace: true\n    });\n    const providers = [{\n      provide: NgZone,\n      useValue: ngZone\n    }, {\n      provide: Compiler,\n      useFactory: () => new R3TestCompiler(this)\n    }, ...this.providers, ...this.providerOverrides];\n    const imports = [RootScopeModule, this.additionalModuleTypes, this.imports || []]; // clang-format off\n\n    ɵcompileNgModuleDefs(this.testModuleType, {\n      declarations: this.declarations,\n      imports,\n      schemas: this.schemas,\n      providers\n    },\n    /* allowDuplicateDeclarationsInRoot */\n    true); // clang-format on\n\n    this.applyProviderOverridesInScope(this.testModuleType);\n  }\n\n  get injector() {\n    if (this._injector !== null) {\n      return this._injector;\n    }\n\n    const providers = [];\n    const compilerOptions = this.platform.injector.get(COMPILER_OPTIONS);\n    compilerOptions.forEach(opts => {\n      if (opts.providers) {\n        providers.push(opts.providers);\n      }\n    });\n\n    if (this.compilerProviders !== null) {\n      providers.push(...this.compilerProviders);\n    } // TODO(ocombe): make this work with an Injector directly instead of creating a module for it\n\n\n    class CompilerModule {}\n\n    ɵcompileNgModuleDefs(CompilerModule, {\n      providers\n    });\n    const CompilerModuleFactory = new ɵNgModuleFactory(CompilerModule);\n    this._injector = CompilerModuleFactory.create(this.platform.injector).injector;\n    return this._injector;\n  } // get overrides for a specific provider (if any)\n\n\n  getSingleProviderOverrides(provider) {\n    const token = getProviderToken(provider);\n    return this.providerOverridesByToken.get(token) || null;\n  }\n\n  getProviderOverrides(providers) {\n    if (!providers || !providers.length || this.providerOverridesByToken.size === 0) return []; // There are two flattening operations here. The inner flatten() operates on the metadata's\n    // providers and applies a mapping function which retrieves overrides for each incoming\n    // provider. The outer flatten() then flattens the produced overrides array. If this is not\n    // done, the array can contain other empty arrays (e.g. `[[], []]`) which leak into the\n    // providers array and contaminate any error messages that might be generated.\n\n    return flatten(flatten(providers, provider => this.getSingleProviderOverrides(provider) || []));\n  }\n\n  getOverriddenProviders(providers) {\n    if (!providers || !providers.length || this.providerOverridesByToken.size === 0) return [];\n    const flattenedProviders = flatten(providers);\n    const overrides = this.getProviderOverrides(flattenedProviders);\n    const overriddenProviders = [...flattenedProviders, ...overrides];\n    const final = [];\n    const seenOverriddenProviders = new Set(); // We iterate through the list of providers in reverse order to make sure provider overrides\n    // take precedence over the values defined in provider list. We also filter out all providers\n    // that have overrides, keeping overridden values only. This is needed, since presence of a\n    // provider with `ngOnDestroy` hook will cause this hook to be registered and invoked later.\n\n    forEachRight(overriddenProviders, provider => {\n      const token = getProviderToken(provider);\n\n      if (this.providerOverridesByToken.has(token)) {\n        if (!seenOverriddenProviders.has(token)) {\n          seenOverriddenProviders.add(token); // Treat all overridden providers as `{multi: false}` (even if it's a multi-provider) to\n          // make sure that provided override takes highest precedence and is not combined with\n          // other instances of the same multi provider.\n\n          final.unshift(Object.assign(Object.assign({}, provider), {\n            multi: false\n          }));\n        }\n      } else {\n        final.unshift(provider);\n      }\n    });\n    return final;\n  }\n\n  hasProviderOverrides(providers) {\n    return this.getProviderOverrides(providers).length > 0;\n  }\n\n  patchDefWithProviderOverrides(declaration, field) {\n    const def = declaration[field];\n\n    if (def && def.providersResolver) {\n      this.maybeStoreNgDef(field, declaration);\n      const resolver = def.providersResolver;\n\n      const processProvidersFn = providers => this.getOverriddenProviders(providers);\n\n      this.storeFieldOfDefOnType(declaration, field, 'providersResolver');\n\n      def.providersResolver = ngDef => resolver(ngDef, processProvidersFn);\n    }\n  }\n\n}\n\nfunction initResolvers() {\n  return {\n    module: new NgModuleResolver(),\n    component: new ComponentResolver(),\n    directive: new DirectiveResolver(),\n    pipe: new PipeResolver()\n  };\n}\n\nfunction isStandaloneComponent(value) {\n  const def = getComponentDef(value);\n  return !!(def === null || def === void 0 ? void 0 : def.standalone);\n}\n\nfunction getComponentDef(value) {\n  var _a;\n\n  return (_a = value.ɵcmp) !== null && _a !== void 0 ? _a : null;\n}\n\nfunction hasNgModuleDef(value) {\n  return value.hasOwnProperty('ɵmod');\n}\n\nfunction isNgModule(value) {\n  return hasNgModuleDef(value);\n}\n\nfunction maybeUnwrapFn(maybeFn) {\n  return maybeFn instanceof Function ? maybeFn() : maybeFn;\n}\n\nfunction flatten(values, mapFn) {\n  const out = [];\n  values.forEach(value => {\n    if (Array.isArray(value)) {\n      out.push(...flatten(value, mapFn));\n    } else {\n      out.push(mapFn ? mapFn(value) : value);\n    }\n  });\n  return out;\n}\n\nfunction getProviderField(provider, field) {\n  return provider && typeof provider === 'object' && provider[field];\n}\n\nfunction getProviderToken(provider) {\n  return getProviderField(provider, 'provide') || provider;\n}\n\nfunction isModuleWithProviders(value) {\n  return value.hasOwnProperty('ngModule');\n}\n\nfunction forEachRight(values, fn) {\n  for (let idx = values.length - 1; idx >= 0; idx--) {\n    fn(values[idx], idx);\n  }\n}\n\nfunction invalidTypeError(name, expectedType) {\n  return new Error(`${name} class doesn't have @${expectedType} decorator or is missing metadata.`);\n}\n\nclass R3TestCompiler {\n  constructor(testBed) {\n    this.testBed = testBed;\n  }\n\n  compileModuleSync(moduleType) {\n    this.testBed._compileNgModuleSync(moduleType);\n\n    return new ɵNgModuleFactory(moduleType);\n  }\n\n  compileModuleAsync(moduleType) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.testBed._compileNgModuleAsync(moduleType);\n      return new ɵNgModuleFactory(moduleType);\n    });\n  }\n\n  compileModuleAndAllComponentsSync(moduleType) {\n    const ngModuleFactory = this.compileModuleSync(moduleType);\n\n    const componentFactories = this.testBed._getComponentFactories(moduleType);\n\n    return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n  }\n\n  compileModuleAndAllComponentsAsync(moduleType) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const ngModuleFactory = yield this.compileModuleAsync(moduleType);\n\n      const componentFactories = this.testBed._getComponentFactories(moduleType);\n\n      return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n    });\n  }\n\n  clearCache() {}\n\n  clearCacheFor(type) {}\n\n  getModuleId(moduleType) {\n    const meta = this.testBed._getModuleResolver().resolve(moduleType);\n\n    return meta && meta.id || undefined;\n  }\n\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Whether test modules should be torn down by default. */\n\n\nconst TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT = true;\n/** Whether unknown elements in templates should throw by default. */\n\nconst THROW_ON_UNKNOWN_ELEMENTS_DEFAULT = false;\n/** Whether unknown properties in templates should throw by default. */\n\nconst THROW_ON_UNKNOWN_PROPERTIES_DEFAULT = false;\n/**\n * An abstract class for inserting the root test component element in a platform independent way.\n *\n * @publicApi\n */\n\nclass TestComponentRenderer {\n  insertRootElement(rootElementId) {}\n\n  removeAllRootElements() {}\n\n}\n/**\n * @publicApi\n */\n\n\nconst ComponentFixtureAutoDetect = new InjectionToken$1('ComponentFixtureAutoDetect');\n/**\n * @publicApi\n */\n\nconst ComponentFixtureNoNgZone = new InjectionToken$1('ComponentFixtureNoNgZone');\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nlet _nextRootElementId = 0;\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * TestBed is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n */\n\nclass TestBedRender3 {\n  constructor() {\n    // Properties\n    this.platform = null;\n    this.ngModule = null;\n    this._compiler = null;\n    this._testModuleRef = null;\n    this._activeFixtures = [];\n    this._globalCompilationChecked = false;\n  }\n  /**\n   * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n   * angular module. These are common to every test in the suite.\n   *\n   * This may only be called once, to set up the common providers for the current test\n   * suite on the current platform. If you absolutely need to change the providers,\n   * first use `resetTestEnvironment`.\n   *\n   * Test modules and platforms for individual platforms are available from\n   * '@angular/<platform_name>/testing'.\n   *\n   * @publicApi\n   */\n\n\n  static initTestEnvironment(ngModule, platform, options) {\n    const testBed = _getTestBedRender3();\n\n    testBed.initTestEnvironment(ngModule, platform, options);\n    return testBed;\n  }\n  /**\n   * Reset the providers for the test injector.\n   *\n   * @publicApi\n   */\n\n\n  static resetTestEnvironment() {\n    _getTestBedRender3().resetTestEnvironment();\n  }\n\n  static configureCompiler(config) {\n    _getTestBedRender3().configureCompiler(config);\n\n    return TestBedRender3;\n  }\n  /**\n   * Allows overriding default providers, directives, pipes, modules of the test injector,\n   * which are defined in test_injector.js\n   */\n\n\n  static configureTestingModule(moduleDef) {\n    _getTestBedRender3().configureTestingModule(moduleDef);\n\n    return TestBedRender3;\n  }\n  /**\n   * Compile components with a `templateUrl` for the test's NgModule.\n   * It is necessary to call this function\n   * as fetching urls is asynchronous.\n   */\n\n\n  static compileComponents() {\n    return _getTestBedRender3().compileComponents();\n  }\n\n  static overrideModule(ngModule, override) {\n    _getTestBedRender3().overrideModule(ngModule, override);\n\n    return TestBedRender3;\n  }\n\n  static overrideComponent(component, override) {\n    _getTestBedRender3().overrideComponent(component, override);\n\n    return TestBedRender3;\n  }\n\n  static overrideDirective(directive, override) {\n    _getTestBedRender3().overrideDirective(directive, override);\n\n    return TestBedRender3;\n  }\n\n  static overridePipe(pipe, override) {\n    _getTestBedRender3().overridePipe(pipe, override);\n\n    return TestBedRender3;\n  }\n\n  static overrideTemplate(component, template) {\n    _getTestBedRender3().overrideComponent(component, {\n      set: {\n        template,\n        templateUrl: null\n      }\n    });\n\n    return TestBedRender3;\n  }\n  /**\n   * Overrides the template of the given component, compiling the template\n   * in the context of the TestingModule.\n   *\n   * Note: This works for JIT and AOTed components as well.\n   */\n\n\n  static overrideTemplateUsingTestingModule(component, template) {\n    _getTestBedRender3().overrideTemplateUsingTestingModule(component, template);\n\n    return TestBedRender3;\n  }\n\n  static overrideProvider(token, provider) {\n    _getTestBedRender3().overrideProvider(token, provider);\n\n    return TestBedRender3;\n  }\n\n  static inject(token, notFoundValue, flags) {\n    return _getTestBedRender3().inject(token, notFoundValue, flags);\n  }\n  /** @deprecated from v9.0.0 use TestBed.inject */\n\n\n  static get(token, notFoundValue = Injector$1.THROW_IF_NOT_FOUND, flags = InjectFlags$1.Default) {\n    return _getTestBedRender3().inject(token, notFoundValue, flags);\n  }\n\n  static createComponent(component) {\n    return _getTestBedRender3().createComponent(component);\n  }\n\n  static resetTestingModule() {\n    _getTestBedRender3().resetTestingModule();\n\n    return TestBedRender3;\n  }\n\n  static shouldTearDownTestingModule() {\n    return _getTestBedRender3().shouldTearDownTestingModule();\n  }\n\n  static tearDownTestingModule() {\n    _getTestBedRender3().tearDownTestingModule();\n  }\n  /**\n   * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n   * angular module. These are common to every test in the suite.\n   *\n   * This may only be called once, to set up the common providers for the current test\n   * suite on the current platform. If you absolutely need to change the providers,\n   * first use `resetTestEnvironment`.\n   *\n   * Test modules and platforms for individual platforms are available from\n   * '@angular/<platform_name>/testing'.\n   *\n   * @publicApi\n   */\n\n\n  initTestEnvironment(ngModule, platform, options) {\n    if (this.platform || this.ngModule) {\n      throw new Error('Cannot set base providers because it has already been called');\n    }\n\n    TestBedRender3._environmentTeardownOptions = options === null || options === void 0 ? void 0 : options.teardown;\n    TestBedRender3._environmentErrorOnUnknownElementsOption = options === null || options === void 0 ? void 0 : options.errorOnUnknownElements;\n    TestBedRender3._environmentErrorOnUnknownPropertiesOption = options === null || options === void 0 ? void 0 : options.errorOnUnknownProperties;\n    this.platform = platform;\n    this.ngModule = ngModule;\n    this._compiler = new R3TestBedCompiler(this.platform, this.ngModule); // TestBed does not have an API which can reliably detect the start of a test, and thus could be\n    // used to track the state of the NgModule registry and reset it correctly. Instead, when we\n    // know we're in a testing scenario, we disable the check for duplicate NgModule registration\n    // completely.\n\n    ɵsetAllowDuplicateNgModuleIdsForTest(true);\n  }\n  /**\n   * Reset the providers for the test injector.\n   *\n   * @publicApi\n   */\n\n\n  resetTestEnvironment() {\n    this.resetTestingModule();\n    this._compiler = null;\n    this.platform = null;\n    this.ngModule = null;\n    TestBedRender3._environmentTeardownOptions = undefined;\n    ɵsetAllowDuplicateNgModuleIdsForTest(false);\n  }\n\n  resetTestingModule() {\n    var _a, _b;\n\n    this.checkGlobalCompilationFinished();\n    ɵresetCompiledComponents();\n\n    if (this._compiler !== null) {\n      this.compiler.restoreOriginalState();\n    }\n\n    this._compiler = new R3TestBedCompiler(this.platform, this.ngModule); // Restore the previous value of the \"error on unknown elements\" option\n\n    ɵsetUnknownElementStrictMode$1((_a = this._previousErrorOnUnknownElementsOption) !== null && _a !== void 0 ? _a : THROW_ON_UNKNOWN_ELEMENTS_DEFAULT); // Restore the previous value of the \"error on unknown properties\" option\n\n    ɵsetUnknownPropertyStrictMode$1((_b = this._previousErrorOnUnknownPropertiesOption) !== null && _b !== void 0 ? _b : THROW_ON_UNKNOWN_PROPERTIES_DEFAULT); // We have to chain a couple of try/finally blocks, because each step can\n    // throw errors and we don't want it to interrupt the next step and we also\n    // want an error to be thrown at the end.\n\n    try {\n      this.destroyActiveFixtures();\n    } finally {\n      try {\n        if (this.shouldTearDownTestingModule()) {\n          this.tearDownTestingModule();\n        }\n      } finally {\n        this._testModuleRef = null;\n        this._instanceTeardownOptions = undefined;\n        this._instanceErrorOnUnknownElementsOption = undefined;\n        this._instanceErrorOnUnknownPropertiesOption = undefined;\n      }\n    }\n  }\n\n  configureCompiler(config) {\n    if (config.useJit != null) {\n      throw new Error('the Render3 compiler JiT mode is not configurable !');\n    }\n\n    if (config.providers !== undefined) {\n      this.compiler.setCompilerProviders(config.providers);\n    }\n  }\n\n  configureTestingModule(moduleDef) {\n    this.assertNotInstantiated('R3TestBed.configureTestingModule', 'configure the test module'); // Trigger module scoping queue flush before executing other TestBed operations in a test.\n    // This is needed for the first test invocation to ensure that globally declared modules have\n    // their components scoped properly. See the `checkGlobalCompilationFinished` function\n    // description for additional info.\n\n    this.checkGlobalCompilationFinished(); // Always re-assign the options, even if they're undefined.\n    // This ensures that we don't carry them between tests.\n\n    this._instanceTeardownOptions = moduleDef.teardown;\n    this._instanceErrorOnUnknownElementsOption = moduleDef.errorOnUnknownElements;\n    this._instanceErrorOnUnknownPropertiesOption = moduleDef.errorOnUnknownProperties; // Store the current value of the strict mode option,\n    // so we can restore it later\n\n    this._previousErrorOnUnknownElementsOption = ɵgetUnknownElementStrictMode$1();\n    ɵsetUnknownElementStrictMode$1(this.shouldThrowErrorOnUnknownElements());\n    this._previousErrorOnUnknownPropertiesOption = ɵgetUnknownPropertyStrictMode$1();\n    ɵsetUnknownPropertyStrictMode$1(this.shouldThrowErrorOnUnknownProperties());\n    this.compiler.configureTestingModule(moduleDef);\n  }\n\n  compileComponents() {\n    return this.compiler.compileComponents();\n  }\n\n  inject(token, notFoundValue, flags) {\n    if (token === TestBedRender3) {\n      return this;\n    }\n\n    const UNDEFINED = {};\n    const result = this.testModuleRef.injector.get(token, UNDEFINED, flags);\n    return result === UNDEFINED ? this.compiler.injector.get(token, notFoundValue, flags) : result;\n  }\n  /** @deprecated from v9.0.0 use TestBed.inject */\n\n\n  get(token, notFoundValue = Injector$1.THROW_IF_NOT_FOUND, flags = InjectFlags$1.Default) {\n    return this.inject(token, notFoundValue, flags);\n  }\n\n  execute(tokens, fn, context) {\n    const params = tokens.map(t => this.inject(t));\n    return fn.apply(context, params);\n  }\n\n  overrideModule(ngModule, override) {\n    this.assertNotInstantiated('overrideModule', 'override module metadata');\n    this.compiler.overrideModule(ngModule, override);\n  }\n\n  overrideComponent(component, override) {\n    this.assertNotInstantiated('overrideComponent', 'override component metadata');\n    this.compiler.overrideComponent(component, override);\n  }\n\n  overrideTemplateUsingTestingModule(component, template) {\n    this.assertNotInstantiated('R3TestBed.overrideTemplateUsingTestingModule', 'Cannot override template when the test module has already been instantiated');\n    this.compiler.overrideTemplateUsingTestingModule(component, template);\n  }\n\n  overrideDirective(directive, override) {\n    this.assertNotInstantiated('overrideDirective', 'override directive metadata');\n    this.compiler.overrideDirective(directive, override);\n  }\n\n  overridePipe(pipe, override) {\n    this.assertNotInstantiated('overridePipe', 'override pipe metadata');\n    this.compiler.overridePipe(pipe, override);\n  }\n  /**\n   * Overwrites all providers for the given token with the given provider definition.\n   */\n\n\n  overrideProvider(token, provider) {\n    this.assertNotInstantiated('overrideProvider', 'override provider');\n    this.compiler.overrideProvider(token, provider);\n  }\n\n  createComponent(type) {\n    const testComponentRenderer = this.inject(TestComponentRenderer);\n    const rootElId = `root${_nextRootElementId++}`;\n    testComponentRenderer.insertRootElement(rootElId);\n    const componentDef = type.ɵcmp;\n\n    if (!componentDef) {\n      throw new Error(`It looks like '${ɵstringify(type)}' has not been compiled.`);\n    } // TODO: Don't cast as `InjectionToken<boolean>`, proper type is boolean[]\n\n\n    const noNgZone = this.inject(ComponentFixtureNoNgZone, false); // TODO: Don't cast as `InjectionToken<boolean>`, proper type is boolean[]\n\n    const autoDetect = this.inject(ComponentFixtureAutoDetect, false);\n    const ngZone = noNgZone ? null : this.inject(NgZone, null);\n    const componentFactory = new ɵRender3ComponentFactory(componentDef);\n\n    const initComponent = () => {\n      const componentRef = componentFactory.create(Injector$1.NULL, [], `#${rootElId}`, this.testModuleRef);\n      return new ComponentFixture(componentRef, ngZone, autoDetect);\n    };\n\n    const fixture = ngZone ? ngZone.run(initComponent) : initComponent();\n\n    this._activeFixtures.push(fixture);\n\n    return fixture;\n  }\n  /**\n   * @internal strip this from published d.ts files due to\n   * https://github.com/microsoft/TypeScript/issues/36216\n   */\n\n\n  get compiler() {\n    if (this._compiler === null) {\n      throw new Error(`Need to call TestBed.initTestEnvironment() first`);\n    }\n\n    return this._compiler;\n  }\n  /**\n   * @internal strip this from published d.ts files due to\n   * https://github.com/microsoft/TypeScript/issues/36216\n   */\n\n\n  get testModuleRef() {\n    if (this._testModuleRef === null) {\n      this._testModuleRef = this.compiler.finalize();\n    }\n\n    return this._testModuleRef;\n  }\n\n  assertNotInstantiated(methodName, methodDescription) {\n    if (this._testModuleRef !== null) {\n      throw new Error(`Cannot ${methodDescription} when the test module has already been instantiated. ` + `Make sure you are not using \\`inject\\` before \\`${methodName}\\`.`);\n    }\n  }\n  /**\n   * Check whether the module scoping queue should be flushed, and flush it if needed.\n   *\n   * When the TestBed is reset, it clears the JIT module compilation queue, cancelling any\n   * in-progress module compilation. This creates a potential hazard - the very first time the\n   * TestBed is initialized (or if it's reset without being initialized), there may be pending\n   * compilations of modules declared in global scope. These compilations should be finished.\n   *\n   * To ensure that globally declared modules have their components scoped properly, this function\n   * is called whenever TestBed is initialized or reset. The _first_ time that this happens, prior\n   * to any other operations, the scoping queue is flushed.\n   */\n\n\n  checkGlobalCompilationFinished() {\n    // Checking _testNgModuleRef is null should not be necessary, but is left in as an additional\n    // guard that compilations queued in tests (after instantiation) are never flushed accidentally.\n    if (!this._globalCompilationChecked && this._testModuleRef === null) {\n      ɵflushModuleScopingQueueAsMuchAsPossible();\n    }\n\n    this._globalCompilationChecked = true;\n  }\n\n  destroyActiveFixtures() {\n    let errorCount = 0;\n\n    this._activeFixtures.forEach(fixture => {\n      try {\n        fixture.destroy();\n      } catch (e) {\n        errorCount++;\n        console.error('Error during cleanup of component', {\n          component: fixture.componentInstance,\n          stacktrace: e\n        });\n      }\n    });\n\n    this._activeFixtures = [];\n\n    if (errorCount > 0 && this.shouldRethrowTeardownErrors()) {\n      throw Error(`${errorCount} ${errorCount === 1 ? 'component' : 'components'} ` + `threw errors during cleanup`);\n    }\n  }\n\n  shouldRethrowTeardownErrors() {\n    var _a, _b;\n\n    const instanceOptions = this._instanceTeardownOptions;\n    const environmentOptions = TestBedRender3._environmentTeardownOptions; // If the new teardown behavior hasn't been configured, preserve the old behavior.\n\n    if (!instanceOptions && !environmentOptions) {\n      return TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n    } // Otherwise use the configured behavior or default to rethrowing.\n\n\n    return (_b = (_a = instanceOptions === null || instanceOptions === void 0 ? void 0 : instanceOptions.rethrowErrors) !== null && _a !== void 0 ? _a : environmentOptions === null || environmentOptions === void 0 ? void 0 : environmentOptions.rethrowErrors) !== null && _b !== void 0 ? _b : this.shouldTearDownTestingModule();\n  }\n\n  shouldThrowErrorOnUnknownElements() {\n    var _a, _b; // Check if a configuration has been provided to throw when an unknown element is found\n\n\n    return (_b = (_a = this._instanceErrorOnUnknownElementsOption) !== null && _a !== void 0 ? _a : TestBedRender3._environmentErrorOnUnknownElementsOption) !== null && _b !== void 0 ? _b : THROW_ON_UNKNOWN_ELEMENTS_DEFAULT;\n  }\n\n  shouldThrowErrorOnUnknownProperties() {\n    var _a, _b; // Check if a configuration has been provided to throw when an unknown property is found\n\n\n    return (_b = (_a = this._instanceErrorOnUnknownPropertiesOption) !== null && _a !== void 0 ? _a : TestBedRender3._environmentErrorOnUnknownPropertiesOption) !== null && _b !== void 0 ? _b : THROW_ON_UNKNOWN_PROPERTIES_DEFAULT;\n  }\n\n  shouldTearDownTestingModule() {\n    var _a, _b, _c, _d;\n\n    return (_d = (_b = (_a = this._instanceTeardownOptions) === null || _a === void 0 ? void 0 : _a.destroyAfterEach) !== null && _b !== void 0 ? _b : (_c = TestBedRender3._environmentTeardownOptions) === null || _c === void 0 ? void 0 : _c.destroyAfterEach) !== null && _d !== void 0 ? _d : TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n  }\n\n  tearDownTestingModule() {\n    var _a; // If the module ref has already been destroyed, we won't be able to get a test renderer.\n\n\n    if (this._testModuleRef === null) {\n      return;\n    } // Resolve the renderer ahead of time, because we want to remove the root elements as the very\n    // last step, but the injector will be destroyed as a part of the module ref destruction.\n\n\n    const testRenderer = this.inject(TestComponentRenderer);\n\n    try {\n      this._testModuleRef.destroy();\n    } catch (e) {\n      if (this.shouldRethrowTeardownErrors()) {\n        throw e;\n      } else {\n        console.error('Error during cleanup of a testing module', {\n          component: this._testModuleRef.instance,\n          stacktrace: e\n        });\n      }\n    } finally {\n      (_a = testRenderer.removeAllRootElements) === null || _a === void 0 ? void 0 : _a.call(testRenderer);\n    }\n  }\n\n}\n\nlet testBed;\n\nfunction _getTestBedRender3() {\n  return testBed = testBed || new TestBedRender3();\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n *\n * @publicApi\n */\n\n\nconst TestBed = TestBedRender3;\n/**\n * Returns a singleton of the applicable `TestBed`.\n *\n * It will be either an instance of `TestBedViewEngine` or `TestBedRender3`.\n *\n * @publicApi\n */\n\nconst getTestBed = _getTestBedRender3;\n/**\n * Allows injecting dependencies in `beforeEach()` and `it()`. Note: this function\n * (imported from the `@angular/core/testing` package) can **only** be used to inject dependencies\n * in tests. To inject dependencies in your application code, use the [`inject`](api/core/inject)\n * function from the `@angular/core` package instead.\n *\n * Example:\n *\n * ```\n * beforeEach(inject([Dependency, AClass], (dep, object) => {\n *   // some code that uses `dep` and `object`\n *   // ...\n * }));\n *\n * it('...', inject([AClass], (object) => {\n *   object.doSomething();\n *   expect(...);\n * })\n * ```\n *\n * @publicApi\n */\n\nfunction inject(tokens, fn) {\n  const testBed = getTestBed(); // Not using an arrow function to preserve context passed from call site\n\n  return function () {\n    return testBed.execute(tokens, fn, this);\n  };\n}\n/**\n * @publicApi\n */\n\n\nclass InjectSetupWrapper {\n  constructor(_moduleDef) {\n    this._moduleDef = _moduleDef;\n  }\n\n  _addModule() {\n    const moduleDef = this._moduleDef();\n\n    if (moduleDef) {\n      getTestBed().configureTestingModule(moduleDef);\n    }\n  }\n\n  inject(tokens, fn) {\n    const self = this; // Not using an arrow function to preserve context passed from call site\n\n    return function () {\n      self._addModule();\n\n      return inject(tokens, fn).call(this);\n    };\n  }\n\n}\n\nfunction withModule(moduleDef, fn) {\n  if (fn) {\n    // Not using an arrow function to preserve context passed from call site\n    return function () {\n      const testBed = getTestBed();\n\n      if (moduleDef) {\n        testBed.configureTestingModule(moduleDef);\n      }\n\n      return fn.apply(this);\n    };\n  }\n\n  return new InjectSetupWrapper(() => moduleDef);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nconst _global = typeof window === 'undefined' ? global : window; // Reset the test providers and the fake async zone before each test.\n\n\nif (_global.beforeEach) {\n  _global.beforeEach(getCleanupHook(false));\n} // We provide both a `beforeEach` and `afterEach`, because the updated behavior for\n// tearing down the module is supposed to run after the test so that we can associate\n// teardown errors with the correct test.\n\n\nif (_global.afterEach) {\n  _global.afterEach(getCleanupHook(true));\n}\n\nfunction getCleanupHook(expectedTeardownValue) {\n  return () => {\n    // TODO(alxhub): find a better type here\n    if (TestBed.shouldTearDownTestingModule() === expectedTeardownValue) {\n      TestBed.resetTestingModule();\n      resetFakeAsyncZone();\n    }\n  };\n}\n/**\n * This API should be removed. But doing so seems to break `google3` and so it requires a bit of\n * investigation.\n *\n * A work around is to mark it as `@codeGenApi` for now and investigate later.\n *\n * @codeGenApi\n */\n// TODO(iminar): Remove this code in a safe way.\n\n\nconst __core_private_testing_placeholder__ = '';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ComponentFixture, ComponentFixtureAutoDetect, ComponentFixtureNoNgZone, InjectSetupWrapper, TestBed, TestComponentRenderer, __core_private_testing_placeholder__, async, discardPeriodicTasks, fakeAsync, flush, flushMicrotasks, getTestBed, inject, resetFakeAsyncZone, tick$1 as tick, waitForAsync, withModule, MetadataOverrider as ɵMetadataOverrider };","map":{"version":3,"names":["getDebugNode","getDebugNode$1","RendererFactory2","RendererFactory2$1","ɵstringify","ɵReflectionCapabilities","Directive","Component","Pipe","NgModule","ɵgetInjectableDef","resolveForwardRef","resolveForwardRef$1","ɵNG_COMP_DEF","ɵRender3NgModuleRef","ApplicationInitStatus","LOCALE_ID","LOCALE_ID$1","ɵDEFAULT_LOCALE_ID","ɵsetLocaleId","ɵRender3ComponentFactory","ɵcompileComponent","ɵNG_DIR_DEF","ɵcompileDirective","ɵNG_PIPE_DEF","ɵcompilePipe","ɵNG_MOD_DEF","ɵtransitiveScopesFor","ɵpatchComponentDefWithScope","ɵNG_INJ_DEF","ɵcompileNgModuleDefs","NgZone","Compiler","COMPILER_OPTIONS","ɵNgModuleFactory","ModuleWithComponentFactories","InjectionToken","InjectionToken$1","Injector","Injector$1","InjectFlags","InjectFlags$1","ɵsetAllowDuplicateNgModuleIdsForTest","ɵresetCompiledComponents","ɵsetUnknownElementStrictMode","ɵsetUnknownElementStrictMode$1","ɵsetUnknownPropertyStrictMode","ɵsetUnknownPropertyStrictMode$1","ɵgetUnknownElementStrictMode","ɵgetUnknownElementStrictMode$1","ɵgetUnknownPropertyStrictMode","ɵgetUnknownPropertyStrictMode$1","ɵflushModuleScopingQueueAsMuchAsPossible","__awaiter","ResourceLoader","Subject","Subscription","waitForAsync","fn","_Zone","Zone","Promise","reject","asyncTest","__symbol__","async","ComponentFixture","constructor","componentRef","ngZone","_autoDetect","_isStable","_isDestroyed","_resolve","_promise","_onUnstableSubscription","_onStableSubscription","_onMicrotaskEmptySubscription","_onErrorSubscription","changeDetectorRef","elementRef","location","debugElement","nativeElement","componentInstance","instance","runOutsideAngular","onUnstable","subscribe","next","onMicrotaskEmpty","detectChanges","onStable","scheduleMicroTask","hasPendingMacrotasks","onError","error","_tick","checkNoChanges","run","autoDetectChanges","autoDetect","Error","isStable","whenStable","resolve","res","_getRenderer","_renderer","undefined","injector","get","whenRenderingDone","renderer","destroy","unsubscribe","current","fakeAsyncTestModule","fakeAsyncTestModuleNotLoadedErrorMessage","resetFakeAsyncZone","fakeAsync","tick$1","millis","tickOptions","processNewMacroTasksSynchronously","tick","flush","maxTurns","discardPeriodicTasks","flushMicrotasks","resolveComponentResources","resourceResolver","componentResolved","urlMap","Map","cachedResourceResolve","url","promise","resp","set","then","unwrapResponse","componentResourceResolutionQueue","forEach","component","type","promises","templateUrl","push","template","styleUrls","styles","styleOffset","length","styleUrl","index","style","splice","indexOf","fullyResolved","all","componentDefResolved","clearResolutionOfComponentResourcesQueue","componentDefPendingResolution","Set","maybeQueueResolutionOfComponentResources","metadata","componentNeedsResolution","add","isComponentDefPendingResolution","has","hasOwnProperty","old","restoreComponentResolutionQueue","queue","clear","_","isComponentResourceResolutionQueueEmpty","size","response","text","delete","_global$1","globalThis","global","window","self","WorkerGlobalScope","FactoryTarget","R3TemplateDependencyKind","ViewEncapsulation$1","ViewEncapsulation","getCompilerFacade","request","globalNg","ɵcompilerFacade","ngDevMode","console","kind","message","name","usage","getClosureSafeProperty","objWithPropertyToExtract","key","fillProperties","target","source","stringify","token","Array","isArray","map","join","overriddenName","toString","newLineIndex","substring","concatStringsWithSpace","before","after","__forward_ref__","forwardRef","forwardRefFn","isForwardRef","ɵɵdefineInjectable","opts","providedIn","factory","value","defineInjectable","ɵɵdefineInjector","options","providers","imports","getInjectableDef","getOwnDefinition","NG_PROV_DEF","NG_INJECTABLE_DEF","field","getInheritedInjectableDef","def","typeName","getTypeName","warn","match","getInjectorDef","NG_INJ_DEF","NG_INJECTOR_DEF","ɵprov","ɵinj","ngInjectableDef","ngInjectorDef","Type","Function","isType","v","assertNumber","actual","msg","throwError","assertNumberInRange","minInclusive","maxInclusive","assertLessThanOrEqual","assertGreaterThanOrEqual","assertString","assertFunction","assertEqual","expected","assertNotEqual","assertSame","assertNotSame","assertLessThan","assertGreaterThan","assertNotDefined","assertDefined","comparison","assertDomNode","node","Node","assertIndexInRange","arr","maxLen","assertOneOf","validValues","JSON","addAllToArray","items","i","arrayEquals","a","b","identityAccessor","valueA","valueB","flatten$1","list","dst","item","slice","deepForEach","input","addToArray","removeFromArray","pop","newArray","arraySplice","array","count","arrayInsert","end","previousEnd","arrayInsert2","value1","value2","arrayInsertSorted","arrayIndexOfSorted","arrayRemoveSorted","_arrayIndexOfSorted","keyValueArraySet","keyValueArray","keyValueArrayIndexOf","keyValueArrayGet","keyValueArrayDelete","shift","start","middle","noSideEffects","ANNOTATIONS","PARAMETERS","PROP_METADATA","makeDecorator","props","parentClass","additionalProcessing","typeFn","metaCtor","makeMetadataCtor","DecoratorFactory","args","call","annotationInstance","TypeDecorator","cls","annotations","Object","defineProperty","prototype","create","ngMetadataName","annotationCls","ctor","values","propName","makeParamDecorator","ParamDecoratorFactory","apply","ParamDecorator","annotation","unusedKey","parameters","makePropDecorator","PropDecoratorFactory","decoratorInstance","PropDecorator","meta","unshift","ES5_DELEGATE_CTOR","ES2015_INHERITED_CLASS","ES2015_INHERITED_CLASS_WITH_CTOR","ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR","isDelegateCtor","typeStr","test","ReflectionCapabilities","reflect","_reflect","t","_zipTypesAndAnnotations","paramTypes","paramAnnotations","result","concat","_ownParameters","parentCtor","tsickleCtorParams","ctorParameters","ctorParam","convertTsickleDecoratorIntoMetadata","decorators","getOwnMetadata","getParentCtor","_ownAnnotations","typeOrFunc","ownAnnotations","parentAnnotations","_ownPropMetadata","propMetadata","propDecorators","keys","prop","parentPropMetadata","ownPropMetadata","hasLifecycleHook","lcProperty","decoratorInvocations","decoratorInvocation","decoratorType","annotationArgs","parentProto","getPrototypeOf","ngDevModeResetPerfCounters","locationString","newCounters","namedConstructors","firstCreatePass","tNode","tView","rendererCreateTextNode","rendererSetText","rendererCreateElement","rendererAddEventListener","rendererSetAttribute","rendererRemoveAttribute","rendererSetProperty","rendererSetClassName","rendererAddClass","rendererRemoveClass","rendererSetStyle","rendererRemoveStyle","rendererDestroy","rendererDestroyNode","rendererMoveNode","rendererRemoveNode","rendererAppendChild","rendererInsertBefore","rendererCreateComment","allowNgDevModeTrue","initNgDevMode","ERROR_DETAILS_PAGE_BASE_URL","RuntimeError","code","formatRuntimeError","fullCode","Math","abs","errorMessage","trim","addPeriodSeparator","separator","renderStringify","String","stringifyForError","throwCyclicDependencyError","path","depPath","throwMixedMultiProviderError","throwInvalidProviderError","ngModuleType","provider","providerDetail","ɵproviders","throwProviderNotFoundError","injectorName","injectorDetails","_injectImplementation","getInjectImplementation","setInjectImplementation","impl","previous","injectRootLimpMode","notFoundValue","flags","injectableDef","Optional","assertInjectImplementationNotEqual","_THROW_IF_NOT_FOUND","THROW_IF_NOT_FOUND","DI_DECORATOR_FLAG","NG_TEMP_TOKEN_PATH","NG_TOKEN_PATH","NEW_LINE","NO_NEW_LINE","SOURCE","_currentInjector","setCurrentInjector","former","injectInjectorOnly","Default","ɵɵinject","ɵɵinvalidFactoryDep","inject$1","injectArgs","types","arg","j","flag","getInjectFlag","attachInjectFlag","decorator","catchInjectorError","e","injectorErrorName","tokenPath","formatError","obj","charAt","context","parts","replace","Inject","Self","SkipSelf","Host","ChangeDetectionStrategy","ChangeDetectorStatus","isDefaultChangeDetectionStrategy","changeDetectionStrategy","EMPTY_OBJ","EMPTY_ARRAY","freeze","NG_COMP_DEF","ɵcmp","NG_DIR_DEF","ɵdir","NG_PIPE_DEF","ɵpipe","NG_MOD_DEF","ɵmod","NG_FACTORY_DEF","ɵfac","NG_ELEMENT_ID","__NG_ELEMENT_ID__","componentDefCount","ɵɵdefineComponent","componentDefinition","standalone","declaredInputs","providersResolver","decls","vars","consts","ngContentSelectors","hostBindings","hostVars","hostAttrs","contentQueries","inputs","outputs","exportAs","onPush","changeDetection","OnPush","directiveDefs","pipeDefs","dependencies","getStandaloneInjector","selectors","viewQuery","features","data","encapsulation","Emulated","id","setInput","schemas","feature","invertObject","extractDirectiveDef","filter","nonNull","getPipeDef$1","ɵɵsetComponentScope","directives","pipes","getComponentDef$1","getDirectiveDef","autoRegisterModuleById","ɵɵdefineNgModule","bootstrap","declarations","exports","transitiveCompileScopes","ɵɵsetNgModuleScope","scope","ngModuleDef","getNgModuleDef","secondary","newLookup","minifiedKey","publicName","declaredName","ɵɵdefineDirective","ɵɵdefinePipe","pipeDef","pure","onDestroy","ngOnDestroy","throwNotFound","TYPE","HAS_TRANSPLANTED_VIEWS","NATIVE","VIEW_REFS","MOVED_VIEWS","CONTAINER_HEADER_OFFSET","unusedValueExportToPlacateAjd$8","HOST","TVIEW","FLAGS","PARENT","NEXT","TRANSPLANTED_VIEWS_TO_REFRESH","T_HOST","CLEANUP","CONTEXT","INJECTOR$1","RENDERER_FACTORY","RENDERER","SANITIZER","CHILD_HEAD","CHILD_TAIL","DECLARATION_VIEW","DECLARATION_COMPONENT_VIEW","DECLARATION_LCONTAINER","PREORDER_HOOK_FLAGS","QUERIES","ID","EMBEDDED_VIEW_INJECTOR","HEADER_OFFSET","TViewTypeAsString","unusedValueExportToPlacateAjd$7","isLView","isLContainer","isContentQueryHost","isComponentHost","isDirectiveHost","isComponentDef","isRootView","assertTNodeForLView","lView","assertTNodeForTView","assertTNode","tView_","assertTIcu","tIcu","currentCaseLViewIndex","assertComponentType","assertNgModuleType","assertCurrentTNodeIsParent","isParent","assertHasParent","parent","assertDataNext","assertLContainer","assertLViewOrUndefined","assertLView","assertFirstCreatePass","errMessage","assertFirstUpdatePass","firstUpdatePass","assertDirectiveDef","assertIndexInDeclRange","assertBetween","bindingStartIndex","assertIndexInVarsRange","expandoStartIndex","assertIndexInExpandoRange","lower","upper","assertProjectionSlots","projection","assertParentView","assertNodeInjector","injectorIndex","getFactoryDef","hasFactoryDef","SimpleChange","previousValue","currentValue","firstChange","isFirstChange","ɵɵNgOnChangesFeature","NgOnChangesFeatureImpl","definition","ngOnChanges","ngOnChangesSetInput","rememberChangeHistoryAndInvokeOnChangesHook","ngInherit","simpleChangesStore","getSimpleChangesStore","privateName","setSimpleChangesStore","previousChange","SIMPLE_CHANGES_STORE","store","profilerCallback","setProfiler","profiler","event","hookOrListener","SVG_NAMESPACE","SVG_NAMESPACE_URI","MATH_ML_NAMESPACE","MATH_ML_NAMESPACE_URI","getNamespaceUri","namespace","toLowerCase","DOCUMENT","setDocument","document","getDocument","RendererStyleFlags3","isProceduralRenderer","listen","domRendererFactory3","createRenderer","hostElement","rendererType","unusedValueExportToPlacateAjd$6","unwrapRNode","unwrapLView","unwrapLContainer","getNativeByIndex","getNativeByTNode","getNativeByTNodeOrNull","getTNode","load","view","getComponentLViewByIndex","nodeIndex","hostView","slotValue","isCreationMode","viewAttachedToChangeDetector","viewAttachedToContainer","getConstant","resetPreOrderHookFlags","updateTransplantedViewCount","lContainer","amount","viewOrContainer","instructionState","lFrame","createLFrame","bindingsEnabled","_isInCheckNoChangesMode","specOnlyIsInstructionStateEmpty","getElementDepthCount","elementDepthCount","increaseElementDepthCount","decreaseElementDepthCount","getBindingsEnabled","ɵɵenableBindings","ɵɵdisableBindings","getLView","getTView","ɵɵrestoreView","viewToRestore","contextLView","ɵɵresetView","getCurrentTNode","currentTNode","getCurrentTNodePlaceholderOk","getCurrentParentTNode","setCurrentTNode","isCurrentTNodeParent","setCurrentTNodeAsNotParent","setCurrentTNodeAsParent","getContextLView","isInCheckNoChangesMode","setIsInCheckNoChangesMode","mode","getBindingRoot","bindingRootIndex","getBindingIndex","bindingIndex","setBindingIndex","nextBindingIndex","incrementBindingIndex","isInI18nBlock","inI18n","setInI18nBlock","setBindingRootForHostBindings","currentDirectiveIndex","setCurrentDirectiveIndex","getCurrentDirectiveIndex","getCurrentDirectiveDef","tData","getCurrentQueryIndex","currentQueryIndex","setCurrentQueryIndex","getDeclarationTNode","declTNode","enterDI","parentTNode","parentLView","allocLFrame","enterView","newView","newLFrame","selectedIndex","currentNamespace","firstChild","currentLFrame","childLFrame","child","leaveViewLight","oldLFrame","leaveDI","leaveView","nextContextImpl","level","walkUpViews","nestingLevel","currentView","getSelectedIndex","setSelectedIndex","getSelectedTNode","ɵɵnamespaceSVG","ɵɵnamespaceMathML","ɵɵnamespaceHTML","namespaceHTMLInternal","getNamespace$1","registerPreOrderHooks","directiveIndex","directiveDef","ngOnInit","ngDoCheck","wrappedOnChanges","preOrderHooks","preOrderCheckHooks","registerPostOrderHooks","directiveStart","directiveEnd","lifecycleHooks","ngAfterContentInit","ngAfterContentChecked","ngAfterViewInit","ngAfterViewChecked","contentHooks","contentCheckHooks","viewHooks","viewCheckHooks","destroyHooks","executeCheckHooks","hooks","callHooks","executeInitAndCheckHooks","initPhase","incrementInitPhaseFlags","currentNodeIndex","startIndex","nodeIndexLimit","max","lastNodeIndexFound","hook","isInitHook","callHook","directive","indexWithintInitPhase","NO_PARENT_INJECTOR","NodeInjectorFactory","isViewProvider","injectImplementation","resolving","canSeeViewProviders","injectImpl","isFactory","unusedValueExportToPlacateAjd$5","toTNodeTypeAsString","tNodeType","unusedValueExportToPlacateAjd$4","hasClassInput","hasStyleInput","assertTNodeType","expectedTypes","assertPureTNodeType","setUpAttributes","native","attrs","isProc","namespaceURI","attrName","attrVal","setAttribute","setAttributeNS","isAnimationProp","setProperty","isNameOnlyAttributeMarker","marker","charCodeAt","mergeHostAttrs","src","srcMarker","mergeHostAttribute","key1","key2","markerInsertPosition","dstValue","hasParentInjector","parentLocation","getParentInjectorIndex","parentInjectorIndex","getParentInjectorViewOffset","getParentInjectorView","startView","viewOffset","parentView","includeViewProviders","setIncludeViewProviders","oldValue","BLOOM_SIZE","BLOOM_MASK","BLOOM_BUCKET_BITS","nextNgElementId","NOT_FOUND","bloomAdd","bloomHash","mask","getOrCreateNodeInjectorForNode","existingInjectorIndex","getInjectorIndex","insertBloom","blueprint","parentLoc","getParentInjectorLocation","parentIndex","parentData","footer","declarationViewOffset","lViewCursor","getTNodeFromLView","diPublicInInjector","injectAttributeImpl","attrNameToInject","classes","attrsLength","notFoundValueOrThrow","lookupTokenUsingModuleInjector","moduleInjector","previousInjectImplementation","getOrCreateInjectable","embeddedInjectorValue","lookupTokenUsingEmbeddedInjector","lookupTokenUsingNodeInjector","bloomHashBitOrFactory","previousTView","hostTElementNode","shouldSearchParent","bloomHasToken","searchTokensOnInjector","currentTView","canAccessViewProviders","isHostSpecialCase","injectableIdx","locateDirectiveOrProvider","getNodeInjectable","nodeProviderIndexes","providerIndexes","tInjectables","injectablesStart","directivesStart","cptViewProvidersCount","startingIndex","endIndex","providerTokenOrDef","dirDef","previousIncludeViewProviders","success","tokenId","createNodeInjector","injectorView","isFirstHostTNode","NodeInjector","_tNode","_lView","ɵɵgetInheritedFactory","ownConstructor","ownFactory","getFactoryOf","objectPrototype","currentLView","nodeInjectorValue","embeddedViewInjector","embeddedViewInjectorValue","tViewType","ɵɵinjectAttribute","Attribute","attributeName","getReflect","reflectDependencies","convertDependencies","deps","dep","reflectDependency","attribute","host","optional","skipSelf","param","proto","modules","checkForDuplicateNgModules","assertSameOrNotExisting","incoming","registerNgModuleType","existing","clearModulesForTest","getRegisteredNgModuleType","setAllowDuplicateNgModuleIdsForTest","allowDuplicates","defaultScheduler","requestAnimationFrame","setTimeout","bind","ɵɵresolveWindow","element","ownerDocument","defaultView","ɵɵresolveDocument","ɵɵresolveBody","body","INTERPOLATION_DELIMITER","maybeUnwrapFn$1","policy$1","getPolicy$1","trustedTypes","createPolicy","createHTML","s","createScript","createScriptURL","_a","trustedHTMLFromString","html","trustedScriptFromString","script","trustedScriptURLFromString","newTrustedFunctionForDev","fnArgs","fnBody","policy","getPolicy","trustedHTMLFromStringBypass","trustedScriptFromStringBypass","trustedScriptURLFromStringBypass","SafeValueImpl","changingThisBreaksApplicationSecurity","SafeHtmlImpl","SafeStyleImpl","SafeScriptImpl","SafeUrlImpl","SafeResourceUrlImpl","unwrapSafeValue","allowSanitizationBypassAndThrow","actualType","getSanitizationBypassType","bypassSanitizationTrustHtml","trustedHtml","bypassSanitizationTrustStyle","trustedStyle","bypassSanitizationTrustScript","trustedScript","bypassSanitizationTrustUrl","trustedUrl","bypassSanitizationTrustResourceUrl","trustedResourceUrl","getInertBodyHelper","defaultDoc","inertDocumentHelper","InertDocumentHelper","isDOMParserAvailable","DOMParserHelper","getInertBodyElement","DOMParser","parseFromString","removeChild","inertDocument","implementation","createHTMLDocument","inertHtml","createElement","appendChild","inertBodyElement","templateEl","innerHTML","inertBody","documentMode","stripCustomNsAttrs","el","elAttrs","attributes","attrib","removeAttribute","childNode","nodeType","ELEMENT_NODE","nextSibling","SAFE_URL_PATTERN","SAFE_SRCSET_PATTERN","DATA_URL_PATTERN","_sanitizeUrl","sanitizeSrcset","srcset","split","tagSet","tags","merge","sets","VOID_ELEMENTS","OPTIONAL_END_TAG_BLOCK_ELEMENTS","OPTIONAL_END_TAG_INLINE_ELEMENTS","OPTIONAL_END_TAG_ELEMENTS","BLOCK_ELEMENTS","INLINE_ELEMENTS","VALID_ELEMENTS","URI_ATTRS","SRCSET_ATTRS","HTML_ATTRS","ARIA_ATTRS","VALID_ATTRS","SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS","SanitizingHtmlSerializer","sanitizedSomething","buf","sanitizeChildren","traverseContent","startElement","TEXT_NODE","chars","nodeValue","endElement","checkClobberedElement","parentNode","tagName","nodeName","elAttr","encodeEntities","nextNode","compareDocumentPosition","DOCUMENT_POSITION_CONTAINED_BY","outerHTML","SURROGATE_PAIR_REGEXP","NON_ALPHANUMERIC_REGEXP","hi","low","inertBodyHelper","_sanitizeHtml","unsafeHtmlInput","unsafeHtml","mXSSAttempts","parsedHtml","sanitizer","safeHtml","getTemplateContent","isTemplateElement","content","SecurityContext","ɵɵsanitizeHtml","getSanitizer","sanitize","HTML","ɵɵsanitizeStyle","unsafeStyle","STYLE","ɵɵsanitizeUrl","unsafeUrl","URL","ɵɵsanitizeResourceUrl","unsafeResourceUrl","RESOURCE_URL","ɵɵsanitizeScript","unsafeScript","SCRIPT","ɵɵtrustConstantHtml","raw","ɵɵtrustConstantResourceUrl","getUrlSanitizer","tag","ɵɵsanitizeUrlOrResourceUrl","validateAgainstEventProperties","startsWith","validateAgainstEventAttributes","ERROR_ORIGINAL_ERROR","wrappedError","originalError","getOriginalError","ErrorHandler","_console","handleError","_findOriginalError","COMMENT_DISALLOWED","COMMENT_DELIMITER","COMMENT_DELIMITER_ESCAPED","escapeCommentText","normalizeDebugBindingName","camelCaseToDashCase","CAMEL_CASE_REGEXP","m","normalizeDebugBindingValue","TRACKED_LVIEWS","uniqueIdCounter","getUniqueLViewId","registerLView","getLViewById","unregisterLView","LContext","lViewId","getLContext","mpValue","readPatchedData","isComponentInstance","findViaComponent","isDirectiveInstance","findViaDirective","getDirectivesAtNodeIndex","findViaNativeElement","existingCtx","createLContext","attachPatchData","rElement","parentContext","getComponentViewByInstance","patchedData","MONKEY_PATCH_KEY_NAME","readPatchedLView","traverseNextElement","componentIndices","components","elementComponentIndex","componentView","rootComponentView","rootComponent","directiveInstance","directiveIndexStart","directiveIndexEnd","includeComponents","directiveStartIndex","directiveEndIndex","getComponentAtNodeIndex","discoverLocalRefs","localNames","localIndex","assertStandaloneComponentType","componentDef","throwMultipleComponentError","first","second","throwErrorIfNoChangesMode","creationMode","currValue","constructDetailsForInterpolation","rootIndex","expressionIndex","changedValue","prefix","chunks","newValue","slotIdx","getExpressionChangedErrorDetails","idx","matches","RegExp","RendererStyleFlags2","_icuContainerIterate","icuContainerIterate","tIcuContainerNode","ensureIcuContainerVisitorLoaded","loader","unusedValueExportToPlacateAjd$3","getLViewParent","getRootView","componentOrLView","getRootContext","viewOrComponent","rootView","getFirstLContainer","getNearestLContainer","getNextLContainer","container","unusedValueToPlacateAjd$2","applyToElementOrContainer","action","lNodeToHandle","beforeNode","isComponent","rNode","nativeAppendChild","nativeInsertBefore","nativeRemoveNode","destroyNode","applyContainer","createTextNode","createText","updateTextNode","setValue","textContent","createCommentNode","createComment","createElementNode","namespaceUri","createElementNS","removeViewFromContainer","applyView","addViewToContainer","parentNativeNode","renderDetachView","destroyViewTree","lViewOrLContainer","cleanUpView","firstView","insertView","indexInContainer","containerLength","declarationLContainer","trackMovedView","lQueries","declarationContainer","movedViews","insertedLContainer","insertedComponentLView","declaredComponentLView","detachMovedView","declarationViewIndex","insertionLContainer","detachView","removeIndex","viewToDetach","removedLView","destroyLView","executeOnDestroys","processCleanups","tCleanup","cleanup","lCleanup","lastLCleanupIndex","idxOrTargetGetter","listener","useCaptureOrSubIdx","removeEventListener","instanceCleanupFn","toCall","callContext","getParentRElement","getClosestRElement","None","isMove","insertBefore","targetParent","isTemplateNode","nativeAppendOrInsertBefore","nativeRemoveChild","isHostElement","nativeParentNode","nativeNextSibling","getInsertInFrontOfRNode","_getInsertInFrontOfRNodeWithI18n","getInsertInFrontOfRNodeWithNoI18n","_processI18nInsertBefore","setI18nHandling","getInsertInFrontOfRNodeWithI18n","processI18nInsertBefore","childRNode","childTNode","parentRNode","anchorNode","getFirstNativeNode","getBeforeNodeForView","elIcuContainerChild","rNodeOrLContainer","nextRNode","projectionNodes","getProjectionNodes","componentHost","viewIndexInContainer","nextViewIndex","firstTNodeOfView","nativeParent","applyNodes","parentRElement","isProjection","rawSlotValue","applyProjectionRecursive","projectionNext","applyProjection","tProjectionNode","componentLView","componentNode","nodeToProjectOrRNodes","nodeToProject","projectedComponentLView","anchor","applyStyling","isClassBased","isProcedural","removeClass","classList","remove","addClass","DashCase","removeStyle","removeProperty","isImportant","endsWith","Important","setStyle","writeDirectStyle","cssText","writeDirectClass","className","classIndexOf","classToSearch","foundIndex","unusedValueToPlacateAjd$1","NG_TEMPLATE_SELECTOR","isCssClassMatching","cssClassToMatch","isProjectionMode","isInlineTemplate","hasTagAndTypeMatch","currentSelector","tagNameToCompare","isNodeMatchingSelector","selector","nodeAttrs","nameOnlyMarkerIdx","getNameOnlyMarkerIndex","skipToNextSelector","isPositive","selectorAttrValue","attrIndexInNode","findAttrIndexInNode","nodeAttrValue","compareAgainstClassName","bindingsMode","maybeAttrName","matchTemplateAttribute","isNodeMatchingSelectorList","getProjectAsAttrValue","ngProjectAsAttrIdx","nodeAttr","attr","isSelectorInSelectorList","selectorListLoop","currentSelectorInList","maybeWrapInNotSelector","isNegativeMode","chunk","stringifyCSSSelector","currentChunk","valueOrMarker","attrValue","stringifyCSSSelectorList","selectorList","extractAttrsAndClassesFromSelector","NO_CHANGE","__brand__","ɵɵadvance","delta","selectIndexInternal","checkNoChangesMode","hooksInitPhaseCompleted","angularCoreDiEnv","compileInjectable","ngFactoryDef","compiler","getInjectableMetadata","compileFactory","typeArgumentCount","Injectable","configurable","USE_VALUE$1","provide","useValue","isUseClassProvider","useClass","isUseValueProvider","isUseFactoryProvider","useFactory","isUseExistingProvider","useExisting","srcMeta","compilerMeta","_desc","multi","ENVIRONMENT_INITIALIZER","INJECTOR_DEF_TYPES","importProvidersFrom","sources","internalImportProvidersFrom","checkForStandaloneCmp","providersOut","dedup","injectorTypesWithProviders","cmpDef","internalSource","walkProviderTree","processInjectorTypesWithProviders","typesWithProviders","ngModule","validateProvider","parents","defType","injDef","defName","isDuplicate","importTypesWithProviders","imported","defProviders","injectorType","containerType","isTypeProvider","isValueProvider","isFactoryProvider","isExistingProvider","classRef","USE_VALUE","isClassProvider","INJECTOR","NullInjector","INJECTOR_SCOPE","NOT_YET","CIRCULAR","NULL_INJECTOR$1","getNullInjector","EnvironmentInjector","R3Injector","scopes","records","_ngOnDestroyHooks","_onDestroyHooks","_destroyed","forEachSingleProvider","processProvider","makeRecord","record","injectorDefTypes","destroyed","assertNotDestroyed","service","callback","previousInjector","couldBeInjectableType","injectableDefInScope","injectableDefOrInjectorDefFactory","hydrate","nextInjector","resolveInjectorInitializers","initializers","initializer","tokens","providerToRecord","multiRecord","hasOnDestroy","getUndecoratedInjectableFactory","paramLength","inheritedInjectableDef","providerToFactory","isImportedNgModuleProviders","unwrappedProvider","hasDeps","createInjector","additionalProviders","createInjectorWithoutInjectorInstances","NULL","findFirstClosedCycle","constructResolvingPath","reversed","reverse","tokenStrs","k","injectionError","constructResolvingMessage","errMsg","addKey","injectors","noProviderError","cyclicDependencyError","instantiationError","originalException","originalStack","invalidProviderError","noAnnotationError","params","signature","ii","parameter","outOfBoundsError","mixingMultiProvidersWithRegularProvidersError","provider1","provider2","ReflectiveKey","displayName","_globalKeyRegistry","numberOfKeys","KeyRegistry","_allKeys","newKey","ReflectiveDependency","visibility","fromKey","_EMPTY_LIST","ResolvedReflectiveProvider_","resolvedFactories","multiProvider","resolvedFactory","ResolvedReflectiveFactory","resolveReflectiveFactory","factoryFn","resolvedDeps","_dependenciesFor","aliasInstance","constructDependencies","resolveReflectiveProvider","resolveReflectiveProviders","normalized","_normalizeProviders","resolved","resolvedProviderMap","mergeResolvedReflectiveProviders","from","normalizedProvidersMap","resolvedProvider","_extractToken","some","p","_createDependency","paramMetadata","UNDEFINED","ReflectiveInjector","resolveAndCreate","ResolvedReflectiveProviders","fromResolvedProviders","ReflectiveInjector_","_providers","_parent","_constructionCounter","len","keyIds","objs","_getByKey","resolveAndCreateChild","createChildFromResolved","inj","resolveAndInstantiate","instantiateResolved","_instantiateProvider","getProviderAtIndex","_new","_getMaxNumberOfObjects","_instantiate","_getByReflectiveDependency","stack","INJECTOR_KEY","_getByKeySelf","_getByKeyDefault","_getObjByKeyId","keyId","_throwOrNull","inj_","_mapProviders","ɵɵdirectiveInject","ɵɵinvalidFactory","CUSTOM_ELEMENTS_SCHEMA","NO_ERRORS_SCHEMA","shouldThrowErrorOnUnknownElement","shouldThrow","shouldThrowErrorOnUnknownProperty","validateElementIsKnown","hasDirectives","isUnknown","HTMLUnknownElement","customElements","matchingSchemas","isHostStandalone","isHostComponentStandalone","templateLocation","getTemplateLocationDetails","isPropertyValid","handleUnknownPropertyError","importLocation","KNOWN_CONTROL_FLOW_DIRECTIVES","getDeclarationComponentDef","declarationLView","hostComponentDef","componentClassName","schema","createNamedArrayType","toTStylingRange","prev","getTStylingRangePrev","tStylingRange","getTStylingRangePrevDuplicate","setTStylingRangePrev","setTStylingRangePrevDuplicate","getTStylingRangeNext","setTStylingRangeNext","getTStylingRangeNextDuplicate","setTStylingRangeNextDuplicate","getTStylingRangeTail","attachDebugObject","debug","enumerable","attachDebugGetter","debugGetter","LVIEW_COMPONENT_CACHE","LVIEW_EMBEDDED_CACHE","LVIEW_ROOT","LVIEW_COMPONENT","LVIEW_EMBEDDED","cloneToLViewFromTViewBlueprint","debugTView","getLViewToClone","LRootView","LComponentView","LEmbeddedView","componentArray","nameSuffix","embeddedArray","lastIndexOf","TViewConstructor","TView","queries","hostBindingOpCodes","staticViewQueries","staticContentQueries","directiveRegistry","pipeRegistry","incompleteFirstPass","_decls","_vars","template_","processTNodeChildren","type_","TNode","insertBeforeIndex","directiveStylingLast","propertyBindings","mergedAttrs","initialInputs","tViews","stylesWithoutHost","residualStyles","classesWithoutHost","residualClasses","classBindings","styleBindings","debugNodeInjectorPath","buildDebugNode","flags_","styleBindings_","toDebugStyleBinding","classBindings_","providerIndexStart_","providerIndexEnd_","TNodeDebug","bindings","range","isTemplate","cursor","itemKey","itemRange","prevDuplicate","nextDuplicate","nextIndex","prevIndex","TViewData","TVIEWDATA_EMPTY","cloneToTViewData","LViewBlueprint","MatchesArray","TViewComponents","TNodeLocalNames","TNodeInitialInputs","LCleanup","TCleanup","attachLViewDebug","LViewDebug","attachLContainerDebug","LContainerDebug","toDebug","toHtml","includeChildren","COMMENT_NODE","_raw_lView","__raw__flags__","initPhaseState","firstViewPass","checkAlways","dirty","attached","isRoot","indexWithinInitPhase","hostHTML","nodes","mapToHTML","toDebugNodes","rendererFactory","childHead","childTail","declarationView","tHost","toLViewRange","expando","childViews","children","l","debugNodes","tNodeCursor","rawValue","factories","instances","buildNodeInjectorDebug","injectorResolutionPath","viewProviders","nodeInjectorDebug","bloom","toBloom","cumulativeBloom","binary","_raw_lContainer","hasTransplantedViews","views","_CLEAN_PROMISE","processHostBindingOpCodes","opCode","directiveIdx","bindingRootIndx","hostBindingFn","refreshContentQueries","queryStartIdx","directiveDefIdx","refreshChildComponents","hostLView","refreshComponent","renderChildComponents","renderComponent$1","createLView","tHostNode","getOrCreateTNode","createTNodeAtIndex","createTNode","allocExpando","numSlotsToAlloc","initialValue","allocIdx","renderView","executeViewQueryFn","templateFn","executeTemplate","refreshView","isInCheckNoChangesPass","markTransplantedViewsForRefresh","refreshEmbeddedViews","renderComponentOrTemplate","creationModeIsActive","begin","rf","prevSelectedIndex","isUpdatePhase","preHookType","postHookType","executeContentQueries","createDirectivesInstances","instantiateAllDirectives","invokeDirectivesHostBindings","saveResolvedLocalsInData","viewData","localRefExtractor","getOrCreateTComponentView","createTView","constsOrFactory","initialViewLength","createViewBlueprint","fill","seal","createError","assertHostNodeExists","elementOrSelector","locateHostElement","preserveContent","ShadowDom","selectRootElement","querySelector","storeCleanupWithContext","cleanupFn","getOrCreateLViewCleanup","getOrCreateTViewCleanup","tParent","generatePropertyAliases","inputAliasMap","propStore","internalName","initializeInputAndOutputAliases","tViewData","tNodeAttrs","inputsFromAttrs","inputsStore","outputsStore","directiveInputs","generateInitialInputs","mapPropName","elementPropertyInternal","nativeOnly","inputData","dataValue","setInputsForProperty","markDirtyIfOnPush","setNgReflectProperties","viewIndex","childComponentLView","setNgReflectProperty","debugValue","instantiateRootComponent","rootTNode","configureViewWithDirective","resolveDirectives","localRefs","findDirectiveDefMatches","exportsMap","initTNodeFlags","preOrderHooksFound","preOrderCheckHooksFound","saveNameToExportMap","lifeCycleHooks","cacheMatchingLocalNames","registerHostBindingOpCodes","directiveVarsIdx","elementIndx","lastSelectedElementIdx","addComponentLogic","setInputsFromAttrs","elementIndex","dirIndex","invokeHostBindingsInCreationMode","registry","markAsComponentHost","hostTNode","numberOfDirectives","directiveFactory","nodeInjectorFactory","addToViewTree","elementAttributeInternal","setElementAttribute","strValue","initialInputData","inputsToStore","LContainerArray","LContainer","createLContainer","hostNative","embeddedLView","embeddedTView","movedLView","componentHostIdx","refreshContainsDirtyView","componentTView","syncViewWithBlueprint","markViewDirty","scheduleTick","rootContext","nothingScheduled","clean","r","scheduler","tickRootContext","playerHandler","flushPlayers","detectChangesInternal","detectChangesInRootView","checkNoChangesInternal","checkNoChangesInRootView","viewQueryFn","storePropertyBindingMetadata","propertyName","interpolationParts","propBindingIdxs","bindingMetadata","CLEAN_PROMISE","loadComponentRenderer","currentDef","errorHandler","textBindingInternal","computeStaticStyling","writeToHost","styleValue","markDirty","getComponent$1","assertDomElement","getContext","getOwningComponent","elementOrDir","getRootComponents","getInjector","getInjectionTokens","providerTokens","isDirectiveDefHack","getDirectives","Text","getDirectiveMetadata","directiveOrComponentInstance","getLocalRefs","getHostElement","componentOrDirective","getRenderedText","getListeners","lContext","listeners","firstParam","secondParam","listenerElement","useCaptureOrIndx","useCapture","sort","sortListeners","valueInLView","getComponentLView","nodeIndx","Element","applyChanges","GLOBAL_PUBLISH_EXPANDO_KEY","_published","publishDefaultGlobalUtils","publishGlobalUtil","COMPILED","w","NULL_INJECTOR","renderComponent","componentType","componentTag","hostRenderer","hostRNode","rootFlags","createRootContext","rootTView","createRootComponentView","createRootComponent","hostFeatures","viewRenderer","rootLView","LifecycleHooksFeature","whenRendered","getSuperType","ɵɵInheritDefinitionFeature","superType","shouldInheritFields","inheritanceChain","superDef","writeableDef","maybeUnwrapEmpty","superHostBindings","inheritHostBindings","superViewQuery","superContentQueries","inheritViewQuery","inheritContentQueries","animation","defData","mergeHostAttrsAcrossInheritance","prevViewQuery","ctx","prevContentQueries","prevHostBindings","COPY_DIRECTIVE_FIELDS","COPY_COMPONENT_FIELDS","ɵɵCopyDefinitionFeature","defAny","_symbolIterator","getSymbolIterator","Symbol","iterator","getOwnPropertyNames","isIterable","isListLikeIterable","isJsObject","areIterablesEqual","comparator","iterator1","iterator2","item1","item2","done","iterateListLike","o","devModeEqual","isListLikeIterableA","isListLikeIterableB","isAObject","isBObject","is","updateBinding","getBinding","bindingUpdated","oldValueToCompare","details","bindingUpdated2","exp1","exp2","different","bindingUpdated3","exp3","bindingUpdated4","exp4","ɵɵattribute","interpolationV","isBindingUpdated","interpolation1","v0","suffix","interpolation2","i0","v1","interpolation3","i1","v2","interpolation4","i2","v3","interpolation5","i3","v4","interpolation6","i4","v5","interpolation7","i5","v6","interpolation8","i6","v7","ɵɵattributeInterpolate1","interpolatedValue","ɵɵattributeInterpolate2","ɵɵattributeInterpolate3","ɵɵattributeInterpolate4","ɵɵattributeInterpolate5","ɵɵattributeInterpolate6","ɵɵattributeInterpolate7","ɵɵattributeInterpolate8","ɵɵattributeInterpolateV","interpolated","interpolationInBetween","templateFirstCreatePass","attrsIndex","localRefsIndex","tViewConsts","ɵɵtemplate","adjustedIndex","comment","ɵɵreference","ɵɵproperty","setDirectiveInputsWhichShadowsStyling","property","elementStartFirstCreatePass","elementStart","ɵɵelementStart","ɵɵelementEnd","elementEnd","ɵɵelement","elementContainerStartFirstCreatePass","ɵɵelementContainerStart","ɵɵelementContainerEnd","ɵɵelementContainer","ɵɵgetCurrentView","isPromise","isSubscribable","isObservable","ɵɵlistener","eventName","listenerFn","eventTargetResolver","listenerInternal","ɵɵsyntheticHostListener","findExistingListener","tNodeIdx","cleanupEventName","listenerIdxInLCleanup","isTNodeDirectiveHost","processOutputs","lCleanupIndex","existingListener","lastListenerFn","__ngLastListenerFn__","__ngNextListenerFn__","wrapListener","addEventListener","propsLength","minifiedName","output","subscription","executeListenerWithErrorHandling","wrapWithPreventDefault","wrapListenerIn_markDirtyAndPreventDefault","nextListenerFn","preventDefault","returnValue","ɵɵnextContext","matchingProjectionSlotIndex","projectionSlots","wildcardNgContentIndex","ngProjectAsAttrVal","ɵɵprojectionDef","numProjectionSlots","projectionHeads","tails","componentChild","slotIndex","ɵɵprojection","selectorIndex","ɵɵpropertyInterpolate","ɵɵpropertyInterpolate1","ɵɵpropertyInterpolate2","ɵɵpropertyInterpolate3","ɵɵpropertyInterpolate4","ɵɵpropertyInterpolate5","ɵɵpropertyInterpolate6","ɵɵpropertyInterpolate7","ɵɵpropertyInterpolate8","ɵɵpropertyInterpolateV","__unused_const_as_closure_does_not_like_standalone_comment_blocks__","insertTStylingBinding","tStylingKeyWithStatic","isHostBinding","isClassBinding","tBindings","tmplHead","tmplTail","isKeyDuplicateOfStatic","tStylingKey","staticKeyValueArray","hasTemplateBindings","previousNode","markDuplicates","markDuplicateOfResidualStyling","residual","isPrevDir","tStylingAtIndex","isMap","foundDuplicate","tStylingValueAtCursor","tStyleRangeAtCursor","isStylingMatch","tStylingKeyCursor","parserState","textEnd","keyEnd","valueEnd","getLastParsedKey","getLastParsedValue","parseClassName","resetParserState","parseClassNameNext","consumeWhitespace","consumeClassToken","parseStyle","parseStyleNext","consumeStyleKey","consumeSeparator","consumeStyleValue","ch","malformedStyleError","fromCharCode","ch1","ch2","ch3","lastChIndex","consumeQuotedText","quoteCharCode","expecting","ɵɵstyleProp","checkStylingProperty","ɵɵclassProp","ɵɵstyleMap","checkStylingMap","styleKeyValueArraySet","styleStringParser","ɵɵclassMap","classStringParser","stylingFirstUpdatePass","updateStyling","normalizeSuffix","stringParser","hasStylingInputShadow","isInHostBindings","staticPrefix","updateStylingMap","toStylingKeyValueArray","isHostBindings","wrapInStaticStylingKey","stylingKey","hostDirectiveDef","isFirstStylingInstructionInTemplate","collectStylingFromDirectives","collectStylingFromTAttrs","isFirstStylingInstructionInHostBinding","templateStylingKey","getTemplateHeadTStylingKey","setTemplateHeadTStylingKey","collectResidual","currentDirective","desiredMarker","currentMarker","styleKeyValueArray","unwrappedValue","oldKeyValueArray","newKeyValueArray","oldIndex","newIndex","oldKey","setKey","tRange","higherPriorityValue","findStylingValue","isStylingValuePresent","isPrevDirection","rawKey","containsStatics","isStylingMap","valueAtLViewIndex","ɵɵtext","textNative","ɵɵtextInterpolate","ɵɵtextInterpolate1","ɵɵtextInterpolate2","ɵɵtextInterpolate3","ɵɵtextInterpolate4","ɵɵtextInterpolate5","ɵɵtextInterpolate6","ɵɵtextInterpolate7","ɵɵtextInterpolate8","ɵɵtextInterpolateV","ɵɵclassMapInterpolate1","ɵɵclassMapInterpolate2","ɵɵclassMapInterpolate3","ɵɵclassMapInterpolate4","ɵɵclassMapInterpolate5","ɵɵclassMapInterpolate6","ɵɵclassMapInterpolate7","ɵɵclassMapInterpolate8","ɵɵclassMapInterpolateV","ɵɵstyleMapInterpolate1","ɵɵstyleMapInterpolate2","ɵɵstyleMapInterpolate3","ɵɵstyleMapInterpolate4","ɵɵstyleMapInterpolate5","ɵɵstyleMapInterpolate6","ɵɵstyleMapInterpolate7","ɵɵstyleMapInterpolate8","ɵɵstyleMapInterpolateV","ɵɵstylePropInterpolate1","valueSuffix","ɵɵstylePropInterpolate2","ɵɵstylePropInterpolate3","ɵɵstylePropInterpolate4","ɵɵstylePropInterpolate5","ɵɵstylePropInterpolate6","ɵɵstylePropInterpolate7","ɵɵstylePropInterpolate8","ɵɵstylePropInterpolateV","ɵɵhostProperty","ɵɵsyntheticHostProperty","ngI18nClosureMode","goog","getMsg","u","plural","val","n","floor","localeEn","LOCALE_DATA","registerLocaleData","localeId","extraData","LocaleDataIndex","LocaleId","ExtraData","findLocaleData","locale","normalizedLocale","normalizeLocale","getLocaleData","parentLocale","getLocaleCurrencyCode","CurrencyCode","getLocalePluralCase","PluralCase","ng","common","locales","unregisterAllLocaleData","pluralMapping","getPluralCase","parseInt","DEFAULT_LOCALE_ID","USD_CURRENCY_CODE","ELEMENT_MARKER","ICU_MARKER","I18nCreateOpCode","unusedValueExportToPlacateAjd$2","setLocaleId","getLocaleId","tNodeInsertBeforeIndex","i18nParent","anchorRNode","i18nChild","addTNodeAndUpdateInsertBeforeIndex","previousTNodes","newTNode","existingTNode","isI18nText","isNewTNodeCreatedBefore","getInsertBeforeIndex","setInsertBeforeIndex","getTIcu","setTIcu","setTNodeInsertBeforeIndex","createTNodePlaceholder","getCurrentICUCaseIndex","currentCase","getParentFromIcuCreateOpCode","mergedCode","getRefFromIcuCreateOpCode","getInstructionFromIcuCreateOpCode","icuCreateOpCode","parentIdx","refIdx","changeMask","changeMaskCounter","setMaskBit","hasChange","min","applyI18n","tI18n","updateOpCodes","update","bindingsStartIndex","applyUpdateOpCodes","applyCreateOpCodes","createOpCodes","insertInFrontOf","isComment","COMMENT","appendNow","APPEND_EAGERLY","SHIFT","applyMutableOpCodes","mutableOpCodes","rootIdx","rootRNode","textNodeIndex","caseIndex","anchorIdx","elementNodeIndex","commentValue","commentNodeIndex","commentRNode","elementRNode","checkBit","skipCodes","sanitizeFn","tNodeOrTagName","rText","applyIcuSwitchCase","applyIcuUpdateCase","currentIndex","activeCaseIndex","getCaseIndex","applyIcuSwitchCaseRemove","removeCodes","nodeOrIcuIndex","icuExpression","bindingValue","cases","resolvedCase","loadIcuContainerVisitor","_stack","_index","_removes","icuContainerIteratorStart","enterIcu","icuContainerIteratorNext","removeOpCode","tIcuIndex","i18nCreateOpCodesToString","opcodes","lines","i18nUpdateOpCodesToString","parser","OpCodeParser","consumeOpCode","ref","consumeString","sanitizationFn","consumeFunction","hasMore","consumeNumber","statements","statement","consumeNumberOrString","opCodeText","icuCreateOpCodesToString","lastRef","consumeNumberStringOrMarker","line","i18nRemoveOpCodesToString","codes","BINDING_REGEXP","ICU_REGEXP","NESTED_ICU","ICU_BLOCK_REGEXP","MARKER","SUBTEMPLATE_REGEXP","PH_REGEXP","NGSP_UNICODE_REGEXP","replaceNgsp","i18nStartFirstCreatePass","parentTNodeIndex","subTemplateIndex","existingTNodeStack","getTranslationForTemplate","msgParts","i18nParseTextIntoPartsAndICU","part","i18nStartFirstCreatePassProcessTextNode","icuContainerTNode","createTNodeAndAddOpCode","mainBinding","icuNodeIndex","icuStart","isClosing","Number","existingTNodes","isICU","i18nNodeIdx","hasBinding","generateBindingUpdateOpCodes","i18nAttributesFirstPass","previousElement","previousElementIndex","countBindings","str","destinationNode","bindingStart","maskIndex","sizeIndex","textParts","textValue","toMaskBit","opCodes","isRootTemplateMessage","removeInnerTemplateTranslation","inTemplate","tagMatched","exec","search","bindingMask","addUpdateIcuSwitch","valueArr","nestedIcus","icuIndex","parseIcuCase","addUpdateIcuUpdate","parseICUBlock","pattern","icuType","binding","pos","blocks","prevPos","braceStack","results","braces","lastIndex","block","caseName","unsafeCaseHtml","inertRootNode","walkIcuTree","sharedUpdateOpCodes","depth","currentNode","addCreateNodeAndAppend","lowerAttrName","addCreateAttribute","addRemoveNode","isNestedIcu","nestedIcuIndex","addRemoveNestedIcu","appendToParentIdx","createAtIdx","ROOT_TEMPLATE_ID","PP_MULTI_VALUE_PLACEHOLDERS_REGEXP","PP_PLACEHOLDERS_REGEXP","PP_ICU_VARS_REGEXP","PP_ICU_PLACEHOLDERS_REGEXP","PP_ICUS_REGEXP","PP_CLOSE_TEMPLATE_REGEXP","PP_TEMPLATE_ID_REGEXP","i18nPostprocess","replacements","templateIdsStack","phs","tmpl","placeholders","placeholder","templateId","isCloseTemplateTag","currentTemplateId","_type","_idx","ɵɵi18nStart","messageIndex","sameViewParentTNode","ɵɵi18nEnd","ɵɵi18n","ɵɵi18nAttributes","ɵɵi18nExp","ɵɵi18nApply","ɵɵi18nPostprocess","resolveProvider","lInjectablesBlueprint","providerFactory","beginIndex","existingFactoryIndex","registerDestroyHooksIfSupported","existingProvidersFactoryIndex","existingViewProvidersFactoryIndex","doesProvidersFactoryExist","doesViewProvidersFactoryExist","multiFactory","multiViewProvidersFactoryResolver","multiProvidersFactoryResolver","indexInFactory","multiFactoryAdd","componentProviders","contextIndex","providerIsTypeProvider","providerIsClassProvider","classToken","existingCallbacksIndex","isComponentProvider","lData","multiResolve","componentCount","multiProviders","f","ɵɵProvidersFeature","processProvidersFn","noComponentFactoryError","ERROR_COMPONENT","getComponent","_NullComponentFactoryResolver","resolveComponentFactory","ComponentFactoryResolver$1","NgModuleRef$1","NgModuleFactory$1","ComponentRef$1","ComponentFactory$1","injectElementRef","createElementRef","ElementRef","unwrapElementRef","Renderer2Interceptor","Renderer2","injectRenderer2","getOrCreateRenderer2","nodeAtIndex","Sanitizer","Version","full","major","minor","patch","VERSION","NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR","collectNativeNodes","lNode","lViewInAContainer","lViewFirstChildTNode","nodesInSlot","ViewRef","_cdRefInjectingView","_appRef","_attachedToViewContainer","rootNodes","viewRefs","markForCheck","detach","reattach","attachToViewContainerRef","detachFromAppRef","attachToAppRef","appRef","RootViewRef","_view","ComponentFactoryResolver","ComponentFactory","toRefArray","nonMinified","minified","templateName","getNamespace","elementName","ChainedInjector","parentInjector","isBoundToModule","projectableNodes","rootSelectorOrNode","environmentInjector","realEnvironmentInjector","rootViewInjector","tElementNode","nodesforSlot","ComponentRef","componentFactoryResolver","injectComponentFactoryResolver","_rootLView","createNgModuleRef","NgModuleRef","_bootstrapComponents","destroyCbs","_r3Injector","injectFlags","NgModuleFactory","moduleType","EnvironmentNgModuleRefAdapter","createEnvironmentInjector","debugName","adapter","StandaloneService","_injector","cachedInjectors","getOrCreateStandaloneInjector","standaloneInjector","ɵɵStandaloneFeature","setClassMetadata","clazz","assign","ɵɵpureFunction0","slotOffset","pureFn","thisArg","ɵɵpureFunction1","exp","pureFunction1Internal","ɵɵpureFunction2","pureFunction2Internal","ɵɵpureFunction3","pureFunction3Internal","ɵɵpureFunction4","pureFunction4Internal","ɵɵpureFunction5","exp5","ɵɵpureFunction6","exp6","ɵɵpureFunction7","exp7","ɵɵpureFunction8","exp8","ɵɵpureFunctionV","exps","pureFunctionVInternal","getPureFunctionReturnValue","returnValueIndex","lastReturnValue","bindingRoot","ɵɵpipe","pipeName","getPipeDef","pipeFactory","pipeInstance","getPipeNotFoundErrorMessage","hostIsStandalone","componentInfoMessage","verifyMessage","ɵɵpipeBind1","isPure","transform","ɵɵpipeBind2","ɵɵpipeBind3","ɵɵpipeBind4","ɵɵpipeBindV","EventEmitter_","isAsync","__isAsync","emit","observerOrNext","complete","_b","_c","nextFn","errorFn","completeFn","observer","_wrapInTimeout","sink","EventEmitter","symbolIterator","_results","QueryList","_emitDistinctChangesOnly","_changesDetected","_changes","last","symbol","changes","find","reduce","init","toArray","reset","resultsTree","newResultFlat","notifyOnChanges","setDirty","TemplateRef","injectTemplateRef","ViewEngineTemplateRef","R3TemplateRef","_declarationLView","_declarationTContainer","createEmbeddedView","declarationViewLQueries","createTemplateRef","ViewContainerRef","injectViewContainerRef","previousTNode","createContainerRef","VE_ViewContainerRef","R3ViewContainerRef","_lContainer","_hostTNode","_hostLView","getViewRefs","templateRef","indexOrOptions","viewRef","insert","createComponent","componentFactoryOrType","isComponentFactory","ngModuleRef","componentFactory","contextInjector","prevIdx","prevLContainer","prevVCRef","adjustedIdx","_adjustIndex","getOrCreateViewRefs","move","viewRefsArr","detachedView","wasDetached","commentNode","parentOfHostNative","unusedValueExportToPlacateAjd$1","unusedValueExportToPlacateAjd","unusedValueToPlacateAjd","LQuery_","queryList","clone","LQueries_","tQueries","noOfInheritedQueries","viewLQueries","tQuery","getByIndex","parentLQuery","indexInDeclarationView","dirtyQueriesWithMatches","getTQuery","TQueryMetadata_","predicate","read","TQueries_","queriesForTemplateRef","childQueryIndex","tqueryClone","track","tquery","TQuery_","crossesNgTemplate","_appliesToNextNode","_declarationNodeIndex","isApplyingToNode","matchTNode","addMatch","declarationNodeIdx","matchTNodeWithReadOption","getIdxOfMatchingSelector","nodeMatchIdx","directiveOrProviderIdx","matchIdx","createResultByTNodeType","createResultForNode","matchingIdx","createSpecialToken","materializeViewResults","queryIndex","lQuery","tQueryMatches","matchedNodeIdx","collectQueryResults","lViewResults","embeddedLViews","ɵɵqueryRefresh","ɵɵviewQuery","createTQuery","createLQuery","ɵɵcontentQuery","saveContentQueryAndDirectiveIndex","ɵɵloadQuery","loadQueryInternal","tViewContentQueries","lastSavedDirectiveIndex","ɵɵtemplateRefExtractor","angularCoreEnv","patchModuleCompilation","isModuleWithProviders$1","isNgModule$1","moduleQueue","enqueueModuleForDelayedScoping","flushingModuleQueue","flushModuleScopingQueueAsMuchAsPossible","every","isResolvedDeclaration","setScopeOnDeclaredComponents","declaration","compileNgModule","compileNgModuleDefs","allowDuplicateDeclarationsInRoot","expandModuleWithProviders","verifySemanticsOfNgModuleDef","compileInjector","isStandalone","generateStandaloneInDeclarationsError","importingModule","verifiedNgModule","errors","unwrapModuleWithProvidersImports","modOrStandaloneCmpt","verifySemanticsOfNgModuleImport","verifyDeclarationsHaveDefinitions","verifyDirectivesHaveSelector","declarationType","verifyNotStandalone","combinedDeclarations","computeCombinedExports","verifyExportsAreDeclaredOrReExported","decl","verifyDeclarationIsUnique","verifyComponentEntryComponentsIsPartOfNgModule","getAnnotation","mod","verifyCorrectBootstrapType","verifyComponentIsPartOfNgModule","entryComponents","suppressErrors","existingModule","ownerNgModule","typeOrWithProviders","collect","__annotations__","readAnnotation","WeakMap","resetCompiledComponents","transitiveScopes","transitiveScopesFor","patchComponentDefWithScope","ngSelectorScope","compilation","dir","pipe","transitiveScopesForNgModule","exported","importedScope","entry","declared","declaredWithDefs","exportedType","exportedScope","_nextReferenceId","MetadataOverrider","_references","overrideMetadata","metadataClass","oldMetadata","override","_valueProps","setMetadata","removeMetadata","addMetadata","references","removeObjects","removeValue","_propHashKey","propValue","addValue","nextObjectId","objectIds","replacer","_serializeReference","protoProp","desc","getOwnPropertyDescriptor","reflection","OverrideResolver","overrides","addOverride","setOverrides","isKnownType","overrider","DirectiveResolver","ComponentResolver","PipeResolver","NgModuleResolver","TestingModuleOverride","isTestingModuleOverride","DECLARATION","OVERRIDE_TEMPLATE","assertNoStandaloneComponents","resolver","R3TestBedCompiler","platform","additionalModuleTypes","originalComponentResolutionQueue","pendingComponents","pendingDirectives","pendingPipes","seenComponents","seenDirectives","overriddenModules","existingComponentStyles","resolvers","initResolvers","componentToModuleScope","initialNgDefs","defCleanupOps","compilerProviders","providerOverrides","rootProviderOverrides","providerOverridesByModule","providerOverridesByToken","scopesWithOverriddenProviders","testModuleRef","DynamicTestModule","testModuleType","setCompilerProviders","configureTestingModule","moduleDef","queueTypeArray","queueTypesFromModulesArray","overrideModule","module","invalidTypeError","recompileNgModule","overrideComponent","verifyNoStandaloneFlagOverrides","overrideDirective","overridePipe","overrideProvider","providerDef","overridesBucket","existingOverrides","overrideTemplateUsingTestingModule","hasStyleUrls","overrideStyleUrls","compileComponents","clearComponentResolutionQueue","needsAsyncResources","compileTypesSync","resourceLoader","finalize","compileTestModule","applyTransitiveScopes","applyProviderOverrides","patchComponentsWithExistingStyles","runInitializers","_compileNgModuleSync","applyProviderOverridesInScope","_compileNgModuleAsync","_getModuleResolver","_getComponentFactories","maybeUnwrapFn","maybeStoreNgDef","testingModuleDef","affectedModules","collectModulesAffectedByOverrides","storeFieldOfDefOnType","moduleToScope","getScopeOfModule","isTestingModule","realType","moduleScope","maybeApplyOverrides","hasProviderOverrides","patchDefWithProviderOverrides","hasScope","isStandaloneComponent","isNgModule","injectorDef","getComponentDef","dependency","getOverriddenProviders","importedModule","flatten","isModuleWithProviders","object","fieldName","originalValue","queueType","processedNgModuleDefs","queueTypesFromModulesArrayRecur","hasNgModuleDef","seenModules","calcAffectedModulesRecur","currentDefs","defField","restoreOriginalState","forEachRight","op","defs","descriptor","RootScopeModule","enableLongStackTrace","R3TestCompiler","compilerOptions","CompilerModule","CompilerModuleFactory","getSingleProviderOverrides","getProviderToken","getProviderOverrides","flattenedProviders","overriddenProviders","final","seenOverriddenProviders","ngDef","maybeFn","mapFn","out","getProviderField","expectedType","testBed","compileModuleSync","compileModuleAsync","compileModuleAndAllComponentsSync","ngModuleFactory","componentFactories","compileModuleAndAllComponentsAsync","clearCache","clearCacheFor","getModuleId","TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT","THROW_ON_UNKNOWN_ELEMENTS_DEFAULT","THROW_ON_UNKNOWN_PROPERTIES_DEFAULT","TestComponentRenderer","insertRootElement","rootElementId","removeAllRootElements","ComponentFixtureAutoDetect","ComponentFixtureNoNgZone","_nextRootElementId","TestBedRender3","_compiler","_testModuleRef","_activeFixtures","_globalCompilationChecked","initTestEnvironment","_getTestBedRender3","resetTestEnvironment","configureCompiler","config","overrideTemplate","inject","resetTestingModule","shouldTearDownTestingModule","tearDownTestingModule","_environmentTeardownOptions","teardown","_environmentErrorOnUnknownElementsOption","errorOnUnknownElements","_environmentErrorOnUnknownPropertiesOption","errorOnUnknownProperties","checkGlobalCompilationFinished","_previousErrorOnUnknownElementsOption","_previousErrorOnUnknownPropertiesOption","destroyActiveFixtures","_instanceTeardownOptions","_instanceErrorOnUnknownElementsOption","_instanceErrorOnUnknownPropertiesOption","useJit","assertNotInstantiated","shouldThrowErrorOnUnknownElements","shouldThrowErrorOnUnknownProperties","execute","testComponentRenderer","rootElId","noNgZone","initComponent","fixture","methodName","methodDescription","errorCount","stacktrace","shouldRethrowTeardownErrors","instanceOptions","environmentOptions","rethrowErrors","_d","destroyAfterEach","testRenderer","TestBed","getTestBed","InjectSetupWrapper","_moduleDef","_addModule","withModule","_global","beforeEach","getCleanupHook","afterEach","expectedTeardownValue","__core_private_testing_placeholder__","ɵMetadataOverrider"],"sources":["E:/PROVA/CalculoCDB/CalculoCDB/CalculoCDB.Presentation/ClientApp/node_modules/@angular/core/fesm2015/testing.mjs"],"sourcesContent":["/**\n * @license Angular v14.0.3\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { getDebugNode as getDebugNode$1, RendererFactory2 as RendererFactory2$1, ɵstringify, ɵReflectionCapabilities, Directive, Component, Pipe, NgModule, ɵgetInjectableDef, resolveForwardRef as resolveForwardRef$1, ɵNG_COMP_DEF, ɵRender3NgModuleRef, ApplicationInitStatus, LOCALE_ID as LOCALE_ID$1, ɵDEFAULT_LOCALE_ID, ɵsetLocaleId, ɵRender3ComponentFactory, ɵcompileComponent, ɵNG_DIR_DEF, ɵcompileDirective, ɵNG_PIPE_DEF, ɵcompilePipe, ɵNG_MOD_DEF, ɵtransitiveScopesFor, ɵpatchComponentDefWithScope, ɵNG_INJ_DEF, ɵcompileNgModuleDefs, NgZone, Compiler, COMPILER_OPTIONS, ɵNgModuleFactory, ModuleWithComponentFactories, InjectionToken as InjectionToken$1, Injector as Injector$1, InjectFlags as InjectFlags$1, ɵsetAllowDuplicateNgModuleIdsForTest, ɵresetCompiledComponents, ɵsetUnknownElementStrictMode as ɵsetUnknownElementStrictMode$1, ɵsetUnknownPropertyStrictMode as ɵsetUnknownPropertyStrictMode$1, ɵgetUnknownElementStrictMode as ɵgetUnknownElementStrictMode$1, ɵgetUnknownPropertyStrictMode as ɵgetUnknownPropertyStrictMode$1, ɵflushModuleScopingQueueAsMuchAsPossible } from '@angular/core';\nimport { __awaiter } from 'tslib';\nimport { ResourceLoader } from '@angular/compiler';\nimport { Subject, Subscription } from 'rxjs';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Wraps a test function in an asynchronous test zone. The test will automatically\n * complete when all asynchronous calls within this zone are done. Can be used\n * to wrap an {@link inject} call.\n *\n * Example:\n *\n * ```\n * it('...', waitForAsync(inject([AClass], (object) => {\n *   object.doSomething.then(() => {\n *     expect(...);\n *   })\n * });\n * ```\n *\n * @publicApi\n */\nfunction waitForAsync(fn) {\n    const _Zone = typeof Zone !== 'undefined' ? Zone : null;\n    if (!_Zone) {\n        return function () {\n            return Promise.reject('Zone is needed for the waitForAsync() test helper but could not be found. ' +\n                'Please make sure that your environment includes zone.js');\n        };\n    }\n    const asyncTest = _Zone && _Zone[_Zone.__symbol__('asyncTest')];\n    if (typeof asyncTest === 'function') {\n        return asyncTest(fn);\n    }\n    return function () {\n        return Promise.reject('zone-testing.js is needed for the async() test helper but could not be found. ' +\n            'Please make sure that your environment includes zone.js/testing');\n    };\n}\n/**\n * @deprecated use `waitForAsync()`, (expected removal in v12)\n * @see {@link waitForAsync}\n * @publicApi\n * */\nfunction async(fn) {\n    return waitForAsync(fn);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Fixture for debugging and testing a component.\n *\n * @publicApi\n */\nclass ComponentFixture {\n    constructor(componentRef, ngZone, _autoDetect) {\n        this.componentRef = componentRef;\n        this.ngZone = ngZone;\n        this._autoDetect = _autoDetect;\n        this._isStable = true;\n        this._isDestroyed = false;\n        this._resolve = null;\n        this._promise = null;\n        this._onUnstableSubscription = null;\n        this._onStableSubscription = null;\n        this._onMicrotaskEmptySubscription = null;\n        this._onErrorSubscription = null;\n        this.changeDetectorRef = componentRef.changeDetectorRef;\n        this.elementRef = componentRef.location;\n        this.debugElement = getDebugNode$1(this.elementRef.nativeElement);\n        this.componentInstance = componentRef.instance;\n        this.nativeElement = this.elementRef.nativeElement;\n        this.componentRef = componentRef;\n        this.ngZone = ngZone;\n        if (ngZone) {\n            // Create subscriptions outside the NgZone so that the callbacks run oustide\n            // of NgZone.\n            ngZone.runOutsideAngular(() => {\n                this._onUnstableSubscription = ngZone.onUnstable.subscribe({\n                    next: () => {\n                        this._isStable = false;\n                    }\n                });\n                this._onMicrotaskEmptySubscription = ngZone.onMicrotaskEmpty.subscribe({\n                    next: () => {\n                        if (this._autoDetect) {\n                            // Do a change detection run with checkNoChanges set to true to check\n                            // there are no changes on the second run.\n                            this.detectChanges(true);\n                        }\n                    }\n                });\n                this._onStableSubscription = ngZone.onStable.subscribe({\n                    next: () => {\n                        this._isStable = true;\n                        // Check whether there is a pending whenStable() completer to resolve.\n                        if (this._promise !== null) {\n                            // If so check whether there are no pending macrotasks before resolving.\n                            // Do this check in the next tick so that ngZone gets a chance to update the state of\n                            // pending macrotasks.\n                            scheduleMicroTask(() => {\n                                if (!ngZone.hasPendingMacrotasks) {\n                                    if (this._promise !== null) {\n                                        this._resolve(true);\n                                        this._resolve = null;\n                                        this._promise = null;\n                                    }\n                                }\n                            });\n                        }\n                    }\n                });\n                this._onErrorSubscription = ngZone.onError.subscribe({\n                    next: (error) => {\n                        throw error;\n                    }\n                });\n            });\n        }\n    }\n    _tick(checkNoChanges) {\n        this.changeDetectorRef.detectChanges();\n        if (checkNoChanges) {\n            this.checkNoChanges();\n        }\n    }\n    /**\n     * Trigger a change detection cycle for the component.\n     */\n    detectChanges(checkNoChanges = true) {\n        if (this.ngZone != null) {\n            // Run the change detection inside the NgZone so that any async tasks as part of the change\n            // detection are captured by the zone and can be waited for in isStable.\n            this.ngZone.run(() => {\n                this._tick(checkNoChanges);\n            });\n        }\n        else {\n            // Running without zone. Just do the change detection.\n            this._tick(checkNoChanges);\n        }\n    }\n    /**\n     * Do a change detection run to make sure there were no changes.\n     */\n    checkNoChanges() {\n        this.changeDetectorRef.checkNoChanges();\n    }\n    /**\n     * Set whether the fixture should autodetect changes.\n     *\n     * Also runs detectChanges once so that any existing change is detected.\n     */\n    autoDetectChanges(autoDetect = true) {\n        if (this.ngZone == null) {\n            throw new Error('Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set');\n        }\n        this._autoDetect = autoDetect;\n        this.detectChanges();\n    }\n    /**\n     * Return whether the fixture is currently stable or has async tasks that have not been completed\n     * yet.\n     */\n    isStable() {\n        return this._isStable && !this.ngZone.hasPendingMacrotasks;\n    }\n    /**\n     * Get a promise that resolves when the fixture is stable.\n     *\n     * This can be used to resume testing after events have triggered asynchronous activity or\n     * asynchronous change detection.\n     */\n    whenStable() {\n        if (this.isStable()) {\n            return Promise.resolve(false);\n        }\n        else if (this._promise !== null) {\n            return this._promise;\n        }\n        else {\n            this._promise = new Promise(res => {\n                this._resolve = res;\n            });\n            return this._promise;\n        }\n    }\n    _getRenderer() {\n        if (this._renderer === undefined) {\n            this._renderer = this.componentRef.injector.get(RendererFactory2$1, null);\n        }\n        return this._renderer;\n    }\n    /**\n     * Get a promise that resolves when the ui state is stable following animations.\n     */\n    whenRenderingDone() {\n        const renderer = this._getRenderer();\n        if (renderer && renderer.whenRenderingDone) {\n            return renderer.whenRenderingDone();\n        }\n        return this.whenStable();\n    }\n    /**\n     * Trigger component destruction.\n     */\n    destroy() {\n        if (!this._isDestroyed) {\n            this.componentRef.destroy();\n            if (this._onUnstableSubscription != null) {\n                this._onUnstableSubscription.unsubscribe();\n                this._onUnstableSubscription = null;\n            }\n            if (this._onStableSubscription != null) {\n                this._onStableSubscription.unsubscribe();\n                this._onStableSubscription = null;\n            }\n            if (this._onMicrotaskEmptySubscription != null) {\n                this._onMicrotaskEmptySubscription.unsubscribe();\n                this._onMicrotaskEmptySubscription = null;\n            }\n            if (this._onErrorSubscription != null) {\n                this._onErrorSubscription.unsubscribe();\n                this._onErrorSubscription = null;\n            }\n            this._isDestroyed = true;\n        }\n    }\n}\nfunction scheduleMicroTask(fn) {\n    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst _Zone = typeof Zone !== 'undefined' ? Zone : null;\nconst fakeAsyncTestModule = _Zone && _Zone[_Zone.__symbol__('fakeAsyncTest')];\nconst fakeAsyncTestModuleNotLoadedErrorMessage = `zone-testing.js is needed for the fakeAsync() test helper but could not be found.\n        Please make sure that your environment includes zone.js/testing`;\n/**\n * Clears out the shared fake async zone for a test.\n * To be called in a global `beforeEach`.\n *\n * @publicApi\n */\nfunction resetFakeAsyncZone() {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.resetFakeAsyncZone();\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Wraps a function to be executed in the `fakeAsync` zone:\n * - Microtasks are manually executed by calling `flushMicrotasks()`.\n * - Timers are synchronous; `tick()` simulates the asynchronous passage of time.\n *\n * If there are any pending timers at the end of the function, an exception is thrown.\n *\n * Can be used to wrap `inject()` calls.\n *\n * @param fn The function that you want to wrap in the `fakeAysnc` zone.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n *\n * @returns The function wrapped to be executed in the `fakeAsync` zone.\n * Any arguments passed when calling this returned function will be passed through to the `fn`\n * function in the parameters when it is called.\n *\n * @publicApi\n */\nfunction fakeAsync(fn) {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.fakeAsync(fn);\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the `fakeAsync` zone.\n *\n * The microtasks queue is drained at the very start of this function and after any timer callback\n * has been executed.\n *\n * @param millis The number of milliseconds to advance the virtual timer.\n * @param tickOptions The options to pass to the `tick()` function.\n *\n * @usageNotes\n *\n * The `tick()` option is a flag called `processNewMacroTasksSynchronously`,\n * which determines whether or not to invoke new macroTasks.\n *\n * If you provide a `tickOptions` object, but do not specify a\n * `processNewMacroTasksSynchronously` property (`tick(100, {})`),\n * then `processNewMacroTasksSynchronously` defaults to true.\n *\n * If you omit the `tickOptions` parameter (`tick(100))`), then\n * `tickOptions` defaults to `{processNewMacroTasksSynchronously: true}`.\n *\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * The following example includes a nested timeout (new macroTask), and\n * the `tickOptions` parameter is allowed to default. In this case,\n * `processNewMacroTasksSynchronously` defaults to true, and the nested\n * function is executed on each tick.\n *\n * ```\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick();\n *   expect(nestedTimeoutInvoked).toBe(true);\n * }));\n * ```\n *\n * In the following case, `processNewMacroTasksSynchronously` is explicitly\n * set to false, so the nested timeout function is not invoked.\n *\n * ```\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick(0, {processNewMacroTasksSynchronously: false});\n *   expect(nestedTimeoutInvoked).toBe(false);\n * }));\n * ```\n *\n *\n * @publicApi\n */\nfunction tick$1(millis = 0, tickOptions = {\n    processNewMacroTasksSynchronously: true\n}) {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.tick(millis, tickOptions);\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Flushes any pending microtasks and simulates the asynchronous passage of time for the timers in\n * the `fakeAsync` zone by\n * draining the macrotask queue until it is empty.\n *\n * @param maxTurns The maximum number of times the scheduler attempts to clear its queue before\n *     throwing an error.\n * @returns The simulated time elapsed, in milliseconds.\n *\n * @publicApi\n */\nfunction flush(maxTurns) {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.flush(maxTurns);\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Discard all remaining periodic tasks.\n *\n * @publicApi\n */\nfunction discardPeriodicTasks() {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.discardPeriodicTasks();\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Flush any pending microtasks.\n *\n * @publicApi\n */\nfunction flushMicrotasks() {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.flushMicrotasks();\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Used to resolve resource URLs on `@Component` when used with JIT compilation.\n *\n * Example:\n * ```\n * @Component({\n *   selector: 'my-comp',\n *   templateUrl: 'my-comp.html', // This requires asynchronous resolution\n * })\n * class MyComponent{\n * }\n *\n * // Calling `renderComponent` will fail because `renderComponent` is a synchronous process\n * // and `MyComponent`'s `@Component.templateUrl` needs to be resolved asynchronously.\n *\n * // Calling `resolveComponentResources()` will resolve `@Component.templateUrl` into\n * // `@Component.template`, which allows `renderComponent` to proceed in a synchronous manner.\n *\n * // Use browser's `fetch()` function as the default resource resolution strategy.\n * resolveComponentResources(fetch).then(() => {\n *   // After resolution all URLs have been converted into `template` strings.\n *   renderComponent(MyComponent);\n * });\n *\n * ```\n *\n * NOTE: In AOT the resolution happens during compilation, and so there should be no need\n * to call this method outside JIT mode.\n *\n * @param resourceResolver a function which is responsible for returning a `Promise` to the\n * contents of the resolved URL. Browser's `fetch()` method is a good default implementation.\n */\nfunction resolveComponentResources(resourceResolver) {\n    // Store all promises which are fetching the resources.\n    const componentResolved = [];\n    // Cache so that we don't fetch the same resource more than once.\n    const urlMap = new Map();\n    function cachedResourceResolve(url) {\n        let promise = urlMap.get(url);\n        if (!promise) {\n            const resp = resourceResolver(url);\n            urlMap.set(url, promise = resp.then(unwrapResponse));\n        }\n        return promise;\n    }\n    componentResourceResolutionQueue.forEach((component, type) => {\n        const promises = [];\n        if (component.templateUrl) {\n            promises.push(cachedResourceResolve(component.templateUrl).then((template) => {\n                component.template = template;\n            }));\n        }\n        const styleUrls = component.styleUrls;\n        const styles = component.styles || (component.styles = []);\n        const styleOffset = component.styles.length;\n        styleUrls && styleUrls.forEach((styleUrl, index) => {\n            styles.push(''); // pre-allocate array.\n            promises.push(cachedResourceResolve(styleUrl).then((style) => {\n                styles[styleOffset + index] = style;\n                styleUrls.splice(styleUrls.indexOf(styleUrl), 1);\n                if (styleUrls.length == 0) {\n                    component.styleUrls = undefined;\n                }\n            }));\n        });\n        const fullyResolved = Promise.all(promises).then(() => componentDefResolved(type));\n        componentResolved.push(fullyResolved);\n    });\n    clearResolutionOfComponentResourcesQueue();\n    return Promise.all(componentResolved).then(() => undefined);\n}\nlet componentResourceResolutionQueue = new Map();\n// Track when existing ɵcmp for a Type is waiting on resources.\nconst componentDefPendingResolution = new Set();\nfunction maybeQueueResolutionOfComponentResources(type, metadata) {\n    if (componentNeedsResolution(metadata)) {\n        componentResourceResolutionQueue.set(type, metadata);\n        componentDefPendingResolution.add(type);\n    }\n}\nfunction isComponentDefPendingResolution(type) {\n    return componentDefPendingResolution.has(type);\n}\nfunction componentNeedsResolution(component) {\n    return !!((component.templateUrl && !component.hasOwnProperty('template')) ||\n        component.styleUrls && component.styleUrls.length);\n}\nfunction clearResolutionOfComponentResourcesQueue() {\n    const old = componentResourceResolutionQueue;\n    componentResourceResolutionQueue = new Map();\n    return old;\n}\nfunction restoreComponentResolutionQueue(queue) {\n    componentDefPendingResolution.clear();\n    queue.forEach((_, type) => componentDefPendingResolution.add(type));\n    componentResourceResolutionQueue = queue;\n}\nfunction isComponentResourceResolutionQueueEmpty() {\n    return componentResourceResolutionQueue.size === 0;\n}\nfunction unwrapResponse(response) {\n    return typeof response == 'string' ? response : response.text();\n}\nfunction componentDefResolved(type) {\n    componentDefPendingResolution.delete(type);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Always use __globalThis if available, which is the spec-defined global variable across all\n// environments, then fallback to __global first, because in Node tests both __global and\n// __window may be defined and _global should be __global in that case. Note: Typeof/Instanceof\n// checks are considered side-effects in Terser. We explicitly mark this as side-effect free:\n// https://github.com/terser/terser/issues/250.\nconst _global$1 = ( /* @__PURE__ */(() => (typeof globalThis !== 'undefined' && globalThis) ||\n    (typeof global !== 'undefined' && global) || (typeof window !== 'undefined' && window) ||\n    (typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n        self instanceof WorkerGlobalScope && self))());\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar FactoryTarget;\n(function (FactoryTarget) {\n    FactoryTarget[FactoryTarget[\"Directive\"] = 0] = \"Directive\";\n    FactoryTarget[FactoryTarget[\"Component\"] = 1] = \"Component\";\n    FactoryTarget[FactoryTarget[\"Injectable\"] = 2] = \"Injectable\";\n    FactoryTarget[FactoryTarget[\"Pipe\"] = 3] = \"Pipe\";\n    FactoryTarget[FactoryTarget[\"NgModule\"] = 4] = \"NgModule\";\n})(FactoryTarget || (FactoryTarget = {}));\nvar R3TemplateDependencyKind;\n(function (R3TemplateDependencyKind) {\n    R3TemplateDependencyKind[R3TemplateDependencyKind[\"Directive\"] = 0] = \"Directive\";\n    R3TemplateDependencyKind[R3TemplateDependencyKind[\"Pipe\"] = 1] = \"Pipe\";\n    R3TemplateDependencyKind[R3TemplateDependencyKind[\"NgModule\"] = 2] = \"NgModule\";\n})(R3TemplateDependencyKind || (R3TemplateDependencyKind = {}));\nvar ViewEncapsulation$1;\n(function (ViewEncapsulation) {\n    ViewEncapsulation[ViewEncapsulation[\"Emulated\"] = 0] = \"Emulated\";\n    // Historically the 1 value was for `Native` encapsulation which has been removed as of v11.\n    ViewEncapsulation[ViewEncapsulation[\"None\"] = 2] = \"None\";\n    ViewEncapsulation[ViewEncapsulation[\"ShadowDom\"] = 3] = \"ShadowDom\";\n})(ViewEncapsulation$1 || (ViewEncapsulation$1 = {}));\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction getCompilerFacade(request) {\n    const globalNg = _global$1['ng'];\n    if (globalNg && globalNg.ɵcompilerFacade) {\n        return globalNg.ɵcompilerFacade;\n    }\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        // Log the type as an error so that a developer can easily navigate to the type from the\n        // console.\n        console.error(`JIT compilation failed for ${request.kind}`, request.type);\n        let message = `The ${request.kind} '${request\n            .type.name}' needs to be compiled using the JIT compiler, but '@angular/compiler' is not available.\\n\\n`;\n        if (request.usage === 1 /* JitCompilerUsage.PartialDeclaration */) {\n            message += `The ${request.kind} is part of a library that has been partially compiled.\\n`;\n            message +=\n                `However, the Angular Linker has not processed the library such that JIT compilation is used as fallback.\\n`;\n            message += '\\n';\n            message +=\n                `Ideally, the library is processed using the Angular Linker to become fully AOT compiled.\\n`;\n        }\n        else {\n            message +=\n                `JIT compilation is discouraged for production use-cases! Consider using AOT mode instead.\\n`;\n        }\n        message +=\n            `Alternatively, the JIT compiler should be loaded by bootstrapping using '@angular/platform-browser-dynamic' or '@angular/platform-server',\\n`;\n        message +=\n            `or manually provide the compiler with 'import \"@angular/compiler\";' before bootstrapping.`;\n        throw new Error(message);\n    }\n    else {\n        throw new Error('JIT compiler unavailable');\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction getClosureSafeProperty(objWithPropertyToExtract) {\n    for (let key in objWithPropertyToExtract) {\n        if (objWithPropertyToExtract[key] === getClosureSafeProperty) {\n            return key;\n        }\n    }\n    throw Error('Could not find renamed property on target object.');\n}\n/**\n * Sets properties on a target object from a source object, but only if\n * the property doesn't already exist on the target object.\n * @param target The target to set properties on\n * @param source The source of the property keys and values to set\n */\nfunction fillProperties(target, source) {\n    for (const key in source) {\n        if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {\n            target[key] = source[key];\n        }\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction stringify(token) {\n    if (typeof token === 'string') {\n        return token;\n    }\n    if (Array.isArray(token)) {\n        return '[' + token.map(stringify).join(', ') + ']';\n    }\n    if (token == null) {\n        return '' + token;\n    }\n    if (token.overriddenName) {\n        return `${token.overriddenName}`;\n    }\n    if (token.name) {\n        return `${token.name}`;\n    }\n    const res = token.toString();\n    if (res == null) {\n        return '' + res;\n    }\n    const newLineIndex = res.indexOf('\\n');\n    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n}\n/**\n * Concatenates two strings with separator, allocating new strings only when necessary.\n *\n * @param before before string.\n * @param separator separator string.\n * @param after after string.\n * @returns concatenated string.\n */\nfunction concatStringsWithSpace(before, after) {\n    return (before == null || before === '') ?\n        (after === null ? '' : after) :\n        ((after == null || after === '') ? before : before + ' ' + after);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst __forward_ref__ = getClosureSafeProperty({ __forward_ref__: getClosureSafeProperty });\n/**\n * Allows to refer to references which are not yet defined.\n *\n * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of\n * DI is declared, but not yet defined. It is also used when the `token` which we use when creating\n * a query is not yet defined.\n *\n * @usageNotes\n * ### Example\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}\n * @publicApi\n */\nfunction forwardRef(forwardRefFn) {\n    forwardRefFn.__forward_ref__ = forwardRef;\n    forwardRefFn.toString = function () {\n        return stringify(this());\n    };\n    return forwardRefFn;\n}\n/**\n * Lazily retrieves the reference value from a forwardRef.\n *\n * Acts as the identity function when given a non-forward-ref value.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}\n *\n * @see `forwardRef`\n * @publicApi\n */\nfunction resolveForwardRef(type) {\n    return isForwardRef(type) ? type() : type;\n}\n/** Checks whether a function is wrapped by a `forwardRef`. */\nfunction isForwardRef(fn) {\n    return typeof fn === 'function' && fn.hasOwnProperty(__forward_ref__) &&\n        fn.__forward_ref__ === forwardRef;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Construct an injectable definition which defines how a token will be constructed by the DI\n * system, and in which injectors (if any) it will be available.\n *\n * This should be assigned to a static `ɵprov` field on a type, which will then be an\n * `InjectableType`.\n *\n * Options:\n * * `providedIn` determines which injectors will include the injectable, by either associating it\n *   with an `@NgModule` or other `InjectorType`, or by specifying that this injectable should be\n *   provided in the `'root'` injector, which will be the application-level injector in most apps.\n * * `factory` gives the zero argument function which will create an instance of the injectable.\n *   The factory can call `inject` to access the `Injector` and request injection of dependencies.\n *\n * @codeGenApi\n * @publicApi This instruction has been emitted by ViewEngine for some time and is deployed to npm.\n */\nfunction ɵɵdefineInjectable(opts) {\n    return {\n        token: opts.token,\n        providedIn: opts.providedIn || null,\n        factory: opts.factory,\n        value: undefined,\n    };\n}\n/**\n * @deprecated in v8, delete after v10. This API should be used only by generated code, and that\n * code should now use ɵɵdefineInjectable instead.\n * @publicApi\n */\nconst defineInjectable = ɵɵdefineInjectable;\n/**\n * Construct an `InjectorDef` which configures an injector.\n *\n * This should be assigned to a static injector def (`ɵinj`) field on a type, which will then be an\n * `InjectorType`.\n *\n * Options:\n *\n * * `providers`: an optional array of providers to add to the injector. Each provider must\n *   either have a factory or point to a type which has a `ɵprov` static property (the\n *   type must be an `InjectableType`).\n * * `imports`: an optional array of imports of other `InjectorType`s or `InjectorTypeWithModule`s\n *   whose providers will also be added to the injector. Locally provided types will override\n *   providers from imports.\n *\n * @codeGenApi\n */\nfunction ɵɵdefineInjector(options) {\n    return { providers: options.providers || [], imports: options.imports || [] };\n}\n/**\n * Read the injectable def (`ɵprov`) for `type` in a way which is immune to accidentally reading\n * inherited value.\n *\n * @param type A type which may have its own (non-inherited) `ɵprov`.\n */\nfunction getInjectableDef(type) {\n    return getOwnDefinition(type, NG_PROV_DEF) || getOwnDefinition(type, NG_INJECTABLE_DEF);\n}\n/**\n * Return definition only if it is defined directly on `type` and is not inherited from a base\n * class of `type`.\n */\nfunction getOwnDefinition(type, field) {\n    return type.hasOwnProperty(field) ? type[field] : null;\n}\n/**\n * Read the injectable def (`ɵprov`) for `type` or read the `ɵprov` from one of its ancestors.\n *\n * @param type A type which may have `ɵprov`, via inheritance.\n *\n * @deprecated Will be removed in a future version of Angular, where an error will occur in the\n *     scenario if we find the `ɵprov` on an ancestor only.\n */\nfunction getInheritedInjectableDef(type) {\n    const def = type && (type[NG_PROV_DEF] || type[NG_INJECTABLE_DEF]);\n    if (def) {\n        const typeName = getTypeName(type);\n        // TODO(FW-1307): Re-add ngDevMode when closure can handle it\n        // ngDevMode &&\n        console.warn(`DEPRECATED: DI is instantiating a token \"${typeName}\" that inherits its @Injectable decorator but does not provide one itself.\\n` +\n            `This will become an error in a future version of Angular. Please add @Injectable() to the \"${typeName}\" class.`);\n        return def;\n    }\n    else {\n        return null;\n    }\n}\n/** Gets the name of a type, accounting for some cross-browser differences. */\nfunction getTypeName(type) {\n    // `Function.prototype.name` behaves differently between IE and other browsers. In most browsers\n    // it'll always return the name of the function itself, no matter how many other functions it\n    // inherits from. On IE the function doesn't have its own `name` property, but it takes it from\n    // the lowest level in the prototype chain. E.g. if we have `class Foo extends Parent` most\n    // browsers will evaluate `Foo.name` to `Foo` while IE will return `Parent`. We work around\n    // the issue by converting the function to a string and parsing its name out that way via a regex.\n    if (type.hasOwnProperty('name')) {\n        return type.name;\n    }\n    const match = ('' + type).match(/^function\\s*([^\\s(]+)/);\n    return match === null ? '' : match[1];\n}\n/**\n * Read the injector def type in a way which is immune to accidentally reading inherited value.\n *\n * @param type type which may have an injector def (`ɵinj`)\n */\nfunction getInjectorDef(type) {\n    return type && (type.hasOwnProperty(NG_INJ_DEF) || type.hasOwnProperty(NG_INJECTOR_DEF)) ?\n        type[NG_INJ_DEF] :\n        null;\n}\nconst NG_PROV_DEF = getClosureSafeProperty({ ɵprov: getClosureSafeProperty });\nconst NG_INJ_DEF = getClosureSafeProperty({ ɵinj: getClosureSafeProperty });\n// We need to keep these around so we can read off old defs if new defs are unavailable\nconst NG_INJECTABLE_DEF = getClosureSafeProperty({ ngInjectableDef: getClosureSafeProperty });\nconst NG_INJECTOR_DEF = getClosureSafeProperty({ ngInjectorDef: getClosureSafeProperty });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @description\n *\n * Represents a type that a Component or other object is instances of.\n *\n * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is represented by\n * the `MyCustomComponent` constructor function.\n *\n * @publicApi\n */\nconst Type = Function;\nfunction isType(v) {\n    return typeof v === 'function';\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction assertNumber(actual, msg) {\n    if (!(typeof actual === 'number')) {\n        throwError(msg, typeof actual, 'number', '===');\n    }\n}\nfunction assertNumberInRange(actual, minInclusive, maxInclusive) {\n    assertNumber(actual, 'Expected a number');\n    assertLessThanOrEqual(actual, maxInclusive, 'Expected number to be less than or equal to');\n    assertGreaterThanOrEqual(actual, minInclusive, 'Expected number to be greater than or equal to');\n}\nfunction assertString(actual, msg) {\n    if (!(typeof actual === 'string')) {\n        throwError(msg, actual === null ? 'null' : typeof actual, 'string', '===');\n    }\n}\nfunction assertFunction(actual, msg) {\n    if (!(typeof actual === 'function')) {\n        throwError(msg, actual === null ? 'null' : typeof actual, 'function', '===');\n    }\n}\nfunction assertEqual(actual, expected, msg) {\n    if (!(actual == expected)) {\n        throwError(msg, actual, expected, '==');\n    }\n}\nfunction assertNotEqual(actual, expected, msg) {\n    if (!(actual != expected)) {\n        throwError(msg, actual, expected, '!=');\n    }\n}\nfunction assertSame(actual, expected, msg) {\n    if (!(actual === expected)) {\n        throwError(msg, actual, expected, '===');\n    }\n}\nfunction assertNotSame(actual, expected, msg) {\n    if (!(actual !== expected)) {\n        throwError(msg, actual, expected, '!==');\n    }\n}\nfunction assertLessThan(actual, expected, msg) {\n    if (!(actual < expected)) {\n        throwError(msg, actual, expected, '<');\n    }\n}\nfunction assertLessThanOrEqual(actual, expected, msg) {\n    if (!(actual <= expected)) {\n        throwError(msg, actual, expected, '<=');\n    }\n}\nfunction assertGreaterThan(actual, expected, msg) {\n    if (!(actual > expected)) {\n        throwError(msg, actual, expected, '>');\n    }\n}\nfunction assertGreaterThanOrEqual(actual, expected, msg) {\n    if (!(actual >= expected)) {\n        throwError(msg, actual, expected, '>=');\n    }\n}\nfunction assertNotDefined(actual, msg) {\n    if (actual != null) {\n        throwError(msg, actual, null, '==');\n    }\n}\nfunction assertDefined(actual, msg) {\n    if (actual == null) {\n        throwError(msg, actual, null, '!=');\n    }\n}\nfunction throwError(msg, actual, expected, comparison) {\n    throw new Error(`ASSERTION ERROR: ${msg}` +\n        (comparison == null ? '' : ` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`));\n}\nfunction assertDomNode(node) {\n    // If we're in a worker, `Node` will not be defined.\n    if (!(typeof Node !== 'undefined' && node instanceof Node) &&\n        !(typeof node === 'object' && node != null &&\n            node.constructor.name === 'WebWorkerRenderNode')) {\n        throwError(`The provided value must be an instance of a DOM Node but got ${stringify(node)}`);\n    }\n}\nfunction assertIndexInRange(arr, index) {\n    assertDefined(arr, 'Array must be defined.');\n    const maxLen = arr.length;\n    if (index < 0 || index >= maxLen) {\n        throwError(`Index expected to be less than ${maxLen} but got ${index}`);\n    }\n}\nfunction assertOneOf(value, ...validValues) {\n    if (validValues.indexOf(value) !== -1)\n        return true;\n    throwError(`Expected value to be one of ${JSON.stringify(validValues)} but was ${JSON.stringify(value)}.`);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Equivalent to ES6 spread, add each item to an array.\n *\n * @param items The items to add\n * @param arr The array to which you want to add the items\n */\nfunction addAllToArray(items, arr) {\n    for (let i = 0; i < items.length; i++) {\n        arr.push(items[i]);\n    }\n}\n/**\n * Determines if the contents of two arrays is identical\n *\n * @param a first array\n * @param b second array\n * @param identityAccessor Optional function for extracting stable object identity from a value in\n *     the array.\n */\nfunction arrayEquals(a, b, identityAccessor) {\n    if (a.length !== b.length)\n        return false;\n    for (let i = 0; i < a.length; i++) {\n        let valueA = a[i];\n        let valueB = b[i];\n        if (identityAccessor) {\n            valueA = identityAccessor(valueA);\n            valueB = identityAccessor(valueB);\n        }\n        if (valueB !== valueA) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Flattens an array.\n */\nfunction flatten$1(list, dst) {\n    if (dst === undefined)\n        dst = list;\n    for (let i = 0; i < list.length; i++) {\n        let item = list[i];\n        if (Array.isArray(item)) {\n            // we need to inline it.\n            if (dst === list) {\n                // Our assumption that the list was already flat was wrong and\n                // we need to clone flat since we need to write to it.\n                dst = list.slice(0, i);\n            }\n            flatten$1(item, dst);\n        }\n        else if (dst !== list) {\n            dst.push(item);\n        }\n    }\n    return dst;\n}\nfunction deepForEach(input, fn) {\n    input.forEach(value => Array.isArray(value) ? deepForEach(value, fn) : fn(value));\n}\nfunction addToArray(arr, index, value) {\n    // perf: array.push is faster than array.splice!\n    if (index >= arr.length) {\n        arr.push(value);\n    }\n    else {\n        arr.splice(index, 0, value);\n    }\n}\nfunction removeFromArray(arr, index) {\n    // perf: array.pop is faster than array.splice!\n    if (index >= arr.length - 1) {\n        return arr.pop();\n    }\n    else {\n        return arr.splice(index, 1)[0];\n    }\n}\nfunction newArray(size, value) {\n    const list = [];\n    for (let i = 0; i < size; i++) {\n        list.push(value);\n    }\n    return list;\n}\n/**\n * Remove item from array (Same as `Array.splice()` but faster.)\n *\n * `Array.splice()` is not as fast because it has to allocate an array for the elements which were\n * removed. This causes memory pressure and slows down code when most of the time we don't\n * care about the deleted items array.\n *\n * https://jsperf.com/fast-array-splice (About 20x faster)\n *\n * @param array Array to splice\n * @param index Index of element in array to remove.\n * @param count Number of items to remove.\n */\nfunction arraySplice(array, index, count) {\n    const length = array.length - count;\n    while (index < length) {\n        array[index] = array[index + count];\n        index++;\n    }\n    while (count--) {\n        array.pop(); // shrink the array\n    }\n}\n/**\n * Same as `Array.splice(index, 0, value)` but faster.\n *\n * `Array.splice()` is not fast because it has to allocate an array for the elements which were\n * removed. This causes memory pressure and slows down code when most of the time we don't\n * care about the deleted items array.\n *\n * @param array Array to splice.\n * @param index Index in array where the `value` should be added.\n * @param value Value to add to array.\n */\nfunction arrayInsert(array, index, value) {\n    ngDevMode && assertLessThanOrEqual(index, array.length, 'Can\\'t insert past array end.');\n    let end = array.length;\n    while (end > index) {\n        const previousEnd = end - 1;\n        array[end] = array[previousEnd];\n        end = previousEnd;\n    }\n    array[index] = value;\n}\n/**\n * Same as `Array.splice2(index, 0, value1, value2)` but faster.\n *\n * `Array.splice()` is not fast because it has to allocate an array for the elements which were\n * removed. This causes memory pressure and slows down code when most of the time we don't\n * care about the deleted items array.\n *\n * @param array Array to splice.\n * @param index Index in array where the `value` should be added.\n * @param value1 Value to add to array.\n * @param value2 Value to add to array.\n */\nfunction arrayInsert2(array, index, value1, value2) {\n    ngDevMode && assertLessThanOrEqual(index, array.length, 'Can\\'t insert past array end.');\n    let end = array.length;\n    if (end == index) {\n        // inserting at the end.\n        array.push(value1, value2);\n    }\n    else if (end === 1) {\n        // corner case when we have less items in array than we have items to insert.\n        array.push(value2, array[0]);\n        array[0] = value1;\n    }\n    else {\n        end--;\n        array.push(array[end - 1], array[end]);\n        while (end > index) {\n            const previousEnd = end - 2;\n            array[end] = array[previousEnd];\n            end--;\n        }\n        array[index] = value1;\n        array[index + 1] = value2;\n    }\n}\n/**\n * Insert a `value` into an `array` so that the array remains sorted.\n *\n * NOTE:\n * - Duplicates are not allowed, and are ignored.\n * - This uses binary search algorithm for fast inserts.\n *\n * @param array A sorted array to insert into.\n * @param value The value to insert.\n * @returns index of the inserted value.\n */\nfunction arrayInsertSorted(array, value) {\n    let index = arrayIndexOfSorted(array, value);\n    if (index < 0) {\n        // if we did not find it insert it.\n        index = ~index;\n        arrayInsert(array, index, value);\n    }\n    return index;\n}\n/**\n * Remove `value` from a sorted `array`.\n *\n * NOTE:\n * - This uses binary search algorithm for fast removals.\n *\n * @param array A sorted array to remove from.\n * @param value The value to remove.\n * @returns index of the removed value.\n *   - positive index if value found and removed.\n *   - negative index if value not found. (`~index` to get the value where it should have been\n *     inserted)\n */\nfunction arrayRemoveSorted(array, value) {\n    const index = arrayIndexOfSorted(array, value);\n    if (index >= 0) {\n        arraySplice(array, index, 1);\n    }\n    return index;\n}\n/**\n * Get an index of an `value` in a sorted `array`.\n *\n * NOTE:\n * - This uses binary search algorithm for fast removals.\n *\n * @param array A sorted array to binary search.\n * @param value The value to look for.\n * @returns index of the value.\n *   - positive index if value found.\n *   - negative index if value not found. (`~index` to get the value where it should have been\n *     located)\n */\nfunction arrayIndexOfSorted(array, value) {\n    return _arrayIndexOfSorted(array, value, 0);\n}\n/**\n * Set a `value` for a `key`.\n *\n * @param keyValueArray to modify.\n * @param key The key to locate or create.\n * @param value The value to set for a `key`.\n * @returns index (always even) of where the value vas set.\n */\nfunction keyValueArraySet(keyValueArray, key, value) {\n    let index = keyValueArrayIndexOf(keyValueArray, key);\n    if (index >= 0) {\n        // if we found it set it.\n        keyValueArray[index | 1] = value;\n    }\n    else {\n        index = ~index;\n        arrayInsert2(keyValueArray, index, key, value);\n    }\n    return index;\n}\n/**\n * Retrieve a `value` for a `key` (on `undefined` if not found.)\n *\n * @param keyValueArray to search.\n * @param key The key to locate.\n * @return The `value` stored at the `key` location or `undefined if not found.\n */\nfunction keyValueArrayGet(keyValueArray, key) {\n    const index = keyValueArrayIndexOf(keyValueArray, key);\n    if (index >= 0) {\n        // if we found it retrieve it.\n        return keyValueArray[index | 1];\n    }\n    return undefined;\n}\n/**\n * Retrieve a `key` index value in the array or `-1` if not found.\n *\n * @param keyValueArray to search.\n * @param key The key to locate.\n * @returns index of where the key is (or should have been.)\n *   - positive (even) index if key found.\n *   - negative index if key not found. (`~index` (even) to get the index where it should have\n *     been inserted.)\n */\nfunction keyValueArrayIndexOf(keyValueArray, key) {\n    return _arrayIndexOfSorted(keyValueArray, key, 1);\n}\n/**\n * Delete a `key` (and `value`) from the `KeyValueArray`.\n *\n * @param keyValueArray to modify.\n * @param key The key to locate or delete (if exist).\n * @returns index of where the key was (or should have been.)\n *   - positive (even) index if key found and deleted.\n *   - negative index if key not found. (`~index` (even) to get the index where it should have\n *     been.)\n */\nfunction keyValueArrayDelete(keyValueArray, key) {\n    const index = keyValueArrayIndexOf(keyValueArray, key);\n    if (index >= 0) {\n        // if we found it remove it.\n        arraySplice(keyValueArray, index, 2);\n    }\n    return index;\n}\n/**\n * INTERNAL: Get an index of an `value` in a sorted `array` by grouping search by `shift`.\n *\n * NOTE:\n * - This uses binary search algorithm for fast removals.\n *\n * @param array A sorted array to binary search.\n * @param value The value to look for.\n * @param shift grouping shift.\n *   - `0` means look at every location\n *   - `1` means only look at every other (even) location (the odd locations are to be ignored as\n *         they are values.)\n * @returns index of the value.\n *   - positive index if value found.\n *   - negative index if value not found. (`~index` to get the value where it should have been\n * inserted)\n */\nfunction _arrayIndexOfSorted(array, value, shift) {\n    ngDevMode && assertEqual(Array.isArray(array), true, 'Expecting an array');\n    let start = 0;\n    let end = array.length >> shift;\n    while (end !== start) {\n        const middle = start + ((end - start) >> 1); // find the middle.\n        const current = array[middle << shift];\n        if (value === current) {\n            return (middle << shift);\n        }\n        else if (current > value) {\n            end = middle;\n        }\n        else {\n            start = middle + 1; // We already searched middle so make it non-inclusive by adding 1\n        }\n    }\n    return ~(end << shift);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Convince closure compiler that the wrapped function has no side-effects.\n *\n * Closure compiler always assumes that `toString` has no side-effects. We use this quirk to\n * allow us to execute a function but have closure compiler mark the call as no-side-effects.\n * It is important that the return value for the `noSideEffects` function be assigned\n * to something which is retained otherwise the call to `noSideEffects` will be removed by closure\n * compiler.\n */\nfunction noSideEffects(fn) {\n    return { toString: fn }.toString();\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst ANNOTATIONS = '__annotations__';\nconst PARAMETERS = '__parameters__';\nconst PROP_METADATA = '__prop__metadata__';\n/**\n * @suppress {globalThis}\n */\nfunction makeDecorator(name, props, parentClass, additionalProcessing, typeFn) {\n    return noSideEffects(() => {\n        const metaCtor = makeMetadataCtor(props);\n        function DecoratorFactory(...args) {\n            if (this instanceof DecoratorFactory) {\n                metaCtor.call(this, ...args);\n                return this;\n            }\n            const annotationInstance = new DecoratorFactory(...args);\n            return function TypeDecorator(cls) {\n                if (typeFn)\n                    typeFn(cls, ...args);\n                // Use of Object.defineProperty is important since it creates non-enumerable property which\n                // prevents the property is copied during subclassing.\n                const annotations = cls.hasOwnProperty(ANNOTATIONS) ?\n                    cls[ANNOTATIONS] :\n                    Object.defineProperty(cls, ANNOTATIONS, { value: [] })[ANNOTATIONS];\n                annotations.push(annotationInstance);\n                if (additionalProcessing)\n                    additionalProcessing(cls);\n                return cls;\n            };\n        }\n        if (parentClass) {\n            DecoratorFactory.prototype = Object.create(parentClass.prototype);\n        }\n        DecoratorFactory.prototype.ngMetadataName = name;\n        DecoratorFactory.annotationCls = DecoratorFactory;\n        return DecoratorFactory;\n    });\n}\nfunction makeMetadataCtor(props) {\n    return function ctor(...args) {\n        if (props) {\n            const values = props(...args);\n            for (const propName in values) {\n                this[propName] = values[propName];\n            }\n        }\n    };\n}\nfunction makeParamDecorator(name, props, parentClass) {\n    return noSideEffects(() => {\n        const metaCtor = makeMetadataCtor(props);\n        function ParamDecoratorFactory(...args) {\n            if (this instanceof ParamDecoratorFactory) {\n                metaCtor.apply(this, args);\n                return this;\n            }\n            const annotationInstance = new ParamDecoratorFactory(...args);\n            ParamDecorator.annotation = annotationInstance;\n            return ParamDecorator;\n            function ParamDecorator(cls, unusedKey, index) {\n                // Use of Object.defineProperty is important since it creates non-enumerable property which\n                // prevents the property is copied during subclassing.\n                const parameters = cls.hasOwnProperty(PARAMETERS) ?\n                    cls[PARAMETERS] :\n                    Object.defineProperty(cls, PARAMETERS, { value: [] })[PARAMETERS];\n                // there might be gaps if some in between parameters do not have annotations.\n                // we pad with nulls.\n                while (parameters.length <= index) {\n                    parameters.push(null);\n                }\n                (parameters[index] = parameters[index] || []).push(annotationInstance);\n                return cls;\n            }\n        }\n        if (parentClass) {\n            ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);\n        }\n        ParamDecoratorFactory.prototype.ngMetadataName = name;\n        ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;\n        return ParamDecoratorFactory;\n    });\n}\nfunction makePropDecorator(name, props, parentClass, additionalProcessing) {\n    return noSideEffects(() => {\n        const metaCtor = makeMetadataCtor(props);\n        function PropDecoratorFactory(...args) {\n            if (this instanceof PropDecoratorFactory) {\n                metaCtor.apply(this, args);\n                return this;\n            }\n            const decoratorInstance = new PropDecoratorFactory(...args);\n            function PropDecorator(target, name) {\n                const constructor = target.constructor;\n                // Use of Object.defineProperty is important because it creates a non-enumerable property\n                // which prevents the property from being copied during subclassing.\n                const meta = constructor.hasOwnProperty(PROP_METADATA) ?\n                    constructor[PROP_METADATA] :\n                    Object.defineProperty(constructor, PROP_METADATA, { value: {} })[PROP_METADATA];\n                meta[name] = meta.hasOwnProperty(name) && meta[name] || [];\n                meta[name].unshift(decoratorInstance);\n                if (additionalProcessing)\n                    additionalProcessing(target, name, ...args);\n            }\n            return PropDecorator;\n        }\n        if (parentClass) {\n            PropDecoratorFactory.prototype = Object.create(parentClass.prototype);\n        }\n        PropDecoratorFactory.prototype.ngMetadataName = name;\n        PropDecoratorFactory.annotationCls = PropDecoratorFactory;\n        return PropDecoratorFactory;\n    });\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/*\n * #########################\n * Attention: These Regular expressions have to hold even if the code is minified!\n * ##########################\n */\n/**\n * Regular expression that detects pass-through constructors for ES5 output. This Regex\n * intends to capture the common delegation pattern emitted by TypeScript and Babel. Also\n * it intends to capture the pattern where existing constructors have been downleveled from\n * ES2015 to ES5 using TypeScript w/ downlevel iteration. e.g.\n *\n * ```\n *   function MyClass() {\n *     var _this = _super.apply(this, arguments) || this;\n * ```\n *\n * downleveled to ES5 with `downlevelIteration` for TypeScript < 4.2:\n * ```\n *   function MyClass() {\n *     var _this = _super.apply(this, __spread(arguments)) || this;\n * ```\n *\n * or downleveled to ES5 with `downlevelIteration` for TypeScript >= 4.2:\n * ```\n *   function MyClass() {\n *     var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;\n * ```\n *\n * More details can be found in: https://github.com/angular/angular/issues/38453.\n */\nconst ES5_DELEGATE_CTOR = /^function\\s+\\S+\\(\\)\\s*{[\\s\\S]+\\.apply\\(this,\\s*(arguments|(?:[^()]+\\(\\[\\],)?[^()]+\\(arguments\\).*)\\)/;\n/** Regular expression that detects ES2015 classes which extend from other classes. */\nconst ES2015_INHERITED_CLASS = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{/;\n/**\n * Regular expression that detects ES2015 classes which extend from other classes and\n * have an explicit constructor defined.\n */\nconst ES2015_INHERITED_CLASS_WITH_CTOR = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{[\\s\\S]*constructor\\s*\\(/;\n/**\n * Regular expression that detects ES2015 classes which extend from other classes\n * and inherit a constructor.\n */\nconst ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{[\\s\\S]*constructor\\s*\\(\\)\\s*{[^}]*super\\(\\.\\.\\.arguments\\)/;\n/**\n * Determine whether a stringified type is a class which delegates its constructor\n * to its parent.\n *\n * This is not trivial since compiled code can actually contain a constructor function\n * even if the original source code did not. For instance, when the child class contains\n * an initialized instance property.\n */\nfunction isDelegateCtor(typeStr) {\n    return ES5_DELEGATE_CTOR.test(typeStr) ||\n        ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr) ||\n        (ES2015_INHERITED_CLASS.test(typeStr) && !ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr));\n}\nclass ReflectionCapabilities {\n    constructor(reflect) {\n        this._reflect = reflect || _global$1['Reflect'];\n    }\n    factory(t) {\n        return (...args) => new t(...args);\n    }\n    /** @internal */\n    _zipTypesAndAnnotations(paramTypes, paramAnnotations) {\n        let result;\n        if (typeof paramTypes === 'undefined') {\n            result = newArray(paramAnnotations.length);\n        }\n        else {\n            result = newArray(paramTypes.length);\n        }\n        for (let i = 0; i < result.length; i++) {\n            // TS outputs Object for parameters without types, while Traceur omits\n            // the annotations. For now we preserve the Traceur behavior to aid\n            // migration, but this can be revisited.\n            if (typeof paramTypes === 'undefined') {\n                result[i] = [];\n            }\n            else if (paramTypes[i] && paramTypes[i] != Object) {\n                result[i] = [paramTypes[i]];\n            }\n            else {\n                result[i] = [];\n            }\n            if (paramAnnotations && paramAnnotations[i] != null) {\n                result[i] = result[i].concat(paramAnnotations[i]);\n            }\n        }\n        return result;\n    }\n    _ownParameters(type, parentCtor) {\n        const typeStr = type.toString();\n        // If we have no decorators, we only have function.length as metadata.\n        // In that case, to detect whether a child class declared an own constructor or not,\n        // we need to look inside of that constructor to check whether it is\n        // just calling the parent.\n        // This also helps to work around for https://github.com/Microsoft/TypeScript/issues/12439\n        // that sets 'design:paramtypes' to []\n        // if a class inherits from another class but has no ctor declared itself.\n        if (isDelegateCtor(typeStr)) {\n            return null;\n        }\n        // Prefer the direct API.\n        if (type.parameters && type.parameters !== parentCtor.parameters) {\n            return type.parameters;\n        }\n        // API of tsickle for lowering decorators to properties on the class.\n        const tsickleCtorParams = type.ctorParameters;\n        if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {\n            // Newer tsickle uses a function closure\n            // Retain the non-function case for compatibility with older tsickle\n            const ctorParameters = typeof tsickleCtorParams === 'function' ? tsickleCtorParams() : tsickleCtorParams;\n            const paramTypes = ctorParameters.map((ctorParam) => ctorParam && ctorParam.type);\n            const paramAnnotations = ctorParameters.map((ctorParam) => ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));\n            return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n        }\n        // API for metadata created by invoking the decorators.\n        const paramAnnotations = type.hasOwnProperty(PARAMETERS) && type[PARAMETERS];\n        const paramTypes = this._reflect && this._reflect.getOwnMetadata &&\n            this._reflect.getOwnMetadata('design:paramtypes', type);\n        if (paramTypes || paramAnnotations) {\n            return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n        }\n        // If a class has no decorators, at least create metadata\n        // based on function.length.\n        // Note: We know that this is a real constructor as we checked\n        // the content of the constructor above.\n        return newArray(type.length);\n    }\n    parameters(type) {\n        // Note: only report metadata if we have at least one class decorator\n        // to stay in sync with the static reflector.\n        if (!isType(type)) {\n            return [];\n        }\n        const parentCtor = getParentCtor(type);\n        let parameters = this._ownParameters(type, parentCtor);\n        if (!parameters && parentCtor !== Object) {\n            parameters = this.parameters(parentCtor);\n        }\n        return parameters || [];\n    }\n    _ownAnnotations(typeOrFunc, parentCtor) {\n        // Prefer the direct API.\n        if (typeOrFunc.annotations && typeOrFunc.annotations !== parentCtor.annotations) {\n            let annotations = typeOrFunc.annotations;\n            if (typeof annotations === 'function' && annotations.annotations) {\n                annotations = annotations.annotations;\n            }\n            return annotations;\n        }\n        // API of tsickle for lowering decorators to properties on the class.\n        if (typeOrFunc.decorators && typeOrFunc.decorators !== parentCtor.decorators) {\n            return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);\n        }\n        // API for metadata created by invoking the decorators.\n        if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {\n            return typeOrFunc[ANNOTATIONS];\n        }\n        return null;\n    }\n    annotations(typeOrFunc) {\n        if (!isType(typeOrFunc)) {\n            return [];\n        }\n        const parentCtor = getParentCtor(typeOrFunc);\n        const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];\n        const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];\n        return parentAnnotations.concat(ownAnnotations);\n    }\n    _ownPropMetadata(typeOrFunc, parentCtor) {\n        // Prefer the direct API.\n        if (typeOrFunc.propMetadata &&\n            typeOrFunc.propMetadata !== parentCtor.propMetadata) {\n            let propMetadata = typeOrFunc.propMetadata;\n            if (typeof propMetadata === 'function' && propMetadata.propMetadata) {\n                propMetadata = propMetadata.propMetadata;\n            }\n            return propMetadata;\n        }\n        // API of tsickle for lowering decorators to properties on the class.\n        if (typeOrFunc.propDecorators &&\n            typeOrFunc.propDecorators !== parentCtor.propDecorators) {\n            const propDecorators = typeOrFunc.propDecorators;\n            const propMetadata = {};\n            Object.keys(propDecorators).forEach(prop => {\n                propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);\n            });\n            return propMetadata;\n        }\n        // API for metadata created by invoking the decorators.\n        if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {\n            return typeOrFunc[PROP_METADATA];\n        }\n        return null;\n    }\n    propMetadata(typeOrFunc) {\n        if (!isType(typeOrFunc)) {\n            return {};\n        }\n        const parentCtor = getParentCtor(typeOrFunc);\n        const propMetadata = {};\n        if (parentCtor !== Object) {\n            const parentPropMetadata = this.propMetadata(parentCtor);\n            Object.keys(parentPropMetadata).forEach((propName) => {\n                propMetadata[propName] = parentPropMetadata[propName];\n            });\n        }\n        const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);\n        if (ownPropMetadata) {\n            Object.keys(ownPropMetadata).forEach((propName) => {\n                const decorators = [];\n                if (propMetadata.hasOwnProperty(propName)) {\n                    decorators.push(...propMetadata[propName]);\n                }\n                decorators.push(...ownPropMetadata[propName]);\n                propMetadata[propName] = decorators;\n            });\n        }\n        return propMetadata;\n    }\n    ownPropMetadata(typeOrFunc) {\n        if (!isType(typeOrFunc)) {\n            return {};\n        }\n        return this._ownPropMetadata(typeOrFunc, getParentCtor(typeOrFunc)) || {};\n    }\n    hasLifecycleHook(type, lcProperty) {\n        return type instanceof Type && lcProperty in type.prototype;\n    }\n}\nfunction convertTsickleDecoratorIntoMetadata(decoratorInvocations) {\n    if (!decoratorInvocations) {\n        return [];\n    }\n    return decoratorInvocations.map(decoratorInvocation => {\n        const decoratorType = decoratorInvocation.type;\n        const annotationCls = decoratorType.annotationCls;\n        const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];\n        return new annotationCls(...annotationArgs);\n    });\n}\nfunction getParentCtor(ctor) {\n    const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;\n    const parentCtor = parentProto ? parentProto.constructor : null;\n    // Note: We always use `Object` as the null value\n    // to simplify checking later on.\n    return parentCtor || Object;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction ngDevModeResetPerfCounters() {\n    const locationString = typeof location !== 'undefined' ? location.toString() : '';\n    const newCounters = {\n        namedConstructors: locationString.indexOf('ngDevMode=namedConstructors') != -1,\n        firstCreatePass: 0,\n        tNode: 0,\n        tView: 0,\n        rendererCreateTextNode: 0,\n        rendererSetText: 0,\n        rendererCreateElement: 0,\n        rendererAddEventListener: 0,\n        rendererSetAttribute: 0,\n        rendererRemoveAttribute: 0,\n        rendererSetProperty: 0,\n        rendererSetClassName: 0,\n        rendererAddClass: 0,\n        rendererRemoveClass: 0,\n        rendererSetStyle: 0,\n        rendererRemoveStyle: 0,\n        rendererDestroy: 0,\n        rendererDestroyNode: 0,\n        rendererMoveNode: 0,\n        rendererRemoveNode: 0,\n        rendererAppendChild: 0,\n        rendererInsertBefore: 0,\n        rendererCreateComment: 0,\n    };\n    // Make sure to refer to ngDevMode as ['ngDevMode'] for closure.\n    const allowNgDevModeTrue = locationString.indexOf('ngDevMode=false') === -1;\n    _global$1['ngDevMode'] = allowNgDevModeTrue && newCounters;\n    return newCounters;\n}\n/**\n * This function checks to see if the `ngDevMode` has been set. If yes,\n * then we honor it, otherwise we default to dev mode with additional checks.\n *\n * The idea is that unless we are doing production build where we explicitly\n * set `ngDevMode == false` we should be helping the developer by providing\n * as much early warning and errors as possible.\n *\n * `ɵɵdefineComponent` is guaranteed to have been called before any component template functions\n * (and thus Ivy instructions), so a single initialization there is sufficient to ensure ngDevMode\n * is defined for the entire instruction set.\n *\n * When checking `ngDevMode` on toplevel, always init it before referencing it\n * (e.g. `((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode())`), otherwise you can\n *  get a `ReferenceError` like in https://github.com/angular/angular/issues/31595.\n *\n * Details on possible values for `ngDevMode` can be found on its docstring.\n *\n * NOTE:\n * - changes to the `ngDevMode` name must be synced with `compiler-cli/src/tooling.ts`.\n */\nfunction initNgDevMode() {\n    // The below checks are to ensure that calling `initNgDevMode` multiple times does not\n    // reset the counters.\n    // If the `ngDevMode` is not an object, then it means we have not created the perf counters\n    // yet.\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        if (typeof ngDevMode !== 'object') {\n            ngDevModeResetPerfCounters();\n        }\n        return typeof ngDevMode !== 'undefined' && !!ngDevMode;\n    }\n    return false;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Base URL for the error details page.\n *\n * Keep the files below in full sync:\n *  - packages/compiler-cli/src/ngtsc/diagnostics/src/error_details_base_url.ts\n *  - packages/core/src/error_details_base_url.ts\n */\nconst ERROR_DETAILS_PAGE_BASE_URL = 'https://angular.io/errors';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Class that represents a runtime error.\n * Formats and outputs the error message in a consistent way.\n *\n * Example:\n * ```\n *  throw new RuntimeError(\n *    RuntimeErrorCode.INJECTOR_ALREADY_DESTROYED,\n *    ngDevMode && 'Injector has already been destroyed.');\n * ```\n *\n * Note: the `message` argument contains a descriptive error message as a string in development\n * mode (when the `ngDevMode` is defined). In production mode (after tree-shaking pass), the\n * `message` argument becomes `false`, thus we account for it in the typings and the runtime logic.\n */\nclass RuntimeError extends Error {\n    constructor(code, message) {\n        super(formatRuntimeError(code, message));\n        this.code = code;\n    }\n}\n/**\n * Called to format a runtime error.\n * See additional info on the `message` argument type in the `RuntimeError` class description.\n */\nfunction formatRuntimeError(code, message) {\n    // Error code might be a negative number, which is a special marker that instructs the logic to\n    // generate a link to the error details page on angular.io.\n    const fullCode = `NG0${Math.abs(code)}`;\n    let errorMessage = `${fullCode}${message ? ': ' + message.trim() : ''}`;\n    if (ngDevMode && code < 0) {\n        const addPeriodSeparator = !errorMessage.match(/[.,;!?]$/);\n        const separator = addPeriodSeparator ? '.' : '';\n        errorMessage =\n            `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;\n    }\n    return errorMessage;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Used for stringify render output in Ivy.\n * Important! This function is very performance-sensitive and we should\n * be extra careful not to introduce megamorphic reads in it.\n * Check `core/test/render3/perf/render_stringify` for benchmarks and alternate implementations.\n */\nfunction renderStringify(value) {\n    if (typeof value === 'string')\n        return value;\n    if (value == null)\n        return '';\n    // Use `String` so that it invokes the `toString` method of the value. Note that this\n    // appears to be faster than calling `value.toString` (see `render_stringify` benchmark).\n    return String(value);\n}\n/**\n * Used to stringify a value so that it can be displayed in an error message.\n * Important! This function contains a megamorphic read and should only be\n * used for error messages.\n */\nfunction stringifyForError(value) {\n    if (typeof value === 'function')\n        return value.name || value.toString();\n    if (typeof value === 'object' && value != null && typeof value.type === 'function') {\n        return value.type.name || value.type.toString();\n    }\n    return renderStringify(value);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Called when directives inject each other (creating a circular dependency) */\nfunction throwCyclicDependencyError(token, path) {\n    const depPath = path ? `. Dependency path: ${path.join(' > ')} > ${token}` : '';\n    throw new RuntimeError(-200 /* RuntimeErrorCode.CYCLIC_DI_DEPENDENCY */, `Circular dependency in DI detected for ${token}${depPath}`);\n}\nfunction throwMixedMultiProviderError() {\n    throw new Error(`Cannot mix multi providers and regular providers`);\n}\nfunction throwInvalidProviderError(ngModuleType, providers, provider) {\n    if (ngModuleType && providers) {\n        const providerDetail = providers.map(v => v == provider ? '?' + provider + '?' : '...');\n        throw new Error(`Invalid provider for the NgModule '${stringify(ngModuleType)}' - only instances of Provider and Type are allowed, got: [${providerDetail.join(', ')}]`);\n    }\n    else if (provider.ɵproviders) {\n        throw new RuntimeError(207 /* RuntimeErrorCode.PROVIDER_IN_WRONG_CONTEXT */, `Invalid providers from 'importProvidersFrom' present in a non-environment injector. 'importProvidersFrom' can't be used for component providers.`);\n    }\n    else {\n        throw new Error('Invalid provider');\n    }\n}\n/** Throws an error when a token is not found in DI. */\nfunction throwProviderNotFoundError(token, injectorName) {\n    const injectorDetails = injectorName ? ` in ${injectorName}` : '';\n    throw new RuntimeError(-201 /* RuntimeErrorCode.PROVIDER_NOT_FOUND */, ngDevMode && `No provider for ${stringifyForError(token)} found${injectorDetails}`);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection flags for DI.\n *\n * @publicApi\n */\nvar InjectFlags;\n(function (InjectFlags) {\n    // TODO(alxhub): make this 'const' (and remove `InternalInjectFlags` enum) when ngc no longer\n    // writes exports of it into ngfactory files.\n    /** Check self and check parent injector if needed */\n    InjectFlags[InjectFlags[\"Default\"] = 0] = \"Default\";\n    /**\n     * Specifies that an injector should retrieve a dependency from any injector until reaching the\n     * host element of the current component. (Only used with Element Injector)\n     */\n    InjectFlags[InjectFlags[\"Host\"] = 1] = \"Host\";\n    /** Don't ascend to ancestors of the node requesting injection. */\n    InjectFlags[InjectFlags[\"Self\"] = 2] = \"Self\";\n    /** Skip the node that is requesting injection. */\n    InjectFlags[InjectFlags[\"SkipSelf\"] = 4] = \"SkipSelf\";\n    /** Inject `defaultValue` instead if token not found. */\n    InjectFlags[InjectFlags[\"Optional\"] = 8] = \"Optional\";\n})(InjectFlags || (InjectFlags = {}));\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Current implementation of inject.\n *\n * By default, it is `injectInjectorOnly`, which makes it `Injector`-only aware. It can be changed\n * to `directiveInject`, which brings in the `NodeInjector` system of ivy. It is designed this\n * way for two reasons:\n *  1. `Injector` should not depend on ivy logic.\n *  2. To maintain tree shake-ability we don't want to bring in unnecessary code.\n */\nlet _injectImplementation;\nfunction getInjectImplementation() {\n    return _injectImplementation;\n}\n/**\n * Sets the current inject implementation.\n */\nfunction setInjectImplementation(impl) {\n    const previous = _injectImplementation;\n    _injectImplementation = impl;\n    return previous;\n}\n/**\n * Injects `root` tokens in limp mode.\n *\n * If no injector exists, we can still inject tree-shakable providers which have `providedIn` set to\n * `\"root\"`. This is known as the limp mode injection. In such case the value is stored in the\n * injectable definition.\n */\nfunction injectRootLimpMode(token, notFoundValue, flags) {\n    const injectableDef = getInjectableDef(token);\n    if (injectableDef && injectableDef.providedIn == 'root') {\n        return injectableDef.value === undefined ? injectableDef.value = injectableDef.factory() :\n            injectableDef.value;\n    }\n    if (flags & InjectFlags.Optional)\n        return null;\n    if (notFoundValue !== undefined)\n        return notFoundValue;\n    throwProviderNotFoundError(stringify(token), 'Injector');\n}\n/**\n * Assert that `_injectImplementation` is not `fn`.\n *\n * This is useful, to prevent infinite recursion.\n *\n * @param fn Function which it should not equal to\n */\nfunction assertInjectImplementationNotEqual(fn) {\n    ngDevMode &&\n        assertNotEqual(_injectImplementation, fn, 'Calling ɵɵinject would cause infinite recursion');\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst _THROW_IF_NOT_FOUND = {};\nconst THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n/*\n * Name of a property (that we patch onto DI decorator), which is used as an annotation of which\n * InjectFlag this decorator represents. This allows to avoid direct references to the DI decorators\n * in the code, thus making them tree-shakable.\n */\nconst DI_DECORATOR_FLAG = '__NG_DI_FLAG__';\nconst NG_TEMP_TOKEN_PATH = 'ngTempTokenPath';\nconst NG_TOKEN_PATH = 'ngTokenPath';\nconst NEW_LINE = /\\n/gm;\nconst NO_NEW_LINE = 'ɵ';\nconst SOURCE = '__source';\n/**\n * Current injector value used by `inject`.\n * - `undefined`: it is an error to call `inject`\n * - `null`: `inject` can be called but there is no injector (limp-mode).\n * - Injector instance: Use the injector for resolution.\n */\nlet _currentInjector = undefined;\nfunction setCurrentInjector(injector) {\n    const former = _currentInjector;\n    _currentInjector = injector;\n    return former;\n}\nfunction injectInjectorOnly(token, flags = InjectFlags.Default) {\n    if (_currentInjector === undefined) {\n        throw new RuntimeError(-203 /* RuntimeErrorCode.MISSING_INJECTION_CONTEXT */, ngDevMode &&\n            `inject() must be called from an injection context (a constructor, a factory function or a field initializer)`);\n    }\n    else if (_currentInjector === null) {\n        return injectRootLimpMode(token, undefined, flags);\n    }\n    else {\n        return _currentInjector.get(token, flags & InjectFlags.Optional ? null : undefined, flags);\n    }\n}\nfunction ɵɵinject(token, flags = InjectFlags.Default) {\n    return (getInjectImplementation() || injectInjectorOnly)(resolveForwardRef(token), flags);\n}\n/**\n * Throws an error indicating that a factory function could not be generated by the compiler for a\n * particular class.\n *\n * This instruction allows the actual error message to be optimized away when ngDevMode is turned\n * off, saving bytes of generated code while still providing a good experience in dev mode.\n *\n * The name of the class is not mentioned here, but will be in the generated factory function name\n * and thus in the stack trace.\n *\n * @codeGenApi\n */\nfunction ɵɵinvalidFactoryDep(index) {\n    const msg = ngDevMode ?\n        `This constructor is not compatible with Angular Dependency Injection because its dependency at index ${index} of the parameter list is invalid.\nThis can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.\n\nPlease check that 1) the type for the parameter at index ${index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.` :\n        'invalid';\n    throw new Error(msg);\n}\n/**\n * Injects a token from the currently active injector.\n * `inject` is only supported during instantiation of a dependency by the DI system. It can be used\n * during:\n * - Construction (via the `constructor`) of a class being instantiated by the DI system, such\n * as an `@Injectable` or `@Component`.\n * - In the initializer for fields of such classes.\n * - In the factory function specified for `useFactory` of a `Provider` or an `@Injectable`.\n * - In the `factory` function specified for an `InjectionToken`.\n *\n * @param token A token that represents a dependency that should be injected.\n * @param flags Optional flags that control how injection is executed.\n * The flags correspond to injection strategies that can be specified with\n * parameter decorators `@Host`, `@Self`, `@SkipSef`, and `@Optional`.\n * @returns the injected value if operation is successful, `null` otherwise.\n * @throws if called outside of a supported context.\n *\n * @usageNotes\n * In practice the `inject()` calls are allowed in a constructor, a constructor parameter and a\n * field initializer:\n *\n * ```typescript\n * @Injectable({providedIn: 'root'})\n * export class Car {\n *   radio: Radio|undefined;\n *   // OK: field initializer\n *   spareTyre = inject(Tyre);\n *\n *   constructor() {\n *     // OK: constructor body\n *     this.radio = inject(Radio);\n *   }\n * }\n * ```\n *\n * It is also legal to call `inject` from a provider's factory:\n *\n * ```typescript\n * providers: [\n *   {provide: Car, useFactory: () => {\n *     // OK: a class factory\n *     const engine = inject(Engine);\n *     return new Car(engine);\n *   }}\n * ]\n * ```\n *\n * Calls to the `inject()` function outside of the class creation context will result in error. Most\n * notably, calls to `inject()` are disallowed after a class instance was created, in methods\n * (including lifecycle hooks):\n *\n * ```typescript\n * @Component({ ... })\n * export class CarComponent {\n *   ngOnInit() {\n *     // ERROR: too late, the component instance was already created\n *     const engine = inject(Engine);\n *     engine.start();\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nfunction inject$1(token, flags = InjectFlags.Default) {\n    return ɵɵinject(token, flags);\n}\nfunction injectArgs(types) {\n    const args = [];\n    for (let i = 0; i < types.length; i++) {\n        const arg = resolveForwardRef(types[i]);\n        if (Array.isArray(arg)) {\n            if (arg.length === 0) {\n                throw new RuntimeError(900 /* RuntimeErrorCode.INVALID_DIFFER_INPUT */, ngDevMode && 'Arguments array must have arguments.');\n            }\n            let type = undefined;\n            let flags = InjectFlags.Default;\n            for (let j = 0; j < arg.length; j++) {\n                const meta = arg[j];\n                const flag = getInjectFlag(meta);\n                if (typeof flag === 'number') {\n                    // Special case when we handle @Inject decorator.\n                    if (flag === -1 /* DecoratorFlags.Inject */) {\n                        type = meta.token;\n                    }\n                    else {\n                        flags |= flag;\n                    }\n                }\n                else {\n                    type = meta;\n                }\n            }\n            args.push(ɵɵinject(type, flags));\n        }\n        else {\n            args.push(ɵɵinject(arg));\n        }\n    }\n    return args;\n}\n/**\n * Attaches a given InjectFlag to a given decorator using monkey-patching.\n * Since DI decorators can be used in providers `deps` array (when provider is configured using\n * `useFactory`) without initialization (e.g. `Host`) and as an instance (e.g. `new Host()`), we\n * attach the flag to make it available both as a static property and as a field on decorator\n * instance.\n *\n * @param decorator Provided DI decorator.\n * @param flag InjectFlag that should be applied.\n */\nfunction attachInjectFlag(decorator, flag) {\n    decorator[DI_DECORATOR_FLAG] = flag;\n    decorator.prototype[DI_DECORATOR_FLAG] = flag;\n    return decorator;\n}\n/**\n * Reads monkey-patched property that contains InjectFlag attached to a decorator.\n *\n * @param token Token that may contain monkey-patched DI flags property.\n */\nfunction getInjectFlag(token) {\n    return token[DI_DECORATOR_FLAG];\n}\nfunction catchInjectorError(e, token, injectorErrorName, source) {\n    const tokenPath = e[NG_TEMP_TOKEN_PATH];\n    if (token[SOURCE]) {\n        tokenPath.unshift(token[SOURCE]);\n    }\n    e.message = formatError('\\n' + e.message, tokenPath, injectorErrorName, source);\n    e[NG_TOKEN_PATH] = tokenPath;\n    e[NG_TEMP_TOKEN_PATH] = null;\n    throw e;\n}\nfunction formatError(text, obj, injectorErrorName, source = null) {\n    text = text && text.charAt(0) === '\\n' && text.charAt(1) == NO_NEW_LINE ? text.slice(2) : text;\n    let context = stringify(obj);\n    if (Array.isArray(obj)) {\n        context = obj.map(stringify).join(' -> ');\n    }\n    else if (typeof obj === 'object') {\n        let parts = [];\n        for (let key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                let value = obj[key];\n                parts.push(key + ':' + (typeof value === 'string' ? JSON.stringify(value) : stringify(value)));\n            }\n        }\n        context = `{${parts.join(', ')}}`;\n    }\n    return `${injectorErrorName}${source ? '(' + source + ')' : ''}[${context}]: ${text.replace(NEW_LINE, '\\n  ')}`;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Inject decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Inject = attachInjectFlag(\n// Disable tslint because `DecoratorFlags` is a const enum which gets inlined.\n// tslint:disable-next-line: no-toplevel-property-access\nmakeParamDecorator('Inject', (token) => ({ token })), -1 /* DecoratorFlags.Inject */);\n/**\n * Optional decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Optional = \n// Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n// tslint:disable-next-line: no-toplevel-property-access\nattachInjectFlag(makeParamDecorator('Optional'), 8 /* InternalInjectFlags.Optional */);\n/**\n * Self decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Self = \n// Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n// tslint:disable-next-line: no-toplevel-property-access\nattachInjectFlag(makeParamDecorator('Self'), 2 /* InternalInjectFlags.Self */);\n/**\n * `SkipSelf` decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst SkipSelf = \n// Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n// tslint:disable-next-line: no-toplevel-property-access\nattachInjectFlag(makeParamDecorator('SkipSelf'), 4 /* InternalInjectFlags.SkipSelf */);\n/**\n * Host decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Host = \n// Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n// tslint:disable-next-line: no-toplevel-property-access\nattachInjectFlag(makeParamDecorator('Host'), 1 /* InternalInjectFlags.Host */);\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * The strategy that the default change detector uses to detect changes.\n * When set, takes effect the next time change detection is triggered.\n *\n * @see {@link ChangeDetectorRef#usage-notes Change detection usage}\n *\n * @publicApi\n */\nvar ChangeDetectionStrategy;\n(function (ChangeDetectionStrategy) {\n    /**\n     * Use the `CheckOnce` strategy, meaning that automatic change detection is deactivated\n     * until reactivated by setting the strategy to `Default` (`CheckAlways`).\n     * Change detection can still be explicitly invoked.\n     * This strategy applies to all child directives and cannot be overridden.\n     */\n    ChangeDetectionStrategy[ChangeDetectionStrategy[\"OnPush\"] = 0] = \"OnPush\";\n    /**\n     * Use the default `CheckAlways` strategy, in which change detection is automatic until\n     * explicitly deactivated.\n     */\n    ChangeDetectionStrategy[ChangeDetectionStrategy[\"Default\"] = 1] = \"Default\";\n})(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));\n/**\n * Defines the possible states of the default change detector.\n * @see `ChangeDetectorRef`\n */\nvar ChangeDetectorStatus;\n(function (ChangeDetectorStatus) {\n    /**\n     * A state in which, after calling `detectChanges()`, the change detector\n     * state becomes `Checked`, and must be explicitly invoked or reactivated.\n     */\n    ChangeDetectorStatus[ChangeDetectorStatus[\"CheckOnce\"] = 0] = \"CheckOnce\";\n    /**\n     * A state in which change detection is skipped until the change detector mode\n     * becomes `CheckOnce`.\n     */\n    ChangeDetectorStatus[ChangeDetectorStatus[\"Checked\"] = 1] = \"Checked\";\n    /**\n     * A state in which change detection continues automatically until explicitly\n     * deactivated.\n     */\n    ChangeDetectorStatus[ChangeDetectorStatus[\"CheckAlways\"] = 2] = \"CheckAlways\";\n    /**\n     * A state in which a change detector sub tree is not a part of the main tree and\n     * should be skipped.\n     */\n    ChangeDetectorStatus[ChangeDetectorStatus[\"Detached\"] = 3] = \"Detached\";\n    /**\n     * Indicates that the change detector encountered an error checking a binding\n     * or calling a directive lifecycle method and is now in an inconsistent state. Change\n     * detectors in this state do not detect changes.\n     */\n    ChangeDetectorStatus[ChangeDetectorStatus[\"Errored\"] = 4] = \"Errored\";\n    /**\n     * Indicates that the change detector has been destroyed.\n     */\n    ChangeDetectorStatus[ChangeDetectorStatus[\"Destroyed\"] = 5] = \"Destroyed\";\n})(ChangeDetectorStatus || (ChangeDetectorStatus = {}));\n/**\n * Reports whether a given strategy is currently the default for change detection.\n * @param changeDetectionStrategy The strategy to check.\n * @returns True if the given strategy is the current default, false otherwise.\n * @see `ChangeDetectorStatus`\n * @see `ChangeDetectorRef`\n */\nfunction isDefaultChangeDetectionStrategy(changeDetectionStrategy) {\n    return changeDetectionStrategy == null ||\n        changeDetectionStrategy === ChangeDetectionStrategy.Default;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Defines the CSS styles encapsulation policies for the {@link Component} decorator's\n * `encapsulation` option.\n *\n * See {@link Component#encapsulation encapsulation}.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/ts/metadata/encapsulation.ts region='longform'}\n *\n * @publicApi\n */\nvar ViewEncapsulation;\n(function (ViewEncapsulation) {\n    // TODO: consider making `ViewEncapsulation` a `const enum` instead. See\n    // https://github.com/angular/angular/issues/44119 for additional information.\n    /**\n     * Emulates a native Shadow DOM encapsulation behavior by adding a specific attribute to the\n     * component's host element and applying the same attribute to all the CSS selectors provided\n     * via {@link Component#styles styles} or {@link Component#styleUrls styleUrls}.\n     *\n     * This is the default option.\n     */\n    ViewEncapsulation[ViewEncapsulation[\"Emulated\"] = 0] = \"Emulated\";\n    // Historically the 1 value was for `Native` encapsulation which has been removed as of v11.\n    /**\n     * Doesn't provide any sort of CSS style encapsulation, meaning that all the styles provided\n     * via {@link Component#styles styles} or {@link Component#styleUrls styleUrls} are applicable\n     * to any HTML element of the application regardless of their host Component.\n     */\n    ViewEncapsulation[ViewEncapsulation[\"None\"] = 2] = \"None\";\n    /**\n     * Uses the browser's native Shadow DOM API to encapsulate CSS styles, meaning that it creates\n     * a ShadowRoot for the component's host element which is then used to encapsulate\n     * all the Component's styling.\n     */\n    ViewEncapsulation[ViewEncapsulation[\"ShadowDom\"] = 3] = \"ShadowDom\";\n})(ViewEncapsulation || (ViewEncapsulation = {}));\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * This file contains reuseable \"empty\" symbols that can be used as default return values\n * in different parts of the rendering code. Because the same symbols are returned, this\n * allows for identity checks against these values to be consistently used by the framework\n * code.\n */\nconst EMPTY_OBJ = {};\nconst EMPTY_ARRAY = [];\n// freezing the values prevents any code from accidentally inserting new values in\nif ((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode()) {\n    // These property accesses can be ignored because ngDevMode will be set to false\n    // when optimizing code and the whole if statement will be dropped.\n    // tslint:disable-next-line:no-toplevel-property-access\n    Object.freeze(EMPTY_OBJ);\n    // tslint:disable-next-line:no-toplevel-property-access\n    Object.freeze(EMPTY_ARRAY);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst NG_COMP_DEF = getClosureSafeProperty({ ɵcmp: getClosureSafeProperty });\nconst NG_DIR_DEF = getClosureSafeProperty({ ɵdir: getClosureSafeProperty });\nconst NG_PIPE_DEF = getClosureSafeProperty({ ɵpipe: getClosureSafeProperty });\nconst NG_MOD_DEF = getClosureSafeProperty({ ɵmod: getClosureSafeProperty });\nconst NG_FACTORY_DEF = getClosureSafeProperty({ ɵfac: getClosureSafeProperty });\n/**\n * If a directive is diPublic, bloomAdd sets a property on the type with this constant as\n * the key and the directive's unique ID as the value. This allows us to map directives to their\n * bloom filter bit for DI.\n */\n// TODO(misko): This is wrong. The NG_ELEMENT_ID should never be minified.\nconst NG_ELEMENT_ID = getClosureSafeProperty({ __NG_ELEMENT_ID__: getClosureSafeProperty });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Counter used to generate unique IDs for component definitions. */\nlet componentDefCount = 0;\n/**\n * Create a component definition object.\n *\n *\n * # Example\n * ```\n * class MyDirective {\n *   // Generated by Angular Template Compiler\n *   // [Symbol] syntax will not be supported by TypeScript until v2.7\n *   static ɵcmp = defineComponent({\n *     ...\n *   });\n * }\n * ```\n * @codeGenApi\n */\nfunction ɵɵdefineComponent(componentDefinition) {\n    return noSideEffects(() => {\n        // Initialize ngDevMode. This must be the first statement in ɵɵdefineComponent.\n        // See the `initNgDevMode` docstring for more information.\n        (typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode();\n        const type = componentDefinition.type;\n        const standalone = componentDefinition.standalone === true;\n        const declaredInputs = {};\n        const def = {\n            type: type,\n            providersResolver: null,\n            decls: componentDefinition.decls,\n            vars: componentDefinition.vars,\n            factory: null,\n            template: componentDefinition.template || null,\n            consts: componentDefinition.consts || null,\n            ngContentSelectors: componentDefinition.ngContentSelectors,\n            hostBindings: componentDefinition.hostBindings || null,\n            hostVars: componentDefinition.hostVars || 0,\n            hostAttrs: componentDefinition.hostAttrs || null,\n            contentQueries: componentDefinition.contentQueries || null,\n            declaredInputs: declaredInputs,\n            inputs: null,\n            outputs: null,\n            exportAs: componentDefinition.exportAs || null,\n            onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,\n            directiveDefs: null,\n            pipeDefs: null,\n            standalone,\n            dependencies: standalone && componentDefinition.dependencies || null,\n            getStandaloneInjector: null,\n            selectors: componentDefinition.selectors || EMPTY_ARRAY,\n            viewQuery: componentDefinition.viewQuery || null,\n            features: componentDefinition.features || null,\n            data: componentDefinition.data || {},\n            encapsulation: componentDefinition.encapsulation || ViewEncapsulation.Emulated,\n            id: `c${componentDefCount++}`,\n            styles: componentDefinition.styles || EMPTY_ARRAY,\n            _: null,\n            setInput: null,\n            schemas: componentDefinition.schemas || null,\n            tView: null,\n        };\n        const dependencies = componentDefinition.dependencies;\n        const feature = componentDefinition.features;\n        def.inputs = invertObject(componentDefinition.inputs, declaredInputs),\n            def.outputs = invertObject(componentDefinition.outputs),\n            feature && feature.forEach((fn) => fn(def));\n        def.directiveDefs = dependencies ?\n            (() => (typeof dependencies === 'function' ? dependencies() : dependencies)\n                .map(extractDirectiveDef)\n                .filter(nonNull)) :\n            null;\n        def.pipeDefs = dependencies ?\n            (() => (typeof dependencies === 'function' ? dependencies() : dependencies)\n                .map(getPipeDef$1)\n                .filter(nonNull)) :\n            null;\n        return def;\n    });\n}\n/**\n * Generated next to NgModules to monkey-patch directive and pipe references onto a component's\n * definition, when generating a direct reference in the component file would otherwise create an\n * import cycle.\n *\n * See [this explanation](https://hackmd.io/Odw80D0pR6yfsOjg_7XCJg?view) for more details.\n *\n * @codeGenApi\n */\nfunction ɵɵsetComponentScope(type, directives, pipes) {\n    const def = type.ɵcmp;\n    def.directiveDefs = () => (typeof directives === 'function' ? directives() : directives).map(extractDirectiveDef);\n    def.pipeDefs = () => (typeof pipes === 'function' ? pipes() : pipes).map(getPipeDef$1);\n}\nfunction extractDirectiveDef(type) {\n    return getComponentDef$1(type) || getDirectiveDef(type);\n}\nfunction nonNull(value) {\n    return value !== null;\n}\nconst autoRegisterModuleById = {};\n/**\n * @codeGenApi\n */\nfunction ɵɵdefineNgModule(def) {\n    return noSideEffects(() => {\n        const res = {\n            type: def.type,\n            bootstrap: def.bootstrap || EMPTY_ARRAY,\n            declarations: def.declarations || EMPTY_ARRAY,\n            imports: def.imports || EMPTY_ARRAY,\n            exports: def.exports || EMPTY_ARRAY,\n            transitiveCompileScopes: null,\n            schemas: def.schemas || null,\n            id: def.id || null,\n        };\n        if (def.id != null) {\n            autoRegisterModuleById[def.id] = def.type;\n        }\n        return res;\n    });\n}\n/**\n * Adds the module metadata that is necessary to compute the module's transitive scope to an\n * existing module definition.\n *\n * Scope metadata of modules is not used in production builds, so calls to this function can be\n * marked pure to tree-shake it from the bundle, allowing for all referenced declarations\n * to become eligible for tree-shaking as well.\n *\n * @codeGenApi\n */\nfunction ɵɵsetNgModuleScope(type, scope) {\n    return noSideEffects(() => {\n        const ngModuleDef = getNgModuleDef(type, true);\n        ngModuleDef.declarations = scope.declarations || EMPTY_ARRAY;\n        ngModuleDef.imports = scope.imports || EMPTY_ARRAY;\n        ngModuleDef.exports = scope.exports || EMPTY_ARRAY;\n    });\n}\n/**\n * Inverts an inputs or outputs lookup such that the keys, which were the\n * minified keys, are part of the values, and the values are parsed so that\n * the publicName of the property is the new key\n *\n * e.g. for\n *\n * ```\n * class Comp {\n *   @Input()\n *   propName1: string;\n *\n *   @Input('publicName2')\n *   declaredPropName2: number;\n * }\n * ```\n *\n * will be serialized as\n *\n * ```\n * {\n *   propName1: 'propName1',\n *   declaredPropName2: ['publicName2', 'declaredPropName2'],\n * }\n * ```\n *\n * which is than translated by the minifier as:\n *\n * ```\n * {\n *   minifiedPropName1: 'propName1',\n *   minifiedPropName2: ['publicName2', 'declaredPropName2'],\n * }\n * ```\n *\n * becomes: (public name => minifiedName)\n *\n * ```\n * {\n *  'propName1': 'minifiedPropName1',\n *  'publicName2': 'minifiedPropName2',\n * }\n * ```\n *\n * Optionally the function can take `secondary` which will result in: (public name => declared name)\n *\n * ```\n * {\n *  'propName1': 'propName1',\n *  'publicName2': 'declaredPropName2',\n * }\n * ```\n *\n\n */\nfunction invertObject(obj, secondary) {\n    if (obj == null)\n        return EMPTY_OBJ;\n    const newLookup = {};\n    for (const minifiedKey in obj) {\n        if (obj.hasOwnProperty(minifiedKey)) {\n            let publicName = obj[minifiedKey];\n            let declaredName = publicName;\n            if (Array.isArray(publicName)) {\n                declaredName = publicName[1];\n                publicName = publicName[0];\n            }\n            newLookup[publicName] = minifiedKey;\n            if (secondary) {\n                (secondary[publicName] = declaredName);\n            }\n        }\n    }\n    return newLookup;\n}\n/**\n * Create a directive definition object.\n *\n * # Example\n * ```ts\n * class MyDirective {\n *   // Generated by Angular Template Compiler\n *   // [Symbol] syntax will not be supported by TypeScript until v2.7\n *   static ɵdir = ɵɵdefineDirective({\n *     ...\n *   });\n * }\n * ```\n *\n * @codeGenApi\n */\nconst ɵɵdefineDirective = ɵɵdefineComponent;\n/**\n * Create a pipe definition object.\n *\n * # Example\n * ```\n * class MyPipe implements PipeTransform {\n *   // Generated by Angular Template Compiler\n *   static ɵpipe = definePipe({\n *     ...\n *   });\n * }\n * ```\n * @param pipeDef Pipe definition generated by the compiler\n *\n * @codeGenApi\n */\nfunction ɵɵdefinePipe(pipeDef) {\n    return {\n        type: pipeDef.type,\n        name: pipeDef.name,\n        factory: null,\n        pure: pipeDef.pure !== false,\n        standalone: pipeDef.standalone === true,\n        onDestroy: pipeDef.type.prototype.ngOnDestroy || null\n    };\n}\n/**\n * The following getter methods retrieve the definition from the type. Currently the retrieval\n * honors inheritance, but in the future we may change the rule to require that definitions are\n * explicit. This would require some sort of migration strategy.\n */\nfunction getComponentDef$1(type) {\n    return type[NG_COMP_DEF] || null;\n}\nfunction getDirectiveDef(type) {\n    return type[NG_DIR_DEF] || null;\n}\nfunction getPipeDef$1(type) {\n    return type[NG_PIPE_DEF] || null;\n}\nfunction getNgModuleDef(type, throwNotFound) {\n    const ngModuleDef = type[NG_MOD_DEF] || null;\n    if (!ngModuleDef && throwNotFound === true) {\n        throw new Error(`Type ${stringify(type)} does not have 'ɵmod' property.`);\n    }\n    return ngModuleDef;\n}\n\n/**\n * Special location which allows easy identification of type. If we have an array which was\n * retrieved from the `LView` and that array has `true` at `TYPE` location, we know it is\n * `LContainer`.\n */\nconst TYPE = 1;\n/**\n * Below are constants for LContainer indices to help us look up LContainer members\n * without having to remember the specific indices.\n * Uglify will inline these when minifying so there shouldn't be a cost.\n */\n/**\n * Flag to signify that this `LContainer` may have transplanted views which need to be change\n * detected. (see: `LView[DECLARATION_COMPONENT_VIEW])`.\n *\n * This flag, once set, is never unset for the `LContainer`. This means that when unset we can skip\n * a lot of work in `refreshEmbeddedViews`. But when set we still need to verify\n * that the `MOVED_VIEWS` are transplanted and on-push.\n */\nconst HAS_TRANSPLANTED_VIEWS = 2;\n// PARENT, NEXT, TRANSPLANTED_VIEWS_TO_REFRESH are indices 3, 4, and 5\n// As we already have these constants in LView, we don't need to re-create them.\n// T_HOST is index 6\n// We already have this constants in LView, we don't need to re-create it.\nconst NATIVE = 7;\nconst VIEW_REFS = 8;\nconst MOVED_VIEWS = 9;\n/**\n * Size of LContainer's header. Represents the index after which all views in the\n * container will be inserted. We need to keep a record of current views so we know\n * which views are already in the DOM (and don't need to be re-added) and so we can\n * remove views from the DOM when they are no longer required.\n */\nconst CONTAINER_HEADER_OFFSET = 10;\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nconst unusedValueExportToPlacateAjd$8 = 1;\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Below are constants for LView indices to help us look up LView members\n// without having to remember the specific indices.\n// Uglify will inline these when minifying so there shouldn't be a cost.\nconst HOST = 0;\nconst TVIEW = 1;\nconst FLAGS = 2;\nconst PARENT = 3;\nconst NEXT = 4;\nconst TRANSPLANTED_VIEWS_TO_REFRESH = 5;\nconst T_HOST = 6;\nconst CLEANUP = 7;\nconst CONTEXT = 8;\nconst INJECTOR$1 = 9;\nconst RENDERER_FACTORY = 10;\nconst RENDERER = 11;\nconst SANITIZER = 12;\nconst CHILD_HEAD = 13;\nconst CHILD_TAIL = 14;\n// FIXME(misko): Investigate if the three declarations aren't all same thing.\nconst DECLARATION_VIEW = 15;\nconst DECLARATION_COMPONENT_VIEW = 16;\nconst DECLARATION_LCONTAINER = 17;\nconst PREORDER_HOOK_FLAGS = 18;\nconst QUERIES = 19;\nconst ID = 20;\nconst EMBEDDED_VIEW_INJECTOR = 21;\n/**\n * Size of LView's header. Necessary to adjust for it when setting slots.\n *\n * IMPORTANT: `HEADER_OFFSET` should only be referred to the in the `ɵɵ*` instructions to translate\n * instruction index into `LView` index. All other indexes should be in the `LView` index space and\n * there should be no need to refer to `HEADER_OFFSET` anywhere else.\n */\nconst HEADER_OFFSET = 22;\n/**\n * Converts `TViewType` into human readable text.\n * Make sure this matches with `TViewType`\n */\nconst TViewTypeAsString = [\n    'Root',\n    'Component',\n    'Embedded', // 2\n];\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nconst unusedValueExportToPlacateAjd$7 = 1;\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * True if `value` is `LView`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nfunction isLView(value) {\n    return Array.isArray(value) && typeof value[TYPE] === 'object';\n}\n/**\n * True if `value` is `LContainer`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nfunction isLContainer(value) {\n    return Array.isArray(value) && value[TYPE] === true;\n}\nfunction isContentQueryHost(tNode) {\n    return (tNode.flags & 8 /* TNodeFlags.hasContentQuery */) !== 0;\n}\nfunction isComponentHost(tNode) {\n    return (tNode.flags & 2 /* TNodeFlags.isComponentHost */) === 2 /* TNodeFlags.isComponentHost */;\n}\nfunction isDirectiveHost(tNode) {\n    return (tNode.flags & 1 /* TNodeFlags.isDirectiveHost */) === 1 /* TNodeFlags.isDirectiveHost */;\n}\nfunction isComponentDef(def) {\n    return def.template !== null;\n}\nfunction isRootView(target) {\n    return (target[FLAGS] & 256 /* LViewFlags.IsRoot */) !== 0;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// [Assert functions do not constraint type when they are guarded by a truthy\n// expression.](https://github.com/microsoft/TypeScript/issues/37295)\nfunction assertTNodeForLView(tNode, lView) {\n    assertTNodeForTView(tNode, lView[TVIEW]);\n}\nfunction assertTNodeForTView(tNode, tView) {\n    assertTNode(tNode);\n    tNode.hasOwnProperty('tView_') &&\n        assertEqual(tNode.tView_, tView, 'This TNode does not belong to this TView.');\n}\nfunction assertTNode(tNode) {\n    assertDefined(tNode, 'TNode must be defined');\n    if (!(tNode && typeof tNode === 'object' && tNode.hasOwnProperty('directiveStylingLast'))) {\n        throwError('Not of type TNode, got: ' + tNode);\n    }\n}\nfunction assertTIcu(tIcu) {\n    assertDefined(tIcu, 'Expected TIcu to be defined');\n    if (!(typeof tIcu.currentCaseLViewIndex === 'number')) {\n        throwError('Object is not of TIcu type.');\n    }\n}\nfunction assertComponentType(actual, msg = 'Type passed in is not ComponentType, it does not have \\'ɵcmp\\' property.') {\n    if (!getComponentDef$1(actual)) {\n        throwError(msg);\n    }\n}\nfunction assertNgModuleType(actual, msg = 'Type passed in is not NgModuleType, it does not have \\'ɵmod\\' property.') {\n    if (!getNgModuleDef(actual)) {\n        throwError(msg);\n    }\n}\nfunction assertCurrentTNodeIsParent(isParent) {\n    assertEqual(isParent, true, 'currentTNode should be a parent');\n}\nfunction assertHasParent(tNode) {\n    assertDefined(tNode, 'currentTNode should exist!');\n    assertDefined(tNode.parent, 'currentTNode should have a parent');\n}\nfunction assertDataNext(lView, index, arr) {\n    if (arr == null)\n        arr = lView;\n    assertEqual(arr.length, index, `index ${index} expected to be at the end of arr (length ${arr.length})`);\n}\nfunction assertLContainer(value) {\n    assertDefined(value, 'LContainer must be defined');\n    assertEqual(isLContainer(value), true, 'Expecting LContainer');\n}\nfunction assertLViewOrUndefined(value) {\n    value && assertEqual(isLView(value), true, 'Expecting LView or undefined or null');\n}\nfunction assertLView(value) {\n    assertDefined(value, 'LView must be defined');\n    assertEqual(isLView(value), true, 'Expecting LView');\n}\nfunction assertFirstCreatePass(tView, errMessage) {\n    assertEqual(tView.firstCreatePass, true, errMessage || 'Should only be called in first create pass.');\n}\nfunction assertFirstUpdatePass(tView, errMessage) {\n    assertEqual(tView.firstUpdatePass, true, errMessage || 'Should only be called in first update pass.');\n}\n/**\n * This is a basic sanity check that an object is probably a directive def. DirectiveDef is\n * an interface, so we can't do a direct instanceof check.\n */\nfunction assertDirectiveDef(obj) {\n    if (obj.type === undefined || obj.selectors == undefined || obj.inputs === undefined) {\n        throwError(`Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);\n    }\n}\nfunction assertIndexInDeclRange(lView, index) {\n    const tView = lView[1];\n    assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index);\n}\nfunction assertIndexInVarsRange(lView, index) {\n    const tView = lView[1];\n    assertBetween(tView.bindingStartIndex, tView.expandoStartIndex, index);\n}\nfunction assertIndexInExpandoRange(lView, index) {\n    const tView = lView[1];\n    assertBetween(tView.expandoStartIndex, lView.length, index);\n}\nfunction assertBetween(lower, upper, index) {\n    if (!(lower <= index && index < upper)) {\n        throwError(`Index out of range (expecting ${lower} <= ${index} < ${upper})`);\n    }\n}\nfunction assertProjectionSlots(lView, errMessage) {\n    assertDefined(lView[DECLARATION_COMPONENT_VIEW], 'Component views should exist.');\n    assertDefined(lView[DECLARATION_COMPONENT_VIEW][T_HOST].projection, errMessage ||\n        'Components with projection nodes (<ng-content>) must have projection slots defined.');\n}\nfunction assertParentView(lView, errMessage) {\n    assertDefined(lView, errMessage || 'Component views should always have a parent view (component\\'s host view)');\n}\n/**\n * This is a basic sanity check that the `injectorIndex` seems to point to what looks like a\n * NodeInjector data structure.\n *\n * @param lView `LView` which should be checked.\n * @param injectorIndex index into the `LView` where the `NodeInjector` is expected.\n */\nfunction assertNodeInjector(lView, injectorIndex) {\n    assertIndexInExpandoRange(lView, injectorIndex);\n    assertIndexInExpandoRange(lView, injectorIndex + 8 /* NodeInjectorOffset.PARENT */);\n    assertNumber(lView[injectorIndex + 0], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 1], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 2], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 3], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 4], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 5], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 6], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 7], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 8 /* NodeInjectorOffset.PARENT */], 'injectorIndex should point to parent injector');\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction getFactoryDef(type, throwNotFound) {\n    const hasFactoryDef = type.hasOwnProperty(NG_FACTORY_DEF);\n    if (!hasFactoryDef && throwNotFound === true && ngDevMode) {\n        throw new Error(`Type ${stringify(type)} does not have 'ɵfac' property.`);\n    }\n    return hasFactoryDef ? type[NG_FACTORY_DEF] : null;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Represents a basic change from a previous to a new value for a single\n * property on a directive instance. Passed as a value in a\n * {@link SimpleChanges} object to the `ngOnChanges` hook.\n *\n * @see `OnChanges`\n *\n * @publicApi\n */\nclass SimpleChange {\n    constructor(previousValue, currentValue, firstChange) {\n        this.previousValue = previousValue;\n        this.currentValue = currentValue;\n        this.firstChange = firstChange;\n    }\n    /**\n     * Check whether the new value is the first value assigned.\n     */\n    isFirstChange() {\n        return this.firstChange;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * The NgOnChangesFeature decorates a component with support for the ngOnChanges\n * lifecycle hook, so it should be included in any component that implements\n * that hook.\n *\n * If the component or directive uses inheritance, the NgOnChangesFeature MUST\n * be included as a feature AFTER {@link InheritDefinitionFeature}, otherwise\n * inherited properties will not be propagated to the ngOnChanges lifecycle\n * hook.\n *\n * Example usage:\n *\n * ```\n * static ɵcmp = defineComponent({\n *   ...\n *   inputs: {name: 'publicName'},\n *   features: [NgOnChangesFeature]\n * });\n * ```\n *\n * @codeGenApi\n */\nfunction ɵɵNgOnChangesFeature() {\n    return NgOnChangesFeatureImpl;\n}\nfunction NgOnChangesFeatureImpl(definition) {\n    if (definition.type.prototype.ngOnChanges) {\n        definition.setInput = ngOnChangesSetInput;\n    }\n    return rememberChangeHistoryAndInvokeOnChangesHook;\n}\n// This option ensures that the ngOnChanges lifecycle hook will be inherited\n// from superclasses (in InheritDefinitionFeature).\n/** @nocollapse */\n// tslint:disable-next-line:no-toplevel-property-access\nɵɵNgOnChangesFeature.ngInherit = true;\n/**\n * This is a synthetic lifecycle hook which gets inserted into `TView.preOrderHooks` to simulate\n * `ngOnChanges`.\n *\n * The hook reads the `NgSimpleChangesStore` data from the component instance and if changes are\n * found it invokes `ngOnChanges` on the component instance.\n *\n * @param this Component instance. Because this function gets inserted into `TView.preOrderHooks`,\n *     it is guaranteed to be called with component instance.\n */\nfunction rememberChangeHistoryAndInvokeOnChangesHook() {\n    const simpleChangesStore = getSimpleChangesStore(this);\n    const current = simpleChangesStore === null || simpleChangesStore === void 0 ? void 0 : simpleChangesStore.current;\n    if (current) {\n        const previous = simpleChangesStore.previous;\n        if (previous === EMPTY_OBJ) {\n            simpleChangesStore.previous = current;\n        }\n        else {\n            // New changes are copied to the previous store, so that we don't lose history for inputs\n            // which were not changed this time\n            for (let key in current) {\n                previous[key] = current[key];\n            }\n        }\n        simpleChangesStore.current = null;\n        this.ngOnChanges(current);\n    }\n}\nfunction ngOnChangesSetInput(instance, value, publicName, privateName) {\n    const simpleChangesStore = getSimpleChangesStore(instance) ||\n        setSimpleChangesStore(instance, { previous: EMPTY_OBJ, current: null });\n    const current = simpleChangesStore.current || (simpleChangesStore.current = {});\n    const previous = simpleChangesStore.previous;\n    const declaredName = this.declaredInputs[publicName];\n    const previousChange = previous[declaredName];\n    current[declaredName] = new SimpleChange(previousChange && previousChange.currentValue, value, previous === EMPTY_OBJ);\n    instance[privateName] = value;\n}\nconst SIMPLE_CHANGES_STORE = '__ngSimpleChanges__';\nfunction getSimpleChangesStore(instance) {\n    return instance[SIMPLE_CHANGES_STORE] || null;\n}\nfunction setSimpleChangesStore(instance, store) {\n    return instance[SIMPLE_CHANGES_STORE] = store;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nlet profilerCallback = null;\n/**\n * Sets the callback function which will be invoked before and after performing certain actions at\n * runtime (for example, before and after running change detection).\n *\n * Warning: this function is *INTERNAL* and should not be relied upon in application's code.\n * The contract of the function might be changed in any release and/or the function can be removed\n * completely.\n *\n * @param profiler function provided by the caller or null value to disable profiling.\n */\nconst setProfiler = (profiler) => {\n    profilerCallback = profiler;\n};\n/**\n * Profiler function which wraps user code executed by the runtime.\n *\n * @param event ProfilerEvent corresponding to the execution context\n * @param instance component instance\n * @param hookOrListener lifecycle hook function or output listener. The value depends on the\n *  execution context\n * @returns\n */\nconst profiler = function (event, instance, hookOrListener) {\n    if (profilerCallback != null /* both `null` and `undefined` */) {\n        profilerCallback(event, instance, hookOrListener);\n    }\n};\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst SVG_NAMESPACE = 'svg';\nconst SVG_NAMESPACE_URI = 'http://www.w3.org/2000/svg';\nconst MATH_ML_NAMESPACE = 'math';\nconst MATH_ML_NAMESPACE_URI = 'http://www.w3.org/1998/MathML/';\nfunction getNamespaceUri(namespace) {\n    const name = namespace.toLowerCase();\n    return name === SVG_NAMESPACE ? SVG_NAMESPACE_URI :\n        (name === MATH_ML_NAMESPACE ? MATH_ML_NAMESPACE_URI : null);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Most of the use of `document` in Angular is from within the DI system so it is possible to simply\n * inject the `DOCUMENT` token and are done.\n *\n * Ivy is special because it does not rely upon the DI and must get hold of the document some other\n * way.\n *\n * The solution is to define `getDocument()` and `setDocument()` top-level functions for ivy.\n * Wherever ivy needs the global document, it calls `getDocument()` instead.\n *\n * When running ivy outside of a browser environment, it is necessary to call `setDocument()` to\n * tell ivy what the global `document` is.\n *\n * Angular does this for us in each of the standard platforms (`Browser`, `Server`, and `WebWorker`)\n * by calling `setDocument()` when providing the `DOCUMENT` token.\n */\nlet DOCUMENT = undefined;\n/**\n * Tell ivy what the `document` is for this platform.\n *\n * It is only necessary to call this if the current platform is not a browser.\n *\n * @param document The object representing the global `document` in this environment.\n */\nfunction setDocument(document) {\n    DOCUMENT = document;\n}\n/**\n * Access the object that represents the `document` for this platform.\n *\n * Ivy calls this whenever it needs to access the `document` object.\n * For example to create the renderer or to do sanitization.\n */\nfunction getDocument() {\n    if (DOCUMENT !== undefined) {\n        return DOCUMENT;\n    }\n    else if (typeof document !== 'undefined') {\n        return document;\n    }\n    // No \"document\" can be found. This should only happen if we are running ivy outside Angular and\n    // the current platform is not a browser. Since this is not a supported scenario at the moment\n    // this should not happen in Angular apps.\n    // Once we support running ivy outside of Angular we will need to publish `setDocument()` as a\n    // public API. Meanwhile we just return `undefined` and let the application fail.\n    return undefined;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// TODO: cleanup once the code is merged in angular/angular\nvar RendererStyleFlags3;\n(function (RendererStyleFlags3) {\n    RendererStyleFlags3[RendererStyleFlags3[\"Important\"] = 1] = \"Important\";\n    RendererStyleFlags3[RendererStyleFlags3[\"DashCase\"] = 2] = \"DashCase\";\n})(RendererStyleFlags3 || (RendererStyleFlags3 = {}));\n/** Returns whether the `renderer` is a `ProceduralRenderer3` */\nfunction isProceduralRenderer(renderer) {\n    return !!(renderer.listen);\n}\nconst domRendererFactory3 = {\n    createRenderer: (hostElement, rendererType) => {\n        return getDocument();\n    }\n};\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nconst unusedValueExportToPlacateAjd$6 = 1;\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * For efficiency reasons we often put several different data types (`RNode`, `LView`, `LContainer`)\n * in same location in `LView`. This is because we don't want to pre-allocate space for it\n * because the storage is sparse. This file contains utilities for dealing with such data types.\n *\n * How do we know what is stored at a given location in `LView`.\n * - `Array.isArray(value) === false` => `RNode` (The normal storage value)\n * - `Array.isArray(value) === true` => then the `value[0]` represents the wrapped value.\n *   - `typeof value[TYPE] === 'object'` => `LView`\n *      - This happens when we have a component at a given location\n *   - `typeof value[TYPE] === true` => `LContainer`\n *      - This happens when we have `LContainer` binding at a given location.\n *\n *\n * NOTE: it is assumed that `Array.isArray` and `typeof` operations are very efficient.\n */\n/**\n * Returns `RNode`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nfunction unwrapRNode(value) {\n    while (Array.isArray(value)) {\n        value = value[HOST];\n    }\n    return value;\n}\n/**\n * Returns `LView` or `null` if not found.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nfunction unwrapLView(value) {\n    while (Array.isArray(value)) {\n        // This check is same as `isLView()` but we don't call at as we don't want to call\n        // `Array.isArray()` twice and give JITer more work for inlining.\n        if (typeof value[TYPE] === 'object')\n            return value;\n        value = value[HOST];\n    }\n    return null;\n}\n/**\n * Returns `LContainer` or `null` if not found.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nfunction unwrapLContainer(value) {\n    while (Array.isArray(value)) {\n        // This check is same as `isLContainer()` but we don't call at as we don't want to call\n        // `Array.isArray()` twice and give JITer more work for inlining.\n        if (value[TYPE] === true)\n            return value;\n        value = value[HOST];\n    }\n    return null;\n}\n/**\n * Retrieves an element value from the provided `viewData`, by unwrapping\n * from any containers, component views, or style contexts.\n */\nfunction getNativeByIndex(index, lView) {\n    ngDevMode && assertIndexInRange(lView, index);\n    ngDevMode && assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Expected to be past HEADER_OFFSET');\n    return unwrapRNode(lView[index]);\n}\n/**\n * Retrieve an `RNode` for a given `TNode` and `LView`.\n *\n * This function guarantees in dev mode to retrieve a non-null `RNode`.\n *\n * @param tNode\n * @param lView\n */\nfunction getNativeByTNode(tNode, lView) {\n    ngDevMode && assertTNodeForLView(tNode, lView);\n    ngDevMode && assertIndexInRange(lView, tNode.index);\n    const node = unwrapRNode(lView[tNode.index]);\n    ngDevMode && !isProceduralRenderer(lView[RENDERER]) && assertDomNode(node);\n    return node;\n}\n/**\n * Retrieve an `RNode` or `null` for a given `TNode` and `LView`.\n *\n * Some `TNode`s don't have associated `RNode`s. For example `Projection`\n *\n * @param tNode\n * @param lView\n */\nfunction getNativeByTNodeOrNull(tNode, lView) {\n    const index = tNode === null ? -1 : tNode.index;\n    if (index !== -1) {\n        ngDevMode && assertTNodeForLView(tNode, lView);\n        const node = unwrapRNode(lView[index]);\n        ngDevMode && node !== null && !isProceduralRenderer(lView[RENDERER]) && assertDomNode(node);\n        return node;\n    }\n    return null;\n}\n// fixme(misko): The return Type should be `TNode|null`\nfunction getTNode(tView, index) {\n    ngDevMode && assertGreaterThan(index, -1, 'wrong index for TNode');\n    ngDevMode && assertLessThan(index, tView.data.length, 'wrong index for TNode');\n    const tNode = tView.data[index];\n    ngDevMode && tNode !== null && assertTNode(tNode);\n    return tNode;\n}\n/** Retrieves a value from any `LView` or `TData`. */\nfunction load(view, index) {\n    ngDevMode && assertIndexInRange(view, index);\n    return view[index];\n}\nfunction getComponentLViewByIndex(nodeIndex, hostView) {\n    // Could be an LView or an LContainer. If LContainer, unwrap to find LView.\n    ngDevMode && assertIndexInRange(hostView, nodeIndex);\n    const slotValue = hostView[nodeIndex];\n    const lView = isLView(slotValue) ? slotValue : slotValue[HOST];\n    return lView;\n}\n/** Checks whether a given view is in creation mode */\nfunction isCreationMode(view) {\n    return (view[FLAGS] & 4 /* LViewFlags.CreationMode */) === 4 /* LViewFlags.CreationMode */;\n}\n/**\n * Returns a boolean for whether the view is attached to the change detection tree.\n *\n * Note: This determines whether a view should be checked, not whether it's inserted\n * into a container. For that, you'll want `viewAttachedToContainer` below.\n */\nfunction viewAttachedToChangeDetector(view) {\n    return (view[FLAGS] & 64 /* LViewFlags.Attached */) === 64 /* LViewFlags.Attached */;\n}\n/** Returns a boolean for whether the view is attached to a container. */\nfunction viewAttachedToContainer(view) {\n    return isLContainer(view[PARENT]);\n}\nfunction getConstant(consts, index) {\n    if (index === null || index === undefined)\n        return null;\n    ngDevMode && assertIndexInRange(consts, index);\n    return consts[index];\n}\n/**\n * Resets the pre-order hook flags of the view.\n * @param lView the LView on which the flags are reset\n */\nfunction resetPreOrderHookFlags(lView) {\n    lView[PREORDER_HOOK_FLAGS] = 0;\n}\n/**\n * Updates the `TRANSPLANTED_VIEWS_TO_REFRESH` counter on the `LContainer` as well as the parents\n * whose\n *  1. counter goes from 0 to 1, indicating that there is a new child that has a view to refresh\n *  or\n *  2. counter goes from 1 to 0, indicating there are no more descendant views to refresh\n */\nfunction updateTransplantedViewCount(lContainer, amount) {\n    lContainer[TRANSPLANTED_VIEWS_TO_REFRESH] += amount;\n    let viewOrContainer = lContainer;\n    let parent = lContainer[PARENT];\n    while (parent !== null &&\n        ((amount === 1 && viewOrContainer[TRANSPLANTED_VIEWS_TO_REFRESH] === 1) ||\n            (amount === -1 && viewOrContainer[TRANSPLANTED_VIEWS_TO_REFRESH] === 0))) {\n        parent[TRANSPLANTED_VIEWS_TO_REFRESH] += amount;\n        viewOrContainer = parent;\n        parent = parent[PARENT];\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst instructionState = {\n    lFrame: createLFrame(null),\n    bindingsEnabled: true,\n};\n/**\n * In this mode, any changes in bindings will throw an ExpressionChangedAfterChecked error.\n *\n * Necessary to support ChangeDetectorRef.checkNoChanges().\n *\n * The `checkNoChanges` function is invoked only in ngDevMode=true and verifies that no unintended\n * changes exist in the change detector or its children.\n */\nlet _isInCheckNoChangesMode = false;\n/**\n * Returns true if the instruction state stack is empty.\n *\n * Intended to be called from tests only (tree shaken otherwise).\n */\nfunction specOnlyIsInstructionStateEmpty() {\n    return instructionState.lFrame.parent === null;\n}\nfunction getElementDepthCount() {\n    return instructionState.lFrame.elementDepthCount;\n}\nfunction increaseElementDepthCount() {\n    instructionState.lFrame.elementDepthCount++;\n}\nfunction decreaseElementDepthCount() {\n    instructionState.lFrame.elementDepthCount--;\n}\nfunction getBindingsEnabled() {\n    return instructionState.bindingsEnabled;\n}\n/**\n * Enables directive matching on elements.\n *\n *  * Example:\n * ```\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- ɵɵdisableBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- ɵɵenableBindings() -->\n * </div>\n * ```\n *\n * @codeGenApi\n */\nfunction ɵɵenableBindings() {\n    instructionState.bindingsEnabled = true;\n}\n/**\n * Disables directive matching on element.\n *\n *  * Example:\n * ```\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- ɵɵdisableBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- ɵɵenableBindings() -->\n * </div>\n * ```\n *\n * @codeGenApi\n */\nfunction ɵɵdisableBindings() {\n    instructionState.bindingsEnabled = false;\n}\n/**\n * Return the current `LView`.\n */\nfunction getLView() {\n    return instructionState.lFrame.lView;\n}\n/**\n * Return the current `TView`.\n */\nfunction getTView() {\n    return instructionState.lFrame.tView;\n}\n/**\n * Restores `contextViewData` to the given OpaqueViewState instance.\n *\n * Used in conjunction with the getCurrentView() instruction to save a snapshot\n * of the current view and restore it when listeners are invoked. This allows\n * walking the declaration view tree in listeners to get vars from parent views.\n *\n * @param viewToRestore The OpaqueViewState instance to restore.\n * @returns Context of the restored OpaqueViewState instance.\n *\n * @codeGenApi\n */\nfunction ɵɵrestoreView(viewToRestore) {\n    instructionState.lFrame.contextLView = viewToRestore;\n    return viewToRestore[CONTEXT];\n}\n/**\n * Clears the view set in `ɵɵrestoreView` from memory. Returns the passed in\n * value so that it can be used as a return value of an instruction.\n *\n * @codeGenApi\n */\nfunction ɵɵresetView(value) {\n    instructionState.lFrame.contextLView = null;\n    return value;\n}\nfunction getCurrentTNode() {\n    let currentTNode = getCurrentTNodePlaceholderOk();\n    while (currentTNode !== null && currentTNode.type === 64 /* TNodeType.Placeholder */) {\n        currentTNode = currentTNode.parent;\n    }\n    return currentTNode;\n}\nfunction getCurrentTNodePlaceholderOk() {\n    return instructionState.lFrame.currentTNode;\n}\nfunction getCurrentParentTNode() {\n    const lFrame = instructionState.lFrame;\n    const currentTNode = lFrame.currentTNode;\n    return lFrame.isParent ? currentTNode : currentTNode.parent;\n}\nfunction setCurrentTNode(tNode, isParent) {\n    ngDevMode && tNode && assertTNodeForTView(tNode, instructionState.lFrame.tView);\n    const lFrame = instructionState.lFrame;\n    lFrame.currentTNode = tNode;\n    lFrame.isParent = isParent;\n}\nfunction isCurrentTNodeParent() {\n    return instructionState.lFrame.isParent;\n}\nfunction setCurrentTNodeAsNotParent() {\n    instructionState.lFrame.isParent = false;\n}\nfunction setCurrentTNodeAsParent() {\n    instructionState.lFrame.isParent = true;\n}\nfunction getContextLView() {\n    const contextLView = instructionState.lFrame.contextLView;\n    ngDevMode && assertDefined(contextLView, 'contextLView must be defined.');\n    return contextLView;\n}\nfunction isInCheckNoChangesMode() {\n    !ngDevMode && throwError('Must never be called in production mode');\n    return _isInCheckNoChangesMode;\n}\nfunction setIsInCheckNoChangesMode(mode) {\n    !ngDevMode && throwError('Must never be called in production mode');\n    _isInCheckNoChangesMode = mode;\n}\n// top level variables should not be exported for performance reasons (PERF_NOTES.md)\nfunction getBindingRoot() {\n    const lFrame = instructionState.lFrame;\n    let index = lFrame.bindingRootIndex;\n    if (index === -1) {\n        index = lFrame.bindingRootIndex = lFrame.tView.bindingStartIndex;\n    }\n    return index;\n}\nfunction getBindingIndex() {\n    return instructionState.lFrame.bindingIndex;\n}\nfunction setBindingIndex(value) {\n    return instructionState.lFrame.bindingIndex = value;\n}\nfunction nextBindingIndex() {\n    return instructionState.lFrame.bindingIndex++;\n}\nfunction incrementBindingIndex(count) {\n    const lFrame = instructionState.lFrame;\n    const index = lFrame.bindingIndex;\n    lFrame.bindingIndex = lFrame.bindingIndex + count;\n    return index;\n}\nfunction isInI18nBlock() {\n    return instructionState.lFrame.inI18n;\n}\nfunction setInI18nBlock(isInI18nBlock) {\n    instructionState.lFrame.inI18n = isInI18nBlock;\n}\n/**\n * Set a new binding root index so that host template functions can execute.\n *\n * Bindings inside the host template are 0 index. But because we don't know ahead of time\n * how many host bindings we have we can't pre-compute them. For this reason they are all\n * 0 index and we just shift the root so that they match next available location in the LView.\n *\n * @param bindingRootIndex Root index for `hostBindings`\n * @param currentDirectiveIndex `TData[currentDirectiveIndex]` will point to the current directive\n *        whose `hostBindings` are being processed.\n */\nfunction setBindingRootForHostBindings(bindingRootIndex, currentDirectiveIndex) {\n    const lFrame = instructionState.lFrame;\n    lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex;\n    setCurrentDirectiveIndex(currentDirectiveIndex);\n}\n/**\n * When host binding is executing this points to the directive index.\n * `TView.data[getCurrentDirectiveIndex()]` is `DirectiveDef`\n * `LView[getCurrentDirectiveIndex()]` is directive instance.\n */\nfunction getCurrentDirectiveIndex() {\n    return instructionState.lFrame.currentDirectiveIndex;\n}\n/**\n * Sets an index of a directive whose `hostBindings` are being processed.\n *\n * @param currentDirectiveIndex `TData` index where current directive instance can be found.\n */\nfunction setCurrentDirectiveIndex(currentDirectiveIndex) {\n    instructionState.lFrame.currentDirectiveIndex = currentDirectiveIndex;\n}\n/**\n * Retrieve the current `DirectiveDef` which is active when `hostBindings` instruction is being\n * executed.\n *\n * @param tData Current `TData` where the `DirectiveDef` will be looked up at.\n */\nfunction getCurrentDirectiveDef(tData) {\n    const currentDirectiveIndex = instructionState.lFrame.currentDirectiveIndex;\n    return currentDirectiveIndex === -1 ? null : tData[currentDirectiveIndex];\n}\nfunction getCurrentQueryIndex() {\n    return instructionState.lFrame.currentQueryIndex;\n}\nfunction setCurrentQueryIndex(value) {\n    instructionState.lFrame.currentQueryIndex = value;\n}\n/**\n * Returns a `TNode` of the location where the current `LView` is declared at.\n *\n * @param lView an `LView` that we want to find parent `TNode` for.\n */\nfunction getDeclarationTNode(lView) {\n    const tView = lView[TVIEW];\n    // Return the declaration parent for embedded views\n    if (tView.type === 2 /* TViewType.Embedded */) {\n        ngDevMode && assertDefined(tView.declTNode, 'Embedded TNodes should have declaration parents.');\n        return tView.declTNode;\n    }\n    // Components don't have `TView.declTNode` because each instance of component could be\n    // inserted in different location, hence `TView.declTNode` is meaningless.\n    // Falling back to `T_HOST` in case we cross component boundary.\n    if (tView.type === 1 /* TViewType.Component */) {\n        return lView[T_HOST];\n    }\n    // Remaining TNode type is `TViewType.Root` which doesn't have a parent TNode.\n    return null;\n}\n/**\n * This is a light weight version of the `enterView` which is needed by the DI system.\n *\n * @param lView `LView` location of the DI context.\n * @param tNode `TNode` for DI context\n * @param flags DI context flags. if `SkipSelf` flag is set than we walk up the declaration\n *     tree from `tNode`  until we find parent declared `TElementNode`.\n * @returns `true` if we have successfully entered DI associated with `tNode` (or with declared\n *     `TNode` if `flags` has  `SkipSelf`). Failing to enter DI implies that no associated\n *     `NodeInjector` can be found and we should instead use `ModuleInjector`.\n *     - If `true` than this call must be fallowed by `leaveDI`\n *     - If `false` than this call failed and we should NOT call `leaveDI`\n */\nfunction enterDI(lView, tNode, flags) {\n    ngDevMode && assertLViewOrUndefined(lView);\n    if (flags & InjectFlags.SkipSelf) {\n        ngDevMode && assertTNodeForTView(tNode, lView[TVIEW]);\n        let parentTNode = tNode;\n        let parentLView = lView;\n        while (true) {\n            ngDevMode && assertDefined(parentTNode, 'Parent TNode should be defined');\n            parentTNode = parentTNode.parent;\n            if (parentTNode === null && !(flags & InjectFlags.Host)) {\n                parentTNode = getDeclarationTNode(parentLView);\n                if (parentTNode === null)\n                    break;\n                // In this case, a parent exists and is definitely an element. So it will definitely\n                // have an existing lView as the declaration view, which is why we can assume it's defined.\n                ngDevMode && assertDefined(parentLView, 'Parent LView should be defined');\n                parentLView = parentLView[DECLARATION_VIEW];\n                // In Ivy there are Comment nodes that correspond to ngIf and NgFor embedded directives\n                // We want to skip those and look only at Elements and ElementContainers to ensure\n                // we're looking at true parent nodes, and not content or other types.\n                if (parentTNode.type & (2 /* TNodeType.Element */ | 8 /* TNodeType.ElementContainer */)) {\n                    break;\n                }\n            }\n            else {\n                break;\n            }\n        }\n        if (parentTNode === null) {\n            // If we failed to find a parent TNode this means that we should use module injector.\n            return false;\n        }\n        else {\n            tNode = parentTNode;\n            lView = parentLView;\n        }\n    }\n    ngDevMode && assertTNodeForLView(tNode, lView);\n    const lFrame = instructionState.lFrame = allocLFrame();\n    lFrame.currentTNode = tNode;\n    lFrame.lView = lView;\n    return true;\n}\n/**\n * Swap the current lView with a new lView.\n *\n * For performance reasons we store the lView in the top level of the module.\n * This way we minimize the number of properties to read. Whenever a new view\n * is entered we have to store the lView for later, and when the view is\n * exited the state has to be restored\n *\n * @param newView New lView to become active\n * @returns the previously active lView;\n */\nfunction enterView(newView) {\n    ngDevMode && assertNotEqual(newView[0], newView[1], '????');\n    ngDevMode && assertLViewOrUndefined(newView);\n    const newLFrame = allocLFrame();\n    if (ngDevMode) {\n        assertEqual(newLFrame.isParent, true, 'Expected clean LFrame');\n        assertEqual(newLFrame.lView, null, 'Expected clean LFrame');\n        assertEqual(newLFrame.tView, null, 'Expected clean LFrame');\n        assertEqual(newLFrame.selectedIndex, -1, 'Expected clean LFrame');\n        assertEqual(newLFrame.elementDepthCount, 0, 'Expected clean LFrame');\n        assertEqual(newLFrame.currentDirectiveIndex, -1, 'Expected clean LFrame');\n        assertEqual(newLFrame.currentNamespace, null, 'Expected clean LFrame');\n        assertEqual(newLFrame.bindingRootIndex, -1, 'Expected clean LFrame');\n        assertEqual(newLFrame.currentQueryIndex, 0, 'Expected clean LFrame');\n    }\n    const tView = newView[TVIEW];\n    instructionState.lFrame = newLFrame;\n    ngDevMode && tView.firstChild && assertTNodeForTView(tView.firstChild, tView);\n    newLFrame.currentTNode = tView.firstChild;\n    newLFrame.lView = newView;\n    newLFrame.tView = tView;\n    newLFrame.contextLView = newView;\n    newLFrame.bindingIndex = tView.bindingStartIndex;\n    newLFrame.inI18n = false;\n}\n/**\n * Allocates next free LFrame. This function tries to reuse the `LFrame`s to lower memory pressure.\n */\nfunction allocLFrame() {\n    const currentLFrame = instructionState.lFrame;\n    const childLFrame = currentLFrame === null ? null : currentLFrame.child;\n    const newLFrame = childLFrame === null ? createLFrame(currentLFrame) : childLFrame;\n    return newLFrame;\n}\nfunction createLFrame(parent) {\n    const lFrame = {\n        currentTNode: null,\n        isParent: true,\n        lView: null,\n        tView: null,\n        selectedIndex: -1,\n        contextLView: null,\n        elementDepthCount: 0,\n        currentNamespace: null,\n        currentDirectiveIndex: -1,\n        bindingRootIndex: -1,\n        bindingIndex: -1,\n        currentQueryIndex: 0,\n        parent: parent,\n        child: null,\n        inI18n: false,\n    };\n    parent !== null && (parent.child = lFrame); // link the new LFrame for reuse.\n    return lFrame;\n}\n/**\n * A lightweight version of leave which is used with DI.\n *\n * This function only resets `currentTNode` and `LView` as those are the only properties\n * used with DI (`enterDI()`).\n *\n * NOTE: This function is reexported as `leaveDI`. However `leaveDI` has return type of `void` where\n * as `leaveViewLight` has `LFrame`. This is so that `leaveViewLight` can be used in `leaveView`.\n */\nfunction leaveViewLight() {\n    const oldLFrame = instructionState.lFrame;\n    instructionState.lFrame = oldLFrame.parent;\n    oldLFrame.currentTNode = null;\n    oldLFrame.lView = null;\n    return oldLFrame;\n}\n/**\n * This is a lightweight version of the `leaveView` which is needed by the DI system.\n *\n * NOTE: this function is an alias so that we can change the type of the function to have `void`\n * return type.\n */\nconst leaveDI = leaveViewLight;\n/**\n * Leave the current `LView`\n *\n * This pops the `LFrame` with the associated `LView` from the stack.\n *\n * IMPORTANT: We must zero out the `LFrame` values here otherwise they will be retained. This is\n * because for performance reasons we don't release `LFrame` but rather keep it for next use.\n */\nfunction leaveView() {\n    const oldLFrame = leaveViewLight();\n    oldLFrame.isParent = true;\n    oldLFrame.tView = null;\n    oldLFrame.selectedIndex = -1;\n    oldLFrame.contextLView = null;\n    oldLFrame.elementDepthCount = 0;\n    oldLFrame.currentDirectiveIndex = -1;\n    oldLFrame.currentNamespace = null;\n    oldLFrame.bindingRootIndex = -1;\n    oldLFrame.bindingIndex = -1;\n    oldLFrame.currentQueryIndex = 0;\n}\nfunction nextContextImpl(level) {\n    const contextLView = instructionState.lFrame.contextLView =\n        walkUpViews(level, instructionState.lFrame.contextLView);\n    return contextLView[CONTEXT];\n}\nfunction walkUpViews(nestingLevel, currentView) {\n    while (nestingLevel > 0) {\n        ngDevMode &&\n            assertDefined(currentView[DECLARATION_VIEW], 'Declaration view should be defined if nesting level is greater than 0.');\n        currentView = currentView[DECLARATION_VIEW];\n        nestingLevel--;\n    }\n    return currentView;\n}\n/**\n * Gets the currently selected element index.\n *\n * Used with {@link property} instruction (and more in the future) to identify the index in the\n * current `LView` to act on.\n */\nfunction getSelectedIndex() {\n    return instructionState.lFrame.selectedIndex;\n}\n/**\n * Sets the most recent index passed to {@link select}\n *\n * Used with {@link property} instruction (and more in the future) to identify the index in the\n * current `LView` to act on.\n *\n * (Note that if an \"exit function\" was set earlier (via `setElementExitFn()`) then that will be\n * run if and when the provided `index` value is different from the current selected index value.)\n */\nfunction setSelectedIndex(index) {\n    ngDevMode && index !== -1 &&\n        assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Index must be past HEADER_OFFSET (or -1).');\n    ngDevMode &&\n        assertLessThan(index, instructionState.lFrame.lView.length, 'Can\\'t set index passed end of LView');\n    instructionState.lFrame.selectedIndex = index;\n}\n/**\n * Gets the `tNode` that represents currently selected element.\n */\nfunction getSelectedTNode() {\n    const lFrame = instructionState.lFrame;\n    return getTNode(lFrame.tView, lFrame.selectedIndex);\n}\n/**\n * Sets the namespace used to create elements to `'http://www.w3.org/2000/svg'` in global state.\n *\n * @codeGenApi\n */\nfunction ɵɵnamespaceSVG() {\n    instructionState.lFrame.currentNamespace = SVG_NAMESPACE;\n}\n/**\n * Sets the namespace used to create elements to `'http://www.w3.org/1998/MathML/'` in global state.\n *\n * @codeGenApi\n */\nfunction ɵɵnamespaceMathML() {\n    instructionState.lFrame.currentNamespace = MATH_ML_NAMESPACE;\n}\n/**\n * Sets the namespace used to create elements to `null`, which forces element creation to use\n * `createElement` rather than `createElementNS`.\n *\n * @codeGenApi\n */\nfunction ɵɵnamespaceHTML() {\n    namespaceHTMLInternal();\n}\n/**\n * Sets the namespace used to create elements to `null`, which forces element creation to use\n * `createElement` rather than `createElementNS`.\n */\nfunction namespaceHTMLInternal() {\n    instructionState.lFrame.currentNamespace = null;\n}\nfunction getNamespace$1() {\n    return instructionState.lFrame.currentNamespace;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Adds all directive lifecycle hooks from the given `DirectiveDef` to the given `TView`.\n *\n * Must be run *only* on the first template pass.\n *\n * Sets up the pre-order hooks on the provided `tView`,\n * see {@link HookData} for details about the data structure.\n *\n * @param directiveIndex The index of the directive in LView\n * @param directiveDef The definition containing the hooks to setup in tView\n * @param tView The current TView\n */\nfunction registerPreOrderHooks(directiveIndex, directiveDef, tView) {\n    ngDevMode && assertFirstCreatePass(tView);\n    const { ngOnChanges, ngOnInit, ngDoCheck } = directiveDef.type.prototype;\n    if (ngOnChanges) {\n        const wrappedOnChanges = NgOnChangesFeatureImpl(directiveDef);\n        (tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, wrappedOnChanges);\n        (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = []))\n            .push(directiveIndex, wrappedOnChanges);\n    }\n    if (ngOnInit) {\n        (tView.preOrderHooks || (tView.preOrderHooks = [])).push(0 - directiveIndex, ngOnInit);\n    }\n    if (ngDoCheck) {\n        (tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, ngDoCheck);\n        (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(directiveIndex, ngDoCheck);\n    }\n}\n/**\n *\n * Loops through the directives on the provided `tNode` and queues hooks to be\n * run that are not initialization hooks.\n *\n * Should be executed during `elementEnd()` and similar to\n * preserve hook execution order. Content, view, and destroy hooks for projected\n * components and directives must be called *before* their hosts.\n *\n * Sets up the content, view, and destroy hooks on the provided `tView`,\n * see {@link HookData} for details about the data structure.\n *\n * NOTE: This does not set up `onChanges`, `onInit` or `doCheck`, those are set up\n * separately at `elementStart`.\n *\n * @param tView The current TView\n * @param tNode The TNode whose directives are to be searched for hooks to queue\n */\nfunction registerPostOrderHooks(tView, tNode) {\n    ngDevMode && assertFirstCreatePass(tView);\n    // It's necessary to loop through the directives at elementEnd() (rather than processing in\n    // directiveCreate) so we can preserve the current hook order. Content, view, and destroy\n    // hooks for projected components and directives must be called *before* their hosts.\n    for (let i = tNode.directiveStart, end = tNode.directiveEnd; i < end; i++) {\n        const directiveDef = tView.data[i];\n        ngDevMode && assertDefined(directiveDef, 'Expecting DirectiveDef');\n        const lifecycleHooks = directiveDef.type.prototype;\n        const { ngAfterContentInit, ngAfterContentChecked, ngAfterViewInit, ngAfterViewChecked, ngOnDestroy } = lifecycleHooks;\n        if (ngAfterContentInit) {\n            (tView.contentHooks || (tView.contentHooks = [])).push(-i, ngAfterContentInit);\n        }\n        if (ngAfterContentChecked) {\n            (tView.contentHooks || (tView.contentHooks = [])).push(i, ngAfterContentChecked);\n            (tView.contentCheckHooks || (tView.contentCheckHooks = [])).push(i, ngAfterContentChecked);\n        }\n        if (ngAfterViewInit) {\n            (tView.viewHooks || (tView.viewHooks = [])).push(-i, ngAfterViewInit);\n        }\n        if (ngAfterViewChecked) {\n            (tView.viewHooks || (tView.viewHooks = [])).push(i, ngAfterViewChecked);\n            (tView.viewCheckHooks || (tView.viewCheckHooks = [])).push(i, ngAfterViewChecked);\n        }\n        if (ngOnDestroy != null) {\n            (tView.destroyHooks || (tView.destroyHooks = [])).push(i, ngOnDestroy);\n        }\n    }\n}\n/**\n * Executing hooks requires complex logic as we need to deal with 2 constraints.\n *\n * 1. Init hooks (ngOnInit, ngAfterContentInit, ngAfterViewInit) must all be executed once and only\n * once, across many change detection cycles. This must be true even if some hooks throw, or if\n * some recursively trigger a change detection cycle.\n * To solve that, it is required to track the state of the execution of these init hooks.\n * This is done by storing and maintaining flags in the view: the {@link InitPhaseState},\n * and the index within that phase. They can be seen as a cursor in the following structure:\n * [[onInit1, onInit2], [afterContentInit1], [afterViewInit1, afterViewInit2, afterViewInit3]]\n * They are are stored as flags in LView[FLAGS].\n *\n * 2. Pre-order hooks can be executed in batches, because of the select instruction.\n * To be able to pause and resume their execution, we also need some state about the hook's array\n * that is being processed:\n * - the index of the next hook to be executed\n * - the number of init hooks already found in the processed part of the  array\n * They are are stored as flags in LView[PREORDER_HOOK_FLAGS].\n */\n/**\n * Executes pre-order check hooks ( OnChanges, DoChanges) given a view where all the init hooks were\n * executed once. This is a light version of executeInitAndCheckPreOrderHooks where we can skip read\n * / write of the init-hooks related flags.\n * @param lView The LView where hooks are defined\n * @param hooks Hooks to be run\n * @param nodeIndex 3 cases depending on the value:\n * - undefined: all hooks from the array should be executed (post-order case)\n * - null: execute hooks only from the saved index until the end of the array (pre-order case, when\n * flushing the remaining hooks)\n * - number: execute hooks only from the saved index until that node index exclusive (pre-order\n * case, when executing select(number))\n */\nfunction executeCheckHooks(lView, hooks, nodeIndex) {\n    callHooks(lView, hooks, 3 /* InitPhaseState.InitPhaseCompleted */, nodeIndex);\n}\n/**\n * Executes post-order init and check hooks (one of AfterContentInit, AfterContentChecked,\n * AfterViewInit, AfterViewChecked) given a view where there are pending init hooks to be executed.\n * @param lView The LView where hooks are defined\n * @param hooks Hooks to be run\n * @param initPhase A phase for which hooks should be run\n * @param nodeIndex 3 cases depending on the value:\n * - undefined: all hooks from the array should be executed (post-order case)\n * - null: execute hooks only from the saved index until the end of the array (pre-order case, when\n * flushing the remaining hooks)\n * - number: execute hooks only from the saved index until that node index exclusive (pre-order\n * case, when executing select(number))\n */\nfunction executeInitAndCheckHooks(lView, hooks, initPhase, nodeIndex) {\n    ngDevMode &&\n        assertNotEqual(initPhase, 3 /* InitPhaseState.InitPhaseCompleted */, 'Init pre-order hooks should not be called more than once');\n    if ((lView[FLAGS] & 3 /* LViewFlags.InitPhaseStateMask */) === initPhase) {\n        callHooks(lView, hooks, initPhase, nodeIndex);\n    }\n}\nfunction incrementInitPhaseFlags(lView, initPhase) {\n    ngDevMode &&\n        assertNotEqual(initPhase, 3 /* InitPhaseState.InitPhaseCompleted */, 'Init hooks phase should not be incremented after all init hooks have been run.');\n    let flags = lView[FLAGS];\n    if ((flags & 3 /* LViewFlags.InitPhaseStateMask */) === initPhase) {\n        flags &= 2047 /* LViewFlags.IndexWithinInitPhaseReset */;\n        flags += 1 /* LViewFlags.InitPhaseStateIncrementer */;\n        lView[FLAGS] = flags;\n    }\n}\n/**\n * Calls lifecycle hooks with their contexts, skipping init hooks if it's not\n * the first LView pass\n *\n * @param currentView The current view\n * @param arr The array in which the hooks are found\n * @param initPhaseState the current state of the init phase\n * @param currentNodeIndex 3 cases depending on the value:\n * - undefined: all hooks from the array should be executed (post-order case)\n * - null: execute hooks only from the saved index until the end of the array (pre-order case, when\n * flushing the remaining hooks)\n * - number: execute hooks only from the saved index until that node index exclusive (pre-order\n * case, when executing select(number))\n */\nfunction callHooks(currentView, arr, initPhase, currentNodeIndex) {\n    ngDevMode &&\n        assertEqual(isInCheckNoChangesMode(), false, 'Hooks should never be run when in check no changes mode.');\n    const startIndex = currentNodeIndex !== undefined ?\n        (currentView[PREORDER_HOOK_FLAGS] & 65535 /* PreOrderHookFlags.IndexOfTheNextPreOrderHookMaskMask */) :\n        0;\n    const nodeIndexLimit = currentNodeIndex != null ? currentNodeIndex : -1;\n    const max = arr.length - 1; // Stop the loop at length - 1, because we look for the hook at i + 1\n    let lastNodeIndexFound = 0;\n    for (let i = startIndex; i < max; i++) {\n        const hook = arr[i + 1];\n        if (typeof hook === 'number') {\n            lastNodeIndexFound = arr[i];\n            if (currentNodeIndex != null && lastNodeIndexFound >= currentNodeIndex) {\n                break;\n            }\n        }\n        else {\n            const isInitHook = arr[i] < 0;\n            if (isInitHook)\n                currentView[PREORDER_HOOK_FLAGS] += 65536 /* PreOrderHookFlags.NumberOfInitHooksCalledIncrementer */;\n            if (lastNodeIndexFound < nodeIndexLimit || nodeIndexLimit == -1) {\n                callHook(currentView, initPhase, arr, i);\n                currentView[PREORDER_HOOK_FLAGS] =\n                    (currentView[PREORDER_HOOK_FLAGS] & 4294901760 /* PreOrderHookFlags.NumberOfInitHooksCalledMask */) + i +\n                        2;\n            }\n            i++;\n        }\n    }\n}\n/**\n * Execute one hook against the current `LView`.\n *\n * @param currentView The current view\n * @param initPhaseState the current state of the init phase\n * @param arr The array in which the hooks are found\n * @param i The current index within the hook data array\n */\nfunction callHook(currentView, initPhase, arr, i) {\n    const isInitHook = arr[i] < 0;\n    const hook = arr[i + 1];\n    const directiveIndex = isInitHook ? -arr[i] : arr[i];\n    const directive = currentView[directiveIndex];\n    if (isInitHook) {\n        const indexWithintInitPhase = currentView[FLAGS] >> 11 /* LViewFlags.IndexWithinInitPhaseShift */;\n        // The init phase state must be always checked here as it may have been recursively updated.\n        if (indexWithintInitPhase <\n            (currentView[PREORDER_HOOK_FLAGS] >> 16 /* PreOrderHookFlags.NumberOfInitHooksCalledShift */) &&\n            (currentView[FLAGS] & 3 /* LViewFlags.InitPhaseStateMask */) === initPhase) {\n            currentView[FLAGS] += 2048 /* LViewFlags.IndexWithinInitPhaseIncrementer */;\n            profiler(4 /* ProfilerEvent.LifecycleHookStart */, directive, hook);\n            try {\n                hook.call(directive);\n            }\n            finally {\n                profiler(5 /* ProfilerEvent.LifecycleHookEnd */, directive, hook);\n            }\n        }\n    }\n    else {\n        profiler(4 /* ProfilerEvent.LifecycleHookStart */, directive, hook);\n        try {\n            hook.call(directive);\n        }\n        finally {\n            profiler(5 /* ProfilerEvent.LifecycleHookEnd */, directive, hook);\n        }\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst NO_PARENT_INJECTOR = -1;\n/**\n * Each injector is saved in 9 contiguous slots in `LView` and 9 contiguous slots in\n * `TView.data`. This allows us to store information about the current node's tokens (which\n * can be shared in `TView`) as well as the tokens of its ancestor nodes (which cannot be\n * shared, so they live in `LView`).\n *\n * Each of these slots (aside from the last slot) contains a bloom filter. This bloom filter\n * determines whether a directive is available on the associated node or not. This prevents us\n * from searching the directives array at this level unless it's probable the directive is in it.\n *\n * See: https://en.wikipedia.org/wiki/Bloom_filter for more about bloom filters.\n *\n * Because all injectors have been flattened into `LView` and `TViewData`, they cannot typed\n * using interfaces as they were previously. The start index of each `LInjector` and `TInjector`\n * will differ based on where it is flattened into the main array, so it's not possible to know\n * the indices ahead of time and save their types here. The interfaces are still included here\n * for documentation purposes.\n *\n * export interface LInjector extends Array<any> {\n *\n *    // Cumulative bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)\n *    [0]: number;\n *\n *    // Cumulative bloom for directive IDs 32-63\n *    [1]: number;\n *\n *    // Cumulative bloom for directive IDs 64-95\n *    [2]: number;\n *\n *    // Cumulative bloom for directive IDs 96-127\n *    [3]: number;\n *\n *    // Cumulative bloom for directive IDs 128-159\n *    [4]: number;\n *\n *    // Cumulative bloom for directive IDs 160 - 191\n *    [5]: number;\n *\n *    // Cumulative bloom for directive IDs 192 - 223\n *    [6]: number;\n *\n *    // Cumulative bloom for directive IDs 224 - 255\n *    [7]: number;\n *\n *    // We need to store a reference to the injector's parent so DI can keep looking up\n *    // the injector tree until it finds the dependency it's looking for.\n *    [PARENT_INJECTOR]: number;\n * }\n *\n * export interface TInjector extends Array<any> {\n *\n *    // Shared node bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)\n *    [0]: number;\n *\n *    // Shared node bloom for directive IDs 32-63\n *    [1]: number;\n *\n *    // Shared node bloom for directive IDs 64-95\n *    [2]: number;\n *\n *    // Shared node bloom for directive IDs 96-127\n *    [3]: number;\n *\n *    // Shared node bloom for directive IDs 128-159\n *    [4]: number;\n *\n *    // Shared node bloom for directive IDs 160 - 191\n *    [5]: number;\n *\n *    // Shared node bloom for directive IDs 192 - 223\n *    [6]: number;\n *\n *    // Shared node bloom for directive IDs 224 - 255\n *    [7]: number;\n *\n *    // Necessary to find directive indices for a particular node.\n *    [TNODE]: TElementNode|TElementContainerNode|TContainerNode;\n *  }\n */\n/**\n * Factory for creating instances of injectors in the NodeInjector.\n *\n * This factory is complicated by the fact that it can resolve `multi` factories as well.\n *\n * NOTE: Some of the fields are optional which means that this class has two hidden classes.\n * - One without `multi` support (most common)\n * - One with `multi` values, (rare).\n *\n * Since VMs can cache up to 4 inline hidden classes this is OK.\n *\n * - Single factory: Only `resolving` and `factory` is defined.\n * - `providers` factory: `componentProviders` is a number and `index = -1`.\n * - `viewProviders` factory: `componentProviders` is a number and `index` points to `providers`.\n */\nclass NodeInjectorFactory {\n    constructor(\n    /**\n     * Factory to invoke in order to create a new instance.\n     */\n    factory, \n    /**\n     * Set to `true` if the token is declared in `viewProviders` (or if it is component).\n     */\n    isViewProvider, injectImplementation) {\n        this.factory = factory;\n        /**\n         * Marker set to true during factory invocation to see if we get into recursive loop.\n         * Recursive loop causes an error to be displayed.\n         */\n        this.resolving = false;\n        ngDevMode && assertDefined(factory, 'Factory not specified');\n        ngDevMode && assertEqual(typeof factory, 'function', 'Expected factory function.');\n        this.canSeeViewProviders = isViewProvider;\n        this.injectImpl = injectImplementation;\n    }\n}\nfunction isFactory(obj) {\n    return obj instanceof NodeInjectorFactory;\n}\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nconst unusedValueExportToPlacateAjd$5 = 1;\n\n/**\n * Converts `TNodeType` into human readable text.\n * Make sure this matches with `TNodeType`\n */\nfunction toTNodeTypeAsString(tNodeType) {\n    let text = '';\n    (tNodeType & 1 /* TNodeType.Text */) && (text += '|Text');\n    (tNodeType & 2 /* TNodeType.Element */) && (text += '|Element');\n    (tNodeType & 4 /* TNodeType.Container */) && (text += '|Container');\n    (tNodeType & 8 /* TNodeType.ElementContainer */) && (text += '|ElementContainer');\n    (tNodeType & 16 /* TNodeType.Projection */) && (text += '|Projection');\n    (tNodeType & 32 /* TNodeType.Icu */) && (text += '|IcuContainer');\n    (tNodeType & 64 /* TNodeType.Placeholder */) && (text += '|Placeholder');\n    return text.length > 0 ? text.substring(1) : text;\n}\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nconst unusedValueExportToPlacateAjd$4 = 1;\n/**\n * Returns `true` if the `TNode` has a directive which has `@Input()` for `class` binding.\n *\n * ```\n * <div my-dir [class]=\"exp\"></div>\n * ```\n * and\n * ```\n * @Directive({\n * })\n * class MyDirective {\n *   @Input()\n *   class: string;\n * }\n * ```\n *\n * In the above case it is necessary to write the reconciled styling information into the\n * directive's input.\n *\n * @param tNode\n */\nfunction hasClassInput(tNode) {\n    return (tNode.flags & 16 /* TNodeFlags.hasClassInput */) !== 0;\n}\n/**\n * Returns `true` if the `TNode` has a directive which has `@Input()` for `style` binding.\n *\n * ```\n * <div my-dir [style]=\"exp\"></div>\n * ```\n * and\n * ```\n * @Directive({\n * })\n * class MyDirective {\n *   @Input()\n *   class: string;\n * }\n * ```\n *\n * In the above case it is necessary to write the reconciled styling information into the\n * directive's input.\n *\n * @param tNode\n */\nfunction hasStyleInput(tNode) {\n    return (tNode.flags & 32 /* TNodeFlags.hasStyleInput */) !== 0;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction assertTNodeType(tNode, expectedTypes, message) {\n    assertDefined(tNode, 'should be called with a TNode');\n    if ((tNode.type & expectedTypes) === 0) {\n        throwError(message ||\n            `Expected [${toTNodeTypeAsString(expectedTypes)}] but got ${toTNodeTypeAsString(tNode.type)}.`);\n    }\n}\nfunction assertPureTNodeType(type) {\n    if (!(type === 2 /* TNodeType.Element */ || //\n        type === 1 /* TNodeType.Text */ || //\n        type === 4 /* TNodeType.Container */ || //\n        type === 8 /* TNodeType.ElementContainer */ || //\n        type === 32 /* TNodeType.Icu */ || //\n        type === 16 /* TNodeType.Projection */ || //\n        type === 64 /* TNodeType.Placeholder */)) {\n        throwError(`Expected TNodeType to have only a single type selected, but got ${toTNodeTypeAsString(type)}.`);\n    }\n}\n\n/**\n * Assigns all attribute values to the provided element via the inferred renderer.\n *\n * This function accepts two forms of attribute entries:\n *\n * default: (key, value):\n *  attrs = [key1, value1, key2, value2]\n *\n * namespaced: (NAMESPACE_MARKER, uri, name, value)\n *  attrs = [NAMESPACE_MARKER, uri, name, value, NAMESPACE_MARKER, uri, name, value]\n *\n * The `attrs` array can contain a mix of both the default and namespaced entries.\n * The \"default\" values are set without a marker, but if the function comes across\n * a marker value then it will attempt to set a namespaced value. If the marker is\n * not of a namespaced value then the function will quit and return the index value\n * where it stopped during the iteration of the attrs array.\n *\n * See [AttributeMarker] to understand what the namespace marker value is.\n *\n * Note that this instruction does not support assigning style and class values to\n * an element. See `elementStart` and `elementHostAttrs` to learn how styling values\n * are applied to an element.\n * @param renderer The renderer to be used\n * @param native The element that the attributes will be assigned to\n * @param attrs The attribute array of values that will be assigned to the element\n * @returns the index value that was last accessed in the attributes array\n */\nfunction setUpAttributes(renderer, native, attrs) {\n    const isProc = isProceduralRenderer(renderer);\n    let i = 0;\n    while (i < attrs.length) {\n        const value = attrs[i];\n        if (typeof value === 'number') {\n            // only namespaces are supported. Other value types (such as style/class\n            // entries) are not supported in this function.\n            if (value !== 0 /* AttributeMarker.NamespaceURI */) {\n                break;\n            }\n            // we just landed on the marker value ... therefore\n            // we should skip to the next entry\n            i++;\n            const namespaceURI = attrs[i++];\n            const attrName = attrs[i++];\n            const attrVal = attrs[i++];\n            ngDevMode && ngDevMode.rendererSetAttribute++;\n            isProc ?\n                renderer.setAttribute(native, attrName, attrVal, namespaceURI) :\n                native.setAttributeNS(namespaceURI, attrName, attrVal);\n        }\n        else {\n            // attrName is string;\n            const attrName = value;\n            const attrVal = attrs[++i];\n            // Standard attributes\n            ngDevMode && ngDevMode.rendererSetAttribute++;\n            if (isAnimationProp(attrName)) {\n                if (isProc) {\n                    renderer.setProperty(native, attrName, attrVal);\n                }\n            }\n            else {\n                isProc ?\n                    renderer.setAttribute(native, attrName, attrVal) :\n                    native.setAttribute(attrName, attrVal);\n            }\n            i++;\n        }\n    }\n    // another piece of code may iterate over the same attributes array. Therefore\n    // it may be helpful to return the exact spot where the attributes array exited\n    // whether by running into an unsupported marker or if all the static values were\n    // iterated over.\n    return i;\n}\n/**\n * Test whether the given value is a marker that indicates that the following\n * attribute values in a `TAttributes` array are only the names of attributes,\n * and not name-value pairs.\n * @param marker The attribute marker to test.\n * @returns true if the marker is a \"name-only\" marker (e.g. `Bindings`, `Template` or `I18n`).\n */\nfunction isNameOnlyAttributeMarker(marker) {\n    return marker === 3 /* AttributeMarker.Bindings */ || marker === 4 /* AttributeMarker.Template */ ||\n        marker === 6 /* AttributeMarker.I18n */;\n}\nfunction isAnimationProp(name) {\n    // Perf note: accessing charCodeAt to check for the first character of a string is faster as\n    // compared to accessing a character at index 0 (ex. name[0]). The main reason for this is that\n    // charCodeAt doesn't allocate memory to return a substring.\n    return name.charCodeAt(0) === 64 /* CharCode.AT_SIGN */;\n}\n/**\n * Merges `src` `TAttributes` into `dst` `TAttributes` removing any duplicates in the process.\n *\n * This merge function keeps the order of attrs same.\n *\n * @param dst Location of where the merged `TAttributes` should end up.\n * @param src `TAttributes` which should be appended to `dst`\n */\nfunction mergeHostAttrs(dst, src) {\n    if (src === null || src.length === 0) {\n        // do nothing\n    }\n    else if (dst === null || dst.length === 0) {\n        // We have source, but dst is empty, just make a copy.\n        dst = src.slice();\n    }\n    else {\n        let srcMarker = -1 /* AttributeMarker.ImplicitAttributes */;\n        for (let i = 0; i < src.length; i++) {\n            const item = src[i];\n            if (typeof item === 'number') {\n                srcMarker = item;\n            }\n            else {\n                if (srcMarker === 0 /* AttributeMarker.NamespaceURI */) {\n                    // Case where we need to consume `key1`, `key2`, `value` items.\n                }\n                else if (srcMarker === -1 /* AttributeMarker.ImplicitAttributes */ ||\n                    srcMarker === 2 /* AttributeMarker.Styles */) {\n                    // Case where we have to consume `key1` and `value` only.\n                    mergeHostAttribute(dst, srcMarker, item, null, src[++i]);\n                }\n                else {\n                    // Case where we have to consume `key1` only.\n                    mergeHostAttribute(dst, srcMarker, item, null, null);\n                }\n            }\n        }\n    }\n    return dst;\n}\n/**\n * Append `key`/`value` to existing `TAttributes` taking region marker and duplicates into account.\n *\n * @param dst `TAttributes` to append to.\n * @param marker Region where the `key`/`value` should be added.\n * @param key1 Key to add to `TAttributes`\n * @param key2 Key to add to `TAttributes` (in case of `AttributeMarker.NamespaceURI`)\n * @param value Value to add or to overwrite to `TAttributes` Only used if `marker` is not Class.\n */\nfunction mergeHostAttribute(dst, marker, key1, key2, value) {\n    let i = 0;\n    // Assume that new markers will be inserted at the end.\n    let markerInsertPosition = dst.length;\n    // scan until correct type.\n    if (marker === -1 /* AttributeMarker.ImplicitAttributes */) {\n        markerInsertPosition = -1;\n    }\n    else {\n        while (i < dst.length) {\n            const dstValue = dst[i++];\n            if (typeof dstValue === 'number') {\n                if (dstValue === marker) {\n                    markerInsertPosition = -1;\n                    break;\n                }\n                else if (dstValue > marker) {\n                    // We need to save this as we want the markers to be inserted in specific order.\n                    markerInsertPosition = i - 1;\n                    break;\n                }\n            }\n        }\n    }\n    // search until you find place of insertion\n    while (i < dst.length) {\n        const item = dst[i];\n        if (typeof item === 'number') {\n            // since `i` started as the index after the marker, we did not find it if we are at the next\n            // marker\n            break;\n        }\n        else if (item === key1) {\n            // We already have same token\n            if (key2 === null) {\n                if (value !== null) {\n                    dst[i + 1] = value;\n                }\n                return;\n            }\n            else if (key2 === dst[i + 1]) {\n                dst[i + 2] = value;\n                return;\n            }\n        }\n        // Increment counter.\n        i++;\n        if (key2 !== null)\n            i++;\n        if (value !== null)\n            i++;\n    }\n    // insert at location.\n    if (markerInsertPosition !== -1) {\n        dst.splice(markerInsertPosition, 0, marker);\n        i = markerInsertPosition + 1;\n    }\n    dst.splice(i++, 0, key1);\n    if (key2 !== null) {\n        dst.splice(i++, 0, key2);\n    }\n    if (value !== null) {\n        dst.splice(i++, 0, value);\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/// Parent Injector Utils ///////////////////////////////////////////////////////////////\nfunction hasParentInjector(parentLocation) {\n    return parentLocation !== NO_PARENT_INJECTOR;\n}\nfunction getParentInjectorIndex(parentLocation) {\n    ngDevMode && assertNumber(parentLocation, 'Number expected');\n    ngDevMode && assertNotEqual(parentLocation, -1, 'Not a valid state.');\n    const parentInjectorIndex = parentLocation & 32767 /* RelativeInjectorLocationFlags.InjectorIndexMask */;\n    ngDevMode &&\n        assertGreaterThan(parentInjectorIndex, HEADER_OFFSET, 'Parent injector must be pointing past HEADER_OFFSET.');\n    return parentLocation & 32767 /* RelativeInjectorLocationFlags.InjectorIndexMask */;\n}\nfunction getParentInjectorViewOffset(parentLocation) {\n    return parentLocation >> 16 /* RelativeInjectorLocationFlags.ViewOffsetShift */;\n}\n/**\n * Unwraps a parent injector location number to find the view offset from the current injector,\n * then walks up the declaration view tree until the view is found that contains the parent\n * injector.\n *\n * @param location The location of the parent injector, which contains the view offset\n * @param startView The LView instance from which to start walking up the view tree\n * @returns The LView instance that contains the parent injector\n */\nfunction getParentInjectorView(location, startView) {\n    let viewOffset = getParentInjectorViewOffset(location);\n    let parentView = startView;\n    // For most cases, the parent injector can be found on the host node (e.g. for component\n    // or container), but we must keep the loop here to support the rarer case of deeply nested\n    // <ng-template> tags or inline views, where the parent injector might live many views\n    // above the child injector.\n    while (viewOffset > 0) {\n        parentView = parentView[DECLARATION_VIEW];\n        viewOffset--;\n    }\n    return parentView;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Defines if the call to `inject` should include `viewProviders` in its resolution.\n *\n * This is set to true when we try to instantiate a component. This value is reset in\n * `getNodeInjectable` to a value which matches the declaration location of the token about to be\n * instantiated. This is done so that if we are injecting a token which was declared outside of\n * `viewProviders` we don't accidentally pull `viewProviders` in.\n *\n * Example:\n *\n * ```\n * @Injectable()\n * class MyService {\n *   constructor(public value: String) {}\n * }\n *\n * @Component({\n *   providers: [\n *     MyService,\n *     {provide: String, value: 'providers' }\n *   ]\n *   viewProviders: [\n *     {provide: String, value: 'viewProviders'}\n *   ]\n * })\n * class MyComponent {\n *   constructor(myService: MyService, value: String) {\n *     // We expect that Component can see into `viewProviders`.\n *     expect(value).toEqual('viewProviders');\n *     // `MyService` was not declared in `viewProviders` hence it can't see it.\n *     expect(myService.value).toEqual('providers');\n *   }\n * }\n *\n * ```\n */\nlet includeViewProviders = true;\nfunction setIncludeViewProviders(v) {\n    const oldValue = includeViewProviders;\n    includeViewProviders = v;\n    return oldValue;\n}\n/**\n * The number of slots in each bloom filter (used by DI). The larger this number, the fewer\n * directives that will share slots, and thus, the fewer false positives when checking for\n * the existence of a directive.\n */\nconst BLOOM_SIZE = 256;\nconst BLOOM_MASK = BLOOM_SIZE - 1;\n/**\n * The number of bits that is represented by a single bloom bucket. JS bit operations are 32 bits,\n * so each bucket represents 32 distinct tokens which accounts for log2(32) = 5 bits of a bloom hash\n * number.\n */\nconst BLOOM_BUCKET_BITS = 5;\n/** Counter used to generate unique IDs for directives. */\nlet nextNgElementId = 0;\n/** Value used when something wasn't found by an injector. */\nconst NOT_FOUND = {};\n/**\n * Registers this directive as present in its node's injector by flipping the directive's\n * corresponding bit in the injector's bloom filter.\n *\n * @param injectorIndex The index of the node injector where this token should be registered\n * @param tView The TView for the injector's bloom filters\n * @param type The directive token to register\n */\nfunction bloomAdd(injectorIndex, tView, type) {\n    ngDevMode && assertEqual(tView.firstCreatePass, true, 'expected firstCreatePass to be true');\n    let id;\n    if (typeof type === 'string') {\n        id = type.charCodeAt(0) || 0;\n    }\n    else if (type.hasOwnProperty(NG_ELEMENT_ID)) {\n        id = type[NG_ELEMENT_ID];\n    }\n    // Set a unique ID on the directive type, so if something tries to inject the directive,\n    // we can easily retrieve the ID and hash it into the bloom bit that should be checked.\n    if (id == null) {\n        id = type[NG_ELEMENT_ID] = nextNgElementId++;\n    }\n    // We only have BLOOM_SIZE (256) slots in our bloom filter (8 buckets * 32 bits each),\n    // so all unique IDs must be modulo-ed into a number from 0 - 255 to fit into the filter.\n    const bloomHash = id & BLOOM_MASK;\n    // Create a mask that targets the specific bit associated with the directive.\n    // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n    // to bit positions 0 - 31 in a 32 bit integer.\n    const mask = 1 << bloomHash;\n    // Each bloom bucket in `tData` represents `BLOOM_BUCKET_BITS` number of bits of `bloomHash`.\n    // Any bits in `bloomHash` beyond `BLOOM_BUCKET_BITS` indicate the bucket offset that the mask\n    // should be written to.\n    tView.data[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)] |= mask;\n}\n/**\n * Creates (or gets an existing) injector for a given element or container.\n *\n * @param tNode for which an injector should be retrieved / created.\n * @param lView View where the node is stored\n * @returns Node injector\n */\nfunction getOrCreateNodeInjectorForNode(tNode, lView) {\n    const existingInjectorIndex = getInjectorIndex(tNode, lView);\n    if (existingInjectorIndex !== -1) {\n        return existingInjectorIndex;\n    }\n    const tView = lView[TVIEW];\n    if (tView.firstCreatePass) {\n        tNode.injectorIndex = lView.length;\n        insertBloom(tView.data, tNode); // foundation for node bloom\n        insertBloom(lView, null); // foundation for cumulative bloom\n        insertBloom(tView.blueprint, null);\n    }\n    const parentLoc = getParentInjectorLocation(tNode, lView);\n    const injectorIndex = tNode.injectorIndex;\n    // If a parent injector can't be found, its location is set to -1.\n    // In that case, we don't need to set up a cumulative bloom\n    if (hasParentInjector(parentLoc)) {\n        const parentIndex = getParentInjectorIndex(parentLoc);\n        const parentLView = getParentInjectorView(parentLoc, lView);\n        const parentData = parentLView[TVIEW].data;\n        // Creates a cumulative bloom filter that merges the parent's bloom filter\n        // and its own cumulative bloom (which contains tokens for all ancestors)\n        for (let i = 0; i < 8 /* NodeInjectorOffset.BLOOM_SIZE */; i++) {\n            lView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];\n        }\n    }\n    lView[injectorIndex + 8 /* NodeInjectorOffset.PARENT */] = parentLoc;\n    return injectorIndex;\n}\nfunction insertBloom(arr, footer) {\n    arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);\n}\nfunction getInjectorIndex(tNode, lView) {\n    if (tNode.injectorIndex === -1 ||\n        // If the injector index is the same as its parent's injector index, then the index has been\n        // copied down from the parent node. No injector has been created yet on this node.\n        (tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex) ||\n        // After the first template pass, the injector index might exist but the parent values\n        // might not have been calculated yet for this instance\n        lView[tNode.injectorIndex + 8 /* NodeInjectorOffset.PARENT */] === null) {\n        return -1;\n    }\n    else {\n        ngDevMode && assertIndexInRange(lView, tNode.injectorIndex);\n        return tNode.injectorIndex;\n    }\n}\n/**\n * Finds the index of the parent injector, with a view offset if applicable. Used to set the\n * parent injector initially.\n *\n * @returns Returns a number that is the combination of the number of LViews that we have to go up\n * to find the LView containing the parent inject AND the index of the injector within that LView.\n */\nfunction getParentInjectorLocation(tNode, lView) {\n    if (tNode.parent && tNode.parent.injectorIndex !== -1) {\n        // If we have a parent `TNode` and there is an injector associated with it we are done, because\n        // the parent injector is within the current `LView`.\n        return tNode.parent.injectorIndex; // ViewOffset is 0\n    }\n    // When parent injector location is computed it may be outside of the current view. (ie it could\n    // be pointing to a declared parent location). This variable stores number of declaration parents\n    // we need to walk up in order to find the parent injector location.\n    let declarationViewOffset = 0;\n    let parentTNode = null;\n    let lViewCursor = lView;\n    // The parent injector is not in the current `LView`. We will have to walk the declared parent\n    // `LView` hierarchy and look for it. If we walk of the top, that means that there is no parent\n    // `NodeInjector`.\n    while (lViewCursor !== null) {\n        parentTNode = getTNodeFromLView(lViewCursor);\n        if (parentTNode === null) {\n            // If we have no parent, than we are done.\n            return NO_PARENT_INJECTOR;\n        }\n        ngDevMode && parentTNode && assertTNodeForLView(parentTNode, lViewCursor[DECLARATION_VIEW]);\n        // Every iteration of the loop requires that we go to the declared parent.\n        declarationViewOffset++;\n        lViewCursor = lViewCursor[DECLARATION_VIEW];\n        if (parentTNode.injectorIndex !== -1) {\n            // We found a NodeInjector which points to something.\n            return (parentTNode.injectorIndex |\n                (declarationViewOffset << 16 /* RelativeInjectorLocationFlags.ViewOffsetShift */));\n        }\n    }\n    return NO_PARENT_INJECTOR;\n}\n/**\n * Makes a type or an injection token public to the DI system by adding it to an\n * injector's bloom filter.\n *\n * @param di The node injector in which a directive will be added\n * @param token The type or the injection token to be made public\n */\nfunction diPublicInInjector(injectorIndex, tView, token) {\n    bloomAdd(injectorIndex, tView, token);\n}\n/**\n * Inject static attribute value into directive constructor.\n *\n * This method is used with `factory` functions which are generated as part of\n * `defineDirective` or `defineComponent`. The method retrieves the static value\n * of an attribute. (Dynamic attributes are not supported since they are not resolved\n *  at the time of injection and can change over time.)\n *\n * # Example\n * Given:\n * ```\n * @Component(...)\n * class MyComponent {\n *   constructor(@Attribute('title') title: string) { ... }\n * }\n * ```\n * When instantiated with\n * ```\n * <my-component title=\"Hello\"></my-component>\n * ```\n *\n * Then factory method generated is:\n * ```\n * MyComponent.ɵcmp = defineComponent({\n *   factory: () => new MyComponent(injectAttribute('title'))\n *   ...\n * })\n * ```\n *\n * @publicApi\n */\nfunction injectAttributeImpl(tNode, attrNameToInject) {\n    ngDevMode && assertTNodeType(tNode, 12 /* TNodeType.AnyContainer */ | 3 /* TNodeType.AnyRNode */);\n    ngDevMode && assertDefined(tNode, 'expecting tNode');\n    if (attrNameToInject === 'class') {\n        return tNode.classes;\n    }\n    if (attrNameToInject === 'style') {\n        return tNode.styles;\n    }\n    const attrs = tNode.attrs;\n    if (attrs) {\n        const attrsLength = attrs.length;\n        let i = 0;\n        while (i < attrsLength) {\n            const value = attrs[i];\n            // If we hit a `Bindings` or `Template` marker then we are done.\n            if (isNameOnlyAttributeMarker(value))\n                break;\n            // Skip namespaced attributes\n            if (value === 0 /* AttributeMarker.NamespaceURI */) {\n                // we skip the next two values\n                // as namespaced attributes looks like\n                // [..., AttributeMarker.NamespaceURI, 'http://someuri.com/test', 'test:exist',\n                // 'existValue', ...]\n                i = i + 2;\n            }\n            else if (typeof value === 'number') {\n                // Skip to the first value of the marked attribute.\n                i++;\n                while (i < attrsLength && typeof attrs[i] === 'string') {\n                    i++;\n                }\n            }\n            else if (value === attrNameToInject) {\n                return attrs[i + 1];\n            }\n            else {\n                i = i + 2;\n            }\n        }\n    }\n    return null;\n}\nfunction notFoundValueOrThrow(notFoundValue, token, flags) {\n    if (flags & InjectFlags.Optional) {\n        return notFoundValue;\n    }\n    else {\n        throwProviderNotFoundError(token, 'NodeInjector');\n    }\n}\n/**\n * Returns the value associated to the given token from the ModuleInjector or throws exception\n *\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`\n * @returns the value from the injector or throws an exception\n */\nfunction lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue) {\n    if (flags & InjectFlags.Optional && notFoundValue === undefined) {\n        // This must be set or the NullInjector will throw for optional deps\n        notFoundValue = null;\n    }\n    if ((flags & (InjectFlags.Self | InjectFlags.Host)) === 0) {\n        const moduleInjector = lView[INJECTOR$1];\n        // switch to `injectInjectorOnly` implementation for module injector, since module injector\n        // should not have access to Component/Directive DI scope (that may happen through\n        // `directiveInject` implementation)\n        const previousInjectImplementation = setInjectImplementation(undefined);\n        try {\n            if (moduleInjector) {\n                return moduleInjector.get(token, notFoundValue, flags & InjectFlags.Optional);\n            }\n            else {\n                return injectRootLimpMode(token, notFoundValue, flags & InjectFlags.Optional);\n            }\n        }\n        finally {\n            setInjectImplementation(previousInjectImplementation);\n        }\n    }\n    return notFoundValueOrThrow(notFoundValue, token, flags);\n}\n/**\n * Returns the value associated to the given token from the NodeInjectors => ModuleInjector.\n *\n * Look for the injector providing the token by walking up the node injector tree and then\n * the module injector tree.\n *\n * This function patches `token` with `__NG_ELEMENT_ID__` which contains the id for the bloom\n * filter. `-1` is reserved for injecting `Injector` (implemented by `NodeInjector`)\n *\n * @param tNode The Node where the search for the injector should start\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`\n * @returns the value from the injector, `null` when not found, or `notFoundValue` if provided\n */\nfunction getOrCreateInjectable(tNode, lView, token, flags = InjectFlags.Default, notFoundValue) {\n    if (tNode !== null) {\n        // If the view or any of its ancestors have an embedded\n        // view injector, we have to look it up there first.\n        if (lView[FLAGS] & 1024 /* LViewFlags.HasEmbeddedViewInjector */) {\n            const embeddedInjectorValue = lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, NOT_FOUND);\n            if (embeddedInjectorValue !== NOT_FOUND) {\n                return embeddedInjectorValue;\n            }\n        }\n        // Otherwise try the node injector.\n        const value = lookupTokenUsingNodeInjector(tNode, lView, token, flags, NOT_FOUND);\n        if (value !== NOT_FOUND) {\n            return value;\n        }\n    }\n    // Finally, fall back to the module injector.\n    return lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);\n}\n/**\n * Returns the value associated to the given token from the node injector.\n *\n * @param tNode The Node where the search for the injector should start\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`\n * @returns the value from the injector, `null` when not found, or `notFoundValue` if provided\n */\nfunction lookupTokenUsingNodeInjector(tNode, lView, token, flags, notFoundValue) {\n    const bloomHash = bloomHashBitOrFactory(token);\n    // If the ID stored here is a function, this is a special object like ElementRef or TemplateRef\n    // so just call the factory function to create it.\n    if (typeof bloomHash === 'function') {\n        if (!enterDI(lView, tNode, flags)) {\n            // Failed to enter DI, try module injector instead. If a token is injected with the @Host\n            // flag, the module injector is not searched for that token in Ivy.\n            return (flags & InjectFlags.Host) ?\n                notFoundValueOrThrow(notFoundValue, token, flags) :\n                lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);\n        }\n        try {\n            const value = bloomHash(flags);\n            if (value == null && !(flags & InjectFlags.Optional)) {\n                throwProviderNotFoundError(token);\n            }\n            else {\n                return value;\n            }\n        }\n        finally {\n            leaveDI();\n        }\n    }\n    else if (typeof bloomHash === 'number') {\n        // A reference to the previous injector TView that was found while climbing the element\n        // injector tree. This is used to know if viewProviders can be accessed on the current\n        // injector.\n        let previousTView = null;\n        let injectorIndex = getInjectorIndex(tNode, lView);\n        let parentLocation = NO_PARENT_INJECTOR;\n        let hostTElementNode = flags & InjectFlags.Host ? lView[DECLARATION_COMPONENT_VIEW][T_HOST] : null;\n        // If we should skip this injector, or if there is no injector on this node, start by\n        // searching the parent injector.\n        if (injectorIndex === -1 || flags & InjectFlags.SkipSelf) {\n            parentLocation = injectorIndex === -1 ? getParentInjectorLocation(tNode, lView) :\n                lView[injectorIndex + 8 /* NodeInjectorOffset.PARENT */];\n            if (parentLocation === NO_PARENT_INJECTOR || !shouldSearchParent(flags, false)) {\n                injectorIndex = -1;\n            }\n            else {\n                previousTView = lView[TVIEW];\n                injectorIndex = getParentInjectorIndex(parentLocation);\n                lView = getParentInjectorView(parentLocation, lView);\n            }\n        }\n        // Traverse up the injector tree until we find a potential match or until we know there\n        // *isn't* a match.\n        while (injectorIndex !== -1) {\n            ngDevMode && assertNodeInjector(lView, injectorIndex);\n            // Check the current injector. If it matches, see if it contains token.\n            const tView = lView[TVIEW];\n            ngDevMode &&\n                assertTNodeForLView(tView.data[injectorIndex + 8 /* NodeInjectorOffset.TNODE */], lView);\n            if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {\n                // At this point, we have an injector which *may* contain the token, so we step through\n                // the providers and directives associated with the injector's corresponding node to get\n                // the instance.\n                const instance = searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode);\n                if (instance !== NOT_FOUND) {\n                    return instance;\n                }\n            }\n            parentLocation = lView[injectorIndex + 8 /* NodeInjectorOffset.PARENT */];\n            if (parentLocation !== NO_PARENT_INJECTOR &&\n                shouldSearchParent(flags, lView[TVIEW].data[injectorIndex + 8 /* NodeInjectorOffset.TNODE */] === hostTElementNode) &&\n                bloomHasToken(bloomHash, injectorIndex, lView)) {\n                // The def wasn't found anywhere on this node, so it was a false positive.\n                // Traverse up the tree and continue searching.\n                previousTView = tView;\n                injectorIndex = getParentInjectorIndex(parentLocation);\n                lView = getParentInjectorView(parentLocation, lView);\n            }\n            else {\n                // If we should not search parent OR If the ancestor bloom filter value does not have the\n                // bit corresponding to the directive we can give up on traversing up to find the specific\n                // injector.\n                injectorIndex = -1;\n            }\n        }\n    }\n    return notFoundValue;\n}\nfunction searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode) {\n    const currentTView = lView[TVIEW];\n    const tNode = currentTView.data[injectorIndex + 8 /* NodeInjectorOffset.TNODE */];\n    // First, we need to determine if view providers can be accessed by the starting element.\n    // There are two possibilities\n    const canAccessViewProviders = previousTView == null ?\n        // 1) This is the first invocation `previousTView == null` which means that we are at the\n        // `TNode` of where injector is starting to look. In such a case the only time we are allowed\n        // to look into the ViewProviders is if:\n        // - we are on a component\n        // - AND the injector set `includeViewProviders` to true (implying that the token can see\n        // ViewProviders because it is the Component or a Service which itself was declared in\n        // ViewProviders)\n        (isComponentHost(tNode) && includeViewProviders) :\n        // 2) `previousTView != null` which means that we are now walking across the parent nodes.\n        // In such a case we are only allowed to look into the ViewProviders if:\n        // - We just crossed from child View to Parent View `previousTView != currentTView`\n        // - AND the parent TNode is an Element.\n        // This means that we just came from the Component's View and therefore are allowed to see\n        // into the ViewProviders.\n        (previousTView != currentTView && ((tNode.type & 3 /* TNodeType.AnyRNode */) !== 0));\n    // This special case happens when there is a @host on the inject and when we are searching\n    // on the host element node.\n    const isHostSpecialCase = (flags & InjectFlags.Host) && hostTElementNode === tNode;\n    const injectableIdx = locateDirectiveOrProvider(tNode, currentTView, token, canAccessViewProviders, isHostSpecialCase);\n    if (injectableIdx !== null) {\n        return getNodeInjectable(lView, currentTView, injectableIdx, tNode);\n    }\n    else {\n        return NOT_FOUND;\n    }\n}\n/**\n * Searches for the given token among the node's directives and providers.\n *\n * @param tNode TNode on which directives are present.\n * @param tView The tView we are currently processing\n * @param token Provider token or type of a directive to look for.\n * @param canAccessViewProviders Whether view providers should be considered.\n * @param isHostSpecialCase Whether the host special case applies.\n * @returns Index of a found directive or provider, or null when none found.\n */\nfunction locateDirectiveOrProvider(tNode, tView, token, canAccessViewProviders, isHostSpecialCase) {\n    const nodeProviderIndexes = tNode.providerIndexes;\n    const tInjectables = tView.data;\n    const injectablesStart = nodeProviderIndexes & 1048575 /* TNodeProviderIndexes.ProvidersStartIndexMask */;\n    const directivesStart = tNode.directiveStart;\n    const directiveEnd = tNode.directiveEnd;\n    const cptViewProvidersCount = nodeProviderIndexes >> 20 /* TNodeProviderIndexes.CptViewProvidersCountShift */;\n    const startingIndex = canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount;\n    // When the host special case applies, only the viewProviders and the component are visible\n    const endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;\n    for (let i = startingIndex; i < endIndex; i++) {\n        const providerTokenOrDef = tInjectables[i];\n        if (i < directivesStart && token === providerTokenOrDef ||\n            i >= directivesStart && providerTokenOrDef.type === token) {\n            return i;\n        }\n    }\n    if (isHostSpecialCase) {\n        const dirDef = tInjectables[directivesStart];\n        if (dirDef && isComponentDef(dirDef) && dirDef.type === token) {\n            return directivesStart;\n        }\n    }\n    return null;\n}\n/**\n * Retrieve or instantiate the injectable from the `LView` at particular `index`.\n *\n * This function checks to see if the value has already been instantiated and if so returns the\n * cached `injectable`. Otherwise if it detects that the value is still a factory it\n * instantiates the `injectable` and caches the value.\n */\nfunction getNodeInjectable(lView, tView, index, tNode) {\n    let value = lView[index];\n    const tData = tView.data;\n    if (isFactory(value)) {\n        const factory = value;\n        if (factory.resolving) {\n            throwCyclicDependencyError(stringifyForError(tData[index]));\n        }\n        const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);\n        factory.resolving = true;\n        const previousInjectImplementation = factory.injectImpl ? setInjectImplementation(factory.injectImpl) : null;\n        const success = enterDI(lView, tNode, InjectFlags.Default);\n        ngDevMode &&\n            assertEqual(success, true, 'Because flags do not contain \\`SkipSelf\\' we expect this to always succeed.');\n        try {\n            value = lView[index] = factory.factory(undefined, tData, lView, tNode);\n            // This code path is hit for both directives and providers.\n            // For perf reasons, we want to avoid searching for hooks on providers.\n            // It does no harm to try (the hooks just won't exist), but the extra\n            // checks are unnecessary and this is a hot path. So we check to see\n            // if the index of the dependency is in the directive range for this\n            // tNode. If it's not, we know it's a provider and skip hook registration.\n            if (tView.firstCreatePass && index >= tNode.directiveStart) {\n                ngDevMode && assertDirectiveDef(tData[index]);\n                registerPreOrderHooks(index, tData[index], tView);\n            }\n        }\n        finally {\n            previousInjectImplementation !== null &&\n                setInjectImplementation(previousInjectImplementation);\n            setIncludeViewProviders(previousIncludeViewProviders);\n            factory.resolving = false;\n            leaveDI();\n        }\n    }\n    return value;\n}\n/**\n * Returns the bit in an injector's bloom filter that should be used to determine whether or not\n * the directive might be provided by the injector.\n *\n * When a directive is public, it is added to the bloom filter and given a unique ID that can be\n * retrieved on the Type. When the directive isn't public or the token is not a directive `null`\n * is returned as the node injector can not possibly provide that token.\n *\n * @param token the injection token\n * @returns the matching bit to check in the bloom filter or `null` if the token is not known.\n *   When the returned value is negative then it represents special values such as `Injector`.\n */\nfunction bloomHashBitOrFactory(token) {\n    ngDevMode && assertDefined(token, 'token must be defined');\n    if (typeof token === 'string') {\n        return token.charCodeAt(0) || 0;\n    }\n    const tokenId = \n    // First check with `hasOwnProperty` so we don't get an inherited ID.\n    token.hasOwnProperty(NG_ELEMENT_ID) ? token[NG_ELEMENT_ID] : undefined;\n    // Negative token IDs are used for special objects such as `Injector`\n    if (typeof tokenId === 'number') {\n        if (tokenId >= 0) {\n            return tokenId & BLOOM_MASK;\n        }\n        else {\n            ngDevMode &&\n                assertEqual(tokenId, -1 /* InjectorMarkers.Injector */, 'Expecting to get Special Injector Id');\n            return createNodeInjector;\n        }\n    }\n    else {\n        return tokenId;\n    }\n}\nfunction bloomHasToken(bloomHash, injectorIndex, injectorView) {\n    // Create a mask that targets the specific bit associated with the directive we're looking for.\n    // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n    // to bit positions 0 - 31 in a 32 bit integer.\n    const mask = 1 << bloomHash;\n    // Each bloom bucket in `injectorView` represents `BLOOM_BUCKET_BITS` number of bits of\n    // `bloomHash`. Any bits in `bloomHash` beyond `BLOOM_BUCKET_BITS` indicate the bucket offset\n    // that should be used.\n    const value = injectorView[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)];\n    // If the bloom filter value has the bit corresponding to the directive's bloomBit flipped on,\n    // this injector is a potential match.\n    return !!(value & mask);\n}\n/** Returns true if flags prevent parent injector from being searched for tokens */\nfunction shouldSearchParent(flags, isFirstHostTNode) {\n    return !(flags & InjectFlags.Self) && !(flags & InjectFlags.Host && isFirstHostTNode);\n}\nclass NodeInjector {\n    constructor(_tNode, _lView) {\n        this._tNode = _tNode;\n        this._lView = _lView;\n    }\n    get(token, notFoundValue, flags) {\n        return getOrCreateInjectable(this._tNode, this._lView, token, flags, notFoundValue);\n    }\n}\n/** Creates a `NodeInjector` for the current node. */\nfunction createNodeInjector() {\n    return new NodeInjector(getCurrentTNode(), getLView());\n}\n/**\n * @codeGenApi\n */\nfunction ɵɵgetInheritedFactory(type) {\n    return noSideEffects(() => {\n        const ownConstructor = type.prototype.constructor;\n        const ownFactory = ownConstructor[NG_FACTORY_DEF] || getFactoryOf(ownConstructor);\n        const objectPrototype = Object.prototype;\n        let parent = Object.getPrototypeOf(type.prototype).constructor;\n        // Go up the prototype until we hit `Object`.\n        while (parent && parent !== objectPrototype) {\n            const factory = parent[NG_FACTORY_DEF] || getFactoryOf(parent);\n            // If we hit something that has a factory and the factory isn't the same as the type,\n            // we've found the inherited factory. Note the check that the factory isn't the type's\n            // own factory is redundant in most cases, but if the user has custom decorators on the\n            // class, this lookup will start one level down in the prototype chain, causing us to\n            // find the own factory first and potentially triggering an infinite loop downstream.\n            if (factory && factory !== ownFactory) {\n                return factory;\n            }\n            parent = Object.getPrototypeOf(parent);\n        }\n        // There is no factory defined. Either this was improper usage of inheritance\n        // (no Angular decorator on the superclass) or there is no constructor at all\n        // in the inheritance chain. Since the two cases cannot be distinguished, the\n        // latter has to be assumed.\n        return t => new t();\n    });\n}\nfunction getFactoryOf(type) {\n    if (isForwardRef(type)) {\n        return () => {\n            const factory = getFactoryOf(resolveForwardRef(type));\n            return factory && factory();\n        };\n    }\n    return getFactoryDef(type);\n}\n/**\n * Returns a value from the closest embedded or node injector.\n *\n * @param tNode The Node where the search for the injector should start\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`\n * @returns the value from the injector, `null` when not found, or `notFoundValue` if provided\n */\nfunction lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, notFoundValue) {\n    let currentTNode = tNode;\n    let currentLView = lView;\n    // When an LView with an embedded view injector is inserted, it'll likely be interlaced with\n    // nodes who may have injectors (e.g. node injector -> embedded view injector -> node injector).\n    // Since the bloom filters for the node injectors have already been constructed and we don't\n    // have a way of extracting the records from an injector, the only way to maintain the correct\n    // hierarchy when resolving the value is to walk it node-by-node while attempting to resolve\n    // the token at each level.\n    while (currentTNode !== null && currentLView !== null &&\n        (currentLView[FLAGS] & 1024 /* LViewFlags.HasEmbeddedViewInjector */) &&\n        !(currentLView[FLAGS] & 256 /* LViewFlags.IsRoot */)) {\n        ngDevMode && assertTNodeForLView(currentTNode, currentLView);\n        // Note that this lookup on the node injector is using the `Self` flag, because\n        // we don't want the node injector to look at any parent injectors since we\n        // may hit the embedded view injector first.\n        const nodeInjectorValue = lookupTokenUsingNodeInjector(currentTNode, currentLView, token, flags | InjectFlags.Self, NOT_FOUND);\n        if (nodeInjectorValue !== NOT_FOUND) {\n            return nodeInjectorValue;\n        }\n        // Has an explicit type due to a TS bug: https://github.com/microsoft/TypeScript/issues/33191\n        let parentTNode = currentTNode.parent;\n        // `TNode.parent` includes the parent within the current view only. If it doesn't exist,\n        // it means that we've hit the view boundary and we need to go up to the next view.\n        if (!parentTNode) {\n            // Before we go to the next LView, check if the token exists on the current embedded injector.\n            const embeddedViewInjector = currentLView[EMBEDDED_VIEW_INJECTOR];\n            if (embeddedViewInjector) {\n                const embeddedViewInjectorValue = embeddedViewInjector.get(token, NOT_FOUND, flags);\n                if (embeddedViewInjectorValue !== NOT_FOUND) {\n                    return embeddedViewInjectorValue;\n                }\n            }\n            // Otherwise keep going up the tree.\n            parentTNode = getTNodeFromLView(currentLView);\n            currentLView = currentLView[DECLARATION_VIEW];\n        }\n        currentTNode = parentTNode;\n    }\n    return notFoundValue;\n}\n/** Gets the TNode associated with an LView inside of the declaration view. */\nfunction getTNodeFromLView(lView) {\n    const tView = lView[TVIEW];\n    const tViewType = tView.type;\n    // The parent pointer differs based on `TView.type`.\n    if (tViewType === 2 /* TViewType.Embedded */) {\n        ngDevMode && assertDefined(tView.declTNode, 'Embedded TNodes should have declaration parents.');\n        return tView.declTNode;\n    }\n    else if (tViewType === 1 /* TViewType.Component */) {\n        // Components don't have `TView.declTNode` because each instance of component could be\n        // inserted in different location, hence `TView.declTNode` is meaningless.\n        return lView[T_HOST];\n    }\n    return null;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Facade for the attribute injection from DI.\n *\n * @codeGenApi\n */\nfunction ɵɵinjectAttribute(attrNameToInject) {\n    return injectAttributeImpl(getCurrentTNode(), attrNameToInject);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Attribute decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Attribute = makeParamDecorator('Attribute', (attributeName) => ({ attributeName, __NG_ELEMENT_ID__: () => ɵɵinjectAttribute(attributeName) }));\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nlet _reflect = null;\nfunction getReflect() {\n    return (_reflect = _reflect || new ReflectionCapabilities());\n}\nfunction reflectDependencies(type) {\n    return convertDependencies(getReflect().parameters(type));\n}\nfunction convertDependencies(deps) {\n    return deps.map(dep => reflectDependency(dep));\n}\nfunction reflectDependency(dep) {\n    const meta = {\n        token: null,\n        attribute: null,\n        host: false,\n        optional: false,\n        self: false,\n        skipSelf: false,\n    };\n    if (Array.isArray(dep) && dep.length > 0) {\n        for (let j = 0; j < dep.length; j++) {\n            const param = dep[j];\n            if (param === undefined) {\n                // param may be undefined if type of dep is not set by ngtsc\n                continue;\n            }\n            const proto = Object.getPrototypeOf(param);\n            if (param instanceof Optional || proto.ngMetadataName === 'Optional') {\n                meta.optional = true;\n            }\n            else if (param instanceof SkipSelf || proto.ngMetadataName === 'SkipSelf') {\n                meta.skipSelf = true;\n            }\n            else if (param instanceof Self || proto.ngMetadataName === 'Self') {\n                meta.self = true;\n            }\n            else if (param instanceof Host || proto.ngMetadataName === 'Host') {\n                meta.host = true;\n            }\n            else if (param instanceof Inject) {\n                meta.token = param.token;\n            }\n            else if (param instanceof Attribute) {\n                if (param.attributeName === undefined) {\n                    throw new Error(`Attribute name must be defined.`);\n                }\n                meta.attribute = param.attributeName;\n            }\n            else {\n                meta.token = param;\n            }\n        }\n    }\n    else if (dep === undefined || (Array.isArray(dep) && dep.length === 0)) {\n        meta.token = null;\n    }\n    else {\n        meta.token = dep;\n    }\n    return meta;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Map of module-id to the corresponding NgModule.\n */\nconst modules = new Map();\n/**\n * Whether to check for duplicate NgModule registrations.\n *\n * This can be disabled for testing.\n */\nlet checkForDuplicateNgModules = true;\nfunction assertSameOrNotExisting(id, type, incoming) {\n    if (type && type !== incoming && checkForDuplicateNgModules) {\n        throw new Error(`Duplicate module registered for ${id} - ${stringify(type)} vs ${stringify(type.name)}`);\n    }\n}\n/**\n * Adds the given NgModule type to Angular's NgModule registry.\n *\n * This is generated as a side-effect of NgModule compilation. Note that the `id` is passed in\n * explicitly and not read from the NgModule definition. This is for two reasons: it avoids a\n * megamorphic read, and in JIT there's a chicken-and-egg problem where the NgModule may not be\n * fully resolved when it's registered.\n *\n * @codeGenApi\n */\nfunction registerNgModuleType(ngModuleType, id) {\n    const existing = modules.get(id) || null;\n    assertSameOrNotExisting(id, existing, ngModuleType);\n    modules.set(id, ngModuleType);\n}\nfunction clearModulesForTest() {\n    modules.clear();\n}\nfunction getRegisteredNgModuleType(id) {\n    return modules.get(id);\n}\n/**\n * Control whether the NgModule registration system enforces that each NgModule type registered has\n * a unique id.\n *\n * This is useful for testing as the NgModule registry cannot be properly reset between tests with\n * Angular's current API.\n */\nfunction setAllowDuplicateNgModuleIdsForTest(allowDuplicates) {\n    checkForDuplicateNgModules = !allowDuplicates;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst defaultScheduler = (() => (typeof requestAnimationFrame !== 'undefined' &&\n    requestAnimationFrame || // browser only\n    setTimeout // everything else\n)\n    .bind(_global$1))();\n/**\n *\n * @codeGenApi\n */\nfunction ɵɵresolveWindow(element) {\n    return element.ownerDocument.defaultView;\n}\n/**\n *\n * @codeGenApi\n */\nfunction ɵɵresolveDocument(element) {\n    return element.ownerDocument;\n}\n/**\n *\n * @codeGenApi\n */\nfunction ɵɵresolveBody(element) {\n    return element.ownerDocument.body;\n}\n/**\n * The special delimiter we use to separate property names, prefixes, and suffixes\n * in property binding metadata. See storeBindingMetadata().\n *\n * We intentionally use the Unicode \"REPLACEMENT CHARACTER\" (U+FFFD) as a delimiter\n * because it is a very uncommon character that is unlikely to be part of a user's\n * property names or interpolation strings. If it is in fact used in a property\n * binding, DebugElement.properties will not return the correct value for that\n * binding. However, there should be no runtime effect for real applications.\n *\n * This character is typically rendered as a question mark inside of a diamond.\n * See https://en.wikipedia.org/wiki/Specials_(Unicode_block)\n *\n */\nconst INTERPOLATION_DELIMITER = `�`;\n/**\n * Unwrap a value which might be behind a closure (for forward declaration reasons).\n */\nfunction maybeUnwrapFn$1(value) {\n    if (value instanceof Function) {\n        return value();\n    }\n    else {\n        return value;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * The Trusted Types policy, or null if Trusted Types are not\n * enabled/supported, or undefined if the policy has not been created yet.\n */\nlet policy$1;\n/**\n * Returns the Trusted Types policy, or null if Trusted Types are not\n * enabled/supported. The first call to this function will create the policy.\n */\nfunction getPolicy$1() {\n    if (policy$1 === undefined) {\n        policy$1 = null;\n        if (_global$1.trustedTypes) {\n            try {\n                policy$1 = _global$1.trustedTypes.createPolicy('angular', {\n                    createHTML: (s) => s,\n                    createScript: (s) => s,\n                    createScriptURL: (s) => s,\n                });\n            }\n            catch (_a) {\n                // trustedTypes.createPolicy throws if called with a name that is\n                // already registered, even in report-only mode. Until the API changes,\n                // catch the error not to break the applications functionally. In such\n                // cases, the code will fall back to using strings.\n            }\n        }\n    }\n    return policy$1;\n}\n/**\n * Unsafely promote a string to a TrustedHTML, falling back to strings when\n * Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that the\n * provided string will never cause an XSS vulnerability if used in a context\n * that will be interpreted as HTML by a browser, e.g. when assigning to\n * element.innerHTML.\n */\nfunction trustedHTMLFromString(html) {\n    var _a;\n    return ((_a = getPolicy$1()) === null || _a === void 0 ? void 0 : _a.createHTML(html)) || html;\n}\n/**\n * Unsafely promote a string to a TrustedScript, falling back to strings when\n * Trusted Types are not available.\n * @security In particular, it must be assured that the provided string will\n * never cause an XSS vulnerability if used in a context that will be\n * interpreted and executed as a script by a browser, e.g. when calling eval.\n */\nfunction trustedScriptFromString(script) {\n    var _a;\n    return ((_a = getPolicy$1()) === null || _a === void 0 ? void 0 : _a.createScript(script)) || script;\n}\n/**\n * Unsafely promote a string to a TrustedScriptURL, falling back to strings\n * when Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that the\n * provided string will never cause an XSS vulnerability if used in a context\n * that will cause a browser to load and execute a resource, e.g. when\n * assigning to script.src.\n */\nfunction trustedScriptURLFromString(url) {\n    var _a;\n    return ((_a = getPolicy$1()) === null || _a === void 0 ? void 0 : _a.createScriptURL(url)) || url;\n}\n/**\n * Unsafely call the Function constructor with the given string arguments. It\n * is only available in development mode, and should be stripped out of\n * production code.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only called from development code, as use in production code can lead to\n * XSS vulnerabilities.\n */\nfunction newTrustedFunctionForDev(...args) {\n    if (typeof ngDevMode === 'undefined') {\n        throw new Error('newTrustedFunctionForDev should never be called in production');\n    }\n    if (!_global$1.trustedTypes) {\n        // In environments that don't support Trusted Types, fall back to the most\n        // straightforward implementation:\n        return new Function(...args);\n    }\n    // Chrome currently does not support passing TrustedScript to the Function\n    // constructor. The following implements the workaround proposed on the page\n    // below, where the Chromium bug is also referenced:\n    // https://github.com/w3c/webappsec-trusted-types/wiki/Trusted-Types-for-function-constructor\n    const fnArgs = args.slice(0, -1).join(',');\n    const fnBody = args[args.length - 1];\n    const body = `(function anonymous(${fnArgs}\n) { ${fnBody}\n})`;\n    // Using eval directly confuses the compiler and prevents this module from\n    // being stripped out of JS binaries even if not used. The global['eval']\n    // indirection fixes that.\n    const fn = _global$1['eval'](trustedScriptFromString(body));\n    if (fn.bind === undefined) {\n        // Workaround for a browser bug that only exists in Chrome 83, where passing\n        // a TrustedScript to eval just returns the TrustedScript back without\n        // evaluating it. In that case, fall back to the most straightforward\n        // implementation:\n        return new Function(...args);\n    }\n    // To completely mimic the behavior of calling \"new Function\", two more\n    // things need to happen:\n    // 1. Stringifying the resulting function should return its source code\n    fn.toString = () => body;\n    // 2. When calling the resulting function, `this` should refer to `global`\n    return fn.bind(_global$1);\n    // When Trusted Types support in Function constructors is widely available,\n    // the implementation of this function can be simplified to:\n    // return new Function(...args.map(a => trustedScriptFromString(a)));\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * The Trusted Types policy, or null if Trusted Types are not\n * enabled/supported, or undefined if the policy has not been created yet.\n */\nlet policy;\n/**\n * Returns the Trusted Types policy, or null if Trusted Types are not\n * enabled/supported. The first call to this function will create the policy.\n */\nfunction getPolicy() {\n    if (policy === undefined) {\n        policy = null;\n        if (_global$1.trustedTypes) {\n            try {\n                policy = _global$1.trustedTypes\n                    .createPolicy('angular#unsafe-bypass', {\n                    createHTML: (s) => s,\n                    createScript: (s) => s,\n                    createScriptURL: (s) => s,\n                });\n            }\n            catch (_a) {\n                // trustedTypes.createPolicy throws if called with a name that is\n                // already registered, even in report-only mode. Until the API changes,\n                // catch the error not to break the applications functionally. In such\n                // cases, the code will fall back to using strings.\n            }\n        }\n    }\n    return policy;\n}\n/**\n * Unsafely promote a string to a TrustedHTML, falling back to strings when\n * Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only passed strings that come directly from custom sanitizers or the\n * bypassSecurityTrust* functions.\n */\nfunction trustedHTMLFromStringBypass(html) {\n    var _a;\n    return ((_a = getPolicy()) === null || _a === void 0 ? void 0 : _a.createHTML(html)) || html;\n}\n/**\n * Unsafely promote a string to a TrustedScript, falling back to strings when\n * Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only passed strings that come directly from custom sanitizers or the\n * bypassSecurityTrust* functions.\n */\nfunction trustedScriptFromStringBypass(script) {\n    var _a;\n    return ((_a = getPolicy()) === null || _a === void 0 ? void 0 : _a.createScript(script)) || script;\n}\n/**\n * Unsafely promote a string to a TrustedScriptURL, falling back to strings\n * when Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only passed strings that come directly from custom sanitizers or the\n * bypassSecurityTrust* functions.\n */\nfunction trustedScriptURLFromStringBypass(url) {\n    var _a;\n    return ((_a = getPolicy()) === null || _a === void 0 ? void 0 : _a.createScriptURL(url)) || url;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass SafeValueImpl {\n    constructor(changingThisBreaksApplicationSecurity) {\n        this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;\n    }\n    toString() {\n        return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity}` +\n            ` (see https://g.co/ng/security#xss)`;\n    }\n}\nclass SafeHtmlImpl extends SafeValueImpl {\n    getTypeName() {\n        return \"HTML\" /* BypassType.Html */;\n    }\n}\nclass SafeStyleImpl extends SafeValueImpl {\n    getTypeName() {\n        return \"Style\" /* BypassType.Style */;\n    }\n}\nclass SafeScriptImpl extends SafeValueImpl {\n    getTypeName() {\n        return \"Script\" /* BypassType.Script */;\n    }\n}\nclass SafeUrlImpl extends SafeValueImpl {\n    getTypeName() {\n        return \"URL\" /* BypassType.Url */;\n    }\n}\nclass SafeResourceUrlImpl extends SafeValueImpl {\n    getTypeName() {\n        return \"ResourceURL\" /* BypassType.ResourceUrl */;\n    }\n}\nfunction unwrapSafeValue(value) {\n    return value instanceof SafeValueImpl ? value.changingThisBreaksApplicationSecurity :\n        value;\n}\nfunction allowSanitizationBypassAndThrow(value, type) {\n    const actualType = getSanitizationBypassType(value);\n    if (actualType != null && actualType !== type) {\n        // Allow ResourceURLs in URL contexts, they are strictly more trusted.\n        if (actualType === \"ResourceURL\" /* BypassType.ResourceUrl */ && type === \"URL\" /* BypassType.Url */)\n            return true;\n        throw new Error(`Required a safe ${type}, got a ${actualType} (see https://g.co/ng/security#xss)`);\n    }\n    return actualType === type;\n}\nfunction getSanitizationBypassType(value) {\n    return value instanceof SafeValueImpl && value.getTypeName() || null;\n}\n/**\n * Mark `html` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link htmlSanitizer} to be trusted implicitly.\n *\n * @param trustedHtml `html` string which needs to be implicitly trusted.\n * @returns a `html` which has been branded to be implicitly trusted.\n */\nfunction bypassSanitizationTrustHtml(trustedHtml) {\n    return new SafeHtmlImpl(trustedHtml);\n}\n/**\n * Mark `style` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link styleSanitizer} to be trusted implicitly.\n *\n * @param trustedStyle `style` string which needs to be implicitly trusted.\n * @returns a `style` hich has been branded to be implicitly trusted.\n */\nfunction bypassSanitizationTrustStyle(trustedStyle) {\n    return new SafeStyleImpl(trustedStyle);\n}\n/**\n * Mark `script` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link scriptSanitizer} to be trusted implicitly.\n *\n * @param trustedScript `script` string which needs to be implicitly trusted.\n * @returns a `script` which has been branded to be implicitly trusted.\n */\nfunction bypassSanitizationTrustScript(trustedScript) {\n    return new SafeScriptImpl(trustedScript);\n}\n/**\n * Mark `url` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link urlSanitizer} to be trusted implicitly.\n *\n * @param trustedUrl `url` string which needs to be implicitly trusted.\n * @returns a `url`  which has been branded to be implicitly trusted.\n */\nfunction bypassSanitizationTrustUrl(trustedUrl) {\n    return new SafeUrlImpl(trustedUrl);\n}\n/**\n * Mark `url` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link resourceUrlSanitizer} to be trusted implicitly.\n *\n * @param trustedResourceUrl `url` string which needs to be implicitly trusted.\n * @returns a `url` which has been branded to be implicitly trusted.\n */\nfunction bypassSanitizationTrustResourceUrl(trustedResourceUrl) {\n    return new SafeResourceUrlImpl(trustedResourceUrl);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * This helper is used to get hold of an inert tree of DOM elements containing dirty HTML\n * that needs sanitizing.\n * Depending upon browser support we use one of two strategies for doing this.\n * Default: DOMParser strategy\n * Fallback: InertDocument strategy\n */\nfunction getInertBodyHelper(defaultDoc) {\n    const inertDocumentHelper = new InertDocumentHelper(defaultDoc);\n    return isDOMParserAvailable() ? new DOMParserHelper(inertDocumentHelper) : inertDocumentHelper;\n}\n/**\n * Uses DOMParser to create and fill an inert body element.\n * This is the default strategy used in browsers that support it.\n */\nclass DOMParserHelper {\n    constructor(inertDocumentHelper) {\n        this.inertDocumentHelper = inertDocumentHelper;\n    }\n    getInertBodyElement(html) {\n        // We add these extra elements to ensure that the rest of the content is parsed as expected\n        // e.g. leading whitespace is maintained and tags like `<meta>` do not get hoisted to the\n        // `<head>` tag. Note that the `<body>` tag is closed implicitly to prevent unclosed tags\n        // in `html` from consuming the otherwise explicit `</body>` tag.\n        html = '<body><remove></remove>' + html;\n        try {\n            const body = new window.DOMParser()\n                .parseFromString(trustedHTMLFromString(html), 'text/html')\n                .body;\n            if (body === null) {\n                // In some browsers (e.g. Mozilla/5.0 iPad AppleWebKit Mobile) the `body` property only\n                // becomes available in the following tick of the JS engine. In that case we fall back to\n                // the `inertDocumentHelper` instead.\n                return this.inertDocumentHelper.getInertBodyElement(html);\n            }\n            body.removeChild(body.firstChild);\n            return body;\n        }\n        catch (_a) {\n            return null;\n        }\n    }\n}\n/**\n * Use an HTML5 `template` element, if supported, or an inert body element created via\n * `createHtmlDocument` to create and fill an inert DOM element.\n * This is the fallback strategy if the browser does not support DOMParser.\n */\nclass InertDocumentHelper {\n    constructor(defaultDoc) {\n        this.defaultDoc = defaultDoc;\n        this.inertDocument = this.defaultDoc.implementation.createHTMLDocument('sanitization-inert');\n        if (this.inertDocument.body == null) {\n            // usually there should be only one body element in the document, but IE doesn't have any, so\n            // we need to create one.\n            const inertHtml = this.inertDocument.createElement('html');\n            this.inertDocument.appendChild(inertHtml);\n            const inertBodyElement = this.inertDocument.createElement('body');\n            inertHtml.appendChild(inertBodyElement);\n        }\n    }\n    getInertBodyElement(html) {\n        // Prefer using <template> element if supported.\n        const templateEl = this.inertDocument.createElement('template');\n        if ('content' in templateEl) {\n            templateEl.innerHTML = trustedHTMLFromString(html);\n            return templateEl;\n        }\n        // Note that previously we used to do something like `this.inertDocument.body.innerHTML = html`\n        // and we returned the inert `body` node. This was changed, because IE seems to treat setting\n        // `innerHTML` on an inserted element differently, compared to one that hasn't been inserted\n        // yet. In particular, IE appears to split some of the text into multiple text nodes rather\n        // than keeping them in a single one which ends up messing with Ivy's i18n parsing further\n        // down the line. This has been worked around by creating a new inert `body` and using it as\n        // the root node in which we insert the HTML.\n        const inertBody = this.inertDocument.createElement('body');\n        inertBody.innerHTML = trustedHTMLFromString(html);\n        // Support: IE 11 only\n        // strip custom-namespaced attributes on IE<=11\n        if (this.defaultDoc.documentMode) {\n            this.stripCustomNsAttrs(inertBody);\n        }\n        return inertBody;\n    }\n    /**\n     * When IE11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1'\n     * attribute to declare ns1 namespace and prefixes the attribute with 'ns1' (e.g.\n     * 'ns1:xlink:foo').\n     *\n     * This is undesirable since we don't want to allow any of these custom attributes. This method\n     * strips them all.\n     */\n    stripCustomNsAttrs(el) {\n        const elAttrs = el.attributes;\n        // loop backwards so that we can support removals.\n        for (let i = elAttrs.length - 1; 0 < i; i--) {\n            const attrib = elAttrs.item(i);\n            const attrName = attrib.name;\n            if (attrName === 'xmlns:ns1' || attrName.indexOf('ns1:') === 0) {\n                el.removeAttribute(attrName);\n            }\n        }\n        let childNode = el.firstChild;\n        while (childNode) {\n            if (childNode.nodeType === Node.ELEMENT_NODE)\n                this.stripCustomNsAttrs(childNode);\n            childNode = childNode.nextSibling;\n        }\n    }\n}\n/**\n * We need to determine whether the DOMParser exists in the global context and\n * supports parsing HTML; HTML parsing support is not as wide as other formats, see\n * https://developer.mozilla.org/en-US/docs/Web/API/DOMParser#Browser_compatibility.\n *\n * @suppress {uselessCode}\n */\nfunction isDOMParserAvailable() {\n    try {\n        return !!new window.DOMParser().parseFromString(trustedHTMLFromString(''), 'text/html');\n    }\n    catch (_a) {\n        return false;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A pattern that recognizes a commonly useful subset of URLs that are safe.\n *\n * This regular expression matches a subset of URLs that will not cause script\n * execution if used in URL context within a HTML document. Specifically, this\n * regular expression matches if (comment from here on and regex copied from\n * Soy's EscapingConventions):\n * (1) Either an allowed protocol (http, https, mailto or ftp).\n * (2) or no protocol.  A protocol must be followed by a colon. The below\n *     allows that by allowing colons only after one of the characters [/?#].\n *     A colon after a hash (#) must be in the fragment.\n *     Otherwise, a colon after a (?) must be in a query.\n *     Otherwise, a colon after a single solidus (/) must be in a path.\n *     Otherwise, a colon after a double solidus (//) must be in the authority\n *     (before port).\n *\n * The pattern disallows &, used in HTML entity declarations before\n * one of the characters in [/?#]. This disallows HTML entities used in the\n * protocol name, which should never happen, e.g. \"h&#116;tp\" for \"http\".\n * It also disallows HTML entities in the first path part of a relative path,\n * e.g. \"foo&lt;bar/baz\".  Our existing escaping functions should not produce\n * that. More importantly, it disallows masking of a colon,\n * e.g. \"javascript&#58;...\".\n *\n * This regular expression was taken from the Closure sanitization library.\n */\nconst SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi;\n/* A pattern that matches safe srcset values */\nconst SAFE_SRCSET_PATTERN = /^(?:(?:https?|file):|[^&:/?#]*(?:[/?#]|$))/gi;\n/** A pattern that matches safe data URLs. Only matches image, video and audio types. */\nconst DATA_URL_PATTERN = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\\/]+=*$/i;\nfunction _sanitizeUrl(url) {\n    url = String(url);\n    if (url.match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN))\n        return url;\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        console.warn(`WARNING: sanitizing unsafe URL value ${url} (see https://g.co/ng/security#xss)`);\n    }\n    return 'unsafe:' + url;\n}\nfunction sanitizeSrcset(srcset) {\n    srcset = String(srcset);\n    return srcset.split(',').map((srcset) => _sanitizeUrl(srcset.trim())).join(', ');\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction tagSet(tags) {\n    const res = {};\n    for (const t of tags.split(','))\n        res[t] = true;\n    return res;\n}\nfunction merge(...sets) {\n    const res = {};\n    for (const s of sets) {\n        for (const v in s) {\n            if (s.hasOwnProperty(v))\n                res[v] = true;\n        }\n    }\n    return res;\n}\n// Good source of info about elements and attributes\n// https://html.spec.whatwg.org/#semantics\n// https://simon.html5.org/html-elements\n// Safe Void Elements - HTML5\n// https://html.spec.whatwg.org/#void-elements\nconst VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr');\n// Elements that you can, intentionally, leave open (and which close themselves)\n// https://html.spec.whatwg.org/#optional-tags\nconst OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');\nconst OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet('rp,rt');\nconst OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);\n// Safe Block Elements - HTML5\nconst BLOCK_ELEMENTS = merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet('address,article,' +\n    'aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' +\n    'h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'));\n// Inline Elements - HTML5\nconst INLINE_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet('a,abbr,acronym,audio,b,' +\n    'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,' +\n    'samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'));\nconst VALID_ELEMENTS = merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);\n// Attributes that have href and hence need to be sanitized\nconst URI_ATTRS = tagSet('background,cite,href,itemtype,longdesc,poster,src,xlink:href');\n// Attributes that have special href set hence need to be sanitized\nconst SRCSET_ATTRS = tagSet('srcset');\nconst HTML_ATTRS = tagSet('abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,' +\n    'compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,' +\n    'ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,' +\n    'scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,' +\n    'valign,value,vspace,width');\n// Accessibility attributes as per WAI-ARIA 1.1 (W3C Working Draft 14 December 2018)\nconst ARIA_ATTRS = tagSet('aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,' +\n    'aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,' +\n    'aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,' +\n    'aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,' +\n    'aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,' +\n    'aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,' +\n    'aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext');\n// NB: This currently consciously doesn't support SVG. SVG sanitization has had several security\n// issues in the past, so it seems safer to leave it out if possible. If support for binding SVG via\n// innerHTML is required, SVG attributes should be added here.\n// NB: Sanitization does not allow <form> elements or other active elements (<button> etc). Those\n// can be sanitized, but they increase security surface area without a legitimate use case, so they\n// are left out here.\nconst VALID_ATTRS = merge(URI_ATTRS, SRCSET_ATTRS, HTML_ATTRS, ARIA_ATTRS);\n// Elements whose content should not be traversed/preserved, if the elements themselves are invalid.\n//\n// Typically, `<invalid>Some content</invalid>` would traverse (and in this case preserve)\n// `Some content`, but strip `invalid-element` opening/closing tags. For some elements, though, we\n// don't want to preserve the content, if the elements themselves are going to be removed.\nconst SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet('script,style,template');\n/**\n * SanitizingHtmlSerializer serializes a DOM fragment, stripping out any unsafe elements and unsafe\n * attributes.\n */\nclass SanitizingHtmlSerializer {\n    constructor() {\n        // Explicitly track if something was stripped, to avoid accidentally warning of sanitization just\n        // because characters were re-encoded.\n        this.sanitizedSomething = false;\n        this.buf = [];\n    }\n    sanitizeChildren(el) {\n        // This cannot use a TreeWalker, as it has to run on Angular's various DOM adapters.\n        // However this code never accesses properties off of `document` before deleting its contents\n        // again, so it shouldn't be vulnerable to DOM clobbering.\n        let current = el.firstChild;\n        let traverseContent = true;\n        while (current) {\n            if (current.nodeType === Node.ELEMENT_NODE) {\n                traverseContent = this.startElement(current);\n            }\n            else if (current.nodeType === Node.TEXT_NODE) {\n                this.chars(current.nodeValue);\n            }\n            else {\n                // Strip non-element, non-text nodes.\n                this.sanitizedSomething = true;\n            }\n            if (traverseContent && current.firstChild) {\n                current = current.firstChild;\n                continue;\n            }\n            while (current) {\n                // Leaving the element. Walk up and to the right, closing tags as we go.\n                if (current.nodeType === Node.ELEMENT_NODE) {\n                    this.endElement(current);\n                }\n                let next = this.checkClobberedElement(current, current.nextSibling);\n                if (next) {\n                    current = next;\n                    break;\n                }\n                current = this.checkClobberedElement(current, current.parentNode);\n            }\n        }\n        return this.buf.join('');\n    }\n    /**\n     * Sanitizes an opening element tag (if valid) and returns whether the element's contents should\n     * be traversed. Element content must always be traversed (even if the element itself is not\n     * valid/safe), unless the element is one of `SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS`.\n     *\n     * @param element The element to sanitize.\n     * @return True if the element's contents should be traversed.\n     */\n    startElement(element) {\n        const tagName = element.nodeName.toLowerCase();\n        if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {\n            this.sanitizedSomething = true;\n            return !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);\n        }\n        this.buf.push('<');\n        this.buf.push(tagName);\n        const elAttrs = element.attributes;\n        for (let i = 0; i < elAttrs.length; i++) {\n            const elAttr = elAttrs.item(i);\n            const attrName = elAttr.name;\n            const lower = attrName.toLowerCase();\n            if (!VALID_ATTRS.hasOwnProperty(lower)) {\n                this.sanitizedSomething = true;\n                continue;\n            }\n            let value = elAttr.value;\n            // TODO(martinprobst): Special case image URIs for data:image/...\n            if (URI_ATTRS[lower])\n                value = _sanitizeUrl(value);\n            if (SRCSET_ATTRS[lower])\n                value = sanitizeSrcset(value);\n            this.buf.push(' ', attrName, '=\"', encodeEntities(value), '\"');\n        }\n        this.buf.push('>');\n        return true;\n    }\n    endElement(current) {\n        const tagName = current.nodeName.toLowerCase();\n        if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {\n            this.buf.push('</');\n            this.buf.push(tagName);\n            this.buf.push('>');\n        }\n    }\n    chars(chars) {\n        this.buf.push(encodeEntities(chars));\n    }\n    checkClobberedElement(node, nextNode) {\n        if (nextNode &&\n            (node.compareDocumentPosition(nextNode) &\n                Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) {\n            throw new Error(`Failed to sanitize html because the element is clobbered: ${node.outerHTML}`);\n        }\n        return nextNode;\n    }\n}\n// Regular Expressions for parsing tags and attributes\nconst SURROGATE_PAIR_REGEXP = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n// ! to ~ is the ASCII range.\nconst NON_ALPHANUMERIC_REGEXP = /([^\\#-~ |!])/g;\n/**\n * Escapes all potentially dangerous characters, so that the\n * resulting string can be safely inserted into attribute or\n * element text.\n * @param value\n */\nfunction encodeEntities(value) {\n    return value.replace(/&/g, '&amp;')\n        .replace(SURROGATE_PAIR_REGEXP, function (match) {\n        const hi = match.charCodeAt(0);\n        const low = match.charCodeAt(1);\n        return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';\n    })\n        .replace(NON_ALPHANUMERIC_REGEXP, function (match) {\n        return '&#' + match.charCodeAt(0) + ';';\n    })\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;');\n}\nlet inertBodyHelper;\n/**\n * Sanitizes the given unsafe, untrusted HTML fragment, and returns HTML text that is safe to add to\n * the DOM in a browser environment.\n */\nfunction _sanitizeHtml(defaultDoc, unsafeHtmlInput) {\n    let inertBodyElement = null;\n    try {\n        inertBodyHelper = inertBodyHelper || getInertBodyHelper(defaultDoc);\n        // Make sure unsafeHtml is actually a string (TypeScript types are not enforced at runtime).\n        let unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : '';\n        inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);\n        // mXSS protection. Repeatedly parse the document to make sure it stabilizes, so that a browser\n        // trying to auto-correct incorrect HTML cannot cause formerly inert HTML to become dangerous.\n        let mXSSAttempts = 5;\n        let parsedHtml = unsafeHtml;\n        do {\n            if (mXSSAttempts === 0) {\n                throw new Error('Failed to sanitize html because the input is unstable');\n            }\n            mXSSAttempts--;\n            unsafeHtml = parsedHtml;\n            parsedHtml = inertBodyElement.innerHTML;\n            inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);\n        } while (unsafeHtml !== parsedHtml);\n        const sanitizer = new SanitizingHtmlSerializer();\n        const safeHtml = sanitizer.sanitizeChildren(getTemplateContent(inertBodyElement) || inertBodyElement);\n        if ((typeof ngDevMode === 'undefined' || ngDevMode) && sanitizer.sanitizedSomething) {\n            console.warn('WARNING: sanitizing HTML stripped some content, see https://g.co/ng/security#xss');\n        }\n        return trustedHTMLFromString(safeHtml);\n    }\n    finally {\n        // In case anything goes wrong, clear out inertElement to reset the entire DOM structure.\n        if (inertBodyElement) {\n            const parent = getTemplateContent(inertBodyElement) || inertBodyElement;\n            while (parent.firstChild) {\n                parent.removeChild(parent.firstChild);\n            }\n        }\n    }\n}\nfunction getTemplateContent(el) {\n    return 'content' in el /** Microsoft/TypeScript#21517 */ && isTemplateElement(el) ?\n        el.content :\n        null;\n}\nfunction isTemplateElement(el) {\n    return el.nodeType === Node.ELEMENT_NODE && el.nodeName === 'TEMPLATE';\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A SecurityContext marks a location that has dangerous security implications, e.g. a DOM property\n * like `innerHTML` that could cause Cross Site Scripting (XSS) security bugs when improperly\n * handled.\n *\n * See DomSanitizer for more details on security in Angular applications.\n *\n * @publicApi\n */\nvar SecurityContext;\n(function (SecurityContext) {\n    SecurityContext[SecurityContext[\"NONE\"] = 0] = \"NONE\";\n    SecurityContext[SecurityContext[\"HTML\"] = 1] = \"HTML\";\n    SecurityContext[SecurityContext[\"STYLE\"] = 2] = \"STYLE\";\n    SecurityContext[SecurityContext[\"SCRIPT\"] = 3] = \"SCRIPT\";\n    SecurityContext[SecurityContext[\"URL\"] = 4] = \"URL\";\n    SecurityContext[SecurityContext[\"RESOURCE_URL\"] = 5] = \"RESOURCE_URL\";\n})(SecurityContext || (SecurityContext = {}));\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * An `html` sanitizer which converts untrusted `html` **string** into trusted string by removing\n * dangerous content.\n *\n * This method parses the `html` and locates potentially dangerous content (such as urls and\n * javascript) and removes it.\n *\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustHtml}.\n *\n * @param unsafeHtml untrusted `html`, typically from the user.\n * @returns `html` string which is safe to display to user, because all of the dangerous javascript\n * and urls have been removed.\n *\n * @codeGenApi\n */\nfunction ɵɵsanitizeHtml(unsafeHtml) {\n    const sanitizer = getSanitizer();\n    if (sanitizer) {\n        return trustedHTMLFromStringBypass(sanitizer.sanitize(SecurityContext.HTML, unsafeHtml) || '');\n    }\n    if (allowSanitizationBypassAndThrow(unsafeHtml, \"HTML\" /* BypassType.Html */)) {\n        return trustedHTMLFromStringBypass(unwrapSafeValue(unsafeHtml));\n    }\n    return _sanitizeHtml(getDocument(), renderStringify(unsafeHtml));\n}\n/**\n * A `style` sanitizer which converts untrusted `style` **string** into trusted string by removing\n * dangerous content.\n *\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustStyle}.\n *\n * @param unsafeStyle untrusted `style`, typically from the user.\n * @returns `style` string which is safe to bind to the `style` properties.\n *\n * @codeGenApi\n */\nfunction ɵɵsanitizeStyle(unsafeStyle) {\n    const sanitizer = getSanitizer();\n    if (sanitizer) {\n        return sanitizer.sanitize(SecurityContext.STYLE, unsafeStyle) || '';\n    }\n    if (allowSanitizationBypassAndThrow(unsafeStyle, \"Style\" /* BypassType.Style */)) {\n        return unwrapSafeValue(unsafeStyle);\n    }\n    return renderStringify(unsafeStyle);\n}\n/**\n * A `url` sanitizer which converts untrusted `url` **string** into trusted string by removing\n * dangerous\n * content.\n *\n * This method parses the `url` and locates potentially dangerous content (such as javascript) and\n * removes it.\n *\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustUrl}.\n *\n * @param unsafeUrl untrusted `url`, typically from the user.\n * @returns `url` string which is safe to bind to the `src` properties such as `<img src>`, because\n * all of the dangerous javascript has been removed.\n *\n * @codeGenApi\n */\nfunction ɵɵsanitizeUrl(unsafeUrl) {\n    const sanitizer = getSanitizer();\n    if (sanitizer) {\n        return sanitizer.sanitize(SecurityContext.URL, unsafeUrl) || '';\n    }\n    if (allowSanitizationBypassAndThrow(unsafeUrl, \"URL\" /* BypassType.Url */)) {\n        return unwrapSafeValue(unsafeUrl);\n    }\n    return _sanitizeUrl(renderStringify(unsafeUrl));\n}\n/**\n * A `url` sanitizer which only lets trusted `url`s through.\n *\n * This passes only `url`s marked trusted by calling {@link bypassSanitizationTrustResourceUrl}.\n *\n * @param unsafeResourceUrl untrusted `url`, typically from the user.\n * @returns `url` string which is safe to bind to the `src` properties such as `<img src>`, because\n * only trusted `url`s have been allowed to pass.\n *\n * @codeGenApi\n */\nfunction ɵɵsanitizeResourceUrl(unsafeResourceUrl) {\n    const sanitizer = getSanitizer();\n    if (sanitizer) {\n        return trustedScriptURLFromStringBypass(sanitizer.sanitize(SecurityContext.RESOURCE_URL, unsafeResourceUrl) || '');\n    }\n    if (allowSanitizationBypassAndThrow(unsafeResourceUrl, \"ResourceURL\" /* BypassType.ResourceUrl */)) {\n        return trustedScriptURLFromStringBypass(unwrapSafeValue(unsafeResourceUrl));\n    }\n    throw new RuntimeError(904 /* RuntimeErrorCode.UNSAFE_VALUE_IN_RESOURCE_URL */, ngDevMode &&\n        'unsafe value used in a resource URL context (see https://g.co/ng/security#xss)');\n}\n/**\n * A `script` sanitizer which only lets trusted javascript through.\n *\n * This passes only `script`s marked trusted by calling {@link\n * bypassSanitizationTrustScript}.\n *\n * @param unsafeScript untrusted `script`, typically from the user.\n * @returns `url` string which is safe to bind to the `<script>` element such as `<img src>`,\n * because only trusted `scripts` have been allowed to pass.\n *\n * @codeGenApi\n */\nfunction ɵɵsanitizeScript(unsafeScript) {\n    const sanitizer = getSanitizer();\n    if (sanitizer) {\n        return trustedScriptFromStringBypass(sanitizer.sanitize(SecurityContext.SCRIPT, unsafeScript) || '');\n    }\n    if (allowSanitizationBypassAndThrow(unsafeScript, \"Script\" /* BypassType.Script */)) {\n        return trustedScriptFromStringBypass(unwrapSafeValue(unsafeScript));\n    }\n    throw new RuntimeError(905 /* RuntimeErrorCode.UNSAFE_VALUE_IN_SCRIPT */, ngDevMode && 'unsafe value used in a script context');\n}\n/**\n * A template tag function for promoting the associated constant literal to a\n * TrustedHTML. Interpolation is explicitly not allowed.\n *\n * @param html constant template literal containing trusted HTML.\n * @returns TrustedHTML wrapping `html`.\n *\n * @security This is a security-sensitive function and should only be used to\n * convert constant values of attributes and properties found in\n * application-provided Angular templates to TrustedHTML.\n *\n * @codeGenApi\n */\nfunction ɵɵtrustConstantHtml(html) {\n    // The following runtime check ensures that the function was called as a\n    // template tag (e.g. ɵɵtrustConstantHtml`content`), without any interpolation\n    // (e.g. not ɵɵtrustConstantHtml`content ${variable}`). A TemplateStringsArray\n    // is an array with a `raw` property that is also an array. The associated\n    // template literal has no interpolation if and only if the length of the\n    // TemplateStringsArray is 1.\n    if (ngDevMode && (!Array.isArray(html) || !Array.isArray(html.raw) || html.length !== 1)) {\n        throw new Error(`Unexpected interpolation in trusted HTML constant: ${html.join('?')}`);\n    }\n    return trustedHTMLFromString(html[0]);\n}\n/**\n * A template tag function for promoting the associated constant literal to a\n * TrustedScriptURL. Interpolation is explicitly not allowed.\n *\n * @param url constant template literal containing a trusted script URL.\n * @returns TrustedScriptURL wrapping `url`.\n *\n * @security This is a security-sensitive function and should only be used to\n * convert constant values of attributes and properties found in\n * application-provided Angular templates to TrustedScriptURL.\n *\n * @codeGenApi\n */\nfunction ɵɵtrustConstantResourceUrl(url) {\n    // The following runtime check ensures that the function was called as a\n    // template tag (e.g. ɵɵtrustConstantResourceUrl`content`), without any\n    // interpolation (e.g. not ɵɵtrustConstantResourceUrl`content ${variable}`). A\n    // TemplateStringsArray is an array with a `raw` property that is also an\n    // array. The associated template literal has no interpolation if and only if\n    // the length of the TemplateStringsArray is 1.\n    if (ngDevMode && (!Array.isArray(url) || !Array.isArray(url.raw) || url.length !== 1)) {\n        throw new Error(`Unexpected interpolation in trusted URL constant: ${url.join('?')}`);\n    }\n    return trustedScriptURLFromString(url[0]);\n}\n/**\n * Detects which sanitizer to use for URL property, based on tag name and prop name.\n *\n * The rules are based on the RESOURCE_URL context config from\n * `packages/compiler/src/schema/dom_security_schema.ts`.\n * If tag and prop names don't match Resource URL schema, use URL sanitizer.\n */\nfunction getUrlSanitizer(tag, prop) {\n    if ((prop === 'src' &&\n        (tag === 'embed' || tag === 'frame' || tag === 'iframe' || tag === 'media' ||\n            tag === 'script')) ||\n        (prop === 'href' && (tag === 'base' || tag === 'link'))) {\n        return ɵɵsanitizeResourceUrl;\n    }\n    return ɵɵsanitizeUrl;\n}\n/**\n * Sanitizes URL, selecting sanitizer function based on tag and property names.\n *\n * This function is used in case we can't define security context at compile time, when only prop\n * name is available. This happens when we generate host bindings for Directives/Components. The\n * host element is unknown at compile time, so we defer calculation of specific sanitizer to\n * runtime.\n *\n * @param unsafeUrl untrusted `url`, typically from the user.\n * @param tag target element tag name.\n * @param prop name of the property that contains the value.\n * @returns `url` string which is safe to bind.\n *\n * @codeGenApi\n */\nfunction ɵɵsanitizeUrlOrResourceUrl(unsafeUrl, tag, prop) {\n    return getUrlSanitizer(tag, prop)(unsafeUrl);\n}\nfunction validateAgainstEventProperties(name) {\n    if (name.toLowerCase().startsWith('on')) {\n        const errorMessage = `Binding to event property '${name}' is disallowed for security reasons, ` +\n            `please use (${name.slice(2)})=...` +\n            `\\nIf '${name}' is a directive input, make sure the directive is imported by the` +\n            ` current module.`;\n        throw new RuntimeError(306 /* RuntimeErrorCode.INVALID_EVENT_BINDING */, errorMessage);\n    }\n}\nfunction validateAgainstEventAttributes(name) {\n    if (name.toLowerCase().startsWith('on')) {\n        const errorMessage = `Binding to event attribute '${name}' is disallowed for security reasons, ` +\n            `please use (${name.slice(2)})=...`;\n        throw new RuntimeError(306 /* RuntimeErrorCode.INVALID_EVENT_BINDING */, errorMessage);\n    }\n}\nfunction getSanitizer() {\n    const lView = getLView();\n    return lView && lView[SANITIZER];\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst ERROR_ORIGINAL_ERROR = 'ngOriginalError';\nfunction wrappedError(message, originalError) {\n    const msg = `${message} caused by: ${originalError instanceof Error ? originalError.message : originalError}`;\n    const error = Error(msg);\n    error[ERROR_ORIGINAL_ERROR] = originalError;\n    return error;\n}\nfunction getOriginalError(error) {\n    return error[ERROR_ORIGINAL_ERROR];\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Provides a hook for centralized exception handling.\n *\n * The default implementation of `ErrorHandler` prints error messages to the `console`. To\n * intercept error handling, write a custom exception handler that replaces this default as\n * appropriate for your app.\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * class MyErrorHandler implements ErrorHandler {\n *   handleError(error) {\n *     // do something with the exception\n *   }\n * }\n *\n * @NgModule({\n *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]\n * })\n * class MyModule {}\n * ```\n *\n * @publicApi\n */\nclass ErrorHandler {\n    constructor() {\n        /**\n         * @internal\n         */\n        this._console = console;\n    }\n    handleError(error) {\n        const originalError = this._findOriginalError(error);\n        this._console.error('ERROR', error);\n        if (originalError) {\n            this._console.error('ORIGINAL ERROR', originalError);\n        }\n    }\n    /** @internal */\n    _findOriginalError(error) {\n        let e = error && getOriginalError(error);\n        while (e && getOriginalError(e)) {\n            e = getOriginalError(e);\n        }\n        return e || null;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Disallowed strings in the comment.\n *\n * see: https://html.spec.whatwg.org/multipage/syntax.html#comments\n */\nconst COMMENT_DISALLOWED = /^>|^->|<!--|-->|--!>|<!-$/g;\n/**\n * Delimiter in the disallowed strings which needs to be wrapped with zero with character.\n */\nconst COMMENT_DELIMITER = /(<|>)/;\nconst COMMENT_DELIMITER_ESCAPED = '\\u200B$1\\u200B';\n/**\n * Escape the content of comment strings so that it can be safely inserted into a comment node.\n *\n * The issue is that HTML does not specify any way to escape comment end text inside the comment.\n * Consider: `<!-- The way you close a comment is with \">\", and \"->\" at the beginning or by \"-->\" or\n * \"--!>\" at the end. -->`. Above the `\"-->\"` is meant to be text not an end to the comment. This\n * can be created programmatically through DOM APIs. (`<!--` are also disallowed.)\n *\n * see: https://html.spec.whatwg.org/multipage/syntax.html#comments\n *\n * ```\n * div.innerHTML = div.innerHTML\n * ```\n *\n * One would expect that the above code would be safe to do, but it turns out that because comment\n * text is not escaped, the comment may contain text which will prematurely close the comment\n * opening up the application for XSS attack. (In SSR we programmatically create comment nodes which\n * may contain such text and expect them to be safe.)\n *\n * This function escapes the comment text by looking for comment delimiters (`<` and `>`) and\n * surrounding them with `_>_` where the `_` is a zero width space `\\u200B`. The result is that if a\n * comment contains any of the comment start/end delimiters (such as `<!--`, `-->` or `--!>`) the\n * text it will render normally but it will not cause the HTML parser to close/open the comment.\n *\n * @param value text to make safe for comment node by escaping the comment open/close character\n *     sequence.\n */\nfunction escapeCommentText(value) {\n    return value.replace(COMMENT_DISALLOWED, (text) => text.replace(COMMENT_DELIMITER, COMMENT_DELIMITER_ESCAPED));\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction normalizeDebugBindingName(name) {\n    // Attribute names with `$` (eg `x-y$`) are valid per spec, but unsupported by some browsers\n    name = camelCaseToDashCase(name.replace(/[$@]/g, '_'));\n    return `ng-reflect-${name}`;\n}\nconst CAMEL_CASE_REGEXP = /([A-Z])/g;\nfunction camelCaseToDashCase(input) {\n    return input.replace(CAMEL_CASE_REGEXP, (...m) => '-' + m[1].toLowerCase());\n}\nfunction normalizeDebugBindingValue(value) {\n    try {\n        // Limit the size of the value as otherwise the DOM just gets polluted.\n        return value != null ? value.toString().slice(0, 30) : value;\n    }\n    catch (e) {\n        return '[ERROR] Exception while trying to serialize the value';\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Keeps track of the currently-active LViews.\nconst TRACKED_LVIEWS = new Map();\n// Used for generating unique IDs for LViews.\nlet uniqueIdCounter = 0;\n/** Gets a unique ID that can be assigned to an LView. */\nfunction getUniqueLViewId() {\n    return uniqueIdCounter++;\n}\n/** Starts tracking an LView. */\nfunction registerLView(lView) {\n    ngDevMode && assertNumber(lView[ID], 'LView must have an ID in order to be registered');\n    TRACKED_LVIEWS.set(lView[ID], lView);\n}\n/** Gets an LView by its unique ID. */\nfunction getLViewById(id) {\n    ngDevMode && assertNumber(id, 'ID used for LView lookup must be a number');\n    return TRACKED_LVIEWS.get(id) || null;\n}\n/** Stops tracking an LView. */\nfunction unregisterLView(lView) {\n    ngDevMode && assertNumber(lView[ID], 'Cannot stop tracking an LView that does not have an ID');\n    TRACKED_LVIEWS.delete(lView[ID]);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * The internal view context which is specific to a given DOM element, directive or\n * component instance. Each value in here (besides the LView and element node details)\n * can be present, null or undefined. If undefined then it implies the value has not been\n * looked up yet, otherwise, if null, then a lookup was executed and nothing was found.\n *\n * Each value will get filled when the respective value is examined within the getContext\n * function. The component, element and each directive instance will share the same instance\n * of the context.\n */\nclass LContext {\n    constructor(\n    /**\n     * ID of the component's parent view data.\n     */\n    lViewId, \n    /**\n     * The index instance of the node.\n     */\n    nodeIndex, \n    /**\n     * The instance of the DOM node that is attached to the lNode.\n     */\n    native) {\n        this.lViewId = lViewId;\n        this.nodeIndex = nodeIndex;\n        this.native = native;\n    }\n    /** Component's parent view data. */\n    get lView() {\n        return getLViewById(this.lViewId);\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Returns the matching `LContext` data for a given DOM node, directive or component instance.\n *\n * This function will examine the provided DOM element, component, or directive instance\\'s\n * monkey-patched property to derive the `LContext` data. Once called then the monkey-patched\n * value will be that of the newly created `LContext`.\n *\n * If the monkey-patched value is the `LView` instance then the context value for that\n * target will be created and the monkey-patch reference will be updated. Therefore when this\n * function is called it may mutate the provided element\\'s, component\\'s or any of the associated\n * directive\\'s monkey-patch values.\n *\n * If the monkey-patch value is not detected then the code will walk up the DOM until an element\n * is found which contains a monkey-patch reference. When that occurs then the provided element\n * will be updated with a new context (which is then returned). If the monkey-patch value is not\n * detected for a component/directive instance then it will throw an error (all components and\n * directives should be automatically monkey-patched by ivy).\n *\n * @param target Component, Directive or DOM Node.\n */\nfunction getLContext(target) {\n    let mpValue = readPatchedData(target);\n    if (mpValue) {\n        // only when it's an array is it considered an LView instance\n        // ... otherwise it's an already constructed LContext instance\n        if (isLView(mpValue)) {\n            const lView = mpValue;\n            let nodeIndex;\n            let component = undefined;\n            let directives = undefined;\n            if (isComponentInstance(target)) {\n                nodeIndex = findViaComponent(lView, target);\n                if (nodeIndex == -1) {\n                    throw new Error('The provided component was not found in the application');\n                }\n                component = target;\n            }\n            else if (isDirectiveInstance(target)) {\n                nodeIndex = findViaDirective(lView, target);\n                if (nodeIndex == -1) {\n                    throw new Error('The provided directive was not found in the application');\n                }\n                directives = getDirectivesAtNodeIndex(nodeIndex, lView, false);\n            }\n            else {\n                nodeIndex = findViaNativeElement(lView, target);\n                if (nodeIndex == -1) {\n                    return null;\n                }\n            }\n            // the goal is not to fill the entire context full of data because the lookups\n            // are expensive. Instead, only the target data (the element, component, container, ICU\n            // expression or directive details) are filled into the context. If called multiple times\n            // with different target values then the missing target data will be filled in.\n            const native = unwrapRNode(lView[nodeIndex]);\n            const existingCtx = readPatchedData(native);\n            const context = (existingCtx && !Array.isArray(existingCtx)) ?\n                existingCtx :\n                createLContext(lView, nodeIndex, native);\n            // only when the component has been discovered then update the monkey-patch\n            if (component && context.component === undefined) {\n                context.component = component;\n                attachPatchData(context.component, context);\n            }\n            // only when the directives have been discovered then update the monkey-patch\n            if (directives && context.directives === undefined) {\n                context.directives = directives;\n                for (let i = 0; i < directives.length; i++) {\n                    attachPatchData(directives[i], context);\n                }\n            }\n            attachPatchData(context.native, context);\n            mpValue = context;\n        }\n    }\n    else {\n        const rElement = target;\n        ngDevMode && assertDomNode(rElement);\n        // if the context is not found then we need to traverse upwards up the DOM\n        // to find the nearest element that has already been monkey patched with data\n        let parent = rElement;\n        while (parent = parent.parentNode) {\n            const parentContext = readPatchedData(parent);\n            if (parentContext) {\n                const lView = Array.isArray(parentContext) ? parentContext : parentContext.lView;\n                // the edge of the app was also reached here through another means\n                // (maybe because the DOM was changed manually).\n                if (!lView) {\n                    return null;\n                }\n                const index = findViaNativeElement(lView, rElement);\n                if (index >= 0) {\n                    const native = unwrapRNode(lView[index]);\n                    const context = createLContext(lView, index, native);\n                    attachPatchData(native, context);\n                    mpValue = context;\n                    break;\n                }\n            }\n        }\n    }\n    return mpValue || null;\n}\n/**\n * Creates an empty instance of a `LContext` context\n */\nfunction createLContext(lView, nodeIndex, native) {\n    return new LContext(lView[ID], nodeIndex, native);\n}\n/**\n * Takes a component instance and returns the view for that component.\n *\n * @param componentInstance\n * @returns The component's view\n */\nfunction getComponentViewByInstance(componentInstance) {\n    let patchedData = readPatchedData(componentInstance);\n    let lView;\n    if (isLView(patchedData)) {\n        const contextLView = patchedData;\n        const nodeIndex = findViaComponent(contextLView, componentInstance);\n        lView = getComponentLViewByIndex(nodeIndex, contextLView);\n        const context = createLContext(contextLView, nodeIndex, lView[HOST]);\n        context.component = componentInstance;\n        attachPatchData(componentInstance, context);\n        attachPatchData(context.native, context);\n    }\n    else {\n        const context = patchedData;\n        const contextLView = context.lView;\n        ngDevMode && assertLView(contextLView);\n        lView = getComponentLViewByIndex(context.nodeIndex, contextLView);\n    }\n    return lView;\n}\n/**\n * This property will be monkey-patched on elements, components and directives.\n */\nconst MONKEY_PATCH_KEY_NAME = '__ngContext__';\n/**\n * Assigns the given data to the given target (which could be a component,\n * directive or DOM node instance) using monkey-patching.\n */\nfunction attachPatchData(target, data) {\n    ngDevMode && assertDefined(target, 'Target expected');\n    // Only attach the ID of the view in order to avoid memory leaks (see #41047). We only do this\n    // for `LView`, because we have control over when an `LView` is created and destroyed, whereas\n    // we can't know when to remove an `LContext`.\n    if (isLView(data)) {\n        target[MONKEY_PATCH_KEY_NAME] = data[ID];\n        registerLView(data);\n    }\n    else {\n        target[MONKEY_PATCH_KEY_NAME] = data;\n    }\n}\n/**\n * Returns the monkey-patch value data present on the target (which could be\n * a component, directive or a DOM node).\n */\nfunction readPatchedData(target) {\n    ngDevMode && assertDefined(target, 'Target expected');\n    const data = target[MONKEY_PATCH_KEY_NAME];\n    return (typeof data === 'number') ? getLViewById(data) : data || null;\n}\nfunction readPatchedLView(target) {\n    const value = readPatchedData(target);\n    if (value) {\n        return (isLView(value) ? value : value.lView);\n    }\n    return null;\n}\nfunction isComponentInstance(instance) {\n    return instance && instance.constructor && instance.constructor.ɵcmp;\n}\nfunction isDirectiveInstance(instance) {\n    return instance && instance.constructor && instance.constructor.ɵdir;\n}\n/**\n * Locates the element within the given LView and returns the matching index\n */\nfunction findViaNativeElement(lView, target) {\n    const tView = lView[TVIEW];\n    for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {\n        if (unwrapRNode(lView[i]) === target) {\n            return i;\n        }\n    }\n    return -1;\n}\n/**\n * Locates the next tNode (child, sibling or parent).\n */\nfunction traverseNextElement(tNode) {\n    if (tNode.child) {\n        return tNode.child;\n    }\n    else if (tNode.next) {\n        return tNode.next;\n    }\n    else {\n        // Let's take the following template: <div><span>text</span></div><component/>\n        // After checking the text node, we need to find the next parent that has a \"next\" TNode,\n        // in this case the parent `div`, so that we can find the component.\n        while (tNode.parent && !tNode.parent.next) {\n            tNode = tNode.parent;\n        }\n        return tNode.parent && tNode.parent.next;\n    }\n}\n/**\n * Locates the component within the given LView and returns the matching index\n */\nfunction findViaComponent(lView, componentInstance) {\n    const componentIndices = lView[TVIEW].components;\n    if (componentIndices) {\n        for (let i = 0; i < componentIndices.length; i++) {\n            const elementComponentIndex = componentIndices[i];\n            const componentView = getComponentLViewByIndex(elementComponentIndex, lView);\n            if (componentView[CONTEXT] === componentInstance) {\n                return elementComponentIndex;\n            }\n        }\n    }\n    else {\n        const rootComponentView = getComponentLViewByIndex(HEADER_OFFSET, lView);\n        const rootComponent = rootComponentView[CONTEXT];\n        if (rootComponent === componentInstance) {\n            // we are dealing with the root element here therefore we know that the\n            // element is the very first element after the HEADER data in the lView\n            return HEADER_OFFSET;\n        }\n    }\n    return -1;\n}\n/**\n * Locates the directive within the given LView and returns the matching index\n */\nfunction findViaDirective(lView, directiveInstance) {\n    // if a directive is monkey patched then it will (by default)\n    // have a reference to the LView of the current view. The\n    // element bound to the directive being search lives somewhere\n    // in the view data. We loop through the nodes and check their\n    // list of directives for the instance.\n    let tNode = lView[TVIEW].firstChild;\n    while (tNode) {\n        const directiveIndexStart = tNode.directiveStart;\n        const directiveIndexEnd = tNode.directiveEnd;\n        for (let i = directiveIndexStart; i < directiveIndexEnd; i++) {\n            if (lView[i] === directiveInstance) {\n                return tNode.index;\n            }\n        }\n        tNode = traverseNextElement(tNode);\n    }\n    return -1;\n}\n/**\n * Returns a list of directives extracted from the given view based on the\n * provided list of directive index values.\n *\n * @param nodeIndex The node index\n * @param lView The target view data\n * @param includeComponents Whether or not to include components in returned directives\n */\nfunction getDirectivesAtNodeIndex(nodeIndex, lView, includeComponents) {\n    const tNode = lView[TVIEW].data[nodeIndex];\n    let directiveStartIndex = tNode.directiveStart;\n    if (directiveStartIndex == 0)\n        return EMPTY_ARRAY;\n    const directiveEndIndex = tNode.directiveEnd;\n    if (!includeComponents && tNode.flags & 2 /* TNodeFlags.isComponentHost */)\n        directiveStartIndex++;\n    return lView.slice(directiveStartIndex, directiveEndIndex);\n}\nfunction getComponentAtNodeIndex(nodeIndex, lView) {\n    const tNode = lView[TVIEW].data[nodeIndex];\n    let directiveStartIndex = tNode.directiveStart;\n    return tNode.flags & 2 /* TNodeFlags.isComponentHost */ ? lView[directiveStartIndex] : null;\n}\n/**\n * Returns a map of local references (local reference name => element or directive instance) that\n * exist on a given element.\n */\nfunction discoverLocalRefs(lView, nodeIndex) {\n    const tNode = lView[TVIEW].data[nodeIndex];\n    if (tNode && tNode.localNames) {\n        const result = {};\n        let localIndex = tNode.index + 1;\n        for (let i = 0; i < tNode.localNames.length; i += 2) {\n            result[tNode.localNames[i]] = lView[localIndex];\n            localIndex++;\n        }\n        return result;\n    }\n    return null;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Verifies that a given type is a Standalone Component. */\nfunction assertStandaloneComponentType(type) {\n    const componentDef = getComponentDef$1(type);\n    if (!componentDef) {\n        throw new RuntimeError(906 /* RuntimeErrorCode.MISSING_GENERATED_DEF */, `The ${stringifyForError(type)} is not an Angular component, ` +\n            `make sure it has the \\`@Component\\` decorator.`);\n    }\n    if (!componentDef.standalone) {\n        throw new RuntimeError(907 /* RuntimeErrorCode.TYPE_IS_NOT_STANDALONE */, `The ${stringifyForError(type)} component is not marked as standalone, ` +\n            `but Angular expects to have a standalone component here. ` +\n            `Please make sure the ${stringifyForError(type)} component has ` +\n            `the \\`standalone: true\\` flag in the decorator.`);\n    }\n}\n/** Called when there are multiple component selectors that match a given node */\nfunction throwMultipleComponentError(tNode, first, second) {\n    throw new RuntimeError(-300 /* RuntimeErrorCode.MULTIPLE_COMPONENTS_MATCH */, `Multiple components match node with tagname ${tNode.value}: ` +\n        `${stringifyForError(first)} and ` +\n        `${stringifyForError(second)}`);\n}\n/** Throws an ExpressionChangedAfterChecked error if checkNoChanges mode is on. */\nfunction throwErrorIfNoChangesMode(creationMode, oldValue, currValue, propName) {\n    const field = propName ? ` for '${propName}'` : '';\n    let msg = `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value${field}: '${oldValue}'. Current value: '${currValue}'.`;\n    if (creationMode) {\n        msg +=\n            ` It seems like the view has been created after its parent and its children have been dirty checked.` +\n                ` Has it been created in a change detection hook?`;\n    }\n    throw new RuntimeError(-100 /* RuntimeErrorCode.EXPRESSION_CHANGED_AFTER_CHECKED */, msg);\n}\nfunction constructDetailsForInterpolation(lView, rootIndex, expressionIndex, meta, changedValue) {\n    const [propName, prefix, ...chunks] = meta.split(INTERPOLATION_DELIMITER);\n    let oldValue = prefix, newValue = prefix;\n    for (let i = 0; i < chunks.length; i++) {\n        const slotIdx = rootIndex + i;\n        oldValue += `${lView[slotIdx]}${chunks[i]}`;\n        newValue += `${slotIdx === expressionIndex ? changedValue : lView[slotIdx]}${chunks[i]}`;\n    }\n    return { propName, oldValue, newValue };\n}\n/**\n * Constructs an object that contains details for the ExpressionChangedAfterItHasBeenCheckedError:\n * - property name (for property bindings or interpolations)\n * - old and new values, enriched using information from metadata\n *\n * More information on the metadata storage format can be found in `storePropertyBindingMetadata`\n * function description.\n */\nfunction getExpressionChangedErrorDetails(lView, bindingIndex, oldValue, newValue) {\n    const tData = lView[TVIEW].data;\n    const metadata = tData[bindingIndex];\n    if (typeof metadata === 'string') {\n        // metadata for property interpolation\n        if (metadata.indexOf(INTERPOLATION_DELIMITER) > -1) {\n            return constructDetailsForInterpolation(lView, bindingIndex, bindingIndex, metadata, newValue);\n        }\n        // metadata for property binding\n        return { propName: metadata, oldValue, newValue };\n    }\n    // metadata is not available for this expression, check if this expression is a part of the\n    // property interpolation by going from the current binding index left and look for a string that\n    // contains INTERPOLATION_DELIMITER, the layout in tView.data for this case will look like this:\n    // [..., 'id�Prefix � and � suffix', null, null, null, ...]\n    if (metadata === null) {\n        let idx = bindingIndex - 1;\n        while (typeof tData[idx] !== 'string' && tData[idx + 1] === null) {\n            idx--;\n        }\n        const meta = tData[idx];\n        if (typeof meta === 'string') {\n            const matches = meta.match(new RegExp(INTERPOLATION_DELIMITER, 'g'));\n            // first interpolation delimiter separates property name from interpolation parts (in case of\n            // property interpolations), so we subtract one from total number of found delimiters\n            if (matches && (matches.length - 1) > bindingIndex - idx) {\n                return constructDetailsForInterpolation(lView, idx, bindingIndex, meta, newValue);\n            }\n        }\n    }\n    return { propName: undefined, oldValue, newValue };\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Flags for renderer-specific style modifiers.\n * @publicApi\n */\nvar RendererStyleFlags2;\n(function (RendererStyleFlags2) {\n    // TODO(misko): This needs to be refactored into a separate file so that it can be imported from\n    // `node_manipulation.ts` Currently doing the import cause resolution order to change and fails\n    // the tests. The work around is to have hard coded value in `node_manipulation.ts` for now.\n    /**\n     * Marks a style as important.\n     */\n    RendererStyleFlags2[RendererStyleFlags2[\"Important\"] = 1] = \"Important\";\n    /**\n     * Marks a style as using dash case naming (this-is-dash-case).\n     */\n    RendererStyleFlags2[RendererStyleFlags2[\"DashCase\"] = 2] = \"DashCase\";\n})(RendererStyleFlags2 || (RendererStyleFlags2 = {}));\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nlet _icuContainerIterate;\n/**\n * Iterator which provides ability to visit all of the `TIcuContainerNode` root `RNode`s.\n */\nfunction icuContainerIterate(tIcuContainerNode, lView) {\n    return _icuContainerIterate(tIcuContainerNode, lView);\n}\n/**\n * Ensures that `IcuContainerVisitor`'s implementation is present.\n *\n * This function is invoked when i18n instruction comes across an ICU. The purpose is to allow the\n * bundler to tree shake ICU logic and only load it if ICU instruction is executed.\n */\nfunction ensureIcuContainerVisitorLoaded(loader) {\n    if (_icuContainerIterate === undefined) {\n        // Do not inline this function. We want to keep `ensureIcuContainerVisitorLoaded` light, so it\n        // can be inlined into call-site.\n        _icuContainerIterate = loader();\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nconst unusedValueExportToPlacateAjd$3 = 1;\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Gets the parent LView of the passed LView, if the PARENT is an LContainer, will get the parent of\n * that LContainer, which is an LView\n * @param lView the lView whose parent to get\n */\nfunction getLViewParent(lView) {\n    ngDevMode && assertLView(lView);\n    const parent = lView[PARENT];\n    return isLContainer(parent) ? parent[PARENT] : parent;\n}\n/**\n * Retrieve the root view from any component or `LView` by walking the parent `LView` until\n * reaching the root `LView`.\n *\n * @param componentOrLView any component or `LView`\n */\nfunction getRootView(componentOrLView) {\n    ngDevMode && assertDefined(componentOrLView, 'component');\n    let lView = isLView(componentOrLView) ? componentOrLView : readPatchedLView(componentOrLView);\n    while (lView && !(lView[FLAGS] & 256 /* LViewFlags.IsRoot */)) {\n        lView = getLViewParent(lView);\n    }\n    ngDevMode && assertLView(lView);\n    return lView;\n}\n/**\n * Returns the `RootContext` instance that is associated with\n * the application where the target is situated. It does this by walking the parent views until it\n * gets to the root view, then getting the context off of that.\n *\n * @param viewOrComponent the `LView` or component to get the root context for.\n */\nfunction getRootContext(viewOrComponent) {\n    const rootView = getRootView(viewOrComponent);\n    ngDevMode &&\n        assertDefined(rootView[CONTEXT], 'RootView has no context. Perhaps it is disconnected?');\n    return rootView[CONTEXT];\n}\n/**\n * Gets the first `LContainer` in the LView or `null` if none exists.\n */\nfunction getFirstLContainer(lView) {\n    return getNearestLContainer(lView[CHILD_HEAD]);\n}\n/**\n * Gets the next `LContainer` that is a sibling of the given container.\n */\nfunction getNextLContainer(container) {\n    return getNearestLContainer(container[NEXT]);\n}\nfunction getNearestLContainer(viewOrContainer) {\n    while (viewOrContainer !== null && !isLContainer(viewOrContainer)) {\n        viewOrContainer = viewOrContainer[NEXT];\n    }\n    return viewOrContainer;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst unusedValueToPlacateAjd$2 = unusedValueExportToPlacateAjd$8 + unusedValueExportToPlacateAjd$4 + unusedValueExportToPlacateAjd$3 + unusedValueExportToPlacateAjd$6 + unusedValueExportToPlacateAjd$7;\n/**\n * NOTE: for performance reasons, the possible actions are inlined within the function instead of\n * being passed as an argument.\n */\nfunction applyToElementOrContainer(action, renderer, parent, lNodeToHandle, beforeNode) {\n    // If this slot was allocated for a text node dynamically created by i18n, the text node itself\n    // won't be created until i18nApply() in the update block, so this node should be skipped.\n    // For more info, see \"ICU expressions should work inside an ngTemplateOutlet inside an ngFor\"\n    // in `i18n_spec.ts`.\n    if (lNodeToHandle != null) {\n        let lContainer;\n        let isComponent = false;\n        // We are expecting an RNode, but in the case of a component or LContainer the `RNode` is\n        // wrapped in an array which needs to be unwrapped. We need to know if it is a component and if\n        // it has LContainer so that we can process all of those cases appropriately.\n        if (isLContainer(lNodeToHandle)) {\n            lContainer = lNodeToHandle;\n        }\n        else if (isLView(lNodeToHandle)) {\n            isComponent = true;\n            ngDevMode && assertDefined(lNodeToHandle[HOST], 'HOST must be defined for a component LView');\n            lNodeToHandle = lNodeToHandle[HOST];\n        }\n        const rNode = unwrapRNode(lNodeToHandle);\n        ngDevMode && !isProceduralRenderer(renderer) && assertDomNode(rNode);\n        if (action === 0 /* WalkTNodeTreeAction.Create */ && parent !== null) {\n            if (beforeNode == null) {\n                nativeAppendChild(renderer, parent, rNode);\n            }\n            else {\n                nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);\n            }\n        }\n        else if (action === 1 /* WalkTNodeTreeAction.Insert */ && parent !== null) {\n            nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);\n        }\n        else if (action === 2 /* WalkTNodeTreeAction.Detach */) {\n            nativeRemoveNode(renderer, rNode, isComponent);\n        }\n        else if (action === 3 /* WalkTNodeTreeAction.Destroy */) {\n            ngDevMode && ngDevMode.rendererDestroyNode++;\n            renderer.destroyNode(rNode);\n        }\n        if (lContainer != null) {\n            applyContainer(renderer, action, lContainer, parent, beforeNode);\n        }\n    }\n}\nfunction createTextNode(renderer, value) {\n    ngDevMode && ngDevMode.rendererCreateTextNode++;\n    ngDevMode && ngDevMode.rendererSetText++;\n    return isProceduralRenderer(renderer) ? renderer.createText(value) :\n        renderer.createTextNode(value);\n}\nfunction updateTextNode(renderer, rNode, value) {\n    ngDevMode && ngDevMode.rendererSetText++;\n    isProceduralRenderer(renderer) ? renderer.setValue(rNode, value) : rNode.textContent = value;\n}\nfunction createCommentNode(renderer, value) {\n    ngDevMode && ngDevMode.rendererCreateComment++;\n    // isProceduralRenderer check is not needed because both `Renderer2` and `Renderer3` have the same\n    // method name.\n    return renderer.createComment(escapeCommentText(value));\n}\n/**\n * Creates a native element from a tag name, using a renderer.\n * @param renderer A renderer to use\n * @param name the tag name\n * @param namespace Optional namespace for element.\n * @returns the element created\n */\nfunction createElementNode(renderer, name, namespace) {\n    ngDevMode && ngDevMode.rendererCreateElement++;\n    if (isProceduralRenderer(renderer)) {\n        return renderer.createElement(name, namespace);\n    }\n    else {\n        const namespaceUri = namespace !== null ? getNamespaceUri(namespace) : null;\n        return namespaceUri === null ? renderer.createElement(name) :\n            renderer.createElementNS(namespaceUri, name);\n    }\n}\n/**\n * Removes all DOM elements associated with a view.\n *\n * Because some root nodes of the view may be containers, we sometimes need\n * to propagate deeply into the nested containers to remove all elements in the\n * views beneath it.\n *\n * @param tView The `TView' of the `LView` from which elements should be added or removed\n * @param lView The view from which elements should be added or removed\n */\nfunction removeViewFromContainer(tView, lView) {\n    const renderer = lView[RENDERER];\n    applyView(tView, lView, renderer, 2 /* WalkTNodeTreeAction.Detach */, null, null);\n    lView[HOST] = null;\n    lView[T_HOST] = null;\n}\n/**\n * Adds all DOM elements associated with a view.\n *\n * Because some root nodes of the view may be containers, we sometimes need\n * to propagate deeply into the nested containers to add all elements in the\n * views beneath it.\n *\n * @param tView The `TView' of the `LView` from which elements should be added or removed\n * @param parentTNode The `TNode` where the `LView` should be attached to.\n * @param renderer Current renderer to use for DOM manipulations.\n * @param lView The view from which elements should be added or removed\n * @param parentNativeNode The parent `RElement` where it should be inserted into.\n * @param beforeNode The node before which elements should be added, if insert mode\n */\nfunction addViewToContainer(tView, parentTNode, renderer, lView, parentNativeNode, beforeNode) {\n    lView[HOST] = parentNativeNode;\n    lView[T_HOST] = parentTNode;\n    applyView(tView, lView, renderer, 1 /* WalkTNodeTreeAction.Insert */, parentNativeNode, beforeNode);\n}\n/**\n * Detach a `LView` from the DOM by detaching its nodes.\n *\n * @param tView The `TView' of the `LView` to be detached\n * @param lView the `LView` to be detached.\n */\nfunction renderDetachView(tView, lView) {\n    applyView(tView, lView, lView[RENDERER], 2 /* WalkTNodeTreeAction.Detach */, null, null);\n}\n/**\n * Traverses down and up the tree of views and containers to remove listeners and\n * call onDestroy callbacks.\n *\n * Notes:\n *  - Because it's used for onDestroy calls, it needs to be bottom-up.\n *  - Must process containers instead of their views to avoid splicing\n *  when views are destroyed and re-added.\n *  - Using a while loop because it's faster than recursion\n *  - Destroy only called on movement to sibling or movement to parent (laterally or up)\n *\n *  @param rootView The view to destroy\n */\nfunction destroyViewTree(rootView) {\n    // If the view has no children, we can clean it up and return early.\n    let lViewOrLContainer = rootView[CHILD_HEAD];\n    if (!lViewOrLContainer) {\n        return cleanUpView(rootView[TVIEW], rootView);\n    }\n    while (lViewOrLContainer) {\n        let next = null;\n        if (isLView(lViewOrLContainer)) {\n            // If LView, traverse down to child.\n            next = lViewOrLContainer[CHILD_HEAD];\n        }\n        else {\n            ngDevMode && assertLContainer(lViewOrLContainer);\n            // If container, traverse down to its first LView.\n            const firstView = lViewOrLContainer[CONTAINER_HEADER_OFFSET];\n            if (firstView)\n                next = firstView;\n        }\n        if (!next) {\n            // Only clean up view when moving to the side or up, as destroy hooks\n            // should be called in order from the bottom up.\n            while (lViewOrLContainer && !lViewOrLContainer[NEXT] && lViewOrLContainer !== rootView) {\n                if (isLView(lViewOrLContainer)) {\n                    cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);\n                }\n                lViewOrLContainer = lViewOrLContainer[PARENT];\n            }\n            if (lViewOrLContainer === null)\n                lViewOrLContainer = rootView;\n            if (isLView(lViewOrLContainer)) {\n                cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);\n            }\n            next = lViewOrLContainer && lViewOrLContainer[NEXT];\n        }\n        lViewOrLContainer = next;\n    }\n}\n/**\n * Inserts a view into a container.\n *\n * This adds the view to the container's array of active views in the correct\n * position. It also adds the view's elements to the DOM if the container isn't a\n * root node of another view (in that case, the view's elements will be added when\n * the container's parent view is added later).\n *\n * @param tView The `TView' of the `LView` to insert\n * @param lView The view to insert\n * @param lContainer The container into which the view should be inserted\n * @param index Which index in the container to insert the child view into\n */\nfunction insertView(tView, lView, lContainer, index) {\n    ngDevMode && assertLView(lView);\n    ngDevMode && assertLContainer(lContainer);\n    const indexInContainer = CONTAINER_HEADER_OFFSET + index;\n    const containerLength = lContainer.length;\n    if (index > 0) {\n        // This is a new view, we need to add it to the children.\n        lContainer[indexInContainer - 1][NEXT] = lView;\n    }\n    if (index < containerLength - CONTAINER_HEADER_OFFSET) {\n        lView[NEXT] = lContainer[indexInContainer];\n        addToArray(lContainer, CONTAINER_HEADER_OFFSET + index, lView);\n    }\n    else {\n        lContainer.push(lView);\n        lView[NEXT] = null;\n    }\n    lView[PARENT] = lContainer;\n    // track views where declaration and insertion points are different\n    const declarationLContainer = lView[DECLARATION_LCONTAINER];\n    if (declarationLContainer !== null && lContainer !== declarationLContainer) {\n        trackMovedView(declarationLContainer, lView);\n    }\n    // notify query that a new view has been added\n    const lQueries = lView[QUERIES];\n    if (lQueries !== null) {\n        lQueries.insertView(tView);\n    }\n    // Sets the attached flag\n    lView[FLAGS] |= 64 /* LViewFlags.Attached */;\n}\n/**\n * Track views created from the declaration container (TemplateRef) and inserted into a\n * different LContainer.\n */\nfunction trackMovedView(declarationContainer, lView) {\n    ngDevMode && assertDefined(lView, 'LView required');\n    ngDevMode && assertLContainer(declarationContainer);\n    const movedViews = declarationContainer[MOVED_VIEWS];\n    const insertedLContainer = lView[PARENT];\n    ngDevMode && assertLContainer(insertedLContainer);\n    const insertedComponentLView = insertedLContainer[PARENT][DECLARATION_COMPONENT_VIEW];\n    ngDevMode && assertDefined(insertedComponentLView, 'Missing insertedComponentLView');\n    const declaredComponentLView = lView[DECLARATION_COMPONENT_VIEW];\n    ngDevMode && assertDefined(declaredComponentLView, 'Missing declaredComponentLView');\n    if (declaredComponentLView !== insertedComponentLView) {\n        // At this point the declaration-component is not same as insertion-component; this means that\n        // this is a transplanted view. Mark the declared lView as having transplanted views so that\n        // those views can participate in CD.\n        declarationContainer[HAS_TRANSPLANTED_VIEWS] = true;\n    }\n    if (movedViews === null) {\n        declarationContainer[MOVED_VIEWS] = [lView];\n    }\n    else {\n        movedViews.push(lView);\n    }\n}\nfunction detachMovedView(declarationContainer, lView) {\n    ngDevMode && assertLContainer(declarationContainer);\n    ngDevMode &&\n        assertDefined(declarationContainer[MOVED_VIEWS], 'A projected view should belong to a non-empty projected views collection');\n    const movedViews = declarationContainer[MOVED_VIEWS];\n    const declarationViewIndex = movedViews.indexOf(lView);\n    const insertionLContainer = lView[PARENT];\n    ngDevMode && assertLContainer(insertionLContainer);\n    // If the view was marked for refresh but then detached before it was checked (where the flag\n    // would be cleared and the counter decremented), we need to decrement the view counter here\n    // instead.\n    if (lView[FLAGS] & 512 /* LViewFlags.RefreshTransplantedView */) {\n        lView[FLAGS] &= ~512 /* LViewFlags.RefreshTransplantedView */;\n        updateTransplantedViewCount(insertionLContainer, -1);\n    }\n    movedViews.splice(declarationViewIndex, 1);\n}\n/**\n * Detaches a view from a container.\n *\n * This method removes the view from the container's array of active views. It also\n * removes the view's elements from the DOM.\n *\n * @param lContainer The container from which to detach a view\n * @param removeIndex The index of the view to detach\n * @returns Detached LView instance.\n */\nfunction detachView(lContainer, removeIndex) {\n    if (lContainer.length <= CONTAINER_HEADER_OFFSET)\n        return;\n    const indexInContainer = CONTAINER_HEADER_OFFSET + removeIndex;\n    const viewToDetach = lContainer[indexInContainer];\n    if (viewToDetach) {\n        const declarationLContainer = viewToDetach[DECLARATION_LCONTAINER];\n        if (declarationLContainer !== null && declarationLContainer !== lContainer) {\n            detachMovedView(declarationLContainer, viewToDetach);\n        }\n        if (removeIndex > 0) {\n            lContainer[indexInContainer - 1][NEXT] = viewToDetach[NEXT];\n        }\n        const removedLView = removeFromArray(lContainer, CONTAINER_HEADER_OFFSET + removeIndex);\n        removeViewFromContainer(viewToDetach[TVIEW], viewToDetach);\n        // notify query that a view has been removed\n        const lQueries = removedLView[QUERIES];\n        if (lQueries !== null) {\n            lQueries.detachView(removedLView[TVIEW]);\n        }\n        viewToDetach[PARENT] = null;\n        viewToDetach[NEXT] = null;\n        // Unsets the attached flag\n        viewToDetach[FLAGS] &= ~64 /* LViewFlags.Attached */;\n    }\n    return viewToDetach;\n}\n/**\n * A standalone function which destroys an LView,\n * conducting clean up (e.g. removing listeners, calling onDestroys).\n *\n * @param tView The `TView' of the `LView` to be destroyed\n * @param lView The view to be destroyed.\n */\nfunction destroyLView(tView, lView) {\n    if (!(lView[FLAGS] & 128 /* LViewFlags.Destroyed */)) {\n        const renderer = lView[RENDERER];\n        if (isProceduralRenderer(renderer) && renderer.destroyNode) {\n            applyView(tView, lView, renderer, 3 /* WalkTNodeTreeAction.Destroy */, null, null);\n        }\n        destroyViewTree(lView);\n    }\n}\n/**\n * Calls onDestroys hooks for all directives and pipes in a given view and then removes all\n * listeners. Listeners are removed as the last step so events delivered in the onDestroys hooks\n * can be propagated to @Output listeners.\n *\n * @param tView `TView` for the `LView` to clean up.\n * @param lView The LView to clean up\n */\nfunction cleanUpView(tView, lView) {\n    if (!(lView[FLAGS] & 128 /* LViewFlags.Destroyed */)) {\n        // Usually the Attached flag is removed when the view is detached from its parent, however\n        // if it's a root view, the flag won't be unset hence why we're also removing on destroy.\n        lView[FLAGS] &= ~64 /* LViewFlags.Attached */;\n        // Mark the LView as destroyed *before* executing the onDestroy hooks. An onDestroy hook\n        // runs arbitrary user code, which could include its own `viewRef.destroy()` (or similar). If\n        // We don't flag the view as destroyed before the hooks, this could lead to an infinite loop.\n        // This also aligns with the ViewEngine behavior. It also means that the onDestroy hook is\n        // really more of an \"afterDestroy\" hook if you think about it.\n        lView[FLAGS] |= 128 /* LViewFlags.Destroyed */;\n        executeOnDestroys(tView, lView);\n        processCleanups(tView, lView);\n        // For component views only, the local renderer is destroyed at clean up time.\n        if (lView[TVIEW].type === 1 /* TViewType.Component */ && isProceduralRenderer(lView[RENDERER])) {\n            ngDevMode && ngDevMode.rendererDestroy++;\n            lView[RENDERER].destroy();\n        }\n        const declarationContainer = lView[DECLARATION_LCONTAINER];\n        // we are dealing with an embedded view that is still inserted into a container\n        if (declarationContainer !== null && isLContainer(lView[PARENT])) {\n            // and this is a projected view\n            if (declarationContainer !== lView[PARENT]) {\n                detachMovedView(declarationContainer, lView);\n            }\n            // For embedded views still attached to a container: remove query result from this view.\n            const lQueries = lView[QUERIES];\n            if (lQueries !== null) {\n                lQueries.detachView(tView);\n            }\n        }\n        // Unregister the view once everything else has been cleaned up.\n        unregisterLView(lView);\n    }\n}\n/** Removes listeners and unsubscribes from output subscriptions */\nfunction processCleanups(tView, lView) {\n    const tCleanup = tView.cleanup;\n    const lCleanup = lView[CLEANUP];\n    // `LCleanup` contains both share information with `TCleanup` as well as instance specific\n    // information appended at the end. We need to know where the end of the `TCleanup` information\n    // is, and we track this with `lastLCleanupIndex`.\n    let lastLCleanupIndex = -1;\n    if (tCleanup !== null) {\n        for (let i = 0; i < tCleanup.length - 1; i += 2) {\n            if (typeof tCleanup[i] === 'string') {\n                // This is a native DOM listener\n                const idxOrTargetGetter = tCleanup[i + 1];\n                const target = typeof idxOrTargetGetter === 'function' ?\n                    idxOrTargetGetter(lView) :\n                    unwrapRNode(lView[idxOrTargetGetter]);\n                const listener = lCleanup[lastLCleanupIndex = tCleanup[i + 2]];\n                const useCaptureOrSubIdx = tCleanup[i + 3];\n                if (typeof useCaptureOrSubIdx === 'boolean') {\n                    // native DOM listener registered with Renderer3\n                    target.removeEventListener(tCleanup[i], listener, useCaptureOrSubIdx);\n                }\n                else {\n                    if (useCaptureOrSubIdx >= 0) {\n                        // unregister\n                        lCleanup[lastLCleanupIndex = useCaptureOrSubIdx]();\n                    }\n                    else {\n                        // Subscription\n                        lCleanup[lastLCleanupIndex = -useCaptureOrSubIdx].unsubscribe();\n                    }\n                }\n                i += 2;\n            }\n            else {\n                // This is a cleanup function that is grouped with the index of its context\n                const context = lCleanup[lastLCleanupIndex = tCleanup[i + 1]];\n                tCleanup[i].call(context);\n            }\n        }\n    }\n    if (lCleanup !== null) {\n        for (let i = lastLCleanupIndex + 1; i < lCleanup.length; i++) {\n            const instanceCleanupFn = lCleanup[i];\n            ngDevMode && assertFunction(instanceCleanupFn, 'Expecting instance cleanup function.');\n            instanceCleanupFn();\n        }\n        lView[CLEANUP] = null;\n    }\n}\n/** Calls onDestroy hooks for this view */\nfunction executeOnDestroys(tView, lView) {\n    let destroyHooks;\n    if (tView != null && (destroyHooks = tView.destroyHooks) != null) {\n        for (let i = 0; i < destroyHooks.length; i += 2) {\n            const context = lView[destroyHooks[i]];\n            // Only call the destroy hook if the context has been requested.\n            if (!(context instanceof NodeInjectorFactory)) {\n                const toCall = destroyHooks[i + 1];\n                if (Array.isArray(toCall)) {\n                    for (let j = 0; j < toCall.length; j += 2) {\n                        const callContext = context[toCall[j]];\n                        const hook = toCall[j + 1];\n                        profiler(4 /* ProfilerEvent.LifecycleHookStart */, callContext, hook);\n                        try {\n                            hook.call(callContext);\n                        }\n                        finally {\n                            profiler(5 /* ProfilerEvent.LifecycleHookEnd */, callContext, hook);\n                        }\n                    }\n                }\n                else {\n                    profiler(4 /* ProfilerEvent.LifecycleHookStart */, context, toCall);\n                    try {\n                        toCall.call(context);\n                    }\n                    finally {\n                        profiler(5 /* ProfilerEvent.LifecycleHookEnd */, context, toCall);\n                    }\n                }\n            }\n        }\n    }\n}\n/**\n * Returns a native element if a node can be inserted into the given parent.\n *\n * There are two reasons why we may not be able to insert a element immediately.\n * - Projection: When creating a child content element of a component, we have to skip the\n *   insertion because the content of a component will be projected.\n *   `<component><content>delayed due to projection</content></component>`\n * - Parent container is disconnected: This can happen when we are inserting a view into\n *   parent container, which itself is disconnected. For example the parent container is part\n *   of a View which has not be inserted or is made for projection but has not been inserted\n *   into destination.\n *\n * @param tView: Current `TView`.\n * @param tNode: `TNode` for which we wish to retrieve render parent.\n * @param lView: Current `LView`.\n */\nfunction getParentRElement(tView, tNode, lView) {\n    return getClosestRElement(tView, tNode.parent, lView);\n}\n/**\n * Get closest `RElement` or `null` if it can't be found.\n *\n * If `TNode` is `TNodeType.Element` => return `RElement` at `LView[tNode.index]` location.\n * If `TNode` is `TNodeType.ElementContainer|IcuContain` => return the parent (recursively).\n * If `TNode` is `null` then return host `RElement`:\n *   - return `null` if projection\n *   - return `null` if parent container is disconnected (we have no parent.)\n *\n * @param tView: Current `TView`.\n * @param tNode: `TNode` for which we wish to retrieve `RElement` (or `null` if host element is\n *     needed).\n * @param lView: Current `LView`.\n * @returns `null` if the `RElement` can't be determined at this time (no parent / projection)\n */\nfunction getClosestRElement(tView, tNode, lView) {\n    let parentTNode = tNode;\n    // Skip over element and ICU containers as those are represented by a comment node and\n    // can't be used as a render parent.\n    while (parentTNode !== null &&\n        (parentTNode.type & (8 /* TNodeType.ElementContainer */ | 32 /* TNodeType.Icu */))) {\n        tNode = parentTNode;\n        parentTNode = tNode.parent;\n    }\n    // If the parent tNode is null, then we are inserting across views: either into an embedded view\n    // or a component view.\n    if (parentTNode === null) {\n        // We are inserting a root element of the component view into the component host element and\n        // it should always be eager.\n        return lView[HOST];\n    }\n    else {\n        ngDevMode && assertTNodeType(parentTNode, 3 /* TNodeType.AnyRNode */ | 4 /* TNodeType.Container */);\n        if (parentTNode.flags & 2 /* TNodeFlags.isComponentHost */) {\n            ngDevMode && assertTNodeForLView(parentTNode, lView);\n            const encapsulation = tView.data[parentTNode.directiveStart].encapsulation;\n            // We've got a parent which is an element in the current view. We just need to verify if the\n            // parent element is not a component. Component's content nodes are not inserted immediately\n            // because they will be projected, and so doing insert at this point would be wasteful.\n            // Since the projection would then move it to its final destination. Note that we can't\n            // make this assumption when using the Shadow DOM, because the native projection placeholders\n            // (<content> or <slot>) have to be in place as elements are being inserted.\n            if (encapsulation === ViewEncapsulation.None ||\n                encapsulation === ViewEncapsulation.Emulated) {\n                return null;\n            }\n        }\n        return getNativeByTNode(parentTNode, lView);\n    }\n}\n/**\n * Inserts a native node before another native node for a given parent using {@link Renderer3}.\n * This is a utility function that can be used when native nodes were determined - it abstracts an\n * actual renderer being used.\n */\nfunction nativeInsertBefore(renderer, parent, child, beforeNode, isMove) {\n    ngDevMode && ngDevMode.rendererInsertBefore++;\n    if (isProceduralRenderer(renderer)) {\n        renderer.insertBefore(parent, child, beforeNode, isMove);\n    }\n    else {\n        const targetParent = isTemplateNode(parent) ? parent.content : parent;\n        targetParent.insertBefore(child, beforeNode, isMove);\n    }\n}\nfunction nativeAppendChild(renderer, parent, child) {\n    ngDevMode && ngDevMode.rendererAppendChild++;\n    ngDevMode && assertDefined(parent, 'parent node must be defined');\n    if (isProceduralRenderer(renderer)) {\n        renderer.appendChild(parent, child);\n    }\n    else {\n        const targetParent = isTemplateNode(parent) ? parent.content : parent;\n        targetParent.appendChild(child);\n    }\n}\nfunction nativeAppendOrInsertBefore(renderer, parent, child, beforeNode, isMove) {\n    if (beforeNode !== null) {\n        nativeInsertBefore(renderer, parent, child, beforeNode, isMove);\n    }\n    else {\n        nativeAppendChild(renderer, parent, child);\n    }\n}\n/** Removes a node from the DOM given its native parent. */\nfunction nativeRemoveChild(renderer, parent, child, isHostElement) {\n    if (isProceduralRenderer(renderer)) {\n        renderer.removeChild(parent, child, isHostElement);\n    }\n    else {\n        parent.removeChild(child);\n    }\n}\n/** Checks if an element is a `<template>` node. */\nfunction isTemplateNode(node) {\n    return node.tagName === 'TEMPLATE' && node.content !== undefined;\n}\n/**\n * Returns a native parent of a given native node.\n */\nfunction nativeParentNode(renderer, node) {\n    return (isProceduralRenderer(renderer) ? renderer.parentNode(node) : node.parentNode);\n}\n/**\n * Returns a native sibling of a given native node.\n */\nfunction nativeNextSibling(renderer, node) {\n    return isProceduralRenderer(renderer) ? renderer.nextSibling(node) : node.nextSibling;\n}\n/**\n * Find a node in front of which `currentTNode` should be inserted.\n *\n * This method determines the `RNode` in front of which we should insert the `currentRNode`. This\n * takes `TNode.insertBeforeIndex` into account if i18n code has been invoked.\n *\n * @param parentTNode parent `TNode`\n * @param currentTNode current `TNode` (The node which we would like to insert into the DOM)\n * @param lView current `LView`\n */\nfunction getInsertInFrontOfRNode(parentTNode, currentTNode, lView) {\n    return _getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView);\n}\n/**\n * Find a node in front of which `currentTNode` should be inserted. (Does not take i18n into\n * account)\n *\n * This method determines the `RNode` in front of which we should insert the `currentRNode`. This\n * does not take `TNode.insertBeforeIndex` into account.\n *\n * @param parentTNode parent `TNode`\n * @param currentTNode current `TNode` (The node which we would like to insert into the DOM)\n * @param lView current `LView`\n */\nfunction getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView) {\n    if (parentTNode.type & (8 /* TNodeType.ElementContainer */ | 32 /* TNodeType.Icu */)) {\n        return getNativeByTNode(parentTNode, lView);\n    }\n    return null;\n}\n/**\n * Tree shakable boundary for `getInsertInFrontOfRNodeWithI18n` function.\n *\n * This function will only be set if i18n code runs.\n */\nlet _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithNoI18n;\n/**\n * Tree shakable boundary for `processI18nInsertBefore` function.\n *\n * This function will only be set if i18n code runs.\n */\nlet _processI18nInsertBefore;\nfunction setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore) {\n    _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithI18n;\n    _processI18nInsertBefore = processI18nInsertBefore;\n}\n/**\n * Appends the `child` native node (or a collection of nodes) to the `parent`.\n *\n * @param tView The `TView' to be appended\n * @param lView The current LView\n * @param childRNode The native child (or children) that should be appended\n * @param childTNode The TNode of the child element\n */\nfunction appendChild(tView, lView, childRNode, childTNode) {\n    const parentRNode = getParentRElement(tView, childTNode, lView);\n    const renderer = lView[RENDERER];\n    const parentTNode = childTNode.parent || lView[T_HOST];\n    const anchorNode = getInsertInFrontOfRNode(parentTNode, childTNode, lView);\n    if (parentRNode != null) {\n        if (Array.isArray(childRNode)) {\n            for (let i = 0; i < childRNode.length; i++) {\n                nativeAppendOrInsertBefore(renderer, parentRNode, childRNode[i], anchorNode, false);\n            }\n        }\n        else {\n            nativeAppendOrInsertBefore(renderer, parentRNode, childRNode, anchorNode, false);\n        }\n    }\n    _processI18nInsertBefore !== undefined &&\n        _processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRNode);\n}\n/**\n * Returns the first native node for a given LView, starting from the provided TNode.\n *\n * Native nodes are returned in the order in which those appear in the native tree (DOM).\n */\nfunction getFirstNativeNode(lView, tNode) {\n    if (tNode !== null) {\n        ngDevMode &&\n            assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */ | 12 /* TNodeType.AnyContainer */ | 32 /* TNodeType.Icu */ | 16 /* TNodeType.Projection */);\n        const tNodeType = tNode.type;\n        if (tNodeType & 3 /* TNodeType.AnyRNode */) {\n            return getNativeByTNode(tNode, lView);\n        }\n        else if (tNodeType & 4 /* TNodeType.Container */) {\n            return getBeforeNodeForView(-1, lView[tNode.index]);\n        }\n        else if (tNodeType & 8 /* TNodeType.ElementContainer */) {\n            const elIcuContainerChild = tNode.child;\n            if (elIcuContainerChild !== null) {\n                return getFirstNativeNode(lView, elIcuContainerChild);\n            }\n            else {\n                const rNodeOrLContainer = lView[tNode.index];\n                if (isLContainer(rNodeOrLContainer)) {\n                    return getBeforeNodeForView(-1, rNodeOrLContainer);\n                }\n                else {\n                    return unwrapRNode(rNodeOrLContainer);\n                }\n            }\n        }\n        else if (tNodeType & 32 /* TNodeType.Icu */) {\n            let nextRNode = icuContainerIterate(tNode, lView);\n            let rNode = nextRNode();\n            // If the ICU container has no nodes, than we use the ICU anchor as the node.\n            return rNode || unwrapRNode(lView[tNode.index]);\n        }\n        else {\n            const projectionNodes = getProjectionNodes(lView, tNode);\n            if (projectionNodes !== null) {\n                if (Array.isArray(projectionNodes)) {\n                    return projectionNodes[0];\n                }\n                const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);\n                ngDevMode && assertParentView(parentView);\n                return getFirstNativeNode(parentView, projectionNodes);\n            }\n            else {\n                return getFirstNativeNode(lView, tNode.next);\n            }\n        }\n    }\n    return null;\n}\nfunction getProjectionNodes(lView, tNode) {\n    if (tNode !== null) {\n        const componentView = lView[DECLARATION_COMPONENT_VIEW];\n        const componentHost = componentView[T_HOST];\n        const slotIdx = tNode.projection;\n        ngDevMode && assertProjectionSlots(lView);\n        return componentHost.projection[slotIdx];\n    }\n    return null;\n}\nfunction getBeforeNodeForView(viewIndexInContainer, lContainer) {\n    const nextViewIndex = CONTAINER_HEADER_OFFSET + viewIndexInContainer + 1;\n    if (nextViewIndex < lContainer.length) {\n        const lView = lContainer[nextViewIndex];\n        const firstTNodeOfView = lView[TVIEW].firstChild;\n        if (firstTNodeOfView !== null) {\n            return getFirstNativeNode(lView, firstTNodeOfView);\n        }\n    }\n    return lContainer[NATIVE];\n}\n/**\n * Removes a native node itself using a given renderer. To remove the node we are looking up its\n * parent from the native tree as not all platforms / browsers support the equivalent of\n * node.remove().\n *\n * @param renderer A renderer to be used\n * @param rNode The native node that should be removed\n * @param isHostElement A flag indicating if a node to be removed is a host of a component.\n */\nfunction nativeRemoveNode(renderer, rNode, isHostElement) {\n    ngDevMode && ngDevMode.rendererRemoveNode++;\n    const nativeParent = nativeParentNode(renderer, rNode);\n    if (nativeParent) {\n        nativeRemoveChild(renderer, nativeParent, rNode, isHostElement);\n    }\n}\n/**\n * Performs the operation of `action` on the node. Typically this involves inserting or removing\n * nodes on the LView or projection boundary.\n */\nfunction applyNodes(renderer, action, tNode, lView, parentRElement, beforeNode, isProjection) {\n    while (tNode != null) {\n        ngDevMode && assertTNodeForLView(tNode, lView);\n        ngDevMode &&\n            assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */ | 12 /* TNodeType.AnyContainer */ | 16 /* TNodeType.Projection */ | 32 /* TNodeType.Icu */);\n        const rawSlotValue = lView[tNode.index];\n        const tNodeType = tNode.type;\n        if (isProjection) {\n            if (action === 0 /* WalkTNodeTreeAction.Create */) {\n                rawSlotValue && attachPatchData(unwrapRNode(rawSlotValue), lView);\n                tNode.flags |= 4 /* TNodeFlags.isProjected */;\n            }\n        }\n        if ((tNode.flags & 64 /* TNodeFlags.isDetached */) !== 64 /* TNodeFlags.isDetached */) {\n            if (tNodeType & 8 /* TNodeType.ElementContainer */) {\n                applyNodes(renderer, action, tNode.child, lView, parentRElement, beforeNode, false);\n                applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);\n            }\n            else if (tNodeType & 32 /* TNodeType.Icu */) {\n                const nextRNode = icuContainerIterate(tNode, lView);\n                let rNode;\n                while (rNode = nextRNode()) {\n                    applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);\n                }\n                applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);\n            }\n            else if (tNodeType & 16 /* TNodeType.Projection */) {\n                applyProjectionRecursive(renderer, action, lView, tNode, parentRElement, beforeNode);\n            }\n            else {\n                ngDevMode && assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */ | 4 /* TNodeType.Container */);\n                applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);\n            }\n        }\n        tNode = isProjection ? tNode.projectionNext : tNode.next;\n    }\n}\nfunction applyView(tView, lView, renderer, action, parentRElement, beforeNode) {\n    applyNodes(renderer, action, tView.firstChild, lView, parentRElement, beforeNode, false);\n}\n/**\n * `applyProjection` performs operation on the projection.\n *\n * Inserting a projection requires us to locate the projected nodes from the parent component. The\n * complication is that those nodes themselves could be re-projected from their parent component.\n *\n * @param tView The `TView` of `LView` which needs to be inserted, detached, destroyed\n * @param lView The `LView` which needs to be inserted, detached, destroyed.\n * @param tProjectionNode node to project\n */\nfunction applyProjection(tView, lView, tProjectionNode) {\n    const renderer = lView[RENDERER];\n    const parentRNode = getParentRElement(tView, tProjectionNode, lView);\n    const parentTNode = tProjectionNode.parent || lView[T_HOST];\n    let beforeNode = getInsertInFrontOfRNode(parentTNode, tProjectionNode, lView);\n    applyProjectionRecursive(renderer, 0 /* WalkTNodeTreeAction.Create */, lView, tProjectionNode, parentRNode, beforeNode);\n}\n/**\n * `applyProjectionRecursive` performs operation on the projection specified by `action` (insert,\n * detach, destroy)\n *\n * Inserting a projection requires us to locate the projected nodes from the parent component. The\n * complication is that those nodes themselves could be re-projected from their parent component.\n *\n * @param renderer Render to use\n * @param action action to perform (insert, detach, destroy)\n * @param lView The LView which needs to be inserted, detached, destroyed.\n * @param tProjectionNode node to project\n * @param parentRElement parent DOM element for insertion/removal.\n * @param beforeNode Before which node the insertions should happen.\n */\nfunction applyProjectionRecursive(renderer, action, lView, tProjectionNode, parentRElement, beforeNode) {\n    const componentLView = lView[DECLARATION_COMPONENT_VIEW];\n    const componentNode = componentLView[T_HOST];\n    ngDevMode &&\n        assertEqual(typeof tProjectionNode.projection, 'number', 'expecting projection index');\n    const nodeToProjectOrRNodes = componentNode.projection[tProjectionNode.projection];\n    if (Array.isArray(nodeToProjectOrRNodes)) {\n        // This should not exist, it is a bit of a hack. When we bootstrap a top level node and we\n        // need to support passing projectable nodes, so we cheat and put them in the TNode\n        // of the Host TView. (Yes we put instance info at the T Level). We can get away with it\n        // because we know that that TView is not shared and therefore it will not be a problem.\n        // This should be refactored and cleaned up.\n        for (let i = 0; i < nodeToProjectOrRNodes.length; i++) {\n            const rNode = nodeToProjectOrRNodes[i];\n            applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);\n        }\n    }\n    else {\n        let nodeToProject = nodeToProjectOrRNodes;\n        const projectedComponentLView = componentLView[PARENT];\n        applyNodes(renderer, action, nodeToProject, projectedComponentLView, parentRElement, beforeNode, true);\n    }\n}\n/**\n * `applyContainer` performs an operation on the container and its views as specified by\n * `action` (insert, detach, destroy)\n *\n * Inserting a Container is complicated by the fact that the container may have Views which\n * themselves have containers or projections.\n *\n * @param renderer Renderer to use\n * @param action action to perform (insert, detach, destroy)\n * @param lContainer The LContainer which needs to be inserted, detached, destroyed.\n * @param parentRElement parent DOM element for insertion/removal.\n * @param beforeNode Before which node the insertions should happen.\n */\nfunction applyContainer(renderer, action, lContainer, parentRElement, beforeNode) {\n    ngDevMode && assertLContainer(lContainer);\n    const anchor = lContainer[NATIVE]; // LContainer has its own before node.\n    const native = unwrapRNode(lContainer);\n    // An LContainer can be created dynamically on any node by injecting ViewContainerRef.\n    // Asking for a ViewContainerRef on an element will result in a creation of a separate anchor\n    // node (comment in the DOM) that will be different from the LContainer's host node. In this\n    // particular case we need to execute action on 2 nodes:\n    // - container's host node (this is done in the executeActionOnElementOrContainer)\n    // - container's host node (this is done here)\n    if (anchor !== native) {\n        // This is very strange to me (Misko). I would expect that the native is same as anchor. I\n        // don't see a reason why they should be different, but they are.\n        //\n        // If they are we need to process the second anchor as well.\n        applyToElementOrContainer(action, renderer, parentRElement, anchor, beforeNode);\n    }\n    for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n        const lView = lContainer[i];\n        applyView(lView[TVIEW], lView, renderer, action, parentRElement, anchor);\n    }\n}\n/**\n * Writes class/style to element.\n *\n * @param renderer Renderer to use.\n * @param isClassBased `true` if it should be written to `class` (`false` to write to `style`)\n * @param rNode The Node to write to.\n * @param prop Property to write to. This would be the class/style name.\n * @param value Value to write. If `null`/`undefined`/`false` this is considered a remove (set/add\n *        otherwise).\n */\nfunction applyStyling(renderer, isClassBased, rNode, prop, value) {\n    const isProcedural = isProceduralRenderer(renderer);\n    if (isClassBased) {\n        // We actually want JS true/false here because any truthy value should add the class\n        if (!value) {\n            ngDevMode && ngDevMode.rendererRemoveClass++;\n            if (isProcedural) {\n                renderer.removeClass(rNode, prop);\n            }\n            else {\n                rNode.classList.remove(prop);\n            }\n        }\n        else {\n            ngDevMode && ngDevMode.rendererAddClass++;\n            if (isProcedural) {\n                renderer.addClass(rNode, prop);\n            }\n            else {\n                ngDevMode && assertDefined(rNode.classList, 'HTMLElement expected');\n                rNode.classList.add(prop);\n            }\n        }\n    }\n    else {\n        let flags = prop.indexOf('-') === -1 ? undefined : RendererStyleFlags2.DashCase;\n        if (value == null /** || value === undefined */) {\n            ngDevMode && ngDevMode.rendererRemoveStyle++;\n            if (isProcedural) {\n                renderer.removeStyle(rNode, prop, flags);\n            }\n            else {\n                rNode.style.removeProperty(prop);\n            }\n        }\n        else {\n            // A value is important if it ends with `!important`. The style\n            // parser strips any semicolons at the end of the value.\n            const isImportant = typeof value === 'string' ? value.endsWith('!important') : false;\n            if (isImportant) {\n                // !important has to be stripped from the value for it to be valid.\n                value = value.slice(0, -10);\n                flags |= RendererStyleFlags2.Important;\n            }\n            ngDevMode && ngDevMode.rendererSetStyle++;\n            if (isProcedural) {\n                renderer.setStyle(rNode, prop, value, flags);\n            }\n            else {\n                ngDevMode && assertDefined(rNode.style, 'HTMLElement expected');\n                rNode.style.setProperty(prop, value, isImportant ? 'important' : '');\n            }\n        }\n    }\n}\n/**\n * Write `cssText` to `RElement`.\n *\n * This function does direct write without any reconciliation. Used for writing initial values, so\n * that static styling values do not pull in the style parser.\n *\n * @param renderer Renderer to use\n * @param element The element which needs to be updated.\n * @param newValue The new class list to write.\n */\nfunction writeDirectStyle(renderer, element, newValue) {\n    ngDevMode && assertString(newValue, '\\'newValue\\' should be a string');\n    if (isProceduralRenderer(renderer)) {\n        renderer.setAttribute(element, 'style', newValue);\n    }\n    else {\n        element.style.cssText = newValue;\n    }\n    ngDevMode && ngDevMode.rendererSetStyle++;\n}\n/**\n * Write `className` to `RElement`.\n *\n * This function does direct write without any reconciliation. Used for writing initial values, so\n * that static styling values do not pull in the style parser.\n *\n * @param renderer Renderer to use\n * @param element The element which needs to be updated.\n * @param newValue The new class list to write.\n */\nfunction writeDirectClass(renderer, element, newValue) {\n    ngDevMode && assertString(newValue, '\\'newValue\\' should be a string');\n    if (isProceduralRenderer(renderer)) {\n        if (newValue === '') {\n            // There are tests in `google3` which expect `element.getAttribute('class')` to be `null`.\n            renderer.removeAttribute(element, 'class');\n        }\n        else {\n            renderer.setAttribute(element, 'class', newValue);\n        }\n    }\n    else {\n        element.className = newValue;\n    }\n    ngDevMode && ngDevMode.rendererSetClassName++;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Returns an index of `classToSearch` in `className` taking token boundaries into account.\n *\n * `classIndexOf('AB A', 'A', 0)` will be 3 (not 0 since `AB!==A`)\n *\n * @param className A string containing classes (whitespace separated)\n * @param classToSearch A class name to locate\n * @param startingIndex Starting location of search\n * @returns an index of the located class (or -1 if not found)\n */\nfunction classIndexOf(className, classToSearch, startingIndex) {\n    ngDevMode && assertNotEqual(classToSearch, '', 'can not look for \"\" string.');\n    let end = className.length;\n    while (true) {\n        const foundIndex = className.indexOf(classToSearch, startingIndex);\n        if (foundIndex === -1)\n            return foundIndex;\n        if (foundIndex === 0 || className.charCodeAt(foundIndex - 1) <= 32 /* CharCode.SPACE */) {\n            // Ensure that it has leading whitespace\n            const length = classToSearch.length;\n            if (foundIndex + length === end ||\n                className.charCodeAt(foundIndex + length) <= 32 /* CharCode.SPACE */) {\n                // Ensure that it has trailing whitespace\n                return foundIndex;\n            }\n        }\n        // False positive, keep searching from where we left off.\n        startingIndex = foundIndex + 1;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst unusedValueToPlacateAjd$1 = unusedValueExportToPlacateAjd$4 + unusedValueExportToPlacateAjd$3;\nconst NG_TEMPLATE_SELECTOR = 'ng-template';\n/**\n * Search the `TAttributes` to see if it contains `cssClassToMatch` (case insensitive)\n *\n * @param attrs `TAttributes` to search through.\n * @param cssClassToMatch class to match (lowercase)\n * @param isProjectionMode Whether or not class matching should look into the attribute `class` in\n *    addition to the `AttributeMarker.Classes`.\n */\nfunction isCssClassMatching(attrs, cssClassToMatch, isProjectionMode) {\n    // TODO(misko): The fact that this function needs to know about `isProjectionMode` seems suspect.\n    // It is strange to me that sometimes the class information comes in form of `class` attribute\n    // and sometimes in form of `AttributeMarker.Classes`. Some investigation is needed to determine\n    // if that is the right behavior.\n    ngDevMode &&\n        assertEqual(cssClassToMatch, cssClassToMatch.toLowerCase(), 'Class name expected to be lowercase.');\n    let i = 0;\n    while (i < attrs.length) {\n        let item = attrs[i++];\n        if (isProjectionMode && item === 'class') {\n            item = attrs[i];\n            if (classIndexOf(item.toLowerCase(), cssClassToMatch, 0) !== -1) {\n                return true;\n            }\n        }\n        else if (item === 1 /* AttributeMarker.Classes */) {\n            // We found the classes section. Start searching for the class.\n            while (i < attrs.length && typeof (item = attrs[i++]) == 'string') {\n                // while we have strings\n                if (item.toLowerCase() === cssClassToMatch)\n                    return true;\n            }\n            return false;\n        }\n    }\n    return false;\n}\n/**\n * Checks whether the `tNode` represents an inline template (e.g. `*ngFor`).\n *\n * @param tNode current TNode\n */\nfunction isInlineTemplate(tNode) {\n    return tNode.type === 4 /* TNodeType.Container */ && tNode.value !== NG_TEMPLATE_SELECTOR;\n}\n/**\n * Function that checks whether a given tNode matches tag-based selector and has a valid type.\n *\n * Matching can be performed in 2 modes: projection mode (when we project nodes) and regular\n * directive matching mode:\n * - in the \"directive matching\" mode we do _not_ take TContainer's tagName into account if it is\n * different from NG_TEMPLATE_SELECTOR (value different from NG_TEMPLATE_SELECTOR indicates that a\n * tag name was extracted from * syntax so we would match the same directive twice);\n * - in the \"projection\" mode, we use a tag name potentially extracted from the * syntax processing\n * (applicable to TNodeType.Container only).\n */\nfunction hasTagAndTypeMatch(tNode, currentSelector, isProjectionMode) {\n    const tagNameToCompare = tNode.type === 4 /* TNodeType.Container */ && !isProjectionMode ? NG_TEMPLATE_SELECTOR : tNode.value;\n    return currentSelector === tagNameToCompare;\n}\n/**\n * A utility function to match an Ivy node static data against a simple CSS selector\n *\n * @param node static data of the node to match\n * @param selector The selector to try matching against the node.\n * @param isProjectionMode if `true` we are matching for content projection, otherwise we are doing\n * directive matching.\n * @returns true if node matches the selector.\n */\nfunction isNodeMatchingSelector(tNode, selector, isProjectionMode) {\n    ngDevMode && assertDefined(selector[0], 'Selector should have a tag name');\n    let mode = 4 /* SelectorFlags.ELEMENT */;\n    const nodeAttrs = tNode.attrs || [];\n    // Find the index of first attribute that has no value, only a name.\n    const nameOnlyMarkerIdx = getNameOnlyMarkerIndex(nodeAttrs);\n    // When processing \":not\" selectors, we skip to the next \":not\" if the\n    // current one doesn't match\n    let skipToNextSelector = false;\n    for (let i = 0; i < selector.length; i++) {\n        const current = selector[i];\n        if (typeof current === 'number') {\n            // If we finish processing a :not selector and it hasn't failed, return false\n            if (!skipToNextSelector && !isPositive(mode) && !isPositive(current)) {\n                return false;\n            }\n            // If we are skipping to the next :not() and this mode flag is positive,\n            // it's a part of the current :not() selector, and we should keep skipping\n            if (skipToNextSelector && isPositive(current))\n                continue;\n            skipToNextSelector = false;\n            mode = current | (mode & 1 /* SelectorFlags.NOT */);\n            continue;\n        }\n        if (skipToNextSelector)\n            continue;\n        if (mode & 4 /* SelectorFlags.ELEMENT */) {\n            mode = 2 /* SelectorFlags.ATTRIBUTE */ | mode & 1 /* SelectorFlags.NOT */;\n            if (current !== '' && !hasTagAndTypeMatch(tNode, current, isProjectionMode) ||\n                current === '' && selector.length === 1) {\n                if (isPositive(mode))\n                    return false;\n                skipToNextSelector = true;\n            }\n        }\n        else {\n            const selectorAttrValue = mode & 8 /* SelectorFlags.CLASS */ ? current : selector[++i];\n            // special case for matching against classes when a tNode has been instantiated with\n            // class and style values as separate attribute values (e.g. ['title', CLASS, 'foo'])\n            if ((mode & 8 /* SelectorFlags.CLASS */) && tNode.attrs !== null) {\n                if (!isCssClassMatching(tNode.attrs, selectorAttrValue, isProjectionMode)) {\n                    if (isPositive(mode))\n                        return false;\n                    skipToNextSelector = true;\n                }\n                continue;\n            }\n            const attrName = (mode & 8 /* SelectorFlags.CLASS */) ? 'class' : current;\n            const attrIndexInNode = findAttrIndexInNode(attrName, nodeAttrs, isInlineTemplate(tNode), isProjectionMode);\n            if (attrIndexInNode === -1) {\n                if (isPositive(mode))\n                    return false;\n                skipToNextSelector = true;\n                continue;\n            }\n            if (selectorAttrValue !== '') {\n                let nodeAttrValue;\n                if (attrIndexInNode > nameOnlyMarkerIdx) {\n                    nodeAttrValue = '';\n                }\n                else {\n                    ngDevMode &&\n                        assertNotEqual(nodeAttrs[attrIndexInNode], 0 /* AttributeMarker.NamespaceURI */, 'We do not match directives on namespaced attributes');\n                    // we lowercase the attribute value to be able to match\n                    // selectors without case-sensitivity\n                    // (selectors are already in lowercase when generated)\n                    nodeAttrValue = nodeAttrs[attrIndexInNode + 1].toLowerCase();\n                }\n                const compareAgainstClassName = mode & 8 /* SelectorFlags.CLASS */ ? nodeAttrValue : null;\n                if (compareAgainstClassName &&\n                    classIndexOf(compareAgainstClassName, selectorAttrValue, 0) !== -1 ||\n                    mode & 2 /* SelectorFlags.ATTRIBUTE */ && selectorAttrValue !== nodeAttrValue) {\n                    if (isPositive(mode))\n                        return false;\n                    skipToNextSelector = true;\n                }\n            }\n        }\n    }\n    return isPositive(mode) || skipToNextSelector;\n}\nfunction isPositive(mode) {\n    return (mode & 1 /* SelectorFlags.NOT */) === 0;\n}\n/**\n * Examines the attribute's definition array for a node to find the index of the\n * attribute that matches the given `name`.\n *\n * NOTE: This will not match namespaced attributes.\n *\n * Attribute matching depends upon `isInlineTemplate` and `isProjectionMode`.\n * The following table summarizes which types of attributes we attempt to match:\n *\n * ===========================================================================================================\n * Modes                   | Normal Attributes | Bindings Attributes | Template Attributes | I18n\n * Attributes\n * ===========================================================================================================\n * Inline + Projection     | YES               | YES                 | NO                  | YES\n * -----------------------------------------------------------------------------------------------------------\n * Inline + Directive      | NO                | NO                  | YES                 | NO\n * -----------------------------------------------------------------------------------------------------------\n * Non-inline + Projection | YES               | YES                 | NO                  | YES\n * -----------------------------------------------------------------------------------------------------------\n * Non-inline + Directive  | YES               | YES                 | NO                  | YES\n * ===========================================================================================================\n *\n * @param name the name of the attribute to find\n * @param attrs the attribute array to examine\n * @param isInlineTemplate true if the node being matched is an inline template (e.g. `*ngFor`)\n * rather than a manually expanded template node (e.g `<ng-template>`).\n * @param isProjectionMode true if we are matching against content projection otherwise we are\n * matching against directives.\n */\nfunction findAttrIndexInNode(name, attrs, isInlineTemplate, isProjectionMode) {\n    if (attrs === null)\n        return -1;\n    let i = 0;\n    if (isProjectionMode || !isInlineTemplate) {\n        let bindingsMode = false;\n        while (i < attrs.length) {\n            const maybeAttrName = attrs[i];\n            if (maybeAttrName === name) {\n                return i;\n            }\n            else if (maybeAttrName === 3 /* AttributeMarker.Bindings */ || maybeAttrName === 6 /* AttributeMarker.I18n */) {\n                bindingsMode = true;\n            }\n            else if (maybeAttrName === 1 /* AttributeMarker.Classes */ || maybeAttrName === 2 /* AttributeMarker.Styles */) {\n                let value = attrs[++i];\n                // We should skip classes here because we have a separate mechanism for\n                // matching classes in projection mode.\n                while (typeof value === 'string') {\n                    value = attrs[++i];\n                }\n                continue;\n            }\n            else if (maybeAttrName === 4 /* AttributeMarker.Template */) {\n                // We do not care about Template attributes in this scenario.\n                break;\n            }\n            else if (maybeAttrName === 0 /* AttributeMarker.NamespaceURI */) {\n                // Skip the whole namespaced attribute and value. This is by design.\n                i += 4;\n                continue;\n            }\n            // In binding mode there are only names, rather than name-value pairs.\n            i += bindingsMode ? 1 : 2;\n        }\n        // We did not match the attribute\n        return -1;\n    }\n    else {\n        return matchTemplateAttribute(attrs, name);\n    }\n}\nfunction isNodeMatchingSelectorList(tNode, selector, isProjectionMode = false) {\n    for (let i = 0; i < selector.length; i++) {\n        if (isNodeMatchingSelector(tNode, selector[i], isProjectionMode)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction getProjectAsAttrValue(tNode) {\n    const nodeAttrs = tNode.attrs;\n    if (nodeAttrs != null) {\n        const ngProjectAsAttrIdx = nodeAttrs.indexOf(5 /* AttributeMarker.ProjectAs */);\n        // only check for ngProjectAs in attribute names, don't accidentally match attribute's value\n        // (attribute names are stored at even indexes)\n        if ((ngProjectAsAttrIdx & 1) === 0) {\n            return nodeAttrs[ngProjectAsAttrIdx + 1];\n        }\n    }\n    return null;\n}\nfunction getNameOnlyMarkerIndex(nodeAttrs) {\n    for (let i = 0; i < nodeAttrs.length; i++) {\n        const nodeAttr = nodeAttrs[i];\n        if (isNameOnlyAttributeMarker(nodeAttr)) {\n            return i;\n        }\n    }\n    return nodeAttrs.length;\n}\nfunction matchTemplateAttribute(attrs, name) {\n    let i = attrs.indexOf(4 /* AttributeMarker.Template */);\n    if (i > -1) {\n        i++;\n        while (i < attrs.length) {\n            const attr = attrs[i];\n            // Return in case we checked all template attrs and are switching to the next section in the\n            // attrs array (that starts with a number that represents an attribute marker).\n            if (typeof attr === 'number')\n                return -1;\n            if (attr === name)\n                return i;\n            i++;\n        }\n    }\n    return -1;\n}\n/**\n * Checks whether a selector is inside a CssSelectorList\n * @param selector Selector to be checked.\n * @param list List in which to look for the selector.\n */\nfunction isSelectorInSelectorList(selector, list) {\n    selectorListLoop: for (let i = 0; i < list.length; i++) {\n        const currentSelectorInList = list[i];\n        if (selector.length !== currentSelectorInList.length) {\n            continue;\n        }\n        for (let j = 0; j < selector.length; j++) {\n            if (selector[j] !== currentSelectorInList[j]) {\n                continue selectorListLoop;\n            }\n        }\n        return true;\n    }\n    return false;\n}\nfunction maybeWrapInNotSelector(isNegativeMode, chunk) {\n    return isNegativeMode ? ':not(' + chunk.trim() + ')' : chunk;\n}\nfunction stringifyCSSSelector(selector) {\n    let result = selector[0];\n    let i = 1;\n    let mode = 2 /* SelectorFlags.ATTRIBUTE */;\n    let currentChunk = '';\n    let isNegativeMode = false;\n    while (i < selector.length) {\n        let valueOrMarker = selector[i];\n        if (typeof valueOrMarker === 'string') {\n            if (mode & 2 /* SelectorFlags.ATTRIBUTE */) {\n                const attrValue = selector[++i];\n                currentChunk +=\n                    '[' + valueOrMarker + (attrValue.length > 0 ? '=\"' + attrValue + '\"' : '') + ']';\n            }\n            else if (mode & 8 /* SelectorFlags.CLASS */) {\n                currentChunk += '.' + valueOrMarker;\n            }\n            else if (mode & 4 /* SelectorFlags.ELEMENT */) {\n                currentChunk += ' ' + valueOrMarker;\n            }\n        }\n        else {\n            //\n            // Append current chunk to the final result in case we come across SelectorFlag, which\n            // indicates that the previous section of a selector is over. We need to accumulate content\n            // between flags to make sure we wrap the chunk later in :not() selector if needed, e.g.\n            // ```\n            //  ['', Flags.CLASS, '.classA', Flags.CLASS | Flags.NOT, '.classB', '.classC']\n            // ```\n            // should be transformed to `.classA :not(.classB .classC)`.\n            //\n            // Note: for negative selector part, we accumulate content between flags until we find the\n            // next negative flag. This is needed to support a case where `:not()` rule contains more than\n            // one chunk, e.g. the following selector:\n            // ```\n            //  ['', Flags.ELEMENT | Flags.NOT, 'p', Flags.CLASS, 'foo', Flags.CLASS | Flags.NOT, 'bar']\n            // ```\n            // should be stringified to `:not(p.foo) :not(.bar)`\n            //\n            if (currentChunk !== '' && !isPositive(valueOrMarker)) {\n                result += maybeWrapInNotSelector(isNegativeMode, currentChunk);\n                currentChunk = '';\n            }\n            mode = valueOrMarker;\n            // According to CssSelector spec, once we come across `SelectorFlags.NOT` flag, the negative\n            // mode is maintained for remaining chunks of a selector.\n            isNegativeMode = isNegativeMode || !isPositive(mode);\n        }\n        i++;\n    }\n    if (currentChunk !== '') {\n        result += maybeWrapInNotSelector(isNegativeMode, currentChunk);\n    }\n    return result;\n}\n/**\n * Generates string representation of CSS selector in parsed form.\n *\n * ComponentDef and DirectiveDef are generated with the selector in parsed form to avoid doing\n * additional parsing at runtime (for example, for directive matching). However in some cases (for\n * example, while bootstrapping a component), a string version of the selector is required to query\n * for the host element on the page. This function takes the parsed form of a selector and returns\n * its string representation.\n *\n * @param selectorList selector in parsed form\n * @returns string representation of a given selector\n */\nfunction stringifyCSSSelectorList(selectorList) {\n    return selectorList.map(stringifyCSSSelector).join(',');\n}\n/**\n * Extracts attributes and classes information from a given CSS selector.\n *\n * This function is used while creating a component dynamically. In this case, the host element\n * (that is created dynamically) should contain attributes and classes specified in component's CSS\n * selector.\n *\n * @param selector CSS selector in parsed form (in a form of array)\n * @returns object with `attrs` and `classes` fields that contain extracted information\n */\nfunction extractAttrsAndClassesFromSelector(selector) {\n    const attrs = [];\n    const classes = [];\n    let i = 1;\n    let mode = 2 /* SelectorFlags.ATTRIBUTE */;\n    while (i < selector.length) {\n        let valueOrMarker = selector[i];\n        if (typeof valueOrMarker === 'string') {\n            if (mode === 2 /* SelectorFlags.ATTRIBUTE */) {\n                if (valueOrMarker !== '') {\n                    attrs.push(valueOrMarker, selector[++i]);\n                }\n            }\n            else if (mode === 8 /* SelectorFlags.CLASS */) {\n                classes.push(valueOrMarker);\n            }\n        }\n        else {\n            // According to CssSelector spec, once we come across `SelectorFlags.NOT` flag, the negative\n            // mode is maintained for remaining chunks of a selector. Since attributes and classes are\n            // extracted only for \"positive\" part of the selector, we can stop here.\n            if (!isPositive(mode))\n                break;\n            mode = valueOrMarker;\n        }\n        i++;\n    }\n    return { attrs, classes };\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** A special value which designates that a value has not changed. */\nconst NO_CHANGE = (typeof ngDevMode === 'undefined' || ngDevMode) ? { __brand__: 'NO_CHANGE' } : {};\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Advances to an element for later binding instructions.\n *\n * Used in conjunction with instructions like {@link property} to act on elements with specified\n * indices, for example those created with {@link element} or {@link elementStart}.\n *\n * ```ts\n * (rf: RenderFlags, ctx: any) => {\n *   if (rf & 1) {\n *     text(0, 'Hello');\n *     text(1, 'Goodbye')\n *     element(2, 'div');\n *   }\n *   if (rf & 2) {\n *     advance(2); // Advance twice to the <div>.\n *     property('title', 'test');\n *   }\n *  }\n * ```\n * @param delta Number of elements to advance forwards by.\n *\n * @codeGenApi\n */\nfunction ɵɵadvance(delta) {\n    ngDevMode && assertGreaterThan(delta, 0, 'Can only advance forward');\n    selectIndexInternal(getTView(), getLView(), getSelectedIndex() + delta, !!ngDevMode && isInCheckNoChangesMode());\n}\nfunction selectIndexInternal(tView, lView, index, checkNoChangesMode) {\n    ngDevMode && assertIndexInDeclRange(lView, index);\n    // Flush the initial hooks for elements in the view that have been added up to this point.\n    // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n    if (!checkNoChangesMode) {\n        const hooksInitPhaseCompleted = (lView[FLAGS] & 3 /* LViewFlags.InitPhaseStateMask */) === 3 /* InitPhaseState.InitPhaseCompleted */;\n        if (hooksInitPhaseCompleted) {\n            const preOrderCheckHooks = tView.preOrderCheckHooks;\n            if (preOrderCheckHooks !== null) {\n                executeCheckHooks(lView, preOrderCheckHooks, index);\n            }\n        }\n        else {\n            const preOrderHooks = tView.preOrderHooks;\n            if (preOrderHooks !== null) {\n                executeInitAndCheckHooks(lView, preOrderHooks, 0 /* InitPhaseState.OnInitHooksToBeRun */, index);\n            }\n        }\n    }\n    // We must set the selected index *after* running the hooks, because hooks may have side-effects\n    // that cause other template functions to run, thus updating the selected index, which is global\n    // state. If we run `setSelectedIndex` *before* we run the hooks, in some cases the selected index\n    // will be altered by the time we leave the `ɵɵadvance` instruction.\n    setSelectedIndex(index);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A mapping of the @angular/core API surface used in generated expressions to the actual symbols.\n *\n * This should be kept up to date with the public exports of @angular/core.\n */\nconst angularCoreDiEnv = {\n    'ɵɵdefineInjectable': ɵɵdefineInjectable,\n    'ɵɵdefineInjector': ɵɵdefineInjector,\n    'ɵɵinject': ɵɵinject,\n    'ɵɵinvalidFactoryDep': ɵɵinvalidFactoryDep,\n    'resolveForwardRef': resolveForwardRef,\n};\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Compile an Angular injectable according to its `Injectable` metadata, and patch the resulting\n * injectable def (`ɵprov`) onto the injectable type.\n */\nfunction compileInjectable(type, meta) {\n    let ngInjectableDef = null;\n    let ngFactoryDef = null;\n    // if NG_PROV_DEF is already defined on this class then don't overwrite it\n    if (!type.hasOwnProperty(NG_PROV_DEF)) {\n        Object.defineProperty(type, NG_PROV_DEF, {\n            get: () => {\n                if (ngInjectableDef === null) {\n                    const compiler = getCompilerFacade({ usage: 0 /* JitCompilerUsage.Decorator */, kind: 'injectable', type });\n                    ngInjectableDef = compiler.compileInjectable(angularCoreDiEnv, `ng:///${type.name}/ɵprov.js`, getInjectableMetadata(type, meta));\n                }\n                return ngInjectableDef;\n            },\n        });\n    }\n    // if NG_FACTORY_DEF is already defined on this class then don't overwrite it\n    if (!type.hasOwnProperty(NG_FACTORY_DEF)) {\n        Object.defineProperty(type, NG_FACTORY_DEF, {\n            get: () => {\n                if (ngFactoryDef === null) {\n                    const compiler = getCompilerFacade({ usage: 0 /* JitCompilerUsage.Decorator */, kind: 'injectable', type });\n                    ngFactoryDef = compiler.compileFactory(angularCoreDiEnv, `ng:///${type.name}/ɵfac.js`, {\n                        name: type.name,\n                        type,\n                        typeArgumentCount: 0,\n                        deps: reflectDependencies(type),\n                        target: compiler.FactoryTarget.Injectable\n                    });\n                }\n                return ngFactoryDef;\n            },\n            // Leave this configurable so that the factories from directives or pipes can take precedence.\n            configurable: true\n        });\n    }\n}\nconst USE_VALUE$1 = getClosureSafeProperty({ provide: String, useValue: getClosureSafeProperty });\nfunction isUseClassProvider(meta) {\n    return meta.useClass !== undefined;\n}\nfunction isUseValueProvider(meta) {\n    return USE_VALUE$1 in meta;\n}\nfunction isUseFactoryProvider(meta) {\n    return meta.useFactory !== undefined;\n}\nfunction isUseExistingProvider(meta) {\n    return meta.useExisting !== undefined;\n}\nfunction getInjectableMetadata(type, srcMeta) {\n    // Allow the compilation of a class with a `@Injectable()` decorator without parameters\n    const meta = srcMeta || { providedIn: null };\n    const compilerMeta = {\n        name: type.name,\n        type: type,\n        typeArgumentCount: 0,\n        providedIn: meta.providedIn,\n    };\n    if ((isUseClassProvider(meta) || isUseFactoryProvider(meta)) && meta.deps !== undefined) {\n        compilerMeta.deps = convertDependencies(meta.deps);\n    }\n    // Check to see if the user explicitly provided a `useXxxx` property.\n    if (isUseClassProvider(meta)) {\n        compilerMeta.useClass = meta.useClass;\n    }\n    else if (isUseValueProvider(meta)) {\n        compilerMeta.useValue = meta.useValue;\n    }\n    else if (isUseFactoryProvider(meta)) {\n        compilerMeta.useFactory = meta.useFactory;\n    }\n    else if (isUseExistingProvider(meta)) {\n        compilerMeta.useExisting = meta.useExisting;\n    }\n    return compilerMeta;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injectable decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Injectable = makeDecorator('Injectable', undefined, undefined, undefined, (type, meta) => compileInjectable(type, meta));\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Creates a token that can be used in a DI Provider.\n *\n * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a\n * runtime representation) such as when injecting an interface, callable type, array or\n * parameterized type.\n *\n * `InjectionToken` is parameterized on `T` which is the type of object which will be returned by\n * the `Injector`. This provides an additional level of type safety.\n *\n * ```\n * interface MyInterface {...}\n * const myInterface = injector.get(new InjectionToken<MyInterface>('SomeToken'));\n * // myInterface is inferred to be MyInterface.\n * ```\n *\n * When creating an `InjectionToken`, you can optionally specify a factory function which returns\n * (possibly by creating) a default value of the parameterized type `T`. This sets up the\n * `InjectionToken` using this factory as a provider as if it was defined explicitly in the\n * application's root injector. If the factory function, which takes zero arguments, needs to inject\n * dependencies, it can do so using the `inject` function.\n * As you can see in the Tree-shakable InjectionToken example below.\n *\n * Additionally, if a `factory` is specified you can also specify the `providedIn` option, which\n * overrides the above behavior and marks the token as belonging to a particular `@NgModule`. As\n * mentioned above, `'root'` is the default value for `providedIn`.\n *\n * @usageNotes\n * ### Basic Examples\n *\n * ### Plain InjectionToken\n *\n * {@example core/di/ts/injector_spec.ts region='InjectionToken'}\n *\n * ### Tree-shakable InjectionToken\n *\n * {@example core/di/ts/injector_spec.ts region='ShakableInjectionToken'}\n *\n *\n * @publicApi\n */\nclass InjectionToken {\n    /**\n     * @param _desc   Description for the token,\n     *                used only for debugging purposes,\n     *                it should but does not need to be unique\n     * @param options Options for the token's usage, as described above\n     */\n    constructor(_desc, options) {\n        this._desc = _desc;\n        /** @internal */\n        this.ngMetadataName = 'InjectionToken';\n        this.ɵprov = undefined;\n        if (typeof options == 'number') {\n            (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                assertLessThan(options, 0, 'Only negative numbers are supported here');\n            // This is a special hack to assign __NG_ELEMENT_ID__ to this instance.\n            // See `InjectorMarkers`\n            this.__NG_ELEMENT_ID__ = options;\n        }\n        else if (options !== undefined) {\n            this.ɵprov = ɵɵdefineInjectable({\n                token: this,\n                providedIn: options.providedIn || 'root',\n                factory: options.factory,\n            });\n        }\n    }\n    /**\n     * @internal\n     */\n    get multi() {\n        return this;\n    }\n    toString() {\n        return `InjectionToken ${this._desc}`;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A multi-provider token for initialization functions that will run upon construction of an\n * environment injector.\n *\n * @publicApi\n */\nconst ENVIRONMENT_INITIALIZER = new InjectionToken('ENVIRONMENT_INITIALIZER');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst INJECTOR_DEF_TYPES = new InjectionToken('INJECTOR_DEF_TYPES');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Collects providers from all NgModules and standalone components, including transitively imported\n * ones.\n *\n * Providers extracted via `importProvidersFrom` are only usable in an application injector or\n * another environment injector (such as a route injector). They should not be used in component\n * providers.\n *\n * More information about standalone components can be found in [this\n * guide](guide/standalone-components).\n *\n * @usageNotes\n * The results of the `importProvidersFrom` call can be used in the `bootstrapApplication` call:\n *\n * ```typescript\n * await bootstrapApplication(RootComponent, {\n *   providers: [\n *     importProvidersFrom(NgModuleOne, NgModuleTwo)\n *   ]\n * });\n * ```\n *\n * You can also use the `importProvidersFrom` results in the `providers` field of a route, when a\n * standalone component is used:\n *\n * ```typescript\n * export const ROUTES: Route[] = [\n *   {\n *     path: 'foo',\n *     providers: [\n *       importProvidersFrom(NgModuleOne, NgModuleTwo)\n *     ],\n *     component: YourStandaloneComponent\n *   }\n * ];\n * ```\n *\n * @returns Collected providers from the specified list of types.\n * @publicApi\n * @developerPreview\n */\nfunction importProvidersFrom(...sources) {\n    return { ɵproviders: internalImportProvidersFrom(true, sources) };\n}\nfunction internalImportProvidersFrom(checkForStandaloneCmp, ...sources) {\n    const providersOut = [];\n    const dedup = new Set(); // already seen types\n    let injectorTypesWithProviders;\n    deepForEach(sources, source => {\n        if ((typeof ngDevMode === 'undefined' || ngDevMode) && checkForStandaloneCmp) {\n            const cmpDef = getComponentDef$1(source);\n            if (cmpDef === null || cmpDef === void 0 ? void 0 : cmpDef.standalone) {\n                throw new RuntimeError(800 /* RuntimeErrorCode.IMPORT_PROVIDERS_FROM_STANDALONE */, `Importing providers supports NgModule or ModuleWithProviders but got a standalone component \"${stringifyForError(source)}\"`);\n            }\n        }\n        // Narrow `source` to access the internal type analogue for `ModuleWithProviders`.\n        const internalSource = source;\n        if (walkProviderTree(internalSource, providersOut, [], dedup)) {\n            injectorTypesWithProviders || (injectorTypesWithProviders = []);\n            injectorTypesWithProviders.push(internalSource);\n        }\n    });\n    // Collect all providers from `ModuleWithProviders` types.\n    if (injectorTypesWithProviders !== undefined) {\n        processInjectorTypesWithProviders(injectorTypesWithProviders, providersOut);\n    }\n    return providersOut;\n}\n/**\n * Collects all providers from the list of `ModuleWithProviders` and appends them to the provided\n * array.\n */\nfunction processInjectorTypesWithProviders(typesWithProviders, providersOut) {\n    for (let i = 0; i < typesWithProviders.length; i++) {\n        const { ngModule, providers } = typesWithProviders[i];\n        deepForEach(providers, provider => {\n            ngDevMode && validateProvider(provider, providers || EMPTY_ARRAY, ngModule);\n            providersOut.push(provider);\n        });\n    }\n}\n/**\n * The logic visits an `InjectorType`, an `InjectorTypeWithProviders`, or a standalone\n * `ComponentType`, and all of its transitive providers and collects providers.\n *\n * If an `InjectorTypeWithProviders` that declares providers besides the type is specified,\n * the function will return \"true\" to indicate that the providers of the type definition need\n * to be processed. This allows us to process providers of injector types after all imports of\n * an injector definition are processed. (following View Engine semantics: see FW-1349)\n */\nfunction walkProviderTree(container, providersOut, parents, dedup) {\n    container = resolveForwardRef(container);\n    if (!container)\n        return false;\n    // The actual type which had the definition. Usually `container`, but may be an unwrapped type\n    // from `InjectorTypeWithProviders`.\n    let defType = null;\n    let injDef = getInjectorDef(container);\n    const cmpDef = !injDef && getComponentDef$1(container);\n    if (!injDef && !cmpDef) {\n        // `container` is not an injector type or a component type. It might be:\n        //  * An `InjectorTypeWithProviders` that wraps an injector type.\n        //  * A standalone directive or pipe that got pulled in from a standalone component's\n        //    dependencies.\n        // Try to unwrap it as an `InjectorTypeWithProviders` first.\n        const ngModule = container.ngModule;\n        injDef = getInjectorDef(ngModule);\n        if (injDef) {\n            defType = ngModule;\n        }\n        else {\n            // Not a component or injector type, so ignore it.\n            return false;\n        }\n    }\n    else if (cmpDef && !cmpDef.standalone) {\n        return false;\n    }\n    else {\n        defType = container;\n    }\n    // Check for circular dependencies.\n    if (ngDevMode && parents.indexOf(defType) !== -1) {\n        const defName = stringify(defType);\n        const path = parents.map(stringify);\n        throwCyclicDependencyError(defName, path);\n    }\n    // Check for multiple imports of the same module\n    const isDuplicate = dedup.has(defType);\n    if (cmpDef) {\n        if (isDuplicate) {\n            // This component definition has already been processed.\n            return false;\n        }\n        dedup.add(defType);\n        if (cmpDef.dependencies) {\n            const deps = typeof cmpDef.dependencies === 'function' ? cmpDef.dependencies() : cmpDef.dependencies;\n            for (const dep of deps) {\n                walkProviderTree(dep, providersOut, parents, dedup);\n            }\n        }\n    }\n    else if (injDef) {\n        // First, include providers from any imports.\n        if (injDef.imports != null && !isDuplicate) {\n            // Before processing defType's imports, add it to the set of parents. This way, if it ends\n            // up deeply importing itself, this can be detected.\n            ngDevMode && parents.push(defType);\n            // Add it to the set of dedups. This way we can detect multiple imports of the same module\n            dedup.add(defType);\n            let importTypesWithProviders;\n            try {\n                deepForEach(injDef.imports, imported => {\n                    if (walkProviderTree(imported, providersOut, parents, dedup)) {\n                        importTypesWithProviders || (importTypesWithProviders = []);\n                        // If the processed import is an injector type with providers, we store it in the\n                        // list of import types with providers, so that we can process those afterwards.\n                        importTypesWithProviders.push(imported);\n                    }\n                });\n            }\n            finally {\n                // Remove it from the parents set when finished.\n                ngDevMode && parents.pop();\n            }\n            // Imports which are declared with providers (TypeWithProviders) need to be processed\n            // after all imported modules are processed. This is similar to how View Engine\n            // processes/merges module imports in the metadata resolver. See: FW-1349.\n            if (importTypesWithProviders !== undefined) {\n                processInjectorTypesWithProviders(importTypesWithProviders, providersOut);\n            }\n        }\n        if (!isDuplicate) {\n            // Track the InjectorType and add a provider for it.\n            // It's important that this is done after the def's imports.\n            const factory = getFactoryDef(defType) || (() => new defType());\n            // Append extra providers to make more info available for consumers (to retrieve an injector\n            // type), as well as internally (to calculate an injection scope correctly and eagerly\n            // instantiate a `defType` when an injector is created).\n            providersOut.push(\n            // Provider to create `defType` using its factory.\n            { provide: defType, useFactory: factory, deps: EMPTY_ARRAY }, \n            // Make this `defType` available to an internal logic that calculates injector scope.\n            { provide: INJECTOR_DEF_TYPES, useValue: defType, multi: true }, \n            // Provider to eagerly instantiate `defType` via `ENVIRONMENT_INITIALIZER`.\n            { provide: ENVIRONMENT_INITIALIZER, useValue: () => ɵɵinject(defType), multi: true } //\n            );\n        }\n        // Next, include providers listed on the definition itself.\n        const defProviders = injDef.providers;\n        if (defProviders != null && !isDuplicate) {\n            const injectorType = container;\n            deepForEach(defProviders, provider => {\n                ngDevMode && validateProvider(provider, defProviders, injectorType);\n                providersOut.push(provider);\n            });\n        }\n    }\n    else {\n        // Should not happen, but just in case.\n        return false;\n    }\n    return (defType !== container &&\n        container.providers !== undefined);\n}\nfunction validateProvider(provider, providers, containerType) {\n    if (isTypeProvider(provider) || isValueProvider(provider) || isFactoryProvider(provider) ||\n        isExistingProvider(provider)) {\n        return;\n    }\n    // Here we expect the provider to be a `useClass` provider (by elimination).\n    const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));\n    if (!classRef) {\n        throwInvalidProviderError(containerType, providers, provider);\n    }\n}\nconst USE_VALUE = getClosureSafeProperty({ provide: String, useValue: getClosureSafeProperty });\nfunction isValueProvider(value) {\n    return value !== null && typeof value == 'object' && USE_VALUE in value;\n}\nfunction isExistingProvider(value) {\n    return !!(value && value.useExisting);\n}\nfunction isFactoryProvider(value) {\n    return !!(value && value.useFactory);\n}\nfunction isTypeProvider(value) {\n    return typeof value === 'function';\n}\nfunction isClassProvider(value) {\n    return !!value.useClass;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.\n *\n * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a\n * project.\n *\n * @publicApi\n */\nconst INJECTOR = new InjectionToken('INJECTOR', \n// Dissable tslint because this is const enum which gets inlined not top level prop access.\n// tslint:disable-next-line: no-toplevel-property-access\n-1 /* InjectorMarkers.Injector */);\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass NullInjector {\n    get(token, notFoundValue = THROW_IF_NOT_FOUND) {\n        if (notFoundValue === THROW_IF_NOT_FOUND) {\n            const error = new Error(`NullInjectorError: No provider for ${stringify(token)}!`);\n            error.name = 'NullInjectorError';\n            throw error;\n        }\n        return notFoundValue;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * An internal token whose presence in an injector indicates that the injector should treat itself\n * as a root scoped injector when processing requests for unknown tokens which may indicate\n * they are provided in the root scope.\n */\nconst INJECTOR_SCOPE = new InjectionToken('Set Injector scope.');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Marker which indicates that a value has not yet been created from the factory function.\n */\nconst NOT_YET = {};\n/**\n * Marker which indicates that the factory function for a token is in the process of being called.\n *\n * If the injector is asked to inject a token with its value set to CIRCULAR, that indicates\n * injection of a dependency has recursively attempted to inject the original token, and there is\n * a circular dependency among the providers.\n */\nconst CIRCULAR = {};\n/**\n * A lazily initialized NullInjector.\n */\nlet NULL_INJECTOR$1 = undefined;\nfunction getNullInjector() {\n    if (NULL_INJECTOR$1 === undefined) {\n        NULL_INJECTOR$1 = new NullInjector();\n    }\n    return NULL_INJECTOR$1;\n}\n/**\n * An `Injector` that's part of the environment injector hierarchy, which exists outside of the\n * component tree.\n *\n * @developerPreview\n */\nclass EnvironmentInjector {\n}\nclass R3Injector extends EnvironmentInjector {\n    constructor(providers, parent, source, scopes) {\n        super();\n        this.parent = parent;\n        this.source = source;\n        this.scopes = scopes;\n        /**\n         * Map of tokens to records which contain the instances of those tokens.\n         * - `null` value implies that we don't have the record. Used by tree-shakable injectors\n         * to prevent further searches.\n         */\n        this.records = new Map();\n        /**\n         * Set of values instantiated by this injector which contain `ngOnDestroy` lifecycle hooks.\n         */\n        this._ngOnDestroyHooks = new Set();\n        this._onDestroyHooks = [];\n        this._destroyed = false;\n        // Start off by creating Records for every provider.\n        forEachSingleProvider(providers, provider => this.processProvider(provider));\n        // Make sure the INJECTOR token provides this injector.\n        this.records.set(INJECTOR, makeRecord(undefined, this));\n        // And `EnvironmentInjector` if the current injector is supposed to be env-scoped.\n        if (scopes.has('environment')) {\n            this.records.set(EnvironmentInjector, makeRecord(undefined, this));\n        }\n        // Detect whether this injector has the APP_ROOT_SCOPE token and thus should provide\n        // any injectable scoped to APP_ROOT_SCOPE.\n        const record = this.records.get(INJECTOR_SCOPE);\n        if (record != null && typeof record.value === 'string') {\n            this.scopes.add(record.value);\n        }\n        this.injectorDefTypes =\n            new Set(this.get(INJECTOR_DEF_TYPES.multi, EMPTY_ARRAY, InjectFlags.Self));\n    }\n    /**\n     * Flag indicating that this injector was previously destroyed.\n     */\n    get destroyed() {\n        return this._destroyed;\n    }\n    /**\n     * Destroy the injector and release references to every instance or provider associated with it.\n     *\n     * Also calls the `OnDestroy` lifecycle hooks of every instance that was created for which a\n     * hook was found.\n     */\n    destroy() {\n        this.assertNotDestroyed();\n        // Set destroyed = true first, in case lifecycle hooks re-enter destroy().\n        this._destroyed = true;\n        try {\n            // Call all the lifecycle hooks.\n            for (const service of this._ngOnDestroyHooks) {\n                service.ngOnDestroy();\n            }\n            for (const hook of this._onDestroyHooks) {\n                hook();\n            }\n        }\n        finally {\n            // Release all references.\n            this.records.clear();\n            this._ngOnDestroyHooks.clear();\n            this.injectorDefTypes.clear();\n            this._onDestroyHooks.length = 0;\n        }\n    }\n    onDestroy(callback) {\n        this._onDestroyHooks.push(callback);\n    }\n    get(token, notFoundValue = THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\n        this.assertNotDestroyed();\n        // Set the injection context.\n        const previousInjector = setCurrentInjector(this);\n        const previousInjectImplementation = setInjectImplementation(undefined);\n        try {\n            // Check for the SkipSelf flag.\n            if (!(flags & InjectFlags.SkipSelf)) {\n                // SkipSelf isn't set, check if the record belongs to this injector.\n                let record = this.records.get(token);\n                if (record === undefined) {\n                    // No record, but maybe the token is scoped to this injector. Look for an injectable\n                    // def with a scope matching this injector.\n                    const def = couldBeInjectableType(token) && getInjectableDef(token);\n                    if (def && this.injectableDefInScope(def)) {\n                        // Found an injectable def and it's scoped to this injector. Pretend as if it was here\n                        // all along.\n                        record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET);\n                    }\n                    else {\n                        record = null;\n                    }\n                    this.records.set(token, record);\n                }\n                // If a record was found, get the instance for it and return it.\n                if (record != null /* NOT null || undefined */) {\n                    return this.hydrate(token, record);\n                }\n            }\n            // Select the next injector based on the Self flag - if self is set, the next injector is\n            // the NullInjector, otherwise it's the parent.\n            const nextInjector = !(flags & InjectFlags.Self) ? this.parent : getNullInjector();\n            // Set the notFoundValue based on the Optional flag - if optional is set and notFoundValue\n            // is undefined, the value is null, otherwise it's the notFoundValue.\n            notFoundValue = (flags & InjectFlags.Optional) && notFoundValue === THROW_IF_NOT_FOUND ?\n                null :\n                notFoundValue;\n            return nextInjector.get(token, notFoundValue);\n        }\n        catch (e) {\n            if (e.name === 'NullInjectorError') {\n                const path = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];\n                path.unshift(stringify(token));\n                if (previousInjector) {\n                    // We still have a parent injector, keep throwing\n                    throw e;\n                }\n                else {\n                    // Format & throw the final error message when we don't have any previous injector\n                    return catchInjectorError(e, token, 'R3InjectorError', this.source);\n                }\n            }\n            else {\n                throw e;\n            }\n        }\n        finally {\n            // Lastly, restore the previous injection context.\n            setInjectImplementation(previousInjectImplementation);\n            setCurrentInjector(previousInjector);\n        }\n    }\n    /** @internal */\n    resolveInjectorInitializers() {\n        const previousInjector = setCurrentInjector(this);\n        const previousInjectImplementation = setInjectImplementation(undefined);\n        try {\n            const initializers = this.get(ENVIRONMENT_INITIALIZER.multi, EMPTY_ARRAY, InjectFlags.Self);\n            for (const initializer of initializers) {\n                initializer();\n            }\n        }\n        finally {\n            setCurrentInjector(previousInjector);\n            setInjectImplementation(previousInjectImplementation);\n        }\n    }\n    toString() {\n        const tokens = [];\n        const records = this.records;\n        for (const token of records.keys()) {\n            tokens.push(stringify(token));\n        }\n        return `R3Injector[${tokens.join(', ')}]`;\n    }\n    assertNotDestroyed() {\n        if (this._destroyed) {\n            throw new RuntimeError(205 /* RuntimeErrorCode.INJECTOR_ALREADY_DESTROYED */, ngDevMode && 'Injector has already been destroyed.');\n        }\n    }\n    /**\n     * Process a `SingleProvider` and add it.\n     */\n    processProvider(provider) {\n        // Determine the token from the provider. Either it's its own token, or has a {provide: ...}\n        // property.\n        provider = resolveForwardRef(provider);\n        let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider && provider.provide);\n        // Construct a `Record` for the provider.\n        const record = providerToRecord(provider);\n        if (!isTypeProvider(provider) && provider.multi === true) {\n            // If the provider indicates that it's a multi-provider, process it specially.\n            // First check whether it's been defined already.\n            let multiRecord = this.records.get(token);\n            if (multiRecord) {\n                // It has. Throw a nice error if\n                if (ngDevMode && multiRecord.multi === undefined) {\n                    throwMixedMultiProviderError();\n                }\n            }\n            else {\n                multiRecord = makeRecord(undefined, NOT_YET, true);\n                multiRecord.factory = () => injectArgs(multiRecord.multi);\n                this.records.set(token, multiRecord);\n            }\n            token = provider;\n            multiRecord.multi.push(provider);\n        }\n        else {\n            const existing = this.records.get(token);\n            if (ngDevMode && existing && existing.multi !== undefined) {\n                throwMixedMultiProviderError();\n            }\n        }\n        this.records.set(token, record);\n    }\n    hydrate(token, record) {\n        if (ngDevMode && record.value === CIRCULAR) {\n            throwCyclicDependencyError(stringify(token));\n        }\n        else if (record.value === NOT_YET) {\n            record.value = CIRCULAR;\n            record.value = record.factory();\n        }\n        if (typeof record.value === 'object' && record.value && hasOnDestroy(record.value)) {\n            this._ngOnDestroyHooks.add(record.value);\n        }\n        return record.value;\n    }\n    injectableDefInScope(def) {\n        if (!def.providedIn) {\n            return false;\n        }\n        const providedIn = resolveForwardRef(def.providedIn);\n        if (typeof providedIn === 'string') {\n            return providedIn === 'any' || (this.scopes.has(providedIn));\n        }\n        else {\n            return this.injectorDefTypes.has(providedIn);\n        }\n    }\n}\nfunction injectableDefOrInjectorDefFactory(token) {\n    // Most tokens will have an injectable def directly on them, which specifies a factory directly.\n    const injectableDef = getInjectableDef(token);\n    const factory = injectableDef !== null ? injectableDef.factory : getFactoryDef(token);\n    if (factory !== null) {\n        return factory;\n    }\n    // InjectionTokens should have an injectable def (ɵprov) and thus should be handled above.\n    // If it's missing that, it's an error.\n    if (token instanceof InjectionToken) {\n        throw new RuntimeError(204 /* RuntimeErrorCode.INVALID_INJECTION_TOKEN */, ngDevMode && `Token ${stringify(token)} is missing a ɵprov definition.`);\n    }\n    // Undecorated types can sometimes be created if they have no constructor arguments.\n    if (token instanceof Function) {\n        return getUndecoratedInjectableFactory(token);\n    }\n    // There was no way to resolve a factory for this token.\n    throw new RuntimeError(204 /* RuntimeErrorCode.INVALID_INJECTION_TOKEN */, ngDevMode && 'unreachable');\n}\nfunction getUndecoratedInjectableFactory(token) {\n    // If the token has parameters then it has dependencies that we cannot resolve implicitly.\n    const paramLength = token.length;\n    if (paramLength > 0) {\n        const args = newArray(paramLength, '?');\n        throw new RuntimeError(204 /* RuntimeErrorCode.INVALID_INJECTION_TOKEN */, ngDevMode && `Can't resolve all parameters for ${stringify(token)}: (${args.join(', ')}).`);\n    }\n    // The constructor function appears to have no parameters.\n    // This might be because it inherits from a super-class. In which case, use an injectable\n    // def from an ancestor if there is one.\n    // Otherwise this really is a simple class with no dependencies, so return a factory that\n    // just instantiates the zero-arg constructor.\n    const inheritedInjectableDef = getInheritedInjectableDef(token);\n    if (inheritedInjectableDef !== null) {\n        return () => inheritedInjectableDef.factory(token);\n    }\n    else {\n        return () => new token();\n    }\n}\nfunction providerToRecord(provider) {\n    if (isValueProvider(provider)) {\n        return makeRecord(undefined, provider.useValue);\n    }\n    else {\n        const factory = providerToFactory(provider);\n        return makeRecord(factory, NOT_YET);\n    }\n}\n/**\n * Converts a `SingleProvider` into a factory function.\n *\n * @param provider provider to convert to factory\n */\nfunction providerToFactory(provider, ngModuleType, providers) {\n    let factory = undefined;\n    if (ngDevMode && isImportedNgModuleProviders(provider)) {\n        throwInvalidProviderError(undefined, providers, provider);\n    }\n    if (isTypeProvider(provider)) {\n        const unwrappedProvider = resolveForwardRef(provider);\n        return getFactoryDef(unwrappedProvider) || injectableDefOrInjectorDefFactory(unwrappedProvider);\n    }\n    else {\n        if (isValueProvider(provider)) {\n            factory = () => resolveForwardRef(provider.useValue);\n        }\n        else if (isFactoryProvider(provider)) {\n            factory = () => provider.useFactory(...injectArgs(provider.deps || []));\n        }\n        else if (isExistingProvider(provider)) {\n            factory = () => ɵɵinject(resolveForwardRef(provider.useExisting));\n        }\n        else {\n            const classRef = resolveForwardRef(provider &&\n                (provider.useClass || provider.provide));\n            if (ngDevMode && !classRef) {\n                throwInvalidProviderError(ngModuleType, providers, provider);\n            }\n            if (hasDeps(provider)) {\n                factory = () => new (classRef)(...injectArgs(provider.deps));\n            }\n            else {\n                return getFactoryDef(classRef) || injectableDefOrInjectorDefFactory(classRef);\n            }\n        }\n    }\n    return factory;\n}\nfunction makeRecord(factory, value, multi = false) {\n    return {\n        factory: factory,\n        value: value,\n        multi: multi ? [] : undefined,\n    };\n}\nfunction hasDeps(value) {\n    return !!value.deps;\n}\nfunction hasOnDestroy(value) {\n    return value !== null && typeof value === 'object' &&\n        typeof value.ngOnDestroy === 'function';\n}\nfunction couldBeInjectableType(value) {\n    return (typeof value === 'function') ||\n        (typeof value === 'object' && value instanceof InjectionToken);\n}\nfunction isImportedNgModuleProviders(provider) {\n    return !!provider.ɵproviders;\n}\nfunction forEachSingleProvider(providers, fn) {\n    for (const provider of providers) {\n        if (Array.isArray(provider)) {\n            forEachSingleProvider(provider, fn);\n        }\n        else if (isImportedNgModuleProviders(provider)) {\n            forEachSingleProvider(provider.ɵproviders, fn);\n        }\n        else {\n            fn(provider);\n        }\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Create a new `Injector` which is configured using a `defType` of `InjectorType<any>`s.\n *\n * @publicApi\n */\nfunction createInjector(defType, parent = null, additionalProviders = null, name) {\n    const injector = createInjectorWithoutInjectorInstances(defType, parent, additionalProviders, name);\n    injector.resolveInjectorInitializers();\n    return injector;\n}\n/**\n * Creates a new injector without eagerly resolving its injector types. Can be used in places\n * where resolving the injector types immediately can lead to an infinite loop. The injector types\n * should be resolved at a later point by calling `_resolveInjectorDefTypes`.\n */\nfunction createInjectorWithoutInjectorInstances(defType, parent = null, additionalProviders = null, name, scopes = new Set()) {\n    const providers = [\n        additionalProviders || EMPTY_ARRAY,\n        importProvidersFrom(defType),\n    ];\n    name = name || (typeof defType === 'object' ? undefined : stringify(defType));\n    return new R3Injector(providers, parent || getNullInjector(), name || null, scopes);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Concrete injectors implement this interface. Injectors are configured\n * with [providers](guide/glossary#provider) that associate\n * dependencies of various types with [injection tokens](guide/glossary#di-token).\n *\n * @see [\"DI Providers\"](guide/dependency-injection-providers).\n * @see `StaticProvider`\n *\n * @usageNotes\n *\n *  The following example creates a service injector instance.\n *\n * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}\n *\n * ### Usage example\n *\n * {@example core/di/ts/injector_spec.ts region='Injector'}\n *\n * `Injector` returns itself when given `Injector` as a token:\n *\n * {@example core/di/ts/injector_spec.ts region='injectInjector'}\n *\n * @publicApi\n */\nclass Injector {\n    static create(options, parent) {\n        var _a;\n        if (Array.isArray(options)) {\n            return createInjector({ name: '' }, parent, options, '');\n        }\n        else {\n            const name = (_a = options.name) !== null && _a !== void 0 ? _a : '';\n            return createInjector({ name }, options.parent, options.providers, name);\n        }\n    }\n}\nInjector.THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;\nInjector.NULL = ( /* @__PURE__ */new NullInjector());\n/** @nocollapse */\nInjector.ɵprov = ɵɵdefineInjectable({\n    token: Injector,\n    providedIn: 'any',\n    factory: () => ɵɵinject(INJECTOR),\n});\n/**\n * @internal\n * @nocollapse\n */\nInjector.__NG_ELEMENT_ID__ = -1 /* InjectorMarkers.Injector */;\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction findFirstClosedCycle(keys) {\n    const res = [];\n    for (let i = 0; i < keys.length; ++i) {\n        if (res.indexOf(keys[i]) > -1) {\n            res.push(keys[i]);\n            return res;\n        }\n        res.push(keys[i]);\n    }\n    return res;\n}\nfunction constructResolvingPath(keys) {\n    if (keys.length > 1) {\n        const reversed = findFirstClosedCycle(keys.slice().reverse());\n        const tokenStrs = reversed.map(k => stringify(k.token));\n        return ' (' + tokenStrs.join(' -> ') + ')';\n    }\n    return '';\n}\nfunction injectionError(injector, key, constructResolvingMessage, originalError) {\n    const keys = [key];\n    const errMsg = constructResolvingMessage(keys);\n    const error = (originalError ? wrappedError(errMsg, originalError) : Error(errMsg));\n    error.addKey = addKey;\n    error.keys = keys;\n    error.injectors = [injector];\n    error.constructResolvingMessage = constructResolvingMessage;\n    error[ERROR_ORIGINAL_ERROR] = originalError;\n    return error;\n}\nfunction addKey(injector, key) {\n    this.injectors.push(injector);\n    this.keys.push(key);\n    // Note: This updated message won't be reflected in the `.stack` property\n    this.message = this.constructResolvingMessage(this.keys);\n}\n/**\n * Thrown when trying to retrieve a dependency by key from {@link Injector}, but the\n * {@link Injector} does not have a {@link Provider} for the given key.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * class A {\n *   constructor(b:B) {}\n * }\n *\n * expect(() => Injector.resolveAndCreate([A])).toThrowError();\n * ```\n */\nfunction noProviderError(injector, key) {\n    return injectionError(injector, key, function (keys) {\n        const first = stringify(keys[0].token);\n        return `No provider for ${first}!${constructResolvingPath(keys)}`;\n    });\n}\n/**\n * Thrown when dependencies form a cycle.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * var injector = Injector.resolveAndCreate([\n *   {provide: \"one\", useFactory: (two) => \"two\", deps: [[new Inject(\"two\")]]},\n *   {provide: \"two\", useFactory: (one) => \"one\", deps: [[new Inject(\"one\")]]}\n * ]);\n *\n * expect(() => injector.get(\"one\")).toThrowError();\n * ```\n *\n * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.\n */\nfunction cyclicDependencyError(injector, key) {\n    return injectionError(injector, key, function (keys) {\n        return `Cannot instantiate cyclic dependency!${constructResolvingPath(keys)}`;\n    });\n}\n/**\n * Thrown when a constructing type returns with an Error.\n *\n * The `InstantiationError` class contains the original error plus the dependency graph which caused\n * this object to be instantiated.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * class A {\n *   constructor() {\n *     throw new Error('message');\n *   }\n * }\n *\n * var injector = Injector.resolveAndCreate([A]);\n\n * try {\n *   injector.get(A);\n * } catch (e) {\n *   expect(e instanceof InstantiationError).toBe(true);\n *   expect(e.originalException.message).toEqual(\"message\");\n *   expect(e.originalStack).toBeDefined();\n * }\n * ```\n */\nfunction instantiationError(injector, originalException, originalStack, key) {\n    return injectionError(injector, key, function (keys) {\n        const first = stringify(keys[0].token);\n        return `${originalException.message}: Error during instantiation of ${first}!${constructResolvingPath(keys)}.`;\n    }, originalException);\n}\n/**\n * Thrown when an object other then {@link Provider} (or `Type`) is passed to {@link Injector}\n * creation.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * expect(() => Injector.resolveAndCreate([\"not a type\"])).toThrowError();\n * ```\n */\nfunction invalidProviderError(provider) {\n    return Error(`Invalid provider - only instances of Provider and Type are allowed, got: ${provider}`);\n}\n/**\n * Thrown when the class has no annotation information.\n *\n * Lack of annotation information prevents the {@link Injector} from determining which dependencies\n * need to be injected into the constructor.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * class A {\n *   constructor(b) {}\n * }\n *\n * expect(() => Injector.resolveAndCreate([A])).toThrowError();\n * ```\n *\n * This error is also thrown when the class not marked with {@link Injectable} has parameter types.\n *\n * ```typescript\n * class B {}\n *\n * class A {\n *   constructor(b:B) {} // no information about the parameter types of A is available at runtime.\n * }\n *\n * expect(() => Injector.resolveAndCreate([A,B])).toThrowError();\n * ```\n *\n */\nfunction noAnnotationError(typeOrFunc, params) {\n    const signature = [];\n    for (let i = 0, ii = params.length; i < ii; i++) {\n        const parameter = params[i];\n        if (!parameter || parameter.length == 0) {\n            signature.push('?');\n        }\n        else {\n            signature.push(parameter.map(stringify).join(' '));\n        }\n    }\n    return Error('Cannot resolve all parameters for \\'' + stringify(typeOrFunc) + '\\'(' +\n        signature.join(', ') + '). ' +\n        'Make sure that all the parameters are decorated with Inject or have valid type annotations and that \\'' +\n        stringify(typeOrFunc) + '\\' is decorated with Injectable.');\n}\n/**\n * Thrown when getting an object by index.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * class A {}\n *\n * var injector = Injector.resolveAndCreate([A]);\n *\n * expect(() => injector.getAt(100)).toThrowError();\n * ```\n *\n */\nfunction outOfBoundsError(index) {\n    return Error(`Index ${index} is out-of-bounds.`);\n}\n// TODO: add a working example after alpha38 is released\n/**\n * Thrown when a multi provider and a regular provider are bound to the same token.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * expect(() => Injector.resolveAndCreate([\n *   { provide: \"Strings\", useValue: \"string1\", multi: true},\n *   { provide: \"Strings\", useValue: \"string2\", multi: false}\n * ])).toThrowError();\n * ```\n */\nfunction mixingMultiProvidersWithRegularProvidersError(provider1, provider2) {\n    return Error(`Cannot mix multi providers and regular providers, got: ${provider1} ${provider2}`);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A unique object used for retrieving items from the {@link ReflectiveInjector}.\n *\n * Keys have:\n * - a system-wide unique `id`.\n * - a `token`.\n *\n * `Key` is used internally by {@link ReflectiveInjector} because its system-wide unique `id` allows\n * the\n * injector to store created objects in a more efficient way.\n *\n * `Key` should not be created directly. {@link ReflectiveInjector} creates keys automatically when\n * resolving\n * providers.\n *\n * @deprecated No replacement\n * @publicApi\n */\nclass ReflectiveKey {\n    /**\n     * Private\n     */\n    constructor(token, id) {\n        this.token = token;\n        this.id = id;\n        if (!token) {\n            throw new Error('Token must be defined!');\n        }\n        this.displayName = stringify(this.token);\n    }\n    /**\n     * Retrieves a `Key` for a token.\n     */\n    static get(token) {\n        return _globalKeyRegistry.get(resolveForwardRef(token));\n    }\n    /**\n     * @returns the number of keys registered in the system.\n     */\n    static get numberOfKeys() {\n        return _globalKeyRegistry.numberOfKeys;\n    }\n}\nclass KeyRegistry {\n    constructor() {\n        this._allKeys = new Map();\n    }\n    get(token) {\n        if (token instanceof ReflectiveKey)\n            return token;\n        if (this._allKeys.has(token)) {\n            return this._allKeys.get(token);\n        }\n        const newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);\n        this._allKeys.set(token, newKey);\n        return newKey;\n    }\n    get numberOfKeys() {\n        return this._allKeys.size;\n    }\n}\nconst _globalKeyRegistry = new KeyRegistry();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * `Dependency` is used by the framework to extend DI.\n * This is internal to Angular and should not be used directly.\n */\nclass ReflectiveDependency {\n    constructor(key, optional, visibility) {\n        this.key = key;\n        this.optional = optional;\n        this.visibility = visibility;\n    }\n    static fromKey(key) {\n        return new ReflectiveDependency(key, false, null);\n    }\n}\nconst _EMPTY_LIST = [];\nclass ResolvedReflectiveProvider_ {\n    constructor(key, resolvedFactories, multiProvider) {\n        this.key = key;\n        this.resolvedFactories = resolvedFactories;\n        this.multiProvider = multiProvider;\n        this.resolvedFactory = this.resolvedFactories[0];\n    }\n}\n/**\n * An internal resolved representation of a factory function created by resolving `Provider`.\n * @publicApi\n */\nclass ResolvedReflectiveFactory {\n    constructor(\n    /**\n     * Factory function which can return an instance of an object represented by a key.\n     */\n    factory, \n    /**\n     * Arguments (dependencies) to the `factory` function.\n     */\n    dependencies) {\n        this.factory = factory;\n        this.dependencies = dependencies;\n    }\n}\n/**\n * Resolve a single provider.\n */\nfunction resolveReflectiveFactory(provider) {\n    let factoryFn;\n    let resolvedDeps;\n    if (provider.useClass) {\n        const useClass = resolveForwardRef(provider.useClass);\n        factoryFn = getReflect().factory(useClass);\n        resolvedDeps = _dependenciesFor(useClass);\n    }\n    else if (provider.useExisting) {\n        factoryFn = (aliasInstance) => aliasInstance;\n        resolvedDeps = [ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))];\n    }\n    else if (provider.useFactory) {\n        factoryFn = provider.useFactory;\n        resolvedDeps = constructDependencies(provider.useFactory, provider.deps);\n    }\n    else {\n        factoryFn = () => provider.useValue;\n        resolvedDeps = _EMPTY_LIST;\n    }\n    return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);\n}\n/**\n * Converts the `Provider` into `ResolvedProvider`.\n *\n * `Injector` internally only uses `ResolvedProvider`, `Provider` contains convenience provider\n * syntax.\n */\nfunction resolveReflectiveProvider(provider) {\n    return new ResolvedReflectiveProvider_(ReflectiveKey.get(provider.provide), [resolveReflectiveFactory(provider)], provider.multi || false);\n}\n/**\n * Resolve a list of Providers.\n */\nfunction resolveReflectiveProviders(providers) {\n    const normalized = _normalizeProviders(providers, []);\n    const resolved = normalized.map(resolveReflectiveProvider);\n    const resolvedProviderMap = mergeResolvedReflectiveProviders(resolved, new Map());\n    return Array.from(resolvedProviderMap.values());\n}\n/**\n * Merges a list of ResolvedProviders into a list where each key is contained exactly once and\n * multi providers have been merged.\n */\nfunction mergeResolvedReflectiveProviders(providers, normalizedProvidersMap) {\n    for (let i = 0; i < providers.length; i++) {\n        const provider = providers[i];\n        const existing = normalizedProvidersMap.get(provider.key.id);\n        if (existing) {\n            if (provider.multiProvider !== existing.multiProvider) {\n                throw mixingMultiProvidersWithRegularProvidersError(existing, provider);\n            }\n            if (provider.multiProvider) {\n                for (let j = 0; j < provider.resolvedFactories.length; j++) {\n                    existing.resolvedFactories.push(provider.resolvedFactories[j]);\n                }\n            }\n            else {\n                normalizedProvidersMap.set(provider.key.id, provider);\n            }\n        }\n        else {\n            let resolvedProvider;\n            if (provider.multiProvider) {\n                resolvedProvider = new ResolvedReflectiveProvider_(provider.key, provider.resolvedFactories.slice(), provider.multiProvider);\n            }\n            else {\n                resolvedProvider = provider;\n            }\n            normalizedProvidersMap.set(provider.key.id, resolvedProvider);\n        }\n    }\n    return normalizedProvidersMap;\n}\nfunction _normalizeProviders(providers, res) {\n    providers.forEach(b => {\n        if (b instanceof Type) {\n            res.push({ provide: b, useClass: b });\n        }\n        else if (b && typeof b == 'object' && b.provide !== undefined) {\n            res.push(b);\n        }\n        else if (Array.isArray(b)) {\n            _normalizeProviders(b, res);\n        }\n        else {\n            throw invalidProviderError(b);\n        }\n    });\n    return res;\n}\nfunction constructDependencies(typeOrFunc, dependencies) {\n    if (!dependencies) {\n        return _dependenciesFor(typeOrFunc);\n    }\n    else {\n        const params = dependencies.map(t => [t]);\n        return dependencies.map(t => _extractToken(typeOrFunc, t, params));\n    }\n}\nfunction _dependenciesFor(typeOrFunc) {\n    const params = getReflect().parameters(typeOrFunc);\n    if (!params)\n        return [];\n    if (params.some(p => p == null)) {\n        throw noAnnotationError(typeOrFunc, params);\n    }\n    return params.map(p => _extractToken(typeOrFunc, p, params));\n}\nfunction _extractToken(typeOrFunc, metadata, params) {\n    let token = null;\n    let optional = false;\n    if (!Array.isArray(metadata)) {\n        if (metadata instanceof Inject) {\n            return _createDependency(metadata.token, optional, null);\n        }\n        else {\n            return _createDependency(metadata, optional, null);\n        }\n    }\n    let visibility = null;\n    for (let i = 0; i < metadata.length; ++i) {\n        const paramMetadata = metadata[i];\n        if (paramMetadata instanceof Type) {\n            token = paramMetadata;\n        }\n        else if (paramMetadata instanceof Inject) {\n            token = paramMetadata.token;\n        }\n        else if (paramMetadata instanceof Optional) {\n            optional = true;\n        }\n        else if (paramMetadata instanceof Self || paramMetadata instanceof SkipSelf) {\n            visibility = paramMetadata;\n        }\n        else if (paramMetadata instanceof InjectionToken) {\n            token = paramMetadata;\n        }\n    }\n    token = resolveForwardRef(token);\n    if (token != null) {\n        return _createDependency(token, optional, visibility);\n    }\n    else {\n        throw noAnnotationError(typeOrFunc, params);\n    }\n}\nfunction _createDependency(token, optional, visibility) {\n    return new ReflectiveDependency(ReflectiveKey.get(token), optional, visibility);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Threshold for the dynamic version\nconst UNDEFINED = {};\n/**\n * A ReflectiveDependency injection container used for instantiating objects and resolving\n * dependencies.\n *\n * An `Injector` is a replacement for a `new` operator, which can automatically resolve the\n * constructor dependencies.\n *\n * In typical use, application code asks for the dependencies in the constructor and they are\n * resolved by the `Injector`.\n *\n * @usageNotes\n * ### Example\n *\n * The following example creates an `Injector` configured to create `Engine` and `Car`.\n *\n * ```typescript\n * @Injectable()\n * class Engine {\n * }\n *\n * @Injectable()\n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n *\n * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\n * var car = injector.get(Car);\n * expect(car instanceof Car).toBe(true);\n * expect(car.engine instanceof Engine).toBe(true);\n * ```\n *\n * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`\n * resolve all of the object's dependencies automatically.\n *\n * TODO: delete in v14.\n *\n * @deprecated from v5 - slow and brings in a lot of code, Use `Injector.create` instead.\n * @publicApi\n */\nclass ReflectiveInjector {\n    /**\n     * Turns an array of provider definitions into an array of resolved providers.\n     *\n     * A resolution is a process of flattening multiple nested arrays and converting individual\n     * providers into an array of `ResolvedReflectiveProvider`s.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * ```typescript\n     * @Injectable()\n     * class Engine {\n     * }\n     *\n     * @Injectable()\n     * class Car {\n     *   constructor(public engine:Engine) {}\n     * }\n     *\n     * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);\n     *\n     * expect(providers.length).toEqual(2);\n     *\n     * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);\n     * expect(providers[0].key.displayName).toBe(\"Car\");\n     * expect(providers[0].dependencies.length).toEqual(1);\n     * expect(providers[0].factory).toBeDefined();\n     *\n     * expect(providers[1].key.displayName).toBe(\"Engine\");\n     * });\n     * ```\n     *\n     */\n    static resolve(providers) {\n        return resolveReflectiveProviders(providers);\n    }\n    /**\n     * Resolves an array of providers and creates an injector from those providers.\n     *\n     * The passed-in providers can be an array of `Type`, `Provider`,\n     * or a recursive array of more providers.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * ```typescript\n     * @Injectable()\n     * class Engine {\n     * }\n     *\n     * @Injectable()\n     * class Car {\n     *   constructor(public engine:Engine) {}\n     * }\n     *\n     * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\n     * expect(injector.get(Car) instanceof Car).toBe(true);\n     * ```\n     */\n    static resolveAndCreate(providers, parent) {\n        const ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);\n        return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);\n    }\n    /**\n     * Creates an injector from previously resolved providers.\n     *\n     * This API is the recommended way to construct injectors in performance-sensitive parts.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * ```typescript\n     * @Injectable()\n     * class Engine {\n     * }\n     *\n     * @Injectable()\n     * class Car {\n     *   constructor(public engine:Engine) {}\n     * }\n     *\n     * var providers = ReflectiveInjector.resolve([Car, Engine]);\n     * var injector = ReflectiveInjector.fromResolvedProviders(providers);\n     * expect(injector.get(Car) instanceof Car).toBe(true);\n     * ```\n     */\n    static fromResolvedProviders(providers, parent) {\n        return new ReflectiveInjector_(providers, parent);\n    }\n}\nclass ReflectiveInjector_ {\n    /**\n     * Private\n     */\n    constructor(_providers, _parent) {\n        /** @internal */\n        this._constructionCounter = 0;\n        this._providers = _providers;\n        this.parent = _parent || null;\n        const len = _providers.length;\n        this.keyIds = [];\n        this.objs = [];\n        for (let i = 0; i < len; i++) {\n            this.keyIds[i] = _providers[i].key.id;\n            this.objs[i] = UNDEFINED;\n        }\n    }\n    get(token, notFoundValue = THROW_IF_NOT_FOUND) {\n        return this._getByKey(ReflectiveKey.get(token), null, notFoundValue);\n    }\n    resolveAndCreateChild(providers) {\n        const ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);\n        return this.createChildFromResolved(ResolvedReflectiveProviders);\n    }\n    createChildFromResolved(providers) {\n        const inj = new ReflectiveInjector_(providers);\n        inj.parent = this;\n        return inj;\n    }\n    resolveAndInstantiate(provider) {\n        return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);\n    }\n    instantiateResolved(provider) {\n        return this._instantiateProvider(provider);\n    }\n    getProviderAtIndex(index) {\n        if (index < 0 || index >= this._providers.length) {\n            throw outOfBoundsError(index);\n        }\n        return this._providers[index];\n    }\n    /** @internal */\n    _new(provider) {\n        if (this._constructionCounter++ > this._getMaxNumberOfObjects()) {\n            throw cyclicDependencyError(this, provider.key);\n        }\n        return this._instantiateProvider(provider);\n    }\n    _getMaxNumberOfObjects() {\n        return this.objs.length;\n    }\n    _instantiateProvider(provider) {\n        if (provider.multiProvider) {\n            const res = [];\n            for (let i = 0; i < provider.resolvedFactories.length; ++i) {\n                res[i] = this._instantiate(provider, provider.resolvedFactories[i]);\n            }\n            return res;\n        }\n        else {\n            return this._instantiate(provider, provider.resolvedFactories[0]);\n        }\n    }\n    _instantiate(provider, ResolvedReflectiveFactory) {\n        const factory = ResolvedReflectiveFactory.factory;\n        let deps;\n        try {\n            deps =\n                ResolvedReflectiveFactory.dependencies.map(dep => this._getByReflectiveDependency(dep));\n        }\n        catch (e) {\n            if (e.addKey) {\n                e.addKey(this, provider.key);\n            }\n            throw e;\n        }\n        let obj;\n        try {\n            obj = factory(...deps);\n        }\n        catch (e) {\n            throw instantiationError(this, e, e.stack, provider.key);\n        }\n        return obj;\n    }\n    _getByReflectiveDependency(dep) {\n        return this._getByKey(dep.key, dep.visibility, dep.optional ? null : THROW_IF_NOT_FOUND);\n    }\n    _getByKey(key, visibility, notFoundValue) {\n        if (key === ReflectiveInjector_.INJECTOR_KEY) {\n            return this;\n        }\n        if (visibility instanceof Self) {\n            return this._getByKeySelf(key, notFoundValue);\n        }\n        else {\n            return this._getByKeyDefault(key, notFoundValue, visibility);\n        }\n    }\n    _getObjByKeyId(keyId) {\n        for (let i = 0; i < this.keyIds.length; i++) {\n            if (this.keyIds[i] === keyId) {\n                if (this.objs[i] === UNDEFINED) {\n                    this.objs[i] = this._new(this._providers[i]);\n                }\n                return this.objs[i];\n            }\n        }\n        return UNDEFINED;\n    }\n    /** @internal */\n    _throwOrNull(key, notFoundValue) {\n        if (notFoundValue !== THROW_IF_NOT_FOUND) {\n            return notFoundValue;\n        }\n        else {\n            throw noProviderError(this, key);\n        }\n    }\n    /** @internal */\n    _getByKeySelf(key, notFoundValue) {\n        const obj = this._getObjByKeyId(key.id);\n        return (obj !== UNDEFINED) ? obj : this._throwOrNull(key, notFoundValue);\n    }\n    /** @internal */\n    _getByKeyDefault(key, notFoundValue, visibility) {\n        let inj;\n        if (visibility instanceof SkipSelf) {\n            inj = this.parent;\n        }\n        else {\n            inj = this;\n        }\n        while (inj instanceof ReflectiveInjector_) {\n            const inj_ = inj;\n            const obj = inj_._getObjByKeyId(key.id);\n            if (obj !== UNDEFINED)\n                return obj;\n            inj = inj_.parent;\n        }\n        if (inj !== null) {\n            return inj.get(key.token, notFoundValue);\n        }\n        else {\n            return this._throwOrNull(key, notFoundValue);\n        }\n    }\n    get displayName() {\n        const providers = _mapProviders(this, (b) => ' \"' + b.key.displayName + '\" ')\n            .join(', ');\n        return `ReflectiveInjector(providers: [${providers}])`;\n    }\n    toString() {\n        return this.displayName;\n    }\n}\nReflectiveInjector_.INJECTOR_KEY = ( /* @__PURE__ */ReflectiveKey.get(Injector));\nfunction _mapProviders(injector, fn) {\n    const res = [];\n    for (let i = 0; i < injector._providers.length; ++i) {\n        res[i] = fn(injector.getProviderAtIndex(i));\n    }\n    return res;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction ɵɵdirectiveInject(token, flags = InjectFlags.Default) {\n    const lView = getLView();\n    // Fall back to inject() if view hasn't been created. This situation can happen in tests\n    // if inject utilities are used before bootstrapping.\n    if (lView === null) {\n        // Verify that we will not get into infinite loop.\n        ngDevMode && assertInjectImplementationNotEqual(ɵɵdirectiveInject);\n        return ɵɵinject(token, flags);\n    }\n    const tNode = getCurrentTNode();\n    return getOrCreateInjectable(tNode, lView, resolveForwardRef(token), flags);\n}\n/**\n * Throws an error indicating that a factory function could not be generated by the compiler for a\n * particular class.\n *\n * This instruction allows the actual error message to be optimized away when ngDevMode is turned\n * off, saving bytes of generated code while still providing a good experience in dev mode.\n *\n * The name of the class is not mentioned here, but will be in the generated factory function name\n * and thus in the stack trace.\n *\n * @codeGenApi\n */\nfunction ɵɵinvalidFactory() {\n    const msg = ngDevMode ? `This constructor was not compatible with Dependency Injection.` : 'invalid';\n    throw new Error(msg);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Defines a schema that allows an NgModule to contain the following:\n * - Non-Angular elements named with dash case (`-`).\n * - Element properties named with dash case (`-`).\n * Dash case is the naming convention for custom elements.\n *\n * @publicApi\n */\nconst CUSTOM_ELEMENTS_SCHEMA = {\n    name: 'custom-elements'\n};\n/**\n * Defines a schema that allows any property on any element.\n *\n * This schema allows you to ignore the errors related to any unknown elements or properties in a\n * template. The usage of this schema is generally discouraged because it prevents useful validation\n * and may hide real errors in your template. Consider using the `CUSTOM_ELEMENTS_SCHEMA` instead.\n *\n * @publicApi\n */\nconst NO_ERRORS_SCHEMA = {\n    name: 'no-errors-schema'\n};\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nlet shouldThrowErrorOnUnknownElement = false;\n/**\n * Sets a strict mode for JIT-compiled components to throw an error on unknown elements,\n * instead of just logging the error.\n * (for AOT-compiled ones this check happens at build time).\n */\nfunction ɵsetUnknownElementStrictMode(shouldThrow) {\n    shouldThrowErrorOnUnknownElement = shouldThrow;\n}\n/**\n * Gets the current value of the strict mode.\n */\nfunction ɵgetUnknownElementStrictMode() {\n    return shouldThrowErrorOnUnknownElement;\n}\nlet shouldThrowErrorOnUnknownProperty = false;\n/**\n * Sets a strict mode for JIT-compiled components to throw an error on unknown properties,\n * instead of just logging the error.\n * (for AOT-compiled ones this check happens at build time).\n */\nfunction ɵsetUnknownPropertyStrictMode(shouldThrow) {\n    shouldThrowErrorOnUnknownProperty = shouldThrow;\n}\n/**\n * Gets the current value of the strict mode.\n */\nfunction ɵgetUnknownPropertyStrictMode() {\n    return shouldThrowErrorOnUnknownProperty;\n}\n/**\n * Validates that the element is known at runtime and produces\n * an error if it's not the case.\n * This check is relevant for JIT-compiled components (for AOT-compiled\n * ones this check happens at build time).\n *\n * The element is considered known if either:\n * - it's a known HTML element\n * - it's a known custom element\n * - the element matches any directive\n * - the element is allowed by one of the schemas\n *\n * @param element Element to validate\n * @param lView An `LView` that represents a current component that is being rendered\n * @param tagName Name of the tag to check\n * @param schemas Array of schemas\n * @param hasDirectives Boolean indicating that the element matches any directive\n */\nfunction validateElementIsKnown(element, lView, tagName, schemas, hasDirectives) {\n    // If `schemas` is set to `null`, that's an indication that this Component was compiled in AOT\n    // mode where this check happens at compile time. In JIT mode, `schemas` is always present and\n    // defined as an array (as an empty array in case `schemas` field is not defined) and we should\n    // execute the check below.\n    if (schemas === null)\n        return;\n    // If the element matches any directive, it's considered as valid.\n    if (!hasDirectives && tagName !== null) {\n        // The element is unknown if it's an instance of HTMLUnknownElement, or it isn't registered\n        // as a custom element. Note that unknown elements with a dash in their name won't be instances\n        // of HTMLUnknownElement in browsers that support web components.\n        const isUnknown = \n        // Note that we can't check for `typeof HTMLUnknownElement === 'function'`,\n        // because while most browsers return 'function', IE returns 'object'.\n        (typeof HTMLUnknownElement !== 'undefined' && HTMLUnknownElement &&\n            element instanceof HTMLUnknownElement) ||\n            (typeof customElements !== 'undefined' && tagName.indexOf('-') > -1 &&\n                !customElements.get(tagName));\n        if (isUnknown && !matchingSchemas(schemas, tagName)) {\n            const isHostStandalone = isHostComponentStandalone(lView);\n            const templateLocation = getTemplateLocationDetails(lView);\n            const schemas = `'${isHostStandalone ? '@Component' : '@NgModule'}.schemas'`;\n            let message = `'${tagName}' is not a known element${templateLocation}:\\n`;\n            message += `1. If '${tagName}' is an Angular component, then verify that it is ${isHostStandalone ? 'included in the \\'@Component.imports\\' of this component' :\n                'a part of an @NgModule where this component is declared'}.\\n`;\n            if (tagName && tagName.indexOf('-') > -1) {\n                message +=\n                    `2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas} of this component to suppress this message.`;\n            }\n            else {\n                message +=\n                    `2. To allow any element add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;\n            }\n            if (shouldThrowErrorOnUnknownElement) {\n                throw new RuntimeError(304 /* RuntimeErrorCode.UNKNOWN_ELEMENT */, message);\n            }\n            else {\n                console.error(formatRuntimeError(304 /* RuntimeErrorCode.UNKNOWN_ELEMENT */, message));\n            }\n        }\n    }\n}\n/**\n * Validates that the property of the element is known at runtime and returns\n * false if it's not the case.\n * This check is relevant for JIT-compiled components (for AOT-compiled\n * ones this check happens at build time).\n *\n * The property is considered known if either:\n * - it's a known property of the element\n * - the element is allowed by one of the schemas\n * - the property is used for animations\n *\n * @param element Element to validate\n * @param propName Name of the property to check\n * @param tagName Name of the tag hosting the property\n * @param schemas Array of schemas\n */\nfunction isPropertyValid(element, propName, tagName, schemas) {\n    // If `schemas` is set to `null`, that's an indication that this Component was compiled in AOT\n    // mode where this check happens at compile time. In JIT mode, `schemas` is always present and\n    // defined as an array (as an empty array in case `schemas` field is not defined) and we should\n    // execute the check below.\n    if (schemas === null)\n        return true;\n    // The property is considered valid if the element matches the schema, it exists on the element,\n    // or it is synthetic, and we are in a browser context (web worker nodes should be skipped).\n    if (matchingSchemas(schemas, tagName) || propName in element || isAnimationProp(propName)) {\n        return true;\n    }\n    // Note: `typeof Node` returns 'function' in most browsers, but on IE it is 'object' so we\n    // need to account for both here, while being careful with `typeof null` also returning 'object'.\n    return typeof Node === 'undefined' || Node === null || !(element instanceof Node);\n}\n/**\n * Logs or throws an error that a property is not supported on an element.\n *\n * @param propName Name of the invalid property\n * @param tagName Name of the tag hosting the property\n * @param nodeType Type of the node hosting the property\n * @param lView An `LView` that represents a current component\n */\nfunction handleUnknownPropertyError(propName, tagName, nodeType, lView) {\n    // Special-case a situation when a structural directive is applied to\n    // an `<ng-template>` element, for example: `<ng-template *ngIf=\"true\">`.\n    // In this case the compiler generates the `ɵɵtemplate` instruction with\n    // the `null` as the tagName. The directive matching logic at runtime relies\n    // on this effect (see `isInlineTemplate`), thus using the 'ng-template' as\n    // a default value of the `tNode.value` is not feasible at this moment.\n    if (!tagName && nodeType === 4 /* TNodeType.Container */) {\n        tagName = 'ng-template';\n    }\n    const isHostStandalone = isHostComponentStandalone(lView);\n    const templateLocation = getTemplateLocationDetails(lView);\n    let message = `Can't bind to '${propName}' since it isn't a known property of '${tagName}'${templateLocation}.`;\n    const schemas = `'${isHostStandalone ? '@Component' : '@NgModule'}.schemas'`;\n    const importLocation = isHostStandalone ?\n        'included in the \\'@Component.imports\\' of this component' :\n        'a part of an @NgModule where this component is declared';\n    if (KNOWN_CONTROL_FLOW_DIRECTIVES.has(propName)) {\n        // Most likely this is a control flow directive (such as `*ngIf`) used in\n        // a template, but the `CommonModule` is not imported.\n        message += `\\nIf the '${propName}' is an Angular control flow directive, ` +\n            `please make sure that the 'CommonModule' is ${importLocation}.`;\n    }\n    else {\n        // May be an Angular component, which is not imported/declared?\n        message += `\\n1. If '${tagName}' is an Angular component and it has the ` +\n            `'${propName}' input, then verify that it is ${importLocation}.`;\n        // May be a Web Component?\n        if (tagName && tagName.indexOf('-') > -1) {\n            message += `\\n2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' ` +\n                `to the ${schemas} of this component to suppress this message.`;\n            message += `\\n3. To allow any property add 'NO_ERRORS_SCHEMA' to ` +\n                `the ${schemas} of this component.`;\n        }\n        else {\n            // If it's expected, the error can be suppressed by the `NO_ERRORS_SCHEMA` schema.\n            message += `\\n2. To allow any property add 'NO_ERRORS_SCHEMA' to ` +\n                `the ${schemas} of this component.`;\n        }\n    }\n    if (shouldThrowErrorOnUnknownProperty) {\n        throw new RuntimeError(303 /* RuntimeErrorCode.UNKNOWN_BINDING */, message);\n    }\n    else {\n        console.error(formatRuntimeError(303 /* RuntimeErrorCode.UNKNOWN_BINDING */, message));\n    }\n}\n/**\n * WARNING: this is a **dev-mode only** function (thus should always be guarded by the `ngDevMode`)\n * and must **not** be used in production bundles. The function makes megamorphic reads, which might\n * be too slow for production mode and also it relies on the constructor function being available.\n *\n * Gets a reference to the host component def (where a current component is declared).\n *\n * @param lView An `LView` that represents a current component that is being rendered.\n */\nfunction getDeclarationComponentDef(lView) {\n    !ngDevMode && throwError('Must never be called in production mode');\n    const declarationLView = lView[DECLARATION_COMPONENT_VIEW];\n    const context = declarationLView[CONTEXT];\n    // Unable to obtain a context.\n    if (!context)\n        return null;\n    return context.constructor ? getComponentDef$1(context.constructor) : null;\n}\n/**\n * WARNING: this is a **dev-mode only** function (thus should always be guarded by the `ngDevMode`)\n * and must **not** be used in production bundles. The function makes megamorphic reads, which might\n * be too slow for production mode.\n *\n * Checks if the current component is declared inside of a standalone component template.\n *\n * @param lView An `LView` that represents a current component that is being rendered.\n */\nfunction isHostComponentStandalone(lView) {\n    !ngDevMode && throwError('Must never be called in production mode');\n    const componentDef = getDeclarationComponentDef(lView);\n    // Treat host component as non-standalone if we can't obtain the def.\n    return !!(componentDef === null || componentDef === void 0 ? void 0 : componentDef.standalone);\n}\n/**\n * WARNING: this is a **dev-mode only** function (thus should always be guarded by the `ngDevMode`)\n * and must **not** be used in production bundles. The function makes megamorphic reads, which might\n * be too slow for production mode.\n *\n * Constructs a string describing the location of the host component template. The function is used\n * in dev mode to produce error messages.\n *\n * @param lView An `LView` that represents a current component that is being rendered.\n */\nfunction getTemplateLocationDetails(lView) {\n    var _a;\n    !ngDevMode && throwError('Must never be called in production mode');\n    const hostComponentDef = getDeclarationComponentDef(lView);\n    const componentClassName = (_a = hostComponentDef === null || hostComponentDef === void 0 ? void 0 : hostComponentDef.type) === null || _a === void 0 ? void 0 : _a.name;\n    return componentClassName ? ` (used in the '${componentClassName}' component template)` : '';\n}\n/**\n * The set of known control flow directives.\n * We use this set to produce a more precises error message with a note\n * that the `CommonModule` should also be included.\n */\nconst KNOWN_CONTROL_FLOW_DIRECTIVES = new Set(['ngIf', 'ngFor', 'ngSwitch', 'ngSwitchCase', 'ngSwitchDefault']);\n/**\n * Returns true if the tag name is allowed by specified schemas.\n * @param schemas Array of schemas\n * @param tagName Name of the tag\n */\nfunction matchingSchemas(schemas, tagName) {\n    if (schemas !== null) {\n        for (let i = 0; i < schemas.length; i++) {\n            const schema = schemas[i];\n            if (schema === NO_ERRORS_SCHEMA ||\n                schema === CUSTOM_ELEMENTS_SCHEMA && tagName && tagName.indexOf('-') > -1) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * THIS FILE CONTAINS CODE WHICH SHOULD BE TREE SHAKEN AND NEVER CALLED FROM PRODUCTION CODE!!!\n */\n/**\n * Creates an `Array` construction with a given name. This is useful when\n * looking for memory consumption to see what time of array it is.\n *\n *\n * @param name Name to give to the constructor\n * @returns A subclass of `Array` if possible. This can only be done in\n *          environments which support `class` construct.\n */\nfunction createNamedArrayType(name) {\n    // This should never be called in prod mode, so let's verify that is the case.\n    if (ngDevMode) {\n        try {\n            // If this function were compromised the following could lead to arbitrary\n            // script execution. We bless it with Trusted Types anyway since this\n            // function is stripped out of production binaries.\n            return (newTrustedFunctionForDev('Array', `return class ${name} extends Array{}`))(Array);\n        }\n        catch (e) {\n            // If it does not work just give up and fall back to regular Array.\n            return Array;\n        }\n    }\n    else {\n        throw new Error('Looks like we are in \\'prod mode\\', but we are creating a named Array type, which is wrong! Check your code');\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction toTStylingRange(prev, next) {\n    ngDevMode && assertNumberInRange(prev, 0, 32767 /* StylingRange.UNSIGNED_MASK */);\n    ngDevMode && assertNumberInRange(next, 0, 32767 /* StylingRange.UNSIGNED_MASK */);\n    return (prev << 17 /* StylingRange.PREV_SHIFT */ | next << 2 /* StylingRange.NEXT_SHIFT */);\n}\nfunction getTStylingRangePrev(tStylingRange) {\n    ngDevMode && assertNumber(tStylingRange, 'expected number');\n    return (tStylingRange >> 17 /* StylingRange.PREV_SHIFT */) & 32767 /* StylingRange.UNSIGNED_MASK */;\n}\nfunction getTStylingRangePrevDuplicate(tStylingRange) {\n    ngDevMode && assertNumber(tStylingRange, 'expected number');\n    return (tStylingRange & 2 /* StylingRange.PREV_DUPLICATE */) ==\n        2 /* StylingRange.PREV_DUPLICATE */;\n}\nfunction setTStylingRangePrev(tStylingRange, previous) {\n    ngDevMode && assertNumber(tStylingRange, 'expected number');\n    ngDevMode && assertNumberInRange(previous, 0, 32767 /* StylingRange.UNSIGNED_MASK */);\n    return ((tStylingRange & ~4294836224 /* StylingRange.PREV_MASK */) |\n        (previous << 17 /* StylingRange.PREV_SHIFT */));\n}\nfunction setTStylingRangePrevDuplicate(tStylingRange) {\n    ngDevMode && assertNumber(tStylingRange, 'expected number');\n    return (tStylingRange | 2 /* StylingRange.PREV_DUPLICATE */);\n}\nfunction getTStylingRangeNext(tStylingRange) {\n    ngDevMode && assertNumber(tStylingRange, 'expected number');\n    return (tStylingRange & 131068 /* StylingRange.NEXT_MASK */) >> 2 /* StylingRange.NEXT_SHIFT */;\n}\nfunction setTStylingRangeNext(tStylingRange, next) {\n    ngDevMode && assertNumber(tStylingRange, 'expected number');\n    ngDevMode && assertNumberInRange(next, 0, 32767 /* StylingRange.UNSIGNED_MASK */);\n    return ((tStylingRange & ~131068 /* StylingRange.NEXT_MASK */) | //\n        next << 2 /* StylingRange.NEXT_SHIFT */);\n}\nfunction getTStylingRangeNextDuplicate(tStylingRange) {\n    ngDevMode && assertNumber(tStylingRange, 'expected number');\n    return (tStylingRange & 1 /* StylingRange.NEXT_DUPLICATE */) ===\n        1 /* StylingRange.NEXT_DUPLICATE */;\n}\nfunction setTStylingRangeNextDuplicate(tStylingRange) {\n    ngDevMode && assertNumber(tStylingRange, 'expected number');\n    return (tStylingRange | 1 /* StylingRange.NEXT_DUPLICATE */);\n}\nfunction getTStylingRangeTail(tStylingRange) {\n    ngDevMode && assertNumber(tStylingRange, 'expected number');\n    const next = getTStylingRangeNext(tStylingRange);\n    return next === 0 ? getTStylingRangePrev(tStylingRange) : next;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Patch a `debug` property on top of the existing object.\n *\n * NOTE: always call this method with `ngDevMode && attachDebugObject(...)`\n *\n * @param obj Object to patch\n * @param debug Value to patch\n */\nfunction attachDebugObject(obj, debug) {\n    if (ngDevMode) {\n        Object.defineProperty(obj, 'debug', { value: debug, enumerable: false });\n    }\n    else {\n        throw new Error('This method should be guarded with `ngDevMode` so that it can be tree shaken in production!');\n    }\n}\n/**\n * Patch a `debug` property getter on top of the existing object.\n *\n * NOTE: always call this method with `ngDevMode && attachDebugObject(...)`\n *\n * @param obj Object to patch\n * @param debugGetter Getter returning a value to patch\n */\nfunction attachDebugGetter(obj, debugGetter) {\n    if (ngDevMode) {\n        Object.defineProperty(obj, 'debug', { get: debugGetter, enumerable: false });\n    }\n    else {\n        throw new Error('This method should be guarded with `ngDevMode` so that it can be tree shaken in production!');\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/*\n * This file contains conditionally attached classes which provide human readable (debug) level\n * information for `LView`, `LContainer` and other internal data structures. These data structures\n * are stored internally as array which makes it very difficult during debugging to reason about the\n * current state of the system.\n *\n * Patching the array with extra property does change the array's hidden class' but it does not\n * change the cost of access, therefore this patching should not have significant if any impact in\n * `ngDevMode` mode. (see: https://jsperf.com/array-vs-monkey-patch-array)\n *\n * So instead of seeing:\n * ```\n * Array(30) [Object, 659, null, …]\n * ```\n *\n * You get to see:\n * ```\n * LViewDebug {\n *   views: [...],\n *   flags: {attached: true, ...}\n *   nodes: [\n *     {html: '<div id=\"123\">', ..., nodes: [\n *       {html: '<span>', ..., nodes: null}\n *     ]}\n *   ]\n * }\n * ```\n */\nlet LVIEW_COMPONENT_CACHE;\nlet LVIEW_EMBEDDED_CACHE;\nlet LVIEW_ROOT;\nlet LVIEW_COMPONENT;\nlet LVIEW_EMBEDDED;\n/**\n * This function clones a blueprint and creates LView.\n *\n * Simple slice will keep the same type, and we need it to be LView\n */\nfunction cloneToLViewFromTViewBlueprint(tView) {\n    const debugTView = tView;\n    const lView = getLViewToClone(debugTView.type, tView.template && tView.template.name);\n    return lView.concat(tView.blueprint);\n}\nclass LRootView extends Array {\n}\nclass LComponentView extends Array {\n}\nclass LEmbeddedView extends Array {\n}\nfunction getLViewToClone(type, name) {\n    switch (type) {\n        case 0 /* TViewType.Root */:\n            if (LVIEW_ROOT === undefined)\n                LVIEW_ROOT = new LRootView();\n            return LVIEW_ROOT;\n        case 1 /* TViewType.Component */:\n            if (!ngDevMode || !ngDevMode.namedConstructors) {\n                if (LVIEW_COMPONENT === undefined)\n                    LVIEW_COMPONENT = new LComponentView();\n                return LVIEW_COMPONENT;\n            }\n            if (LVIEW_COMPONENT_CACHE === undefined)\n                LVIEW_COMPONENT_CACHE = new Map();\n            let componentArray = LVIEW_COMPONENT_CACHE.get(name);\n            if (componentArray === undefined) {\n                componentArray = new (createNamedArrayType('LComponentView' + nameSuffix(name)))();\n                LVIEW_COMPONENT_CACHE.set(name, componentArray);\n            }\n            return componentArray;\n        case 2 /* TViewType.Embedded */:\n            if (!ngDevMode || !ngDevMode.namedConstructors) {\n                if (LVIEW_EMBEDDED === undefined)\n                    LVIEW_EMBEDDED = new LEmbeddedView();\n                return LVIEW_EMBEDDED;\n            }\n            if (LVIEW_EMBEDDED_CACHE === undefined)\n                LVIEW_EMBEDDED_CACHE = new Map();\n            let embeddedArray = LVIEW_EMBEDDED_CACHE.get(name);\n            if (embeddedArray === undefined) {\n                embeddedArray = new (createNamedArrayType('LEmbeddedView' + nameSuffix(name)))();\n                LVIEW_EMBEDDED_CACHE.set(name, embeddedArray);\n            }\n            return embeddedArray;\n    }\n}\nfunction nameSuffix(text) {\n    if (text == null)\n        return '';\n    const index = text.lastIndexOf('_Template');\n    return '_' + (index === -1 ? text : text.slice(0, index));\n}\n/**\n * This class is a debug version of Object literal so that we can have constructor name show up\n * in\n * debug tools in ngDevMode.\n */\nconst TViewConstructor = class TView {\n    constructor(type, blueprint, template, queries, viewQuery, declTNode, data, bindingStartIndex, expandoStartIndex, hostBindingOpCodes, firstCreatePass, firstUpdatePass, staticViewQueries, staticContentQueries, preOrderHooks, preOrderCheckHooks, contentHooks, contentCheckHooks, viewHooks, viewCheckHooks, destroyHooks, cleanup, contentQueries, components, directiveRegistry, pipeRegistry, firstChild, schemas, consts, incompleteFirstPass, _decls, _vars) {\n        this.type = type;\n        this.blueprint = blueprint;\n        this.template = template;\n        this.queries = queries;\n        this.viewQuery = viewQuery;\n        this.declTNode = declTNode;\n        this.data = data;\n        this.bindingStartIndex = bindingStartIndex;\n        this.expandoStartIndex = expandoStartIndex;\n        this.hostBindingOpCodes = hostBindingOpCodes;\n        this.firstCreatePass = firstCreatePass;\n        this.firstUpdatePass = firstUpdatePass;\n        this.staticViewQueries = staticViewQueries;\n        this.staticContentQueries = staticContentQueries;\n        this.preOrderHooks = preOrderHooks;\n        this.preOrderCheckHooks = preOrderCheckHooks;\n        this.contentHooks = contentHooks;\n        this.contentCheckHooks = contentCheckHooks;\n        this.viewHooks = viewHooks;\n        this.viewCheckHooks = viewCheckHooks;\n        this.destroyHooks = destroyHooks;\n        this.cleanup = cleanup;\n        this.contentQueries = contentQueries;\n        this.components = components;\n        this.directiveRegistry = directiveRegistry;\n        this.pipeRegistry = pipeRegistry;\n        this.firstChild = firstChild;\n        this.schemas = schemas;\n        this.consts = consts;\n        this.incompleteFirstPass = incompleteFirstPass;\n        this._decls = _decls;\n        this._vars = _vars;\n    }\n    get template_() {\n        const buf = [];\n        processTNodeChildren(this.firstChild, buf);\n        return buf.join('');\n    }\n    get type_() {\n        return TViewTypeAsString[this.type] || `TViewType.?${this.type}?`;\n    }\n};\nclass TNode {\n    constructor(tView_, //\n    type, //\n    index, //\n    insertBeforeIndex, //\n    injectorIndex, //\n    directiveStart, //\n    directiveEnd, //\n    directiveStylingLast, //\n    propertyBindings, //\n    flags, //\n    providerIndexes, //\n    value, //\n    attrs, //\n    mergedAttrs, //\n    localNames, //\n    initialInputs, //\n    inputs, //\n    outputs, //\n    tViews, //\n    next, //\n    projectionNext, //\n    child, //\n    parent, //\n    projection, //\n    styles, //\n    stylesWithoutHost, //\n    residualStyles, //\n    classes, //\n    classesWithoutHost, //\n    residualClasses, //\n    classBindings, //\n    styleBindings) {\n        this.tView_ = tView_;\n        this.type = type;\n        this.index = index;\n        this.insertBeforeIndex = insertBeforeIndex;\n        this.injectorIndex = injectorIndex;\n        this.directiveStart = directiveStart;\n        this.directiveEnd = directiveEnd;\n        this.directiveStylingLast = directiveStylingLast;\n        this.propertyBindings = propertyBindings;\n        this.flags = flags;\n        this.providerIndexes = providerIndexes;\n        this.value = value;\n        this.attrs = attrs;\n        this.mergedAttrs = mergedAttrs;\n        this.localNames = localNames;\n        this.initialInputs = initialInputs;\n        this.inputs = inputs;\n        this.outputs = outputs;\n        this.tViews = tViews;\n        this.next = next;\n        this.projectionNext = projectionNext;\n        this.child = child;\n        this.parent = parent;\n        this.projection = projection;\n        this.styles = styles;\n        this.stylesWithoutHost = stylesWithoutHost;\n        this.residualStyles = residualStyles;\n        this.classes = classes;\n        this.classesWithoutHost = classesWithoutHost;\n        this.residualClasses = residualClasses;\n        this.classBindings = classBindings;\n        this.styleBindings = styleBindings;\n    }\n    /**\n     * Return a human debug version of the set of `NodeInjector`s which will be consulted when\n     * resolving tokens from this `TNode`.\n     *\n     * When debugging applications, it is often difficult to determine which `NodeInjector`s will be\n     * consulted. This method shows a list of `DebugNode`s representing the `TNode`s which will be\n     * consulted in order when resolving a token starting at this `TNode`.\n     *\n     * The original data is stored in `LView` and `TView` with a lot of offset indexes, and so it is\n     * difficult to reason about.\n     *\n     * @param lView The `LView` instance for this `TNode`.\n     */\n    debugNodeInjectorPath(lView) {\n        const path = [];\n        let injectorIndex = getInjectorIndex(this, lView);\n        if (injectorIndex === -1) {\n            // Looks like the current `TNode` does not have `NodeInjector` associated with it => look for\n            // parent NodeInjector.\n            const parentLocation = getParentInjectorLocation(this, lView);\n            if (parentLocation !== NO_PARENT_INJECTOR) {\n                // We found a parent, so start searching from the parent location.\n                injectorIndex = getParentInjectorIndex(parentLocation);\n                lView = getParentInjectorView(parentLocation, lView);\n            }\n            else {\n                // No parents have been found, so there are no `NodeInjector`s to consult.\n            }\n        }\n        while (injectorIndex !== -1) {\n            ngDevMode && assertNodeInjector(lView, injectorIndex);\n            const tNode = lView[TVIEW].data[injectorIndex + 8 /* NodeInjectorOffset.TNODE */];\n            path.push(buildDebugNode(tNode, lView));\n            const parentLocation = lView[injectorIndex + 8 /* NodeInjectorOffset.PARENT */];\n            if (parentLocation === NO_PARENT_INJECTOR) {\n                injectorIndex = -1;\n            }\n            else {\n                injectorIndex = getParentInjectorIndex(parentLocation);\n                lView = getParentInjectorView(parentLocation, lView);\n            }\n        }\n        return path;\n    }\n    get type_() {\n        return toTNodeTypeAsString(this.type) || `TNodeType.?${this.type}?`;\n    }\n    get flags_() {\n        const flags = [];\n        if (this.flags & 16 /* TNodeFlags.hasClassInput */)\n            flags.push('TNodeFlags.hasClassInput');\n        if (this.flags & 8 /* TNodeFlags.hasContentQuery */)\n            flags.push('TNodeFlags.hasContentQuery');\n        if (this.flags & 32 /* TNodeFlags.hasStyleInput */)\n            flags.push('TNodeFlags.hasStyleInput');\n        if (this.flags & 128 /* TNodeFlags.hasHostBindings */)\n            flags.push('TNodeFlags.hasHostBindings');\n        if (this.flags & 2 /* TNodeFlags.isComponentHost */)\n            flags.push('TNodeFlags.isComponentHost');\n        if (this.flags & 1 /* TNodeFlags.isDirectiveHost */)\n            flags.push('TNodeFlags.isDirectiveHost');\n        if (this.flags & 64 /* TNodeFlags.isDetached */)\n            flags.push('TNodeFlags.isDetached');\n        if (this.flags & 4 /* TNodeFlags.isProjected */)\n            flags.push('TNodeFlags.isProjected');\n        return flags.join('|');\n    }\n    get template_() {\n        if (this.type & 1 /* TNodeType.Text */)\n            return this.value;\n        const buf = [];\n        const tagName = typeof this.value === 'string' && this.value || this.type_;\n        buf.push('<', tagName);\n        if (this.flags) {\n            buf.push(' ', this.flags_);\n        }\n        if (this.attrs) {\n            for (let i = 0; i < this.attrs.length;) {\n                const attrName = this.attrs[i++];\n                if (typeof attrName == 'number') {\n                    break;\n                }\n                const attrValue = this.attrs[i++];\n                buf.push(' ', attrName, '=\"', attrValue, '\"');\n            }\n        }\n        buf.push('>');\n        processTNodeChildren(this.child, buf);\n        buf.push('</', tagName, '>');\n        return buf.join('');\n    }\n    get styleBindings_() {\n        return toDebugStyleBinding(this, false);\n    }\n    get classBindings_() {\n        return toDebugStyleBinding(this, true);\n    }\n    get providerIndexStart_() {\n        return this.providerIndexes & 1048575 /* TNodeProviderIndexes.ProvidersStartIndexMask */;\n    }\n    get providerIndexEnd_() {\n        return this.providerIndexStart_ +\n            (this.providerIndexes >>> 20 /* TNodeProviderIndexes.CptViewProvidersCountShift */);\n    }\n}\nconst TNodeDebug = TNode;\nfunction toDebugStyleBinding(tNode, isClassBased) {\n    const tData = tNode.tView_.data;\n    const bindings = [];\n    const range = isClassBased ? tNode.classBindings : tNode.styleBindings;\n    const prev = getTStylingRangePrev(range);\n    const next = getTStylingRangeNext(range);\n    let isTemplate = next !== 0;\n    let cursor = isTemplate ? next : prev;\n    while (cursor !== 0) {\n        const itemKey = tData[cursor];\n        const itemRange = tData[cursor + 1];\n        bindings.unshift({\n            key: itemKey,\n            index: cursor,\n            isTemplate: isTemplate,\n            prevDuplicate: getTStylingRangePrevDuplicate(itemRange),\n            nextDuplicate: getTStylingRangeNextDuplicate(itemRange),\n            nextIndex: getTStylingRangeNext(itemRange),\n            prevIndex: getTStylingRangePrev(itemRange),\n        });\n        if (cursor === prev)\n            isTemplate = false;\n        cursor = getTStylingRangePrev(itemRange);\n    }\n    bindings.push((isClassBased ? tNode.residualClasses : tNode.residualStyles) || null);\n    return bindings;\n}\nfunction processTNodeChildren(tNode, buf) {\n    while (tNode) {\n        buf.push(tNode.template_);\n        tNode = tNode.next;\n    }\n}\nclass TViewData extends Array {\n}\nlet TVIEWDATA_EMPTY; // can't initialize here or it will not be tree shaken, because\n// `LView` constructor could have side-effects.\n/**\n * This function clones a blueprint and creates TData.\n *\n * Simple slice will keep the same type, and we need it to be TData\n */\nfunction cloneToTViewData(list) {\n    if (TVIEWDATA_EMPTY === undefined)\n        TVIEWDATA_EMPTY = new TViewData();\n    return TVIEWDATA_EMPTY.concat(list);\n}\nclass LViewBlueprint extends Array {\n}\nclass MatchesArray extends Array {\n}\nclass TViewComponents extends Array {\n}\nclass TNodeLocalNames extends Array {\n}\nclass TNodeInitialInputs extends Array {\n}\nclass LCleanup extends Array {\n}\nclass TCleanup extends Array {\n}\nfunction attachLViewDebug(lView) {\n    attachDebugObject(lView, new LViewDebug(lView));\n}\nfunction attachLContainerDebug(lContainer) {\n    attachDebugObject(lContainer, new LContainerDebug(lContainer));\n}\nfunction toDebug(obj) {\n    if (obj) {\n        const debug = obj.debug;\n        assertDefined(debug, 'Object does not have a debug representation.');\n        return debug;\n    }\n    else {\n        return obj;\n    }\n}\n/**\n * Use this method to unwrap a native element in `LView` and convert it into HTML for easier\n * reading.\n *\n * @param value possibly wrapped native DOM node.\n * @param includeChildren If `true` then the serialized HTML form will include child elements\n * (same\n * as `outerHTML`). If `false` then the serialized HTML form will only contain the element\n * itself\n * (will not serialize child elements).\n */\nfunction toHtml(value, includeChildren = false) {\n    const node = unwrapRNode(value);\n    if (node) {\n        switch (node.nodeType) {\n            case Node.TEXT_NODE:\n                return node.textContent;\n            case Node.COMMENT_NODE:\n                return `<!--${node.textContent}-->`;\n            case Node.ELEMENT_NODE:\n                const outerHTML = node.outerHTML;\n                if (includeChildren) {\n                    return outerHTML;\n                }\n                else {\n                    const innerHTML = '>' + node.innerHTML + '<';\n                    return (outerHTML.split(innerHTML)[0]) + '>';\n                }\n        }\n    }\n    return null;\n}\nclass LViewDebug {\n    constructor(_raw_lView) {\n        this._raw_lView = _raw_lView;\n    }\n    /**\n     * Flags associated with the `LView` unpacked into a more readable state.\n     */\n    get flags() {\n        const flags = this._raw_lView[FLAGS];\n        return {\n            __raw__flags__: flags,\n            initPhaseState: flags & 3 /* LViewFlags.InitPhaseStateMask */,\n            creationMode: !!(flags & 4 /* LViewFlags.CreationMode */),\n            firstViewPass: !!(flags & 8 /* LViewFlags.FirstLViewPass */),\n            checkAlways: !!(flags & 16 /* LViewFlags.CheckAlways */),\n            dirty: !!(flags & 32 /* LViewFlags.Dirty */),\n            attached: !!(flags & 64 /* LViewFlags.Attached */),\n            destroyed: !!(flags & 128 /* LViewFlags.Destroyed */),\n            isRoot: !!(flags & 256 /* LViewFlags.IsRoot */),\n            indexWithinInitPhase: flags >> 11 /* LViewFlags.IndexWithinInitPhaseShift */,\n        };\n    }\n    get parent() {\n        return toDebug(this._raw_lView[PARENT]);\n    }\n    get hostHTML() {\n        return toHtml(this._raw_lView[HOST], true);\n    }\n    get html() {\n        return (this.nodes || []).map(mapToHTML).join('');\n    }\n    get context() {\n        return this._raw_lView[CONTEXT];\n    }\n    /**\n     * The tree of nodes associated with the current `LView`. The nodes have been normalized into\n     * a tree structure with relevant details pulled out for readability.\n     */\n    get nodes() {\n        const lView = this._raw_lView;\n        const tNode = lView[TVIEW].firstChild;\n        return toDebugNodes(tNode, lView);\n    }\n    get template() {\n        return this.tView.template_;\n    }\n    get tView() {\n        return this._raw_lView[TVIEW];\n    }\n    get cleanup() {\n        return this._raw_lView[CLEANUP];\n    }\n    get injector() {\n        return this._raw_lView[INJECTOR$1];\n    }\n    get rendererFactory() {\n        return this._raw_lView[RENDERER_FACTORY];\n    }\n    get renderer() {\n        return this._raw_lView[RENDERER];\n    }\n    get sanitizer() {\n        return this._raw_lView[SANITIZER];\n    }\n    get childHead() {\n        return toDebug(this._raw_lView[CHILD_HEAD]);\n    }\n    get next() {\n        return toDebug(this._raw_lView[NEXT]);\n    }\n    get childTail() {\n        return toDebug(this._raw_lView[CHILD_TAIL]);\n    }\n    get declarationView() {\n        return toDebug(this._raw_lView[DECLARATION_VIEW]);\n    }\n    get queries() {\n        return this._raw_lView[QUERIES];\n    }\n    get tHost() {\n        return this._raw_lView[T_HOST];\n    }\n    get id() {\n        return this._raw_lView[ID];\n    }\n    get decls() {\n        return toLViewRange(this.tView, this._raw_lView, HEADER_OFFSET, this.tView.bindingStartIndex);\n    }\n    get vars() {\n        return toLViewRange(this.tView, this._raw_lView, this.tView.bindingStartIndex, this.tView.expandoStartIndex);\n    }\n    get expando() {\n        return toLViewRange(this.tView, this._raw_lView, this.tView.expandoStartIndex, this._raw_lView.length);\n    }\n    /**\n     * Normalized view of child views (and containers) attached at this location.\n     */\n    get childViews() {\n        const childViews = [];\n        let child = this.childHead;\n        while (child) {\n            childViews.push(child);\n            child = child.next;\n        }\n        return childViews;\n    }\n}\nfunction mapToHTML(node) {\n    if (node.type === 'ElementContainer') {\n        return (node.children || []).map(mapToHTML).join('');\n    }\n    else if (node.type === 'IcuContainer') {\n        throw new Error('Not implemented');\n    }\n    else {\n        return toHtml(node.native, true) || '';\n    }\n}\nfunction toLViewRange(tView, lView, start, end) {\n    let content = [];\n    for (let index = start; index < end; index++) {\n        content.push({ index: index, t: tView.data[index], l: lView[index] });\n    }\n    return { start: start, end: end, length: end - start, content: content };\n}\n/**\n * Turns a flat list of nodes into a tree by walking the associated `TNode` tree.\n *\n * @param tNode\n * @param lView\n */\nfunction toDebugNodes(tNode, lView) {\n    if (tNode) {\n        const debugNodes = [];\n        let tNodeCursor = tNode;\n        while (tNodeCursor) {\n            debugNodes.push(buildDebugNode(tNodeCursor, lView));\n            tNodeCursor = tNodeCursor.next;\n        }\n        return debugNodes;\n    }\n    else {\n        return [];\n    }\n}\nfunction buildDebugNode(tNode, lView) {\n    const rawValue = lView[tNode.index];\n    const native = unwrapRNode(rawValue);\n    const factories = [];\n    const instances = [];\n    const tView = lView[TVIEW];\n    for (let i = tNode.directiveStart; i < tNode.directiveEnd; i++) {\n        const def = tView.data[i];\n        factories.push(def.type);\n        instances.push(lView[i]);\n    }\n    return {\n        html: toHtml(native),\n        type: toTNodeTypeAsString(tNode.type),\n        tNode,\n        native: native,\n        children: toDebugNodes(tNode.child, lView),\n        factories,\n        instances,\n        injector: buildNodeInjectorDebug(tNode, tView, lView),\n        get injectorResolutionPath() {\n            return tNode.debugNodeInjectorPath(lView);\n        },\n    };\n}\nfunction buildNodeInjectorDebug(tNode, tView, lView) {\n    const viewProviders = [];\n    for (let i = tNode.providerIndexStart_; i < tNode.providerIndexEnd_; i++) {\n        viewProviders.push(tView.data[i]);\n    }\n    const providers = [];\n    for (let i = tNode.providerIndexEnd_; i < tNode.directiveEnd; i++) {\n        providers.push(tView.data[i]);\n    }\n    const nodeInjectorDebug = {\n        bloom: toBloom(lView, tNode.injectorIndex),\n        cumulativeBloom: toBloom(tView.data, tNode.injectorIndex),\n        providers,\n        viewProviders,\n        parentInjectorIndex: lView[tNode.providerIndexStart_ - 1],\n    };\n    return nodeInjectorDebug;\n}\n/**\n * Convert a number at `idx` location in `array` into binary representation.\n *\n * @param array\n * @param idx\n */\nfunction binary(array, idx) {\n    const value = array[idx];\n    // If not a number we print 8 `?` to retain alignment but let user know that it was called on\n    // wrong type.\n    if (typeof value !== 'number')\n        return '????????';\n    // We prefix 0s so that we have constant length number\n    const text = '00000000' + value.toString(2);\n    return text.substring(text.length - 8);\n}\n/**\n * Convert a bloom filter at location `idx` in `array` into binary representation.\n *\n * @param array\n * @param idx\n */\nfunction toBloom(array, idx) {\n    if (idx < 0) {\n        return 'NO_NODE_INJECTOR';\n    }\n    return `${binary(array, idx + 7)}_${binary(array, idx + 6)}_${binary(array, idx + 5)}_${binary(array, idx + 4)}_${binary(array, idx + 3)}_${binary(array, idx + 2)}_${binary(array, idx + 1)}_${binary(array, idx + 0)}`;\n}\nclass LContainerDebug {\n    constructor(_raw_lContainer) {\n        this._raw_lContainer = _raw_lContainer;\n    }\n    get hasTransplantedViews() {\n        return this._raw_lContainer[HAS_TRANSPLANTED_VIEWS];\n    }\n    get views() {\n        return this._raw_lContainer.slice(CONTAINER_HEADER_OFFSET)\n            .map(toDebug);\n    }\n    get parent() {\n        return toDebug(this._raw_lContainer[PARENT]);\n    }\n    get movedViews() {\n        return this._raw_lContainer[MOVED_VIEWS];\n    }\n    get host() {\n        return this._raw_lContainer[HOST];\n    }\n    get native() {\n        return this._raw_lContainer[NATIVE];\n    }\n    get next() {\n        return toDebug(this._raw_lContainer[NEXT]);\n    }\n}\n\n/**\n * A permanent marker promise which signifies that the current CD tree is\n * clean.\n */\nconst _CLEAN_PROMISE = (() => Promise.resolve(null))();\n/**\n * Invoke `HostBindingsFunction`s for view.\n *\n * This methods executes `TView.hostBindingOpCodes`. It is used to execute the\n * `HostBindingsFunction`s associated with the current `LView`.\n *\n * @param tView Current `TView`.\n * @param lView Current `LView`.\n */\nfunction processHostBindingOpCodes(tView, lView) {\n    const hostBindingOpCodes = tView.hostBindingOpCodes;\n    if (hostBindingOpCodes === null)\n        return;\n    try {\n        for (let i = 0; i < hostBindingOpCodes.length; i++) {\n            const opCode = hostBindingOpCodes[i];\n            if (opCode < 0) {\n                // Negative numbers are element indexes.\n                setSelectedIndex(~opCode);\n            }\n            else {\n                // Positive numbers are NumberTuple which store bindingRootIndex and directiveIndex.\n                const directiveIdx = opCode;\n                const bindingRootIndx = hostBindingOpCodes[++i];\n                const hostBindingFn = hostBindingOpCodes[++i];\n                setBindingRootForHostBindings(bindingRootIndx, directiveIdx);\n                const context = lView[directiveIdx];\n                hostBindingFn(2 /* RenderFlags.Update */, context);\n            }\n        }\n    }\n    finally {\n        setSelectedIndex(-1);\n    }\n}\n/** Refreshes all content queries declared by directives in a given view */\nfunction refreshContentQueries(tView, lView) {\n    const contentQueries = tView.contentQueries;\n    if (contentQueries !== null) {\n        for (let i = 0; i < contentQueries.length; i += 2) {\n            const queryStartIdx = contentQueries[i];\n            const directiveDefIdx = contentQueries[i + 1];\n            if (directiveDefIdx !== -1) {\n                const directiveDef = tView.data[directiveDefIdx];\n                ngDevMode && assertDefined(directiveDef, 'DirectiveDef not found.');\n                ngDevMode &&\n                    assertDefined(directiveDef.contentQueries, 'contentQueries function should be defined');\n                setCurrentQueryIndex(queryStartIdx);\n                directiveDef.contentQueries(2 /* RenderFlags.Update */, lView[directiveDefIdx], directiveDefIdx);\n            }\n        }\n    }\n}\n/** Refreshes child components in the current view (update mode). */\nfunction refreshChildComponents(hostLView, components) {\n    for (let i = 0; i < components.length; i++) {\n        refreshComponent(hostLView, components[i]);\n    }\n}\n/** Renders child components in the current view (creation mode). */\nfunction renderChildComponents(hostLView, components) {\n    for (let i = 0; i < components.length; i++) {\n        renderComponent$1(hostLView, components[i]);\n    }\n}\nfunction createLView(parentLView, tView, context, flags, host, tHostNode, rendererFactory, renderer, sanitizer, injector, embeddedViewInjector) {\n    const lView = ngDevMode ? cloneToLViewFromTViewBlueprint(tView) : tView.blueprint.slice();\n    lView[HOST] = host;\n    lView[FLAGS] = flags | 4 /* LViewFlags.CreationMode */ | 64 /* LViewFlags.Attached */ | 8 /* LViewFlags.FirstLViewPass */;\n    if (embeddedViewInjector !== null ||\n        (parentLView && (parentLView[FLAGS] & 1024 /* LViewFlags.HasEmbeddedViewInjector */))) {\n        lView[FLAGS] |= 1024 /* LViewFlags.HasEmbeddedViewInjector */;\n    }\n    resetPreOrderHookFlags(lView);\n    ngDevMode && tView.declTNode && parentLView && assertTNodeForLView(tView.declTNode, parentLView);\n    lView[PARENT] = lView[DECLARATION_VIEW] = parentLView;\n    lView[CONTEXT] = context;\n    lView[RENDERER_FACTORY] = (rendererFactory || parentLView && parentLView[RENDERER_FACTORY]);\n    ngDevMode && assertDefined(lView[RENDERER_FACTORY], 'RendererFactory is required');\n    lView[RENDERER] = (renderer || parentLView && parentLView[RENDERER]);\n    ngDevMode && assertDefined(lView[RENDERER], 'Renderer is required');\n    lView[SANITIZER] = sanitizer || parentLView && parentLView[SANITIZER] || null;\n    lView[INJECTOR$1] = injector || parentLView && parentLView[INJECTOR$1] || null;\n    lView[T_HOST] = tHostNode;\n    lView[ID] = getUniqueLViewId();\n    lView[EMBEDDED_VIEW_INJECTOR] = embeddedViewInjector;\n    ngDevMode &&\n        assertEqual(tView.type == 2 /* TViewType.Embedded */ ? parentLView !== null : true, true, 'Embedded views must have parentLView');\n    lView[DECLARATION_COMPONENT_VIEW] =\n        tView.type == 2 /* TViewType.Embedded */ ? parentLView[DECLARATION_COMPONENT_VIEW] : lView;\n    ngDevMode && attachLViewDebug(lView);\n    return lView;\n}\nfunction getOrCreateTNode(tView, index, type, name, attrs) {\n    ngDevMode && index !== 0 && // 0 are bogus nodes and they are OK. See `createContainerRef` in\n        // `view_engine_compatibility` for additional context.\n        assertGreaterThanOrEqual(index, HEADER_OFFSET, 'TNodes can\\'t be in the LView header.');\n    // Keep this function short, so that the VM will inline it.\n    ngDevMode && assertPureTNodeType(type);\n    let tNode = tView.data[index];\n    if (tNode === null) {\n        tNode = createTNodeAtIndex(tView, index, type, name, attrs);\n        if (isInI18nBlock()) {\n            // If we are in i18n block then all elements should be pre declared through `Placeholder`\n            // See `TNodeType.Placeholder` and `LFrame.inI18n` for more context.\n            // If the `TNode` was not pre-declared than it means it was not mentioned which means it was\n            // removed, so we mark it as detached.\n            tNode.flags |= 64 /* TNodeFlags.isDetached */;\n        }\n    }\n    else if (tNode.type & 64 /* TNodeType.Placeholder */) {\n        tNode.type = type;\n        tNode.value = name;\n        tNode.attrs = attrs;\n        const parent = getCurrentParentTNode();\n        tNode.injectorIndex = parent === null ? -1 : parent.injectorIndex;\n        ngDevMode && assertTNodeForTView(tNode, tView);\n        ngDevMode && assertEqual(index, tNode.index, 'Expecting same index');\n    }\n    setCurrentTNode(tNode, true);\n    return tNode;\n}\nfunction createTNodeAtIndex(tView, index, type, name, attrs) {\n    const currentTNode = getCurrentTNodePlaceholderOk();\n    const isParent = isCurrentTNodeParent();\n    const parent = isParent ? currentTNode : currentTNode && currentTNode.parent;\n    // Parents cannot cross component boundaries because components will be used in multiple places.\n    const tNode = tView.data[index] =\n        createTNode(tView, parent, type, index, name, attrs);\n    // Assign a pointer to the first child node of a given view. The first node is not always the one\n    // at index 0, in case of i18n, index 0 can be the instruction `i18nStart` and the first node has\n    // the index 1 or more, so we can't just check node index.\n    if (tView.firstChild === null) {\n        tView.firstChild = tNode;\n    }\n    if (currentTNode !== null) {\n        if (isParent) {\n            // FIXME(misko): This logic looks unnecessarily complicated. Could we simplify?\n            if (currentTNode.child == null && tNode.parent !== null) {\n                // We are in the same view, which means we are adding content node to the parent view.\n                currentTNode.child = tNode;\n            }\n        }\n        else {\n            if (currentTNode.next === null) {\n                // In the case of i18n the `currentTNode` may already be linked, in which case we don't want\n                // to break the links which i18n created.\n                currentTNode.next = tNode;\n            }\n        }\n    }\n    return tNode;\n}\n/**\n * When elements are created dynamically after a view blueprint is created (e.g. through\n * i18nApply()), we need to adjust the blueprint for future\n * template passes.\n *\n * @param tView `TView` associated with `LView`\n * @param lView The `LView` containing the blueprint to adjust\n * @param numSlotsToAlloc The number of slots to alloc in the LView, should be >0\n * @param initialValue Initial value to store in blueprint\n */\nfunction allocExpando(tView, lView, numSlotsToAlloc, initialValue) {\n    if (numSlotsToAlloc === 0)\n        return -1;\n    if (ngDevMode) {\n        assertFirstCreatePass(tView);\n        assertSame(tView, lView[TVIEW], '`LView` must be associated with `TView`!');\n        assertEqual(tView.data.length, lView.length, 'Expecting LView to be same size as TView');\n        assertEqual(tView.data.length, tView.blueprint.length, 'Expecting Blueprint to be same size as TView');\n        assertFirstUpdatePass(tView);\n    }\n    const allocIdx = lView.length;\n    for (let i = 0; i < numSlotsToAlloc; i++) {\n        lView.push(initialValue);\n        tView.blueprint.push(initialValue);\n        tView.data.push(null);\n    }\n    return allocIdx;\n}\n//////////////////////////\n//// Render\n//////////////////////////\n/**\n * Processes a view in the creation mode. This includes a number of steps in a specific order:\n * - creating view query functions (if any);\n * - executing a template function in the creation mode;\n * - updating static queries (if any);\n * - creating child components defined in a given view.\n */\nfunction renderView(tView, lView, context) {\n    ngDevMode && assertEqual(isCreationMode(lView), true, 'Should be run in creation mode');\n    enterView(lView);\n    try {\n        const viewQuery = tView.viewQuery;\n        if (viewQuery !== null) {\n            executeViewQueryFn(1 /* RenderFlags.Create */, viewQuery, context);\n        }\n        // Execute a template associated with this view, if it exists. A template function might not be\n        // defined for the root component views.\n        const templateFn = tView.template;\n        if (templateFn !== null) {\n            executeTemplate(tView, lView, templateFn, 1 /* RenderFlags.Create */, context);\n        }\n        // This needs to be set before children are processed to support recursive components.\n        // This must be set to false immediately after the first creation run because in an\n        // ngFor loop, all the views will be created together before update mode runs and turns\n        // off firstCreatePass. If we don't set it here, instances will perform directive\n        // matching, etc again and again.\n        if (tView.firstCreatePass) {\n            tView.firstCreatePass = false;\n        }\n        // We resolve content queries specifically marked as `static` in creation mode. Dynamic\n        // content queries are resolved during change detection (i.e. update mode), after embedded\n        // views are refreshed (see block above).\n        if (tView.staticContentQueries) {\n            refreshContentQueries(tView, lView);\n        }\n        // We must materialize query results before child components are processed\n        // in case a child component has projected a container. The LContainer needs\n        // to exist so the embedded views are properly attached by the container.\n        if (tView.staticViewQueries) {\n            executeViewQueryFn(2 /* RenderFlags.Update */, tView.viewQuery, context);\n        }\n        // Render child component views.\n        const components = tView.components;\n        if (components !== null) {\n            renderChildComponents(lView, components);\n        }\n    }\n    catch (error) {\n        // If we didn't manage to get past the first template pass due to\n        // an error, mark the view as corrupted so we can try to recover.\n        if (tView.firstCreatePass) {\n            tView.incompleteFirstPass = true;\n            tView.firstCreatePass = false;\n        }\n        throw error;\n    }\n    finally {\n        lView[FLAGS] &= ~4 /* LViewFlags.CreationMode */;\n        leaveView();\n    }\n}\n/**\n * Processes a view in update mode. This includes a number of steps in a specific order:\n * - executing a template function in update mode;\n * - executing hooks;\n * - refreshing queries;\n * - setting host bindings;\n * - refreshing child (embedded and component) views.\n */\nfunction refreshView(tView, lView, templateFn, context) {\n    ngDevMode && assertEqual(isCreationMode(lView), false, 'Should be run in update mode');\n    const flags = lView[FLAGS];\n    if ((flags & 128 /* LViewFlags.Destroyed */) === 128 /* LViewFlags.Destroyed */)\n        return;\n    enterView(lView);\n    // Check no changes mode is a dev only mode used to verify that bindings have not changed\n    // since they were assigned. We do not want to execute lifecycle hooks in that mode.\n    const isInCheckNoChangesPass = ngDevMode && isInCheckNoChangesMode();\n    try {\n        resetPreOrderHookFlags(lView);\n        setBindingIndex(tView.bindingStartIndex);\n        if (templateFn !== null) {\n            executeTemplate(tView, lView, templateFn, 2 /* RenderFlags.Update */, context);\n        }\n        const hooksInitPhaseCompleted = (flags & 3 /* LViewFlags.InitPhaseStateMask */) === 3 /* InitPhaseState.InitPhaseCompleted */;\n        // execute pre-order hooks (OnInit, OnChanges, DoCheck)\n        // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n        if (!isInCheckNoChangesPass) {\n            if (hooksInitPhaseCompleted) {\n                const preOrderCheckHooks = tView.preOrderCheckHooks;\n                if (preOrderCheckHooks !== null) {\n                    executeCheckHooks(lView, preOrderCheckHooks, null);\n                }\n            }\n            else {\n                const preOrderHooks = tView.preOrderHooks;\n                if (preOrderHooks !== null) {\n                    executeInitAndCheckHooks(lView, preOrderHooks, 0 /* InitPhaseState.OnInitHooksToBeRun */, null);\n                }\n                incrementInitPhaseFlags(lView, 0 /* InitPhaseState.OnInitHooksToBeRun */);\n            }\n        }\n        // First mark transplanted views that are declared in this lView as needing a refresh at their\n        // insertion points. This is needed to avoid the situation where the template is defined in this\n        // `LView` but its declaration appears after the insertion component.\n        markTransplantedViewsForRefresh(lView);\n        refreshEmbeddedViews(lView);\n        // Content query results must be refreshed before content hooks are called.\n        if (tView.contentQueries !== null) {\n            refreshContentQueries(tView, lView);\n        }\n        // execute content hooks (AfterContentInit, AfterContentChecked)\n        // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n        if (!isInCheckNoChangesPass) {\n            if (hooksInitPhaseCompleted) {\n                const contentCheckHooks = tView.contentCheckHooks;\n                if (contentCheckHooks !== null) {\n                    executeCheckHooks(lView, contentCheckHooks);\n                }\n            }\n            else {\n                const contentHooks = tView.contentHooks;\n                if (contentHooks !== null) {\n                    executeInitAndCheckHooks(lView, contentHooks, 1 /* InitPhaseState.AfterContentInitHooksToBeRun */);\n                }\n                incrementInitPhaseFlags(lView, 1 /* InitPhaseState.AfterContentInitHooksToBeRun */);\n            }\n        }\n        processHostBindingOpCodes(tView, lView);\n        // Refresh child component views.\n        const components = tView.components;\n        if (components !== null) {\n            refreshChildComponents(lView, components);\n        }\n        // View queries must execute after refreshing child components because a template in this view\n        // could be inserted in a child component. If the view query executes before child component\n        // refresh, the template might not yet be inserted.\n        const viewQuery = tView.viewQuery;\n        if (viewQuery !== null) {\n            executeViewQueryFn(2 /* RenderFlags.Update */, viewQuery, context);\n        }\n        // execute view hooks (AfterViewInit, AfterViewChecked)\n        // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n        if (!isInCheckNoChangesPass) {\n            if (hooksInitPhaseCompleted) {\n                const viewCheckHooks = tView.viewCheckHooks;\n                if (viewCheckHooks !== null) {\n                    executeCheckHooks(lView, viewCheckHooks);\n                }\n            }\n            else {\n                const viewHooks = tView.viewHooks;\n                if (viewHooks !== null) {\n                    executeInitAndCheckHooks(lView, viewHooks, 2 /* InitPhaseState.AfterViewInitHooksToBeRun */);\n                }\n                incrementInitPhaseFlags(lView, 2 /* InitPhaseState.AfterViewInitHooksToBeRun */);\n            }\n        }\n        if (tView.firstUpdatePass === true) {\n            // We need to make sure that we only flip the flag on successful `refreshView` only\n            // Don't do this in `finally` block.\n            // If we did this in `finally` block then an exception could block the execution of styling\n            // instructions which in turn would be unable to insert themselves into the styling linked\n            // list. The result of this would be that if the exception would not be throw on subsequent CD\n            // the styling would be unable to process it data and reflect to the DOM.\n            tView.firstUpdatePass = false;\n        }\n        // Do not reset the dirty state when running in check no changes mode. We don't want components\n        // to behave differently depending on whether check no changes is enabled or not. For example:\n        // Marking an OnPush component as dirty from within the `ngAfterViewInit` hook in order to\n        // refresh a `NgClass` binding should work. If we would reset the dirty state in the check\n        // no changes cycle, the component would be not be dirty for the next update pass. This would\n        // be different in production mode where the component dirty state is not reset.\n        if (!isInCheckNoChangesPass) {\n            lView[FLAGS] &= ~(32 /* LViewFlags.Dirty */ | 8 /* LViewFlags.FirstLViewPass */);\n        }\n        if (lView[FLAGS] & 512 /* LViewFlags.RefreshTransplantedView */) {\n            lView[FLAGS] &= ~512 /* LViewFlags.RefreshTransplantedView */;\n            updateTransplantedViewCount(lView[PARENT], -1);\n        }\n    }\n    finally {\n        leaveView();\n    }\n}\nfunction renderComponentOrTemplate(tView, lView, templateFn, context) {\n    const rendererFactory = lView[RENDERER_FACTORY];\n    // Check no changes mode is a dev only mode used to verify that bindings have not changed\n    // since they were assigned. We do not want to invoke renderer factory functions in that mode\n    // to avoid any possible side-effects.\n    const checkNoChangesMode = !!ngDevMode && isInCheckNoChangesMode();\n    const creationModeIsActive = isCreationMode(lView);\n    try {\n        if (!checkNoChangesMode && !creationModeIsActive && rendererFactory.begin) {\n            rendererFactory.begin();\n        }\n        if (creationModeIsActive) {\n            renderView(tView, lView, context);\n        }\n        refreshView(tView, lView, templateFn, context);\n    }\n    finally {\n        if (!checkNoChangesMode && !creationModeIsActive && rendererFactory.end) {\n            rendererFactory.end();\n        }\n    }\n}\nfunction executeTemplate(tView, lView, templateFn, rf, context) {\n    const prevSelectedIndex = getSelectedIndex();\n    const isUpdatePhase = rf & 2 /* RenderFlags.Update */;\n    try {\n        setSelectedIndex(-1);\n        if (isUpdatePhase && lView.length > HEADER_OFFSET) {\n            // When we're updating, inherently select 0 so we don't\n            // have to generate that instruction for most update blocks.\n            selectIndexInternal(tView, lView, HEADER_OFFSET, !!ngDevMode && isInCheckNoChangesMode());\n        }\n        const preHookType = isUpdatePhase ? 2 /* ProfilerEvent.TemplateUpdateStart */ : 0 /* ProfilerEvent.TemplateCreateStart */;\n        profiler(preHookType, context);\n        templateFn(rf, context);\n    }\n    finally {\n        setSelectedIndex(prevSelectedIndex);\n        const postHookType = isUpdatePhase ? 3 /* ProfilerEvent.TemplateUpdateEnd */ : 1 /* ProfilerEvent.TemplateCreateEnd */;\n        profiler(postHookType, context);\n    }\n}\n//////////////////////////\n//// Element\n//////////////////////////\nfunction executeContentQueries(tView, tNode, lView) {\n    if (isContentQueryHost(tNode)) {\n        const start = tNode.directiveStart;\n        const end = tNode.directiveEnd;\n        for (let directiveIndex = start; directiveIndex < end; directiveIndex++) {\n            const def = tView.data[directiveIndex];\n            if (def.contentQueries) {\n                def.contentQueries(1 /* RenderFlags.Create */, lView[directiveIndex], directiveIndex);\n            }\n        }\n    }\n}\n/**\n * Creates directive instances.\n */\nfunction createDirectivesInstances(tView, lView, tNode) {\n    if (!getBindingsEnabled())\n        return;\n    instantiateAllDirectives(tView, lView, tNode, getNativeByTNode(tNode, lView));\n    if ((tNode.flags & 128 /* TNodeFlags.hasHostBindings */) === 128 /* TNodeFlags.hasHostBindings */) {\n        invokeDirectivesHostBindings(tView, lView, tNode);\n    }\n}\n/**\n * Takes a list of local names and indices and pushes the resolved local variable values\n * to LView in the same order as they are loaded in the template with load().\n */\nfunction saveResolvedLocalsInData(viewData, tNode, localRefExtractor = getNativeByTNode) {\n    const localNames = tNode.localNames;\n    if (localNames !== null) {\n        let localIndex = tNode.index + 1;\n        for (let i = 0; i < localNames.length; i += 2) {\n            const index = localNames[i + 1];\n            const value = index === -1 ?\n                localRefExtractor(tNode, viewData) :\n                viewData[index];\n            viewData[localIndex++] = value;\n        }\n    }\n}\n/**\n * Gets TView from a template function or creates a new TView\n * if it doesn't already exist.\n *\n * @param def ComponentDef\n * @returns TView\n */\nfunction getOrCreateTComponentView(def) {\n    const tView = def.tView;\n    // Create a TView if there isn't one, or recreate it if the first create pass didn't\n    // complete successfully since we can't know for sure whether it's in a usable shape.\n    if (tView === null || tView.incompleteFirstPass) {\n        // Declaration node here is null since this function is called when we dynamically create a\n        // component and hence there is no declaration.\n        const declTNode = null;\n        return def.tView = createTView(1 /* TViewType.Component */, declTNode, def.template, def.decls, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery, def.schemas, def.consts);\n    }\n    return tView;\n}\n/**\n * Creates a TView instance\n *\n * @param type Type of `TView`.\n * @param declTNode Declaration location of this `TView`.\n * @param templateFn Template function\n * @param decls The number of nodes, local refs, and pipes in this template\n * @param directives Registry of directives for this view\n * @param pipes Registry of pipes for this view\n * @param viewQuery View queries for this view\n * @param schemas Schemas for this view\n * @param consts Constants for this view\n */\nfunction createTView(type, declTNode, templateFn, decls, vars, directives, pipes, viewQuery, schemas, constsOrFactory) {\n    ngDevMode && ngDevMode.tView++;\n    const bindingStartIndex = HEADER_OFFSET + decls;\n    // This length does not yet contain host bindings from child directives because at this point,\n    // we don't know which directives are active on this template. As soon as a directive is matched\n    // that has a host binding, we will update the blueprint with that def's hostVars count.\n    const initialViewLength = bindingStartIndex + vars;\n    const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);\n    const consts = typeof constsOrFactory === 'function' ? constsOrFactory() : constsOrFactory;\n    const tView = blueprint[TVIEW] = ngDevMode ?\n        new TViewConstructor(type, // type: TViewType,\n        blueprint, // blueprint: LView,\n        templateFn, // template: ComponentTemplate<{}>|null,\n        null, // queries: TQueries|null\n        viewQuery, // viewQuery: ViewQueriesFunction<{}>|null,\n        declTNode, // declTNode: TNode|null,\n        cloneToTViewData(blueprint).fill(null, bindingStartIndex), // data: TData,\n        bindingStartIndex, // bindingStartIndex: number,\n        initialViewLength, // expandoStartIndex: number,\n        null, // hostBindingOpCodes: HostBindingOpCodes,\n        true, // firstCreatePass: boolean,\n        true, // firstUpdatePass: boolean,\n        false, // staticViewQueries: boolean,\n        false, // staticContentQueries: boolean,\n        null, // preOrderHooks: HookData|null,\n        null, // preOrderCheckHooks: HookData|null,\n        null, // contentHooks: HookData|null,\n        null, // contentCheckHooks: HookData|null,\n        null, // viewHooks: HookData|null,\n        null, // viewCheckHooks: HookData|null,\n        null, // destroyHooks: DestroyHookData|null,\n        null, // cleanup: any[]|null,\n        null, // contentQueries: number[]|null,\n        null, // components: number[]|null,\n        typeof directives === 'function' ? //\n            directives() : //\n            directives, // directiveRegistry: DirectiveDefList|null,\n        typeof pipes === 'function' ? pipes() : pipes, // pipeRegistry: PipeDefList|null,\n        null, // firstChild: TNode|null,\n        schemas, // schemas: SchemaMetadata[]|null,\n        consts, // consts: TConstants|null\n        false, // incompleteFirstPass: boolean\n        decls, // ngDevMode only: decls\n        vars) :\n        {\n            type: type,\n            blueprint: blueprint,\n            template: templateFn,\n            queries: null,\n            viewQuery: viewQuery,\n            declTNode: declTNode,\n            data: blueprint.slice().fill(null, bindingStartIndex),\n            bindingStartIndex: bindingStartIndex,\n            expandoStartIndex: initialViewLength,\n            hostBindingOpCodes: null,\n            firstCreatePass: true,\n            firstUpdatePass: true,\n            staticViewQueries: false,\n            staticContentQueries: false,\n            preOrderHooks: null,\n            preOrderCheckHooks: null,\n            contentHooks: null,\n            contentCheckHooks: null,\n            viewHooks: null,\n            viewCheckHooks: null,\n            destroyHooks: null,\n            cleanup: null,\n            contentQueries: null,\n            components: null,\n            directiveRegistry: typeof directives === 'function' ? directives() : directives,\n            pipeRegistry: typeof pipes === 'function' ? pipes() : pipes,\n            firstChild: null,\n            schemas: schemas,\n            consts: consts,\n            incompleteFirstPass: false\n        };\n    if (ngDevMode) {\n        // For performance reasons it is important that the tView retains the same shape during runtime.\n        // (To make sure that all of the code is monomorphic.) For this reason we seal the object to\n        // prevent class transitions.\n        Object.seal(tView);\n    }\n    return tView;\n}\nfunction createViewBlueprint(bindingStartIndex, initialViewLength) {\n    const blueprint = ngDevMode ? new LViewBlueprint() : [];\n    for (let i = 0; i < initialViewLength; i++) {\n        blueprint.push(i < bindingStartIndex ? null : NO_CHANGE);\n    }\n    return blueprint;\n}\nfunction createError(text, token) {\n    return new Error(`Renderer: ${text} [${stringifyForError(token)}]`);\n}\nfunction assertHostNodeExists(rElement, elementOrSelector) {\n    if (!rElement) {\n        if (typeof elementOrSelector === 'string') {\n            throw createError('Host node with selector not found:', elementOrSelector);\n        }\n        else {\n            throw createError('Host node is required:', elementOrSelector);\n        }\n    }\n}\n/**\n * Locates the host native element, used for bootstrapping existing nodes into rendering pipeline.\n *\n * @param rendererFactory Factory function to create renderer instance.\n * @param elementOrSelector Render element or CSS selector to locate the element.\n * @param encapsulation View Encapsulation defined for component that requests host element.\n */\nfunction locateHostElement(renderer, elementOrSelector, encapsulation) {\n    if (isProceduralRenderer(renderer)) {\n        // When using native Shadow DOM, do not clear host element to allow native slot projection\n        const preserveContent = encapsulation === ViewEncapsulation.ShadowDom;\n        return renderer.selectRootElement(elementOrSelector, preserveContent);\n    }\n    let rElement = typeof elementOrSelector === 'string' ?\n        renderer.querySelector(elementOrSelector) :\n        elementOrSelector;\n    ngDevMode && assertHostNodeExists(rElement, elementOrSelector);\n    // Always clear host element's content when Renderer3 is in use. For procedural renderer case we\n    // make it depend on whether ShadowDom encapsulation is used (in which case the content should be\n    // preserved to allow native slot projection). ShadowDom encapsulation requires procedural\n    // renderer, and procedural renderer case is handled above.\n    rElement.textContent = '';\n    return rElement;\n}\n/**\n * Saves context for this cleanup function in LView.cleanupInstances.\n *\n * On the first template pass, saves in TView:\n * - Cleanup function\n * - Index of context we just saved in LView.cleanupInstances\n *\n * This function can also be used to store instance specific cleanup fns. In that case the `context`\n * is `null` and the function is store in `LView` (rather than it `TView`).\n */\nfunction storeCleanupWithContext(tView, lView, context, cleanupFn) {\n    const lCleanup = getOrCreateLViewCleanup(lView);\n    if (context === null) {\n        // If context is null that this is instance specific callback. These callbacks can only be\n        // inserted after template shared instances. For this reason in ngDevMode we freeze the TView.\n        if (ngDevMode) {\n            Object.freeze(getOrCreateTViewCleanup(tView));\n        }\n        lCleanup.push(cleanupFn);\n    }\n    else {\n        lCleanup.push(context);\n        if (tView.firstCreatePass) {\n            getOrCreateTViewCleanup(tView).push(cleanupFn, lCleanup.length - 1);\n        }\n    }\n}\nfunction createTNode(tView, tParent, type, index, value, attrs) {\n    ngDevMode && index !== 0 && // 0 are bogus nodes and they are OK. See `createContainerRef` in\n        // `view_engine_compatibility` for additional context.\n        assertGreaterThanOrEqual(index, HEADER_OFFSET, 'TNodes can\\'t be in the LView header.');\n    ngDevMode && assertNotSame(attrs, undefined, '\\'undefined\\' is not valid value for \\'attrs\\'');\n    ngDevMode && ngDevMode.tNode++;\n    ngDevMode && tParent && assertTNodeForTView(tParent, tView);\n    let injectorIndex = tParent ? tParent.injectorIndex : -1;\n    const tNode = ngDevMode ?\n        new TNodeDebug(tView, // tView_: TView\n        type, // type: TNodeType\n        index, // index: number\n        null, // insertBeforeIndex: null|-1|number|number[]\n        injectorIndex, // injectorIndex: number\n        -1, // directiveStart: number\n        -1, // directiveEnd: number\n        -1, // directiveStylingLast: number\n        null, // propertyBindings: number[]|null\n        0, // flags: TNodeFlags\n        0, // providerIndexes: TNodeProviderIndexes\n        value, // value: string|null\n        attrs, // attrs: (string|AttributeMarker|(string|SelectorFlags)[])[]|null\n        null, // mergedAttrs\n        null, // localNames: (string|number)[]|null\n        undefined, // initialInputs: (string[]|null)[]|null|undefined\n        null, // inputs: PropertyAliases|null\n        null, // outputs: PropertyAliases|null\n        null, // tViews: ITView|ITView[]|null\n        null, // next: ITNode|null\n        null, // projectionNext: ITNode|null\n        null, // child: ITNode|null\n        tParent, // parent: TElementNode|TContainerNode|null\n        null, // projection: number|(ITNode|RNode[])[]|null\n        null, // styles: string|null\n        null, // stylesWithoutHost: string|null\n        undefined, // residualStyles: string|null\n        null, // classes: string|null\n        null, // classesWithoutHost: string|null\n        undefined, // residualClasses: string|null\n        0, // classBindings: TStylingRange;\n        0) :\n        {\n            type,\n            index,\n            insertBeforeIndex: null,\n            injectorIndex,\n            directiveStart: -1,\n            directiveEnd: -1,\n            directiveStylingLast: -1,\n            propertyBindings: null,\n            flags: 0,\n            providerIndexes: 0,\n            value: value,\n            attrs: attrs,\n            mergedAttrs: null,\n            localNames: null,\n            initialInputs: undefined,\n            inputs: null,\n            outputs: null,\n            tViews: null,\n            next: null,\n            projectionNext: null,\n            child: null,\n            parent: tParent,\n            projection: null,\n            styles: null,\n            stylesWithoutHost: null,\n            residualStyles: undefined,\n            classes: null,\n            classesWithoutHost: null,\n            residualClasses: undefined,\n            classBindings: 0,\n            styleBindings: 0,\n        };\n    if (ngDevMode) {\n        // For performance reasons it is important that the tNode retains the same shape during runtime.\n        // (To make sure that all of the code is monomorphic.) For this reason we seal the object to\n        // prevent class transitions.\n        Object.seal(tNode);\n    }\n    return tNode;\n}\nfunction generatePropertyAliases(inputAliasMap, directiveDefIdx, propStore) {\n    for (let publicName in inputAliasMap) {\n        if (inputAliasMap.hasOwnProperty(publicName)) {\n            propStore = propStore === null ? {} : propStore;\n            const internalName = inputAliasMap[publicName];\n            if (propStore.hasOwnProperty(publicName)) {\n                propStore[publicName].push(directiveDefIdx, internalName);\n            }\n            else {\n                (propStore[publicName] = [directiveDefIdx, internalName]);\n            }\n        }\n    }\n    return propStore;\n}\n/**\n * Initializes data structures required to work with directive inputs and outputs.\n * Initialization is done for all directives matched on a given TNode.\n */\nfunction initializeInputAndOutputAliases(tView, tNode) {\n    ngDevMode && assertFirstCreatePass(tView);\n    const start = tNode.directiveStart;\n    const end = tNode.directiveEnd;\n    const tViewData = tView.data;\n    const tNodeAttrs = tNode.attrs;\n    const inputsFromAttrs = ngDevMode ? new TNodeInitialInputs() : [];\n    let inputsStore = null;\n    let outputsStore = null;\n    for (let i = start; i < end; i++) {\n        const directiveDef = tViewData[i];\n        const directiveInputs = directiveDef.inputs;\n        // Do not use unbound attributes as inputs to structural directives, since structural\n        // directive inputs can only be set using microsyntax (e.g. `<div *dir=\"exp\">`).\n        // TODO(FW-1930): microsyntax expressions may also contain unbound/static attributes, which\n        // should be set for inline templates.\n        const initialInputs = (tNodeAttrs !== null && !isInlineTemplate(tNode)) ?\n            generateInitialInputs(directiveInputs, tNodeAttrs) :\n            null;\n        inputsFromAttrs.push(initialInputs);\n        inputsStore = generatePropertyAliases(directiveInputs, i, inputsStore);\n        outputsStore = generatePropertyAliases(directiveDef.outputs, i, outputsStore);\n    }\n    if (inputsStore !== null) {\n        if (inputsStore.hasOwnProperty('class')) {\n            tNode.flags |= 16 /* TNodeFlags.hasClassInput */;\n        }\n        if (inputsStore.hasOwnProperty('style')) {\n            tNode.flags |= 32 /* TNodeFlags.hasStyleInput */;\n        }\n    }\n    tNode.initialInputs = inputsFromAttrs;\n    tNode.inputs = inputsStore;\n    tNode.outputs = outputsStore;\n}\n/**\n * Mapping between attributes names that don't correspond to their element property names.\n *\n * Performance note: this function is written as a series of if checks (instead of, say, a property\n * object lookup) for performance reasons - the series of `if` checks seems to be the fastest way of\n * mapping property names. Do NOT change without benchmarking.\n *\n * Note: this mapping has to be kept in sync with the equally named mapping in the template\n * type-checking machinery of ngtsc.\n */\nfunction mapPropName(name) {\n    if (name === 'class')\n        return 'className';\n    if (name === 'for')\n        return 'htmlFor';\n    if (name === 'formaction')\n        return 'formAction';\n    if (name === 'innerHtml')\n        return 'innerHTML';\n    if (name === 'readonly')\n        return 'readOnly';\n    if (name === 'tabindex')\n        return 'tabIndex';\n    return name;\n}\nfunction elementPropertyInternal(tView, tNode, lView, propName, value, renderer, sanitizer, nativeOnly) {\n    ngDevMode && assertNotSame(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');\n    const element = getNativeByTNode(tNode, lView);\n    let inputData = tNode.inputs;\n    let dataValue;\n    if (!nativeOnly && inputData != null && (dataValue = inputData[propName])) {\n        setInputsForProperty(tView, lView, dataValue, propName, value);\n        if (isComponentHost(tNode))\n            markDirtyIfOnPush(lView, tNode.index);\n        if (ngDevMode) {\n            setNgReflectProperties(lView, element, tNode.type, dataValue, value);\n        }\n    }\n    else if (tNode.type & 3 /* TNodeType.AnyRNode */) {\n        propName = mapPropName(propName);\n        if (ngDevMode) {\n            validateAgainstEventProperties(propName);\n            if (!isPropertyValid(element, propName, tNode.value, tView.schemas)) {\n                handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);\n            }\n            ngDevMode.rendererSetProperty++;\n        }\n        // It is assumed that the sanitizer is only added when the compiler determines that the\n        // property is risky, so sanitization can be done without further checks.\n        value = sanitizer != null ? sanitizer(value, tNode.value || '', propName) : value;\n        if (isProceduralRenderer(renderer)) {\n            renderer.setProperty(element, propName, value);\n        }\n        else if (!isAnimationProp(propName)) {\n            element.setProperty ? element.setProperty(propName, value) :\n                element[propName] = value;\n        }\n    }\n    else if (tNode.type & 12 /* TNodeType.AnyContainer */) {\n        // If the node is a container and the property didn't\n        // match any of the inputs or schemas we should throw.\n        if (ngDevMode && !matchingSchemas(tView.schemas, tNode.value)) {\n            handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);\n        }\n    }\n}\n/** If node is an OnPush component, marks its LView dirty. */\nfunction markDirtyIfOnPush(lView, viewIndex) {\n    ngDevMode && assertLView(lView);\n    const childComponentLView = getComponentLViewByIndex(viewIndex, lView);\n    if (!(childComponentLView[FLAGS] & 16 /* LViewFlags.CheckAlways */)) {\n        childComponentLView[FLAGS] |= 32 /* LViewFlags.Dirty */;\n    }\n}\nfunction setNgReflectProperty(lView, element, type, attrName, value) {\n    const renderer = lView[RENDERER];\n    attrName = normalizeDebugBindingName(attrName);\n    const debugValue = normalizeDebugBindingValue(value);\n    if (type & 3 /* TNodeType.AnyRNode */) {\n        if (value == null) {\n            isProceduralRenderer(renderer) ? renderer.removeAttribute(element, attrName) :\n                element.removeAttribute(attrName);\n        }\n        else {\n            isProceduralRenderer(renderer) ?\n                renderer.setAttribute(element, attrName, debugValue) :\n                element.setAttribute(attrName, debugValue);\n        }\n    }\n    else {\n        const textContent = escapeCommentText(`bindings=${JSON.stringify({ [attrName]: debugValue }, null, 2)}`);\n        if (isProceduralRenderer(renderer)) {\n            renderer.setValue(element, textContent);\n        }\n        else {\n            element.textContent = textContent;\n        }\n    }\n}\nfunction setNgReflectProperties(lView, element, type, dataValue, value) {\n    if (type & (3 /* TNodeType.AnyRNode */ | 4 /* TNodeType.Container */)) {\n        /**\n         * dataValue is an array containing runtime input or output names for the directives:\n         * i+0: directive instance index\n         * i+1: privateName\n         *\n         * e.g. [0, 'change', 'change-minified']\n         * we want to set the reflected property with the privateName: dataValue[i+1]\n         */\n        for (let i = 0; i < dataValue.length; i += 2) {\n            setNgReflectProperty(lView, element, type, dataValue[i + 1], value);\n        }\n    }\n}\n/**\n * Instantiate a root component.\n */\nfunction instantiateRootComponent(tView, lView, def) {\n    const rootTNode = getCurrentTNode();\n    if (tView.firstCreatePass) {\n        if (def.providersResolver)\n            def.providersResolver(def);\n        const directiveIndex = allocExpando(tView, lView, 1, null);\n        ngDevMode &&\n            assertEqual(directiveIndex, rootTNode.directiveStart, 'Because this is a root component the allocated expando should match the TNode component.');\n        configureViewWithDirective(tView, rootTNode, lView, directiveIndex, def);\n    }\n    const directive = getNodeInjectable(lView, tView, rootTNode.directiveStart, rootTNode);\n    attachPatchData(directive, lView);\n    const native = getNativeByTNode(rootTNode, lView);\n    if (native) {\n        attachPatchData(native, lView);\n    }\n    return directive;\n}\n/**\n * Resolve the matched directives on a node.\n */\nfunction resolveDirectives(tView, lView, tNode, localRefs) {\n    // Please make sure to have explicit type for `exportsMap`. Inferred type triggers bug in\n    // tsickle.\n    ngDevMode && assertFirstCreatePass(tView);\n    let hasDirectives = false;\n    if (getBindingsEnabled()) {\n        const directiveDefs = findDirectiveDefMatches(tView, lView, tNode);\n        const exportsMap = localRefs === null ? null : { '': -1 };\n        if (directiveDefs !== null) {\n            hasDirectives = true;\n            initTNodeFlags(tNode, tView.data.length, directiveDefs.length);\n            // When the same token is provided by several directives on the same node, some rules apply in\n            // the viewEngine:\n            // - viewProviders have priority over providers\n            // - the last directive in NgModule.declarations has priority over the previous one\n            // So to match these rules, the order in which providers are added in the arrays is very\n            // important.\n            for (let i = 0; i < directiveDefs.length; i++) {\n                const def = directiveDefs[i];\n                if (def.providersResolver)\n                    def.providersResolver(def);\n            }\n            let preOrderHooksFound = false;\n            let preOrderCheckHooksFound = false;\n            let directiveIdx = allocExpando(tView, lView, directiveDefs.length, null);\n            ngDevMode &&\n                assertSame(directiveIdx, tNode.directiveStart, 'TNode.directiveStart should point to just allocated space');\n            for (let i = 0; i < directiveDefs.length; i++) {\n                const def = directiveDefs[i];\n                // Merge the attrs in the order of matches. This assumes that the first directive is the\n                // component itself, so that the component has the least priority.\n                tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);\n                configureViewWithDirective(tView, tNode, lView, directiveIdx, def);\n                saveNameToExportMap(directiveIdx, def, exportsMap);\n                if (def.contentQueries !== null)\n                    tNode.flags |= 8 /* TNodeFlags.hasContentQuery */;\n                if (def.hostBindings !== null || def.hostAttrs !== null || def.hostVars !== 0)\n                    tNode.flags |= 128 /* TNodeFlags.hasHostBindings */;\n                const lifeCycleHooks = def.type.prototype;\n                // Only push a node index into the preOrderHooks array if this is the first\n                // pre-order hook found on this node.\n                if (!preOrderHooksFound &&\n                    (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngOnInit || lifeCycleHooks.ngDoCheck)) {\n                    // We will push the actual hook function into this array later during dir instantiation.\n                    // We cannot do it now because we must ensure hooks are registered in the same\n                    // order that directives are created (i.e. injection order).\n                    (tView.preOrderHooks || (tView.preOrderHooks = [])).push(tNode.index);\n                    preOrderHooksFound = true;\n                }\n                if (!preOrderCheckHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngDoCheck)) {\n                    (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(tNode.index);\n                    preOrderCheckHooksFound = true;\n                }\n                directiveIdx++;\n            }\n            initializeInputAndOutputAliases(tView, tNode);\n        }\n        if (exportsMap)\n            cacheMatchingLocalNames(tNode, localRefs, exportsMap);\n    }\n    // Merge the template attrs last so that they have the highest priority.\n    tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);\n    return hasDirectives;\n}\n/**\n * Add `hostBindings` to the `TView.hostBindingOpCodes`.\n *\n * @param tView `TView` to which the `hostBindings` should be added.\n * @param tNode `TNode` the element which contains the directive\n * @param lView `LView` current `LView`\n * @param directiveIdx Directive index in view.\n * @param directiveVarsIdx Where will the directive's vars be stored\n * @param def `ComponentDef`/`DirectiveDef`, which contains the `hostVars`/`hostBindings` to add.\n */\nfunction registerHostBindingOpCodes(tView, tNode, lView, directiveIdx, directiveVarsIdx, def) {\n    ngDevMode && assertFirstCreatePass(tView);\n    const hostBindings = def.hostBindings;\n    if (hostBindings) {\n        let hostBindingOpCodes = tView.hostBindingOpCodes;\n        if (hostBindingOpCodes === null) {\n            hostBindingOpCodes = tView.hostBindingOpCodes = [];\n        }\n        const elementIndx = ~tNode.index;\n        if (lastSelectedElementIdx(hostBindingOpCodes) != elementIndx) {\n            // Conditionally add select element so that we are more efficient in execution.\n            // NOTE: this is strictly not necessary and it trades code size for runtime perf.\n            // (We could just always add it.)\n            hostBindingOpCodes.push(elementIndx);\n        }\n        hostBindingOpCodes.push(directiveIdx, directiveVarsIdx, hostBindings);\n    }\n}\n/**\n * Returns the last selected element index in the `HostBindingOpCodes`\n *\n * For perf reasons we don't need to update the selected element index in `HostBindingOpCodes` only\n * if it changes. This method returns the last index (or '0' if not found.)\n *\n * Selected element index are only the ones which are negative.\n */\nfunction lastSelectedElementIdx(hostBindingOpCodes) {\n    let i = hostBindingOpCodes.length;\n    while (i > 0) {\n        const value = hostBindingOpCodes[--i];\n        if (typeof value === 'number' && value < 0) {\n            return value;\n        }\n    }\n    return 0;\n}\n/**\n * Instantiate all the directives that were previously resolved on the current node.\n */\nfunction instantiateAllDirectives(tView, lView, tNode, native) {\n    const start = tNode.directiveStart;\n    const end = tNode.directiveEnd;\n    if (!tView.firstCreatePass) {\n        getOrCreateNodeInjectorForNode(tNode, lView);\n    }\n    attachPatchData(native, lView);\n    const initialInputs = tNode.initialInputs;\n    for (let i = start; i < end; i++) {\n        const def = tView.data[i];\n        const isComponent = isComponentDef(def);\n        if (isComponent) {\n            ngDevMode && assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */);\n            addComponentLogic(lView, tNode, def);\n        }\n        const directive = getNodeInjectable(lView, tView, i, tNode);\n        attachPatchData(directive, lView);\n        if (initialInputs !== null) {\n            setInputsFromAttrs(lView, i - start, directive, def, tNode, initialInputs);\n        }\n        if (isComponent) {\n            const componentView = getComponentLViewByIndex(tNode.index, lView);\n            componentView[CONTEXT] = directive;\n        }\n    }\n}\nfunction invokeDirectivesHostBindings(tView, lView, tNode) {\n    const start = tNode.directiveStart;\n    const end = tNode.directiveEnd;\n    const elementIndex = tNode.index;\n    const currentDirectiveIndex = getCurrentDirectiveIndex();\n    try {\n        setSelectedIndex(elementIndex);\n        for (let dirIndex = start; dirIndex < end; dirIndex++) {\n            const def = tView.data[dirIndex];\n            const directive = lView[dirIndex];\n            setCurrentDirectiveIndex(dirIndex);\n            if (def.hostBindings !== null || def.hostVars !== 0 || def.hostAttrs !== null) {\n                invokeHostBindingsInCreationMode(def, directive);\n            }\n        }\n    }\n    finally {\n        setSelectedIndex(-1);\n        setCurrentDirectiveIndex(currentDirectiveIndex);\n    }\n}\n/**\n * Invoke the host bindings in creation mode.\n *\n * @param def `DirectiveDef` which may contain the `hostBindings` function.\n * @param directive Instance of directive.\n */\nfunction invokeHostBindingsInCreationMode(def, directive) {\n    if (def.hostBindings !== null) {\n        def.hostBindings(1 /* RenderFlags.Create */, directive);\n    }\n}\n/**\n * Matches the current node against all available selectors.\n * If a component is matched (at most one), it is returned in first position in the array.\n */\nfunction findDirectiveDefMatches(tView, viewData, tNode) {\n    ngDevMode && assertFirstCreatePass(tView);\n    ngDevMode && assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */ | 12 /* TNodeType.AnyContainer */);\n    const registry = tView.directiveRegistry;\n    let matches = null;\n    if (registry) {\n        for (let i = 0; i < registry.length; i++) {\n            const def = registry[i];\n            if (isNodeMatchingSelectorList(tNode, def.selectors, /* isProjectionMode */ false)) {\n                matches || (matches = ngDevMode ? new MatchesArray() : []);\n                diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, viewData), tView, def.type);\n                if (isComponentDef(def)) {\n                    if (ngDevMode) {\n                        assertTNodeType(tNode, 2 /* TNodeType.Element */, `\"${tNode.value}\" tags cannot be used as component hosts. ` +\n                            `Please use a different tag to activate the ${stringify(def.type)} component.`);\n                        if (tNode.flags & 2 /* TNodeFlags.isComponentHost */) {\n                            // If another component has been matched previously, it's the first element in the\n                            // `matches` array, see how we store components/directives in `matches` below.\n                            throwMultipleComponentError(tNode, matches[0].type, def.type);\n                        }\n                    }\n                    markAsComponentHost(tView, tNode);\n                    // The component is always stored first with directives after.\n                    matches.unshift(def);\n                }\n                else {\n                    matches.push(def);\n                }\n            }\n        }\n    }\n    return matches;\n}\n/**\n * Marks a given TNode as a component's host. This consists of:\n * - setting appropriate TNode flags;\n * - storing index of component's host element so it will be queued for view refresh during CD.\n */\nfunction markAsComponentHost(tView, hostTNode) {\n    ngDevMode && assertFirstCreatePass(tView);\n    hostTNode.flags |= 2 /* TNodeFlags.isComponentHost */;\n    (tView.components || (tView.components = ngDevMode ? new TViewComponents() : []))\n        .push(hostTNode.index);\n}\n/** Caches local names and their matching directive indices for query and template lookups. */\nfunction cacheMatchingLocalNames(tNode, localRefs, exportsMap) {\n    if (localRefs) {\n        const localNames = tNode.localNames = ngDevMode ? new TNodeLocalNames() : [];\n        // Local names must be stored in tNode in the same order that localRefs are defined\n        // in the template to ensure the data is loaded in the same slots as their refs\n        // in the template (for template queries).\n        for (let i = 0; i < localRefs.length; i += 2) {\n            const index = exportsMap[localRefs[i + 1]];\n            if (index == null)\n                throw new RuntimeError(-301 /* RuntimeErrorCode.EXPORT_NOT_FOUND */, ngDevMode && `Export of name '${localRefs[i + 1]}' not found!`);\n            localNames.push(localRefs[i], index);\n        }\n    }\n}\n/**\n * Builds up an export map as directives are created, so local refs can be quickly mapped\n * to their directive instances.\n */\nfunction saveNameToExportMap(directiveIdx, def, exportsMap) {\n    if (exportsMap) {\n        if (def.exportAs) {\n            for (let i = 0; i < def.exportAs.length; i++) {\n                exportsMap[def.exportAs[i]] = directiveIdx;\n            }\n        }\n        if (isComponentDef(def))\n            exportsMap[''] = directiveIdx;\n    }\n}\n/**\n * Initializes the flags on the current node, setting all indices to the initial index,\n * the directive count to 0, and adding the isComponent flag.\n * @param index the initial index\n */\nfunction initTNodeFlags(tNode, index, numberOfDirectives) {\n    ngDevMode &&\n        assertNotEqual(numberOfDirectives, tNode.directiveEnd - tNode.directiveStart, 'Reached the max number of directives');\n    tNode.flags |= 1 /* TNodeFlags.isDirectiveHost */;\n    // When the first directive is created on a node, save the index\n    tNode.directiveStart = index;\n    tNode.directiveEnd = index + numberOfDirectives;\n    tNode.providerIndexes = index;\n}\n/**\n * Setup directive for instantiation.\n *\n * We need to create a `NodeInjectorFactory` which is then inserted in both the `Blueprint` as well\n * as `LView`. `TView` gets the `DirectiveDef`.\n *\n * @param tView `TView`\n * @param tNode `TNode`\n * @param lView `LView`\n * @param directiveIndex Index where the directive will be stored in the Expando.\n * @param def `DirectiveDef`\n */\nfunction configureViewWithDirective(tView, tNode, lView, directiveIndex, def) {\n    ngDevMode &&\n        assertGreaterThanOrEqual(directiveIndex, HEADER_OFFSET, 'Must be in Expando section');\n    tView.data[directiveIndex] = def;\n    const directiveFactory = def.factory || (def.factory = getFactoryDef(def.type, true));\n    // Even though `directiveFactory` will already be using `ɵɵdirectiveInject` in its generated code,\n    // we also want to support `inject()` directly from the directive constructor context so we set\n    // `ɵɵdirectiveInject` as the inject implementation here too.\n    const nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, isComponentDef(def), ɵɵdirectiveInject);\n    tView.blueprint[directiveIndex] = nodeInjectorFactory;\n    lView[directiveIndex] = nodeInjectorFactory;\n    registerHostBindingOpCodes(tView, tNode, lView, directiveIndex, allocExpando(tView, lView, def.hostVars, NO_CHANGE), def);\n}\nfunction addComponentLogic(lView, hostTNode, def) {\n    const native = getNativeByTNode(hostTNode, lView);\n    const tView = getOrCreateTComponentView(def);\n    // Only component views should be added to the view tree directly. Embedded views are\n    // accessed through their containers because they may be removed / re-added later.\n    const rendererFactory = lView[RENDERER_FACTORY];\n    const componentView = addToViewTree(lView, createLView(lView, tView, null, def.onPush ? 32 /* LViewFlags.Dirty */ : 16 /* LViewFlags.CheckAlways */, native, hostTNode, rendererFactory, rendererFactory.createRenderer(native, def), null, null, null));\n    // Component view will always be created before any injected LContainers,\n    // so this is a regular element, wrap it with the component view\n    lView[hostTNode.index] = componentView;\n}\nfunction elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace) {\n    if (ngDevMode) {\n        assertNotSame(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');\n        validateAgainstEventAttributes(name);\n        assertTNodeType(tNode, 2 /* TNodeType.Element */, `Attempted to set attribute \\`${name}\\` on a container node. ` +\n            `Host bindings are not valid on ng-container or ng-template.`);\n    }\n    const element = getNativeByTNode(tNode, lView);\n    setElementAttribute(lView[RENDERER], element, namespace, tNode.value, name, value, sanitizer);\n}\nfunction setElementAttribute(renderer, element, namespace, tagName, name, value, sanitizer) {\n    if (value == null) {\n        ngDevMode && ngDevMode.rendererRemoveAttribute++;\n        isProceduralRenderer(renderer) ? renderer.removeAttribute(element, name, namespace) :\n            element.removeAttribute(name);\n    }\n    else {\n        ngDevMode && ngDevMode.rendererSetAttribute++;\n        const strValue = sanitizer == null ? renderStringify(value) : sanitizer(value, tagName || '', name);\n        if (isProceduralRenderer(renderer)) {\n            renderer.setAttribute(element, name, strValue, namespace);\n        }\n        else {\n            namespace ? element.setAttributeNS(namespace, name, strValue) :\n                element.setAttribute(name, strValue);\n        }\n    }\n}\n/**\n * Sets initial input properties on directive instances from attribute data\n *\n * @param lView Current LView that is being processed.\n * @param directiveIndex Index of the directive in directives array\n * @param instance Instance of the directive on which to set the initial inputs\n * @param def The directive def that contains the list of inputs\n * @param tNode The static data for this node\n */\nfunction setInputsFromAttrs(lView, directiveIndex, instance, def, tNode, initialInputData) {\n    const initialInputs = initialInputData[directiveIndex];\n    if (initialInputs !== null) {\n        const setInput = def.setInput;\n        for (let i = 0; i < initialInputs.length;) {\n            const publicName = initialInputs[i++];\n            const privateName = initialInputs[i++];\n            const value = initialInputs[i++];\n            if (setInput !== null) {\n                def.setInput(instance, value, publicName, privateName);\n            }\n            else {\n                instance[privateName] = value;\n            }\n            if (ngDevMode) {\n                const nativeElement = getNativeByTNode(tNode, lView);\n                setNgReflectProperty(lView, nativeElement, tNode.type, privateName, value);\n            }\n        }\n    }\n}\n/**\n * Generates initialInputData for a node and stores it in the template's static storage\n * so subsequent template invocations don't have to recalculate it.\n *\n * initialInputData is an array containing values that need to be set as input properties\n * for directives on this node, but only once on creation. We need this array to support\n * the case where you set an @Input property of a directive using attribute-like syntax.\n * e.g. if you have a `name` @Input, you can set it once like this:\n *\n * <my-component name=\"Bess\"></my-component>\n *\n * @param inputs The list of inputs from the directive def\n * @param attrs The static attrs on this node\n */\nfunction generateInitialInputs(inputs, attrs) {\n    let inputsToStore = null;\n    let i = 0;\n    while (i < attrs.length) {\n        const attrName = attrs[i];\n        if (attrName === 0 /* AttributeMarker.NamespaceURI */) {\n            // We do not allow inputs on namespaced attributes.\n            i += 4;\n            continue;\n        }\n        else if (attrName === 5 /* AttributeMarker.ProjectAs */) {\n            // Skip over the `ngProjectAs` value.\n            i += 2;\n            continue;\n        }\n        // If we hit any other attribute markers, we're done anyway. None of those are valid inputs.\n        if (typeof attrName === 'number')\n            break;\n        if (inputs.hasOwnProperty(attrName)) {\n            if (inputsToStore === null)\n                inputsToStore = [];\n            inputsToStore.push(attrName, inputs[attrName], attrs[i + 1]);\n        }\n        i += 2;\n    }\n    return inputsToStore;\n}\n//////////////////////////\n//// ViewContainer & View\n//////////////////////////\n// Not sure why I need to do `any` here but TS complains later.\nconst LContainerArray = class LContainer extends Array {\n};\n/**\n * Creates a LContainer, either from a container instruction, or for a ViewContainerRef.\n *\n * @param hostNative The host element for the LContainer\n * @param hostTNode The host TNode for the LContainer\n * @param currentView The parent view of the LContainer\n * @param native The native comment element\n * @param isForViewContainerRef Optional a flag indicating the ViewContainerRef case\n * @returns LContainer\n */\nfunction createLContainer(hostNative, currentView, native, tNode) {\n    ngDevMode && assertLView(currentView);\n    ngDevMode && !isProceduralRenderer(currentView[RENDERER]) && assertDomNode(native);\n    // https://jsperf.com/array-literal-vs-new-array-really\n    const lContainer = new (ngDevMode ? LContainerArray : Array)(hostNative, // host native\n    true, // Boolean `true` in this position signifies that this is an `LContainer`\n    false, // has transplanted views\n    currentView, // parent\n    null, // next\n    0, // transplanted views to refresh count\n    tNode, // t_host\n    native, // native,\n    null, // view refs\n    null);\n    ngDevMode &&\n        assertEqual(lContainer.length, CONTAINER_HEADER_OFFSET, 'Should allocate correct number of slots for LContainer header.');\n    ngDevMode && attachLContainerDebug(lContainer);\n    return lContainer;\n}\n/**\n * Goes over embedded views (ones created through ViewContainerRef APIs) and refreshes\n * them by executing an associated template function.\n */\nfunction refreshEmbeddedViews(lView) {\n    for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {\n        for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n            const embeddedLView = lContainer[i];\n            const embeddedTView = embeddedLView[TVIEW];\n            ngDevMode && assertDefined(embeddedTView, 'TView must be allocated');\n            if (viewAttachedToChangeDetector(embeddedLView)) {\n                refreshView(embeddedTView, embeddedLView, embeddedTView.template, embeddedLView[CONTEXT]);\n            }\n        }\n    }\n}\n/**\n * Mark transplanted views as needing to be refreshed at their insertion points.\n *\n * @param lView The `LView` that may have transplanted views.\n */\nfunction markTransplantedViewsForRefresh(lView) {\n    for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {\n        if (!lContainer[HAS_TRANSPLANTED_VIEWS])\n            continue;\n        const movedViews = lContainer[MOVED_VIEWS];\n        ngDevMode && assertDefined(movedViews, 'Transplanted View flags set but missing MOVED_VIEWS');\n        for (let i = 0; i < movedViews.length; i++) {\n            const movedLView = movedViews[i];\n            const insertionLContainer = movedLView[PARENT];\n            ngDevMode && assertLContainer(insertionLContainer);\n            // We don't want to increment the counter if the moved LView was already marked for\n            // refresh.\n            if ((movedLView[FLAGS] & 512 /* LViewFlags.RefreshTransplantedView */) === 0) {\n                updateTransplantedViewCount(insertionLContainer, 1);\n            }\n            // Note, it is possible that the `movedViews` is tracking views that are transplanted *and*\n            // those that aren't (declaration component === insertion component). In the latter case,\n            // it's fine to add the flag, as we will clear it immediately in\n            // `refreshEmbeddedViews` for the view currently being refreshed.\n            movedLView[FLAGS] |= 512 /* LViewFlags.RefreshTransplantedView */;\n        }\n    }\n}\n/////////////\n/**\n * Refreshes components by entering the component view and processing its bindings, queries, etc.\n *\n * @param componentHostIdx  Element index in LView[] (adjusted for HEADER_OFFSET)\n */\nfunction refreshComponent(hostLView, componentHostIdx) {\n    ngDevMode && assertEqual(isCreationMode(hostLView), false, 'Should be run in update mode');\n    const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);\n    // Only attached components that are CheckAlways or OnPush and dirty should be refreshed\n    if (viewAttachedToChangeDetector(componentView)) {\n        const tView = componentView[TVIEW];\n        if (componentView[FLAGS] & (16 /* LViewFlags.CheckAlways */ | 32 /* LViewFlags.Dirty */)) {\n            refreshView(tView, componentView, tView.template, componentView[CONTEXT]);\n        }\n        else if (componentView[TRANSPLANTED_VIEWS_TO_REFRESH] > 0) {\n            // Only attached components that are CheckAlways or OnPush and dirty should be refreshed\n            refreshContainsDirtyView(componentView);\n        }\n    }\n}\n/**\n * Refreshes all transplanted views marked with `LViewFlags.RefreshTransplantedView` that are\n * children or descendants of the given lView.\n *\n * @param lView The lView which contains descendant transplanted views that need to be refreshed.\n */\nfunction refreshContainsDirtyView(lView) {\n    for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {\n        for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n            const embeddedLView = lContainer[i];\n            if (embeddedLView[FLAGS] & 512 /* LViewFlags.RefreshTransplantedView */) {\n                const embeddedTView = embeddedLView[TVIEW];\n                ngDevMode && assertDefined(embeddedTView, 'TView must be allocated');\n                refreshView(embeddedTView, embeddedLView, embeddedTView.template, embeddedLView[CONTEXT]);\n            }\n            else if (embeddedLView[TRANSPLANTED_VIEWS_TO_REFRESH] > 0) {\n                refreshContainsDirtyView(embeddedLView);\n            }\n        }\n    }\n    const tView = lView[TVIEW];\n    // Refresh child component views.\n    const components = tView.components;\n    if (components !== null) {\n        for (let i = 0; i < components.length; i++) {\n            const componentView = getComponentLViewByIndex(components[i], lView);\n            // Only attached components that are CheckAlways or OnPush and dirty should be refreshed\n            if (viewAttachedToChangeDetector(componentView) &&\n                componentView[TRANSPLANTED_VIEWS_TO_REFRESH] > 0) {\n                refreshContainsDirtyView(componentView);\n            }\n        }\n    }\n}\nfunction renderComponent$1(hostLView, componentHostIdx) {\n    ngDevMode && assertEqual(isCreationMode(hostLView), true, 'Should be run in creation mode');\n    const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);\n    const componentTView = componentView[TVIEW];\n    syncViewWithBlueprint(componentTView, componentView);\n    renderView(componentTView, componentView, componentView[CONTEXT]);\n}\n/**\n * Syncs an LView instance with its blueprint if they have gotten out of sync.\n *\n * Typically, blueprints and their view instances should always be in sync, so the loop here\n * will be skipped. However, consider this case of two components side-by-side:\n *\n * App template:\n * ```\n * <comp></comp>\n * <comp></comp>\n * ```\n *\n * The following will happen:\n * 1. App template begins processing.\n * 2. First <comp> is matched as a component and its LView is created.\n * 3. Second <comp> is matched as a component and its LView is created.\n * 4. App template completes processing, so it's time to check child templates.\n * 5. First <comp> template is checked. It has a directive, so its def is pushed to blueprint.\n * 6. Second <comp> template is checked. Its blueprint has been updated by the first\n * <comp> template, but its LView was created before this update, so it is out of sync.\n *\n * Note that embedded views inside ngFor loops will never be out of sync because these views\n * are processed as soon as they are created.\n *\n * @param tView The `TView` that contains the blueprint for syncing\n * @param lView The view to sync\n */\nfunction syncViewWithBlueprint(tView, lView) {\n    for (let i = lView.length; i < tView.blueprint.length; i++) {\n        lView.push(tView.blueprint[i]);\n    }\n}\n/**\n * Adds LView or LContainer to the end of the current view tree.\n *\n * This structure will be used to traverse through nested views to remove listeners\n * and call onDestroy callbacks.\n *\n * @param lView The view where LView or LContainer should be added\n * @param adjustedHostIndex Index of the view's host node in LView[], adjusted for header\n * @param lViewOrLContainer The LView or LContainer to add to the view tree\n * @returns The state passed in\n */\nfunction addToViewTree(lView, lViewOrLContainer) {\n    // TODO(benlesh/misko): This implementation is incorrect, because it always adds the LContainer\n    // to the end of the queue, which means if the developer retrieves the LContainers from RNodes out\n    // of order, the change detection will run out of order, as the act of retrieving the the\n    // LContainer from the RNode is what adds it to the queue.\n    if (lView[CHILD_HEAD]) {\n        lView[CHILD_TAIL][NEXT] = lViewOrLContainer;\n    }\n    else {\n        lView[CHILD_HEAD] = lViewOrLContainer;\n    }\n    lView[CHILD_TAIL] = lViewOrLContainer;\n    return lViewOrLContainer;\n}\n///////////////////////////////\n//// Change detection\n///////////////////////////////\n/**\n * Marks current view and all ancestors dirty.\n *\n * Returns the root view because it is found as a byproduct of marking the view tree\n * dirty, and can be used by methods that consume markViewDirty() to easily schedule\n * change detection. Otherwise, such methods would need to traverse up the view tree\n * an additional time to get the root view and schedule a tick on it.\n *\n * @param lView The starting LView to mark dirty\n * @returns the root LView\n */\nfunction markViewDirty(lView) {\n    while (lView) {\n        lView[FLAGS] |= 32 /* LViewFlags.Dirty */;\n        const parent = getLViewParent(lView);\n        // Stop traversing up as soon as you find a root view that wasn't attached to any container\n        if (isRootView(lView) && !parent) {\n            return lView;\n        }\n        // continue otherwise\n        lView = parent;\n    }\n    return null;\n}\n/**\n * Used to schedule change detection on the whole application.\n *\n * Unlike `tick`, `scheduleTick` coalesces multiple calls into one change detection run.\n * It is usually called indirectly by calling `markDirty` when the view needs to be\n * re-rendered.\n *\n * Typically `scheduleTick` uses `requestAnimationFrame` to coalesce multiple\n * `scheduleTick` requests. The scheduling function can be overridden in\n * `renderComponent`'s `scheduler` option.\n */\nfunction scheduleTick(rootContext, flags) {\n    const nothingScheduled = rootContext.flags === 0 /* RootContextFlags.Empty */;\n    if (nothingScheduled && rootContext.clean == _CLEAN_PROMISE) {\n        // https://github.com/angular/angular/issues/39296\n        // should only attach the flags when really scheduling a tick\n        rootContext.flags |= flags;\n        let res;\n        rootContext.clean = new Promise((r) => res = r);\n        rootContext.scheduler(() => {\n            if (rootContext.flags & 1 /* RootContextFlags.DetectChanges */) {\n                rootContext.flags &= ~1 /* RootContextFlags.DetectChanges */;\n                tickRootContext(rootContext);\n            }\n            if (rootContext.flags & 2 /* RootContextFlags.FlushPlayers */) {\n                rootContext.flags &= ~2 /* RootContextFlags.FlushPlayers */;\n                const playerHandler = rootContext.playerHandler;\n                if (playerHandler) {\n                    playerHandler.flushPlayers();\n                }\n            }\n            rootContext.clean = _CLEAN_PROMISE;\n            res(null);\n        });\n    }\n}\nfunction tickRootContext(rootContext) {\n    for (let i = 0; i < rootContext.components.length; i++) {\n        const rootComponent = rootContext.components[i];\n        const lView = readPatchedLView(rootComponent);\n        // We might not have an `LView` if the component was destroyed.\n        if (lView !== null) {\n            const tView = lView[TVIEW];\n            renderComponentOrTemplate(tView, lView, tView.template, rootComponent);\n        }\n    }\n}\nfunction detectChangesInternal(tView, lView, context) {\n    const rendererFactory = lView[RENDERER_FACTORY];\n    if (rendererFactory.begin)\n        rendererFactory.begin();\n    try {\n        refreshView(tView, lView, tView.template, context);\n    }\n    catch (error) {\n        handleError(lView, error);\n        throw error;\n    }\n    finally {\n        if (rendererFactory.end)\n            rendererFactory.end();\n    }\n}\n/**\n * Synchronously perform change detection on a root view and its components.\n *\n * @param lView The view which the change detection should be performed on.\n */\nfunction detectChangesInRootView(lView) {\n    tickRootContext(lView[CONTEXT]);\n}\nfunction checkNoChangesInternal(tView, view, context) {\n    setIsInCheckNoChangesMode(true);\n    try {\n        detectChangesInternal(tView, view, context);\n    }\n    finally {\n        setIsInCheckNoChangesMode(false);\n    }\n}\n/**\n * Checks the change detector on a root view and its components, and throws if any changes are\n * detected.\n *\n * This is used in development mode to verify that running change detection doesn't\n * introduce other changes.\n *\n * @param lView The view which the change detection should be checked on.\n */\nfunction checkNoChangesInRootView(lView) {\n    setIsInCheckNoChangesMode(true);\n    try {\n        detectChangesInRootView(lView);\n    }\n    finally {\n        setIsInCheckNoChangesMode(false);\n    }\n}\nfunction executeViewQueryFn(flags, viewQueryFn, component) {\n    ngDevMode && assertDefined(viewQueryFn, 'View queries function to execute must be defined.');\n    setCurrentQueryIndex(0);\n    viewQueryFn(flags, component);\n}\n///////////////////////////////\n//// Bindings & interpolations\n///////////////////////////////\n/**\n * Stores meta-data for a property binding to be used by TestBed's `DebugElement.properties`.\n *\n * In order to support TestBed's `DebugElement.properties` we need to save, for each binding:\n * - a bound property name;\n * - a static parts of interpolated strings;\n *\n * A given property metadata is saved at the binding's index in the `TView.data` (in other words, a\n * property binding metadata will be stored in `TView.data` at the same index as a bound value in\n * `LView`). Metadata are represented as `INTERPOLATION_DELIMITER`-delimited string with the\n * following format:\n * - `propertyName` for bound properties;\n * - `propertyName�prefix�interpolation_static_part1�..interpolation_static_partN�suffix` for\n * interpolated properties.\n *\n * @param tData `TData` where meta-data will be saved;\n * @param tNode `TNode` that is a target of the binding;\n * @param propertyName bound property name;\n * @param bindingIndex binding index in `LView`\n * @param interpolationParts static interpolation parts (for property interpolations)\n */\nfunction storePropertyBindingMetadata(tData, tNode, propertyName, bindingIndex, ...interpolationParts) {\n    // Binding meta-data are stored only the first time a given property instruction is processed.\n    // Since we don't have a concept of the \"first update pass\" we need to check for presence of the\n    // binding meta-data to decide if one should be stored (or if was stored already).\n    if (tData[bindingIndex] === null) {\n        if (tNode.inputs == null || !tNode.inputs[propertyName]) {\n            const propBindingIdxs = tNode.propertyBindings || (tNode.propertyBindings = []);\n            propBindingIdxs.push(bindingIndex);\n            let bindingMetadata = propertyName;\n            if (interpolationParts.length > 0) {\n                bindingMetadata +=\n                    INTERPOLATION_DELIMITER + interpolationParts.join(INTERPOLATION_DELIMITER);\n            }\n            tData[bindingIndex] = bindingMetadata;\n        }\n    }\n}\nconst CLEAN_PROMISE = _CLEAN_PROMISE;\nfunction getOrCreateLViewCleanup(view) {\n    // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n    return view[CLEANUP] || (view[CLEANUP] = ngDevMode ? new LCleanup() : []);\n}\nfunction getOrCreateTViewCleanup(tView) {\n    return tView.cleanup || (tView.cleanup = ngDevMode ? new TCleanup() : []);\n}\n/**\n * There are cases where the sub component's renderer needs to be included\n * instead of the current renderer (see the componentSyntheticHost* instructions).\n */\nfunction loadComponentRenderer(currentDef, tNode, lView) {\n    // TODO(FW-2043): the `currentDef` is null when host bindings are invoked while creating root\n    // component (see packages/core/src/render3/component.ts). This is not consistent with the process\n    // of creating inner components, when current directive index is available in the state. In order\n    // to avoid relying on current def being `null` (thus special-casing root component creation), the\n    // process of creating root component should be unified with the process of creating inner\n    // components.\n    if (currentDef === null || isComponentDef(currentDef)) {\n        lView = unwrapLView(lView[tNode.index]);\n    }\n    return lView[RENDERER];\n}\n/** Handles an error thrown in an LView. */\nfunction handleError(lView, error) {\n    const injector = lView[INJECTOR$1];\n    const errorHandler = injector ? injector.get(ErrorHandler, null) : null;\n    errorHandler && errorHandler.handleError(error);\n}\n/**\n * Set the inputs of directives at the current node to corresponding value.\n *\n * @param tView The current TView\n * @param lView the `LView` which contains the directives.\n * @param inputs mapping between the public \"input\" name and privately-known,\n *        possibly minified, property names to write to.\n * @param value Value to set.\n */\nfunction setInputsForProperty(tView, lView, inputs, publicName, value) {\n    for (let i = 0; i < inputs.length;) {\n        const index = inputs[i++];\n        const privateName = inputs[i++];\n        const instance = lView[index];\n        ngDevMode && assertIndexInRange(lView, index);\n        const def = tView.data[index];\n        if (def.setInput !== null) {\n            def.setInput(instance, value, publicName, privateName);\n        }\n        else {\n            instance[privateName] = value;\n        }\n    }\n}\n/**\n * Updates a text binding at a given index in a given LView.\n */\nfunction textBindingInternal(lView, index, value) {\n    ngDevMode && assertString(value, 'Value should be a string');\n    ngDevMode && assertNotSame(value, NO_CHANGE, 'value should not be NO_CHANGE');\n    ngDevMode && assertIndexInRange(lView, index);\n    const element = getNativeByIndex(index, lView);\n    ngDevMode && assertDefined(element, 'native element should exist');\n    updateTextNode(lView[RENDERER], element, value);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Compute the static styling (class/style) from `TAttributes`.\n *\n * This function should be called during `firstCreatePass` only.\n *\n * @param tNode The `TNode` into which the styling information should be loaded.\n * @param attrs `TAttributes` containing the styling information.\n * @param writeToHost Where should the resulting static styles be written?\n *   - `false` Write to `TNode.stylesWithoutHost` / `TNode.classesWithoutHost`\n *   - `true` Write to `TNode.styles` / `TNode.classes`\n */\nfunction computeStaticStyling(tNode, attrs, writeToHost) {\n    ngDevMode &&\n        assertFirstCreatePass(getTView(), 'Expecting to be called in first template pass only');\n    let styles = writeToHost ? tNode.styles : null;\n    let classes = writeToHost ? tNode.classes : null;\n    let mode = 0;\n    if (attrs !== null) {\n        for (let i = 0; i < attrs.length; i++) {\n            const value = attrs[i];\n            if (typeof value === 'number') {\n                mode = value;\n            }\n            else if (mode == 1 /* AttributeMarker.Classes */) {\n                classes = concatStringsWithSpace(classes, value);\n            }\n            else if (mode == 2 /* AttributeMarker.Styles */) {\n                const style = value;\n                const styleValue = attrs[++i];\n                styles = concatStringsWithSpace(styles, style + ': ' + styleValue + ';');\n            }\n        }\n    }\n    writeToHost ? tNode.styles = styles : tNode.stylesWithoutHost = styles;\n    writeToHost ? tNode.classes = classes : tNode.classesWithoutHost = classes;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Synchronously perform change detection on a component (and possibly its sub-components).\n *\n * This function triggers change detection in a synchronous way on a component.\n *\n * @param component The component which the change detection should be performed on.\n */\nfunction detectChanges(component) {\n    const view = getComponentViewByInstance(component);\n    detectChangesInternal(view[TVIEW], view, component);\n}\n/**\n * Marks the component as dirty (needing change detection). Marking a component dirty will\n * schedule a change detection on it at some point in the future.\n *\n * Marking an already dirty component as dirty won't do anything. Only one outstanding change\n * detection can be scheduled per component tree.\n *\n * @param component Component to mark as dirty.\n */\nfunction markDirty(component) {\n    ngDevMode && assertDefined(component, 'component');\n    const rootView = markViewDirty(getComponentViewByInstance(component));\n    ngDevMode && assertDefined(rootView[CONTEXT], 'rootContext should be defined');\n    scheduleTick(rootView[CONTEXT], 1 /* RootContextFlags.DetectChanges */);\n}\n/**\n * Used to perform change detection on the whole application.\n *\n * This is equivalent to `detectChanges`, but invoked on root component. Additionally, `tick`\n * executes lifecycle hooks and conditionally checks components based on their\n * `ChangeDetectionStrategy` and dirtiness.\n *\n * The preferred way to trigger change detection is to call `markDirty`. `markDirty` internally\n * schedules `tick` using a scheduler in order to coalesce multiple `markDirty` calls into a\n * single change detection run. By default, the scheduler is `requestAnimationFrame`, but can\n * be changed when calling `renderComponent` and providing the `scheduler` option.\n */\nfunction tick(component) {\n    const rootView = getRootView(component);\n    const rootContext = rootView[CONTEXT];\n    tickRootContext(rootContext);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Retrieves the component instance associated with a given DOM element.\n *\n * @usageNotes\n * Given the following DOM structure:\n *\n * ```html\n * <app-root>\n *   <div>\n *     <child-comp></child-comp>\n *   </div>\n * </app-root>\n * ```\n *\n * Calling `getComponent` on `<child-comp>` will return the instance of `ChildComponent`\n * associated with this DOM element.\n *\n * Calling the function on `<app-root>` will return the `MyApp` instance.\n *\n *\n * @param element DOM element from which the component should be retrieved.\n * @returns Component instance associated with the element or `null` if there\n *    is no component associated with it.\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getComponent$1(element) {\n    ngDevMode && assertDomElement(element);\n    const context = getLContext(element);\n    if (context === null)\n        return null;\n    if (context.component === undefined) {\n        const lView = context.lView;\n        if (lView === null) {\n            return null;\n        }\n        context.component = getComponentAtNodeIndex(context.nodeIndex, lView);\n    }\n    return context.component;\n}\n/**\n * If inside an embedded view (e.g. `*ngIf` or `*ngFor`), retrieves the context of the embedded\n * view that the element is part of. Otherwise retrieves the instance of the component whose view\n * owns the element (in this case, the result is the same as calling `getOwningComponent`).\n *\n * @param element Element for which to get the surrounding component instance.\n * @returns Instance of the component that is around the element or null if the element isn't\n *    inside any component.\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getContext(element) {\n    assertDomElement(element);\n    const context = getLContext(element);\n    const lView = context ? context.lView : null;\n    return lView === null ? null : lView[CONTEXT];\n}\n/**\n * Retrieves the component instance whose view contains the DOM element.\n *\n * For example, if `<child-comp>` is used in the template of `<app-comp>`\n * (i.e. a `ViewChild` of `<app-comp>`), calling `getOwningComponent` on `<child-comp>`\n * would return `<app-comp>`.\n *\n * @param elementOrDir DOM element, component or directive instance\n *    for which to retrieve the root components.\n * @returns Component instance whose view owns the DOM element or null if the element is not\n *    part of a component view.\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getOwningComponent(elementOrDir) {\n    const context = getLContext(elementOrDir);\n    let lView = context ? context.lView : null;\n    if (lView === null)\n        return null;\n    let parent;\n    while (lView[TVIEW].type === 2 /* TViewType.Embedded */ && (parent = getLViewParent(lView))) {\n        lView = parent;\n    }\n    return lView[FLAGS] & 256 /* LViewFlags.IsRoot */ ? null : lView[CONTEXT];\n}\n/**\n * Retrieves all root components associated with a DOM element, directive or component instance.\n * Root components are those which have been bootstrapped by Angular.\n *\n * @param elementOrDir DOM element, component or directive instance\n *    for which to retrieve the root components.\n * @returns Root components associated with the target object.\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getRootComponents(elementOrDir) {\n    const lView = readPatchedLView(elementOrDir);\n    return lView !== null ? [...getRootContext(lView).components] : [];\n}\n/**\n * Retrieves an `Injector` associated with an element, component or directive instance.\n *\n * @param elementOrDir DOM element, component or directive instance for which to\n *    retrieve the injector.\n * @returns Injector associated with the element, component or directive instance.\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getInjector(elementOrDir) {\n    const context = getLContext(elementOrDir);\n    const lView = context ? context.lView : null;\n    if (lView === null)\n        return Injector.NULL;\n    const tNode = lView[TVIEW].data[context.nodeIndex];\n    return new NodeInjector(tNode, lView);\n}\n/**\n * Retrieve a set of injection tokens at a given DOM node.\n *\n * @param element Element for which the injection tokens should be retrieved.\n */\nfunction getInjectionTokens(element) {\n    const context = getLContext(element);\n    const lView = context ? context.lView : null;\n    if (lView === null)\n        return [];\n    const tView = lView[TVIEW];\n    const tNode = tView.data[context.nodeIndex];\n    const providerTokens = [];\n    const startIndex = tNode.providerIndexes & 1048575 /* TNodeProviderIndexes.ProvidersStartIndexMask */;\n    const endIndex = tNode.directiveEnd;\n    for (let i = startIndex; i < endIndex; i++) {\n        let value = tView.data[i];\n        if (isDirectiveDefHack(value)) {\n            // The fact that we sometimes store Type and sometimes DirectiveDef in this location is a\n            // design flaw.  We should always store same type so that we can be monomorphic. The issue\n            // is that for Components/Directives we store the def instead the type. The correct behavior\n            // is that we should always be storing injectable type in this location.\n            value = value.type;\n        }\n        providerTokens.push(value);\n    }\n    return providerTokens;\n}\n/**\n * Retrieves directive instances associated with a given DOM node. Does not include\n * component instances.\n *\n * @usageNotes\n * Given the following DOM structure:\n *\n * ```html\n * <app-root>\n *   <button my-button></button>\n *   <my-comp></my-comp>\n * </app-root>\n * ```\n *\n * Calling `getDirectives` on `<button>` will return an array with an instance of the `MyButton`\n * directive that is associated with the DOM node.\n *\n * Calling `getDirectives` on `<my-comp>` will return an empty array.\n *\n * @param node DOM node for which to get the directives.\n * @returns Array of directives associated with the node.\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getDirectives(node) {\n    // Skip text nodes because we can't have directives associated with them.\n    if (node instanceof Text) {\n        return [];\n    }\n    const context = getLContext(node);\n    const lView = context ? context.lView : null;\n    if (lView === null) {\n        return [];\n    }\n    const tView = lView[TVIEW];\n    const nodeIndex = context.nodeIndex;\n    if (!(tView === null || tView === void 0 ? void 0 : tView.data[nodeIndex])) {\n        return [];\n    }\n    if (context.directives === undefined) {\n        context.directives = getDirectivesAtNodeIndex(nodeIndex, lView, false);\n    }\n    // The `directives` in this case are a named array called `LComponentView`. Clone the\n    // result so we don't expose an internal data structure in the user's console.\n    return context.directives === null ? [] : [...context.directives];\n}\n/**\n * Returns the debug (partial) metadata for a particular directive or component instance.\n * The function accepts an instance of a directive or component and returns the corresponding\n * metadata.\n *\n * @param directiveOrComponentInstance Instance of a directive or component\n * @returns metadata of the passed directive or component\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getDirectiveMetadata(directiveOrComponentInstance) {\n    const { constructor } = directiveOrComponentInstance;\n    if (!constructor) {\n        throw new Error('Unable to find the instance constructor');\n    }\n    // In case a component inherits from a directive, we may have component and directive metadata\n    // To ensure we don't get the metadata of the directive, we want to call `getComponentDef` first.\n    const componentDef = getComponentDef$1(constructor);\n    if (componentDef) {\n        return {\n            inputs: componentDef.inputs,\n            outputs: componentDef.outputs,\n            encapsulation: componentDef.encapsulation,\n            changeDetection: componentDef.onPush ? ChangeDetectionStrategy.OnPush :\n                ChangeDetectionStrategy.Default\n        };\n    }\n    const directiveDef = getDirectiveDef(constructor);\n    if (directiveDef) {\n        return { inputs: directiveDef.inputs, outputs: directiveDef.outputs };\n    }\n    return null;\n}\n/**\n * Retrieve map of local references.\n *\n * The references are retrieved as a map of local reference name to element or directive instance.\n *\n * @param target DOM element, component or directive instance for which to retrieve\n *    the local references.\n */\nfunction getLocalRefs(target) {\n    const context = getLContext(target);\n    if (context === null)\n        return {};\n    if (context.localRefs === undefined) {\n        const lView = context.lView;\n        if (lView === null) {\n            return {};\n        }\n        context.localRefs = discoverLocalRefs(lView, context.nodeIndex);\n    }\n    return context.localRefs || {};\n}\n/**\n * Retrieves the host element of a component or directive instance.\n * The host element is the DOM element that matched the selector of the directive.\n *\n * @param componentOrDirective Component or directive instance for which the host\n *     element should be retrieved.\n * @returns Host element of the target.\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getHostElement(componentOrDirective) {\n    return getLContext(componentOrDirective).native;\n}\n/**\n * Retrieves the rendered text for a given component.\n *\n * This function retrieves the host element of a component and\n * and then returns the `textContent` for that element. This implies\n * that the text returned will include re-projected content of\n * the component as well.\n *\n * @param component The component to return the content text for.\n */\nfunction getRenderedText(component) {\n    const hostElement = getHostElement(component);\n    return hostElement.textContent || '';\n}\n/**\n * Retrieves a list of event listeners associated with a DOM element. The list does include host\n * listeners, but it does not include event listeners defined outside of the Angular context\n * (e.g. through `addEventListener`).\n *\n * @usageNotes\n * Given the following DOM structure:\n *\n * ```html\n * <app-root>\n *   <div (click)=\"doSomething()\"></div>\n * </app-root>\n * ```\n *\n * Calling `getListeners` on `<div>` will return an object that looks as follows:\n *\n * ```ts\n * {\n *   name: 'click',\n *   element: <div>,\n *   callback: () => doSomething(),\n *   useCapture: false\n * }\n * ```\n *\n * @param element Element for which the DOM listeners should be retrieved.\n * @returns Array of event listeners on the DOM element.\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getListeners(element) {\n    ngDevMode && assertDomElement(element);\n    const lContext = getLContext(element);\n    const lView = lContext === null ? null : lContext.lView;\n    if (lView === null)\n        return [];\n    const tView = lView[TVIEW];\n    const lCleanup = lView[CLEANUP];\n    const tCleanup = tView.cleanup;\n    const listeners = [];\n    if (tCleanup && lCleanup) {\n        for (let i = 0; i < tCleanup.length;) {\n            const firstParam = tCleanup[i++];\n            const secondParam = tCleanup[i++];\n            if (typeof firstParam === 'string') {\n                const name = firstParam;\n                const listenerElement = unwrapRNode(lView[secondParam]);\n                const callback = lCleanup[tCleanup[i++]];\n                const useCaptureOrIndx = tCleanup[i++];\n                // if useCaptureOrIndx is boolean then report it as is.\n                // if useCaptureOrIndx is positive number then it in unsubscribe method\n                // if useCaptureOrIndx is negative number then it is a Subscription\n                const type = (typeof useCaptureOrIndx === 'boolean' || useCaptureOrIndx >= 0) ? 'dom' : 'output';\n                const useCapture = typeof useCaptureOrIndx === 'boolean' ? useCaptureOrIndx : false;\n                if (element == listenerElement) {\n                    listeners.push({ element, name, callback, useCapture, type });\n                }\n            }\n        }\n    }\n    listeners.sort(sortListeners);\n    return listeners;\n}\nfunction sortListeners(a, b) {\n    if (a.name == b.name)\n        return 0;\n    return a.name < b.name ? -1 : 1;\n}\n/**\n * This function should not exist because it is megamorphic and only mostly correct.\n *\n * See call site for more info.\n */\nfunction isDirectiveDefHack(obj) {\n    return obj.type !== undefined && obj.template !== undefined && obj.declaredInputs !== undefined;\n}\n/**\n * Returns the attached `DebugNode` instance for an element in the DOM.\n *\n * @param element DOM element which is owned by an existing component's view.\n */\nfunction getDebugNode(element) {\n    if (ngDevMode && !(element instanceof Node)) {\n        throw new Error('Expecting instance of DOM Element');\n    }\n    const lContext = getLContext(element);\n    const lView = lContext ? lContext.lView : null;\n    if (lView === null) {\n        return null;\n    }\n    const nodeIndex = lContext.nodeIndex;\n    if (nodeIndex !== -1) {\n        const valueInLView = lView[nodeIndex];\n        // this means that value in the lView is a component with its own\n        // data. In this situation the TNode is not accessed at the same spot.\n        const tNode = isLView(valueInLView) ? valueInLView[T_HOST] : getTNode(lView[TVIEW], nodeIndex);\n        ngDevMode &&\n            assertEqual(tNode.index, nodeIndex, 'Expecting that TNode at index is same as index');\n        return buildDebugNode(tNode, lView);\n    }\n    return null;\n}\n/**\n * Retrieve the component `LView` from component/element.\n *\n * NOTE: `LView` is a private and should not be leaked outside.\n *       Don't export this method to `ng.*` on window.\n *\n * @param target DOM element or component instance for which to retrieve the LView.\n */\nfunction getComponentLView(target) {\n    const lContext = getLContext(target);\n    const nodeIndx = lContext.nodeIndex;\n    const lView = lContext.lView;\n    ngDevMode && assertLView(lView);\n    const componentLView = lView[nodeIndx];\n    ngDevMode && assertLView(componentLView);\n    return componentLView;\n}\n/** Asserts that a value is a DOM Element. */\nfunction assertDomElement(value) {\n    if (typeof Element !== 'undefined' && !(value instanceof Element)) {\n        throw new Error('Expecting instance of DOM Element');\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Marks a component for check (in case of OnPush components) and synchronously\n * performs change detection on the application this component belongs to.\n *\n * @param component Component to {@link ChangeDetectorRef#markForCheck mark for check}.\n *\n * @publicApi\n * @globalApi ng\n */\nfunction applyChanges(component) {\n    markDirty(component);\n    getRootComponents(component).forEach(rootComponent => detectChanges(rootComponent));\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * This file introduces series of globally accessible debug tools\n * to allow for the Angular debugging story to function.\n *\n * To see this in action run the following command:\n *\n *   bazel run //packages/core/test/bundling/todo:devserver\n *\n *  Then load `localhost:5432` and start using the console tools.\n */\n/**\n * This value reflects the property on the window where the dev\n * tools are patched (window.ng).\n * */\nconst GLOBAL_PUBLISH_EXPANDO_KEY = 'ng';\nlet _published = false;\n/**\n * Publishes a collection of default debug tools onto`window.ng`.\n *\n * These functions are available globally when Angular is in development\n * mode and are automatically stripped away from prod mode is on.\n */\nfunction publishDefaultGlobalUtils() {\n    if (!_published) {\n        _published = true;\n        /**\n         * Warning: this function is *INTERNAL* and should not be relied upon in application's code.\n         * The contract of the function might be changed in any release and/or the function can be\n         * removed completely.\n         */\n        publishGlobalUtil('ɵsetProfiler', setProfiler);\n        publishGlobalUtil('getDirectiveMetadata', getDirectiveMetadata);\n        publishGlobalUtil('getComponent', getComponent$1);\n        publishGlobalUtil('getContext', getContext);\n        publishGlobalUtil('getListeners', getListeners);\n        publishGlobalUtil('getOwningComponent', getOwningComponent);\n        publishGlobalUtil('getHostElement', getHostElement);\n        publishGlobalUtil('getInjector', getInjector);\n        publishGlobalUtil('getRootComponents', getRootComponents);\n        publishGlobalUtil('getDirectives', getDirectives);\n        publishGlobalUtil('applyChanges', applyChanges);\n    }\n}\n/**\n * Publishes the given function to `window.ng` so that it can be\n * used from the browser console when an application is not in production.\n */\nfunction publishGlobalUtil(name, fn) {\n    if (typeof COMPILED === 'undefined' || !COMPILED) {\n        // Note: we can't export `ng` when using closure enhanced optimization as:\n        // - closure declares globals itself for minified names, which sometimes clobber our `ng` global\n        // - we can't declare a closure extern as the namespace `ng` is already used within Google\n        //   for typings for AngularJS (via `goog.provide('ng....')`).\n        const w = _global$1;\n        ngDevMode && assertDefined(fn, 'function not defined');\n        if (w) {\n            let container = w[GLOBAL_PUBLISH_EXPANDO_KEY];\n            if (!container) {\n                container = w[GLOBAL_PUBLISH_EXPANDO_KEY] = {};\n            }\n            container[name] = fn;\n        }\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// TODO: A hack to not pull in the NullInjector from @angular/core.\nconst NULL_INJECTOR = {\n    get: (token, notFoundValue) => {\n        throwProviderNotFoundError(token, 'NullInjector');\n    }\n};\n/**\n * Bootstraps a Component into an existing host element and returns an instance\n * of the component.\n *\n * Use this function to bootstrap a component into the DOM tree. Each invocation\n * of this function will create a separate tree of components, injectors and\n * change detection cycles and lifetimes. To dynamically insert a new component\n * into an existing tree such that it shares the same injection, change detection\n * and object lifetime, use {@link ViewContainer#createComponent}.\n *\n * @param componentType Component to bootstrap\n * @param options Optional parameters which control bootstrapping\n */\nfunction renderComponent(componentType /* Type as workaround for: Microsoft/TypeScript/issues/4881 */, opts = {}) {\n    ngDevMode && publishDefaultGlobalUtils();\n    ngDevMode && assertComponentType(componentType);\n    const rendererFactory = opts.rendererFactory || domRendererFactory3;\n    const sanitizer = opts.sanitizer || null;\n    const componentDef = getComponentDef$1(componentType);\n    if (componentDef.type != componentType)\n        componentDef.type = componentType;\n    // The first index of the first selector is the tag name.\n    const componentTag = componentDef.selectors[0][0];\n    const hostRenderer = rendererFactory.createRenderer(null, null);\n    const hostRNode = locateHostElement(hostRenderer, opts.host || componentTag, componentDef.encapsulation);\n    const rootFlags = componentDef.onPush ? 32 /* LViewFlags.Dirty */ | 256 /* LViewFlags.IsRoot */ :\n        16 /* LViewFlags.CheckAlways */ | 256 /* LViewFlags.IsRoot */;\n    const rootContext = createRootContext(opts.scheduler, opts.playerHandler);\n    const renderer = rendererFactory.createRenderer(hostRNode, componentDef);\n    const rootTView = createTView(0 /* TViewType.Root */, null, null, 1, 0, null, null, null, null, null);\n    const rootView = createLView(null, rootTView, rootContext, rootFlags, null, null, rendererFactory, renderer, null, opts.injector || null, null);\n    enterView(rootView);\n    let component;\n    try {\n        if (rendererFactory.begin)\n            rendererFactory.begin();\n        const componentView = createRootComponentView(hostRNode, componentDef, rootView, rendererFactory, renderer, sanitizer);\n        component = createRootComponent(componentView, componentDef, rootView, rootContext, opts.hostFeatures || null);\n        // create mode pass\n        renderView(rootTView, rootView, null);\n        // update mode pass\n        refreshView(rootTView, rootView, null, null);\n    }\n    finally {\n        leaveView();\n        if (rendererFactory.end)\n            rendererFactory.end();\n    }\n    return component;\n}\n/**\n * Creates the root component view and the root component node.\n *\n * @param rNode Render host element.\n * @param def ComponentDef\n * @param rootView The parent view where the host node is stored\n * @param rendererFactory Factory to be used for creating child renderers.\n * @param hostRenderer The current renderer\n * @param sanitizer The sanitizer, if provided\n *\n * @returns Component view created\n */\nfunction createRootComponentView(rNode, def, rootView, rendererFactory, hostRenderer, sanitizer) {\n    const tView = rootView[TVIEW];\n    const index = HEADER_OFFSET;\n    ngDevMode && assertIndexInRange(rootView, index);\n    rootView[index] = rNode;\n    // '#host' is added here as we don't know the real host DOM name (we don't want to read it) and at\n    // the same time we want to communicate the debug `TNode` that this is a special `TNode`\n    // representing a host element.\n    const tNode = getOrCreateTNode(tView, index, 2 /* TNodeType.Element */, '#host', null);\n    const mergedAttrs = tNode.mergedAttrs = def.hostAttrs;\n    if (mergedAttrs !== null) {\n        computeStaticStyling(tNode, mergedAttrs, true);\n        if (rNode !== null) {\n            setUpAttributes(hostRenderer, rNode, mergedAttrs);\n            if (tNode.classes !== null) {\n                writeDirectClass(hostRenderer, rNode, tNode.classes);\n            }\n            if (tNode.styles !== null) {\n                writeDirectStyle(hostRenderer, rNode, tNode.styles);\n            }\n        }\n    }\n    const viewRenderer = rendererFactory.createRenderer(rNode, def);\n    const componentView = createLView(rootView, getOrCreateTComponentView(def), null, def.onPush ? 32 /* LViewFlags.Dirty */ : 16 /* LViewFlags.CheckAlways */, rootView[index], tNode, rendererFactory, viewRenderer, sanitizer || null, null, null);\n    if (tView.firstCreatePass) {\n        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, rootView), tView, def.type);\n        markAsComponentHost(tView, tNode);\n        initTNodeFlags(tNode, rootView.length, 1);\n    }\n    addToViewTree(rootView, componentView);\n    // Store component view at node index, with node as the HOST\n    return rootView[index] = componentView;\n}\n/**\n * Creates a root component and sets it up with features and host bindings. Shared by\n * renderComponent() and ViewContainerRef.createComponent().\n */\nfunction createRootComponent(componentView, componentDef, rootLView, rootContext, hostFeatures) {\n    const tView = rootLView[TVIEW];\n    // Create directive instance with factory() and store at next index in viewData\n    const component = instantiateRootComponent(tView, rootLView, componentDef);\n    rootContext.components.push(component);\n    componentView[CONTEXT] = component;\n    if (hostFeatures !== null) {\n        for (const feature of hostFeatures) {\n            feature(component, componentDef);\n        }\n    }\n    // We want to generate an empty QueryList for root content queries for backwards\n    // compatibility with ViewEngine.\n    if (componentDef.contentQueries) {\n        const tNode = getCurrentTNode();\n        ngDevMode && assertDefined(tNode, 'TNode expected');\n        componentDef.contentQueries(1 /* RenderFlags.Create */, component, tNode.directiveStart);\n    }\n    const rootTNode = getCurrentTNode();\n    ngDevMode && assertDefined(rootTNode, 'tNode should have been already created');\n    if (tView.firstCreatePass &&\n        (componentDef.hostBindings !== null || componentDef.hostAttrs !== null)) {\n        setSelectedIndex(rootTNode.index);\n        const rootTView = rootLView[TVIEW];\n        registerHostBindingOpCodes(rootTView, rootTNode, rootLView, rootTNode.directiveStart, rootTNode.directiveEnd, componentDef);\n        invokeHostBindingsInCreationMode(componentDef, component);\n    }\n    return component;\n}\nfunction createRootContext(scheduler, playerHandler) {\n    return {\n        components: [],\n        scheduler: scheduler || defaultScheduler,\n        clean: CLEAN_PROMISE,\n        playerHandler: playerHandler || null,\n        flags: 0 /* RootContextFlags.Empty */\n    };\n}\n/**\n * Used to enable lifecycle hooks on the root component.\n *\n * Include this feature when calling `renderComponent` if the root component\n * you are rendering has lifecycle hooks defined. Otherwise, the hooks won't\n * be called properly.\n *\n * Example:\n *\n * ```\n * renderComponent(AppComponent, {hostFeatures: [LifecycleHooksFeature]});\n * ```\n */\nfunction LifecycleHooksFeature() {\n    const tNode = getCurrentTNode();\n    ngDevMode && assertDefined(tNode, 'TNode is required');\n    registerPostOrderHooks(getLView()[TVIEW], tNode);\n}\n/**\n * Wait on component until it is rendered.\n *\n * This function returns a `Promise` which is resolved when the component's\n * change detection is executed. This is determined by finding the scheduler\n * associated with the `component`'s render tree and waiting until the scheduler\n * flushes. If nothing is scheduled, the function returns a resolved promise.\n *\n * Example:\n * ```\n * await whenRendered(myComponent);\n * ```\n *\n * @param component Component to wait upon\n * @returns Promise which resolves when the component is rendered.\n */\nfunction whenRendered(component) {\n    return getRootContext(component).clean;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction getSuperType(type) {\n    return Object.getPrototypeOf(type.prototype).constructor;\n}\n/**\n * Merges the definition from a super class to a sub class.\n * @param definition The definition that is a SubClass of another directive of component\n *\n * @codeGenApi\n */\nfunction ɵɵInheritDefinitionFeature(definition) {\n    let superType = getSuperType(definition.type);\n    let shouldInheritFields = true;\n    const inheritanceChain = [definition];\n    while (superType) {\n        let superDef = undefined;\n        if (isComponentDef(definition)) {\n            // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n            superDef = superType.ɵcmp || superType.ɵdir;\n        }\n        else {\n            if (superType.ɵcmp) {\n                throw new RuntimeError(903 /* RuntimeErrorCode.INVALID_INHERITANCE */, ngDevMode &&\n                    `Directives cannot inherit Components. Directive ${stringifyForError(definition.type)} is attempting to extend component ${stringifyForError(superType)}`);\n            }\n            // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n            superDef = superType.ɵdir;\n        }\n        if (superDef) {\n            if (shouldInheritFields) {\n                inheritanceChain.push(superDef);\n                // Some fields in the definition may be empty, if there were no values to put in them that\n                // would've justified object creation. Unwrap them if necessary.\n                const writeableDef = definition;\n                writeableDef.inputs = maybeUnwrapEmpty(definition.inputs);\n                writeableDef.declaredInputs = maybeUnwrapEmpty(definition.declaredInputs);\n                writeableDef.outputs = maybeUnwrapEmpty(definition.outputs);\n                // Merge hostBindings\n                const superHostBindings = superDef.hostBindings;\n                superHostBindings && inheritHostBindings(definition, superHostBindings);\n                // Merge queries\n                const superViewQuery = superDef.viewQuery;\n                const superContentQueries = superDef.contentQueries;\n                superViewQuery && inheritViewQuery(definition, superViewQuery);\n                superContentQueries && inheritContentQueries(definition, superContentQueries);\n                // Merge inputs and outputs\n                fillProperties(definition.inputs, superDef.inputs);\n                fillProperties(definition.declaredInputs, superDef.declaredInputs);\n                fillProperties(definition.outputs, superDef.outputs);\n                // Merge animations metadata.\n                // If `superDef` is a Component, the `data` field is present (defaults to an empty object).\n                if (isComponentDef(superDef) && superDef.data.animation) {\n                    // If super def is a Component, the `definition` is also a Component, since Directives can\n                    // not inherit Components (we throw an error above and cannot reach this code).\n                    const defData = definition.data;\n                    defData.animation = (defData.animation || []).concat(superDef.data.animation);\n                }\n            }\n            // Run parent features\n            const features = superDef.features;\n            if (features) {\n                for (let i = 0; i < features.length; i++) {\n                    const feature = features[i];\n                    if (feature && feature.ngInherit) {\n                        feature(definition);\n                    }\n                    // If `InheritDefinitionFeature` is a part of the current `superDef`, it means that this\n                    // def already has all the necessary information inherited from its super class(es), so we\n                    // can stop merging fields from super classes. However we need to iterate through the\n                    // prototype chain to look for classes that might contain other \"features\" (like\n                    // NgOnChanges), which we should invoke for the original `definition`. We set the\n                    // `shouldInheritFields` flag to indicate that, essentially skipping fields inheritance\n                    // logic and only invoking functions from the \"features\" list.\n                    if (feature === ɵɵInheritDefinitionFeature) {\n                        shouldInheritFields = false;\n                    }\n                }\n            }\n        }\n        superType = Object.getPrototypeOf(superType);\n    }\n    mergeHostAttrsAcrossInheritance(inheritanceChain);\n}\n/**\n * Merge the `hostAttrs` and `hostVars` from the inherited parent to the base class.\n *\n * @param inheritanceChain A list of `WritableDefs` starting at the top most type and listing\n * sub-types in order. For each type take the `hostAttrs` and `hostVars` and merge it with the child\n * type.\n */\nfunction mergeHostAttrsAcrossInheritance(inheritanceChain) {\n    let hostVars = 0;\n    let hostAttrs = null;\n    // We process the inheritance order from the base to the leaves here.\n    for (let i = inheritanceChain.length - 1; i >= 0; i--) {\n        const def = inheritanceChain[i];\n        // For each `hostVars`, we need to add the superclass amount.\n        def.hostVars = (hostVars += def.hostVars);\n        // for each `hostAttrs` we need to merge it with superclass.\n        def.hostAttrs =\n            mergeHostAttrs(def.hostAttrs, hostAttrs = mergeHostAttrs(hostAttrs, def.hostAttrs));\n    }\n}\nfunction maybeUnwrapEmpty(value) {\n    if (value === EMPTY_OBJ) {\n        return {};\n    }\n    else if (value === EMPTY_ARRAY) {\n        return [];\n    }\n    else {\n        return value;\n    }\n}\nfunction inheritViewQuery(definition, superViewQuery) {\n    const prevViewQuery = definition.viewQuery;\n    if (prevViewQuery) {\n        definition.viewQuery = (rf, ctx) => {\n            superViewQuery(rf, ctx);\n            prevViewQuery(rf, ctx);\n        };\n    }\n    else {\n        definition.viewQuery = superViewQuery;\n    }\n}\nfunction inheritContentQueries(definition, superContentQueries) {\n    const prevContentQueries = definition.contentQueries;\n    if (prevContentQueries) {\n        definition.contentQueries = (rf, ctx, directiveIndex) => {\n            superContentQueries(rf, ctx, directiveIndex);\n            prevContentQueries(rf, ctx, directiveIndex);\n        };\n    }\n    else {\n        definition.contentQueries = superContentQueries;\n    }\n}\nfunction inheritHostBindings(definition, superHostBindings) {\n    const prevHostBindings = definition.hostBindings;\n    if (prevHostBindings) {\n        definition.hostBindings = (rf, ctx) => {\n            superHostBindings(rf, ctx);\n            prevHostBindings(rf, ctx);\n        };\n    }\n    else {\n        definition.hostBindings = superHostBindings;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Fields which exist on either directive or component definitions, and need to be copied from\n * parent to child classes by the `ɵɵCopyDefinitionFeature`.\n */\nconst COPY_DIRECTIVE_FIELDS = [\n    // The child class should use the providers of its parent.\n    'providersResolver',\n    // Not listed here are any fields which are handled by the `ɵɵInheritDefinitionFeature`, such\n    // as inputs, outputs, and host binding functions.\n];\n/**\n * Fields which exist only on component definitions, and need to be copied from parent to child\n * classes by the `ɵɵCopyDefinitionFeature`.\n *\n * The type here allows any field of `ComponentDef` which is not also a property of `DirectiveDef`,\n * since those should go in `COPY_DIRECTIVE_FIELDS` above.\n */\nconst COPY_COMPONENT_FIELDS = [\n    // The child class should use the template function of its parent, including all template\n    // semantics.\n    'template',\n    'decls',\n    'consts',\n    'vars',\n    'onPush',\n    'ngContentSelectors',\n    // The child class should use the CSS styles of its parent, including all styling semantics.\n    'styles',\n    'encapsulation',\n    // The child class should be checked by the runtime in the same way as its parent.\n    'schemas',\n];\n/**\n * Copies the fields not handled by the `ɵɵInheritDefinitionFeature` from the supertype of a\n * definition.\n *\n * This exists primarily to support ngcc migration of an existing View Engine pattern, where an\n * entire decorator is inherited from a parent to a child class. When ngcc detects this case, it\n * generates a skeleton definition on the child class, and applies this feature.\n *\n * The `ɵɵCopyDefinitionFeature` then copies any needed fields from the parent class' definition,\n * including things like the component template function.\n *\n * @param definition The definition of a child class which inherits from a parent class with its\n * own definition.\n *\n * @codeGenApi\n */\nfunction ɵɵCopyDefinitionFeature(definition) {\n    let superType = getSuperType(definition.type);\n    let superDef = undefined;\n    if (isComponentDef(definition)) {\n        // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n        superDef = superType.ɵcmp;\n    }\n    else {\n        // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n        superDef = superType.ɵdir;\n    }\n    // Needed because `definition` fields are readonly.\n    const defAny = definition;\n    // Copy over any fields that apply to either directives or components.\n    for (const field of COPY_DIRECTIVE_FIELDS) {\n        defAny[field] = superDef[field];\n    }\n    if (isComponentDef(superDef)) {\n        // Copy over any component-specific fields.\n        for (const field of COPY_COMPONENT_FIELDS) {\n            defAny[field] = superDef[field];\n        }\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nlet _symbolIterator = null;\nfunction getSymbolIterator() {\n    if (!_symbolIterator) {\n        const Symbol = _global$1['Symbol'];\n        if (Symbol && Symbol.iterator) {\n            _symbolIterator = Symbol.iterator;\n        }\n        else {\n            // es6-shim specific logic\n            const keys = Object.getOwnPropertyNames(Map.prototype);\n            for (let i = 0; i < keys.length; ++i) {\n                const key = keys[i];\n                if (key !== 'entries' && key !== 'size' &&\n                    Map.prototype[key] === Map.prototype['entries']) {\n                    _symbolIterator = key;\n                }\n            }\n        }\n    }\n    return _symbolIterator;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction isIterable(obj) {\n    return obj !== null && typeof obj === 'object' && obj[getSymbolIterator()] !== undefined;\n}\nfunction isListLikeIterable(obj) {\n    if (!isJsObject(obj))\n        return false;\n    return Array.isArray(obj) ||\n        (!(obj instanceof Map) && // JS Map are iterables but return entries as [k, v]\n            getSymbolIterator() in obj); // JS Iterable have a Symbol.iterator prop\n}\nfunction areIterablesEqual(a, b, comparator) {\n    const iterator1 = a[getSymbolIterator()]();\n    const iterator2 = b[getSymbolIterator()]();\n    while (true) {\n        const item1 = iterator1.next();\n        const item2 = iterator2.next();\n        if (item1.done && item2.done)\n            return true;\n        if (item1.done || item2.done)\n            return false;\n        if (!comparator(item1.value, item2.value))\n            return false;\n    }\n}\nfunction iterateListLike(obj, fn) {\n    if (Array.isArray(obj)) {\n        for (let i = 0; i < obj.length; i++) {\n            fn(obj[i]);\n        }\n    }\n    else {\n        const iterator = obj[getSymbolIterator()]();\n        let item;\n        while (!((item = iterator.next()).done)) {\n            fn(item.value);\n        }\n    }\n}\nfunction isJsObject(o) {\n    return o !== null && (typeof o === 'function' || typeof o === 'object');\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction devModeEqual(a, b) {\n    const isListLikeIterableA = isListLikeIterable(a);\n    const isListLikeIterableB = isListLikeIterable(b);\n    if (isListLikeIterableA && isListLikeIterableB) {\n        return areIterablesEqual(a, b, devModeEqual);\n    }\n    else {\n        const isAObject = a && (typeof a === 'object' || typeof a === 'function');\n        const isBObject = b && (typeof b === 'object' || typeof b === 'function');\n        if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {\n            return true;\n        }\n        else {\n            return Object.is(a, b);\n        }\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// TODO(misko): consider inlining\n/** Updates binding and returns the value. */\nfunction updateBinding(lView, bindingIndex, value) {\n    return lView[bindingIndex] = value;\n}\n/** Gets the current binding value. */\nfunction getBinding(lView, bindingIndex) {\n    ngDevMode && assertIndexInRange(lView, bindingIndex);\n    ngDevMode &&\n        assertNotSame(lView[bindingIndex], NO_CHANGE, 'Stored value should never be NO_CHANGE.');\n    return lView[bindingIndex];\n}\n/**\n * Updates binding if changed, then returns whether it was updated.\n *\n * This function also checks the `CheckNoChangesMode` and throws if changes are made.\n * Some changes (Objects/iterables) during `CheckNoChangesMode` are exempt to comply with VE\n * behavior.\n *\n * @param lView current `LView`\n * @param bindingIndex The binding in the `LView` to check\n * @param value New value to check against `lView[bindingIndex]`\n * @returns `true` if the bindings has changed. (Throws if binding has changed during\n *          `CheckNoChangesMode`)\n */\nfunction bindingUpdated(lView, bindingIndex, value) {\n    ngDevMode && assertNotSame(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');\n    ngDevMode &&\n        assertLessThan(bindingIndex, lView.length, `Slot should have been initialized to NO_CHANGE`);\n    const oldValue = lView[bindingIndex];\n    if (Object.is(oldValue, value)) {\n        return false;\n    }\n    else {\n        if (ngDevMode && isInCheckNoChangesMode()) {\n            // View engine didn't report undefined values as changed on the first checkNoChanges pass\n            // (before the change detection was run).\n            const oldValueToCompare = oldValue !== NO_CHANGE ? oldValue : undefined;\n            if (!devModeEqual(oldValueToCompare, value)) {\n                const details = getExpressionChangedErrorDetails(lView, bindingIndex, oldValueToCompare, value);\n                throwErrorIfNoChangesMode(oldValue === NO_CHANGE, details.oldValue, details.newValue, details.propName);\n            }\n            // There was a change, but the `devModeEqual` decided that the change is exempt from an error.\n            // For this reason we exit as if no change. The early exit is needed to prevent the changed\n            // value to be written into `LView` (If we would write the new value that we would not see it\n            // as change on next CD.)\n            return false;\n        }\n        lView[bindingIndex] = value;\n        return true;\n    }\n}\n/** Updates 2 bindings if changed, then returns whether either was updated. */\nfunction bindingUpdated2(lView, bindingIndex, exp1, exp2) {\n    const different = bindingUpdated(lView, bindingIndex, exp1);\n    return bindingUpdated(lView, bindingIndex + 1, exp2) || different;\n}\n/** Updates 3 bindings if changed, then returns whether any was updated. */\nfunction bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) {\n    const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);\n    return bindingUpdated(lView, bindingIndex + 2, exp3) || different;\n}\n/** Updates 4 bindings if changed, then returns whether any was updated. */\nfunction bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) {\n    const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);\n    return bindingUpdated2(lView, bindingIndex + 2, exp3, exp4) || different;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Updates the value of or removes a bound attribute on an Element.\n *\n * Used in the case of `[attr.title]=\"value\"`\n *\n * @param name name The name of the attribute.\n * @param value value The attribute is removed when value is `null` or `undefined`.\n *                  Otherwise the attribute value is set to the stringified value.\n * @param sanitizer An optional function used to sanitize the value.\n * @param namespace Optional namespace to use when setting the attribute.\n *\n * @codeGenApi\n */\nfunction ɵɵattribute(name, value, sanitizer, namespace) {\n    const lView = getLView();\n    const bindingIndex = nextBindingIndex();\n    if (bindingUpdated(lView, bindingIndex, value)) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace);\n        ngDevMode && storePropertyBindingMetadata(tView.data, tNode, 'attr.' + name, bindingIndex);\n    }\n    return ɵɵattribute;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Create interpolation bindings with a variable number of expressions.\n *\n * If there are 1 to 8 expressions `interpolation1()` to `interpolation8()` should be used instead.\n * Those are faster because there is no need to create an array of expressions and iterate over it.\n *\n * `values`:\n * - has static text at even indexes,\n * - has evaluated expressions at odd indexes.\n *\n * Returns the concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nfunction interpolationV(lView, values) {\n    ngDevMode && assertLessThan(2, values.length, 'should have at least 3 values');\n    ngDevMode && assertEqual(values.length % 2, 1, 'should have an odd number of values');\n    let isBindingUpdated = false;\n    let bindingIndex = getBindingIndex();\n    for (let i = 1; i < values.length; i += 2) {\n        // Check if bindings (odd indexes) have changed\n        isBindingUpdated = bindingUpdated(lView, bindingIndex++, values[i]) || isBindingUpdated;\n    }\n    setBindingIndex(bindingIndex);\n    if (!isBindingUpdated) {\n        return NO_CHANGE;\n    }\n    // Build the updated content\n    let content = values[0];\n    for (let i = 1; i < values.length; i += 2) {\n        content += renderStringify(values[i]) + values[i + 1];\n    }\n    return content;\n}\n/**\n * Creates an interpolation binding with 1 expression.\n *\n * @param prefix static value used for concatenation only.\n * @param v0 value checked for change.\n * @param suffix static value used for concatenation only.\n */\nfunction interpolation1(lView, prefix, v0, suffix) {\n    const different = bindingUpdated(lView, nextBindingIndex(), v0);\n    return different ? prefix + renderStringify(v0) + suffix : NO_CHANGE;\n}\n/**\n * Creates an interpolation binding with 2 expressions.\n */\nfunction interpolation2(lView, prefix, v0, i0, v1, suffix) {\n    const bindingIndex = getBindingIndex();\n    const different = bindingUpdated2(lView, bindingIndex, v0, v1);\n    incrementBindingIndex(2);\n    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + suffix : NO_CHANGE;\n}\n/**\n * Creates an interpolation binding with 3 expressions.\n */\nfunction interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix) {\n    const bindingIndex = getBindingIndex();\n    const different = bindingUpdated3(lView, bindingIndex, v0, v1, v2);\n    incrementBindingIndex(3);\n    return different ?\n        prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + suffix :\n        NO_CHANGE;\n}\n/**\n * Create an interpolation binding with 4 expressions.\n */\nfunction interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {\n    const bindingIndex = getBindingIndex();\n    const different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n    incrementBindingIndex(4);\n    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 +\n        renderStringify(v2) + i2 + renderStringify(v3) + suffix :\n        NO_CHANGE;\n}\n/**\n * Creates an interpolation binding with 5 expressions.\n */\nfunction interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {\n    const bindingIndex = getBindingIndex();\n    let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n    different = bindingUpdated(lView, bindingIndex + 4, v4) || different;\n    incrementBindingIndex(5);\n    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 +\n        renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + suffix :\n        NO_CHANGE;\n}\n/**\n * Creates an interpolation binding with 6 expressions.\n */\nfunction interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {\n    const bindingIndex = getBindingIndex();\n    let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n    different = bindingUpdated2(lView, bindingIndex + 4, v4, v5) || different;\n    incrementBindingIndex(6);\n    return different ?\n        prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 +\n            renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + suffix :\n        NO_CHANGE;\n}\n/**\n * Creates an interpolation binding with 7 expressions.\n */\nfunction interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {\n    const bindingIndex = getBindingIndex();\n    let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n    different = bindingUpdated3(lView, bindingIndex + 4, v4, v5, v6) || different;\n    incrementBindingIndex(7);\n    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 +\n        renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 +\n        renderStringify(v5) + i5 + renderStringify(v6) + suffix :\n        NO_CHANGE;\n}\n/**\n * Creates an interpolation binding with 8 expressions.\n */\nfunction interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {\n    const bindingIndex = getBindingIndex();\n    let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n    different = bindingUpdated4(lView, bindingIndex + 4, v4, v5, v6, v7) || different;\n    incrementBindingIndex(8);\n    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 +\n        renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 +\n        renderStringify(v5) + i5 + renderStringify(v6) + i6 + renderStringify(v7) + suffix :\n        NO_CHANGE;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate1('title', 'prefix', v0, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵattributeInterpolate1(attrName, prefix, v0, suffix, sanitizer, namespace) {\n    const lView = getLView();\n    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tNode = getSelectedTNode();\n        elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n        ngDevMode &&\n            storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 1, prefix, suffix);\n    }\n    return ɵɵattributeInterpolate1;\n}\n/**\n *\n * Update an interpolated attribute on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate2('title', 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵattributeInterpolate2(attrName, prefix, v0, i0, v1, suffix, sanitizer, namespace) {\n    const lView = getLView();\n    const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tNode = getSelectedTNode();\n        elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n        ngDevMode &&\n            storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 2, prefix, i0, suffix);\n    }\n    return ɵɵattributeInterpolate2;\n}\n/**\n *\n * Update an interpolated attribute on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate3(\n * 'title', 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵattributeInterpolate3(attrName, prefix, v0, i0, v1, i1, v2, suffix, sanitizer, namespace) {\n    const lView = getLView();\n    const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tNode = getSelectedTNode();\n        elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n        ngDevMode &&\n            storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 3, prefix, i0, i1, suffix);\n    }\n    return ɵɵattributeInterpolate3;\n}\n/**\n *\n * Update an interpolated attribute on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate4(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵattributeInterpolate4(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, sanitizer, namespace) {\n    const lView = getLView();\n    const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tNode = getSelectedTNode();\n        elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n        ngDevMode &&\n            storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 4, prefix, i0, i1, i2, suffix);\n    }\n    return ɵɵattributeInterpolate4;\n}\n/**\n *\n * Update an interpolated attribute on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate5(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵattributeInterpolate5(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, sanitizer, namespace) {\n    const lView = getLView();\n    const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tNode = getSelectedTNode();\n        elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n        ngDevMode &&\n            storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 5, prefix, i0, i1, i2, i3, suffix);\n    }\n    return ɵɵattributeInterpolate5;\n}\n/**\n *\n * Update an interpolated attribute on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate6(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵattributeInterpolate6(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, sanitizer, namespace) {\n    const lView = getLView();\n    const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tNode = getSelectedTNode();\n        elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n        ngDevMode &&\n            storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 6, prefix, i0, i1, i2, i3, i4, suffix);\n    }\n    return ɵɵattributeInterpolate6;\n}\n/**\n *\n * Update an interpolated attribute on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate7(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵattributeInterpolate7(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer, namespace) {\n    const lView = getLView();\n    const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tNode = getSelectedTNode();\n        elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n        ngDevMode &&\n            storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 7, prefix, i0, i1, i2, i3, i4, i5, suffix);\n    }\n    return ɵɵattributeInterpolate7;\n}\n/**\n *\n * Update an interpolated attribute on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolate8(\n *  'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵattributeInterpolate8(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer, namespace) {\n    const lView = getLView();\n    const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tNode = getSelectedTNode();\n        elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n        ngDevMode &&\n            storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 8, prefix, i0, i1, i2, i3, i4, i5, i6, suffix);\n    }\n    return ɵɵattributeInterpolate8;\n}\n/**\n * Update an interpolated attribute on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵattributeInterpolateV(\n *  'title', ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * @param attrName The name of the attribute to update.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵattributeInterpolateV(attrName, values, sanitizer, namespace) {\n    const lView = getLView();\n    const interpolated = interpolationV(lView, values);\n    if (interpolated !== NO_CHANGE) {\n        const tNode = getSelectedTNode();\n        elementAttributeInternal(tNode, lView, attrName, interpolated, sanitizer, namespace);\n        if (ngDevMode) {\n            const interpolationInBetween = [values[0]]; // prefix\n            for (let i = 2; i < values.length; i += 2) {\n                interpolationInBetween.push(values[i]);\n            }\n            storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);\n        }\n    }\n    return ɵɵattributeInterpolateV;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction templateFirstCreatePass(index, tView, lView, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex) {\n    ngDevMode && assertFirstCreatePass(tView);\n    ngDevMode && ngDevMode.firstCreatePass++;\n    const tViewConsts = tView.consts;\n    // TODO(pk): refactor getOrCreateTNode to have the \"create\" only version\n    const tNode = getOrCreateTNode(tView, index, 4 /* TNodeType.Container */, tagName || null, getConstant(tViewConsts, attrsIndex));\n    resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex));\n    registerPostOrderHooks(tView, tNode);\n    const embeddedTView = tNode.tViews = createTView(2 /* TViewType.Embedded */, tNode, templateFn, decls, vars, tView.directiveRegistry, tView.pipeRegistry, null, tView.schemas, tViewConsts);\n    if (tView.queries !== null) {\n        tView.queries.template(tView, tNode);\n        embeddedTView.queries = tView.queries.embeddedTView(tNode);\n    }\n    return tNode;\n}\n/**\n * Creates an LContainer for an ng-template (dynamically-inserted view), e.g.\n *\n * <ng-template #foo>\n *    <div></div>\n * </ng-template>\n *\n * @param index The index of the container in the data array\n * @param templateFn Inline template\n * @param decls The number of nodes, local refs, and pipes for this template\n * @param vars The number of bindings for this template\n * @param tagName The name of the container element, if applicable\n * @param attrsIndex Index of template attributes in the `consts` array.\n * @param localRefs Index of the local references in the `consts` array.\n * @param localRefExtractor A function which extracts local-refs values from the template.\n *        Defaults to the current element associated with the local-ref.\n *\n * @codeGenApi\n */\nfunction ɵɵtemplate(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {\n    const lView = getLView();\n    const tView = getTView();\n    const adjustedIndex = index + HEADER_OFFSET;\n    const tNode = tView.firstCreatePass ? templateFirstCreatePass(adjustedIndex, tView, lView, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex) :\n        tView.data[adjustedIndex];\n    setCurrentTNode(tNode, false);\n    const comment = lView[RENDERER].createComment(ngDevMode ? 'container' : '');\n    appendChild(tView, lView, comment, tNode);\n    attachPatchData(comment, lView);\n    addToViewTree(lView, lView[adjustedIndex] = createLContainer(comment, lView, comment, tNode));\n    if (isDirectiveHost(tNode)) {\n        createDirectivesInstances(tView, lView, tNode);\n    }\n    if (localRefsIndex != null) {\n        saveResolvedLocalsInData(lView, tNode, localRefExtractor);\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Store a value in the `data` at a given `index`. */\nfunction store(tView, lView, index, value) {\n    // We don't store any static data for local variables, so the first time\n    // we see the template, we should store as null to avoid a sparse array\n    if (index >= tView.data.length) {\n        tView.data[index] = null;\n        tView.blueprint[index] = null;\n    }\n    lView[index] = value;\n}\n/**\n * Retrieves a local reference from the current contextViewData.\n *\n * If the reference to retrieve is in a parent view, this instruction is used in conjunction\n * with a nextContext() call, which walks up the tree and updates the contextViewData instance.\n *\n * @param index The index of the local ref in contextViewData.\n *\n * @codeGenApi\n */\nfunction ɵɵreference(index) {\n    const contextLView = getContextLView();\n    return load(contextLView, HEADER_OFFSET + index);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Update a property on a selected element.\n *\n * Operates on the element selected by index via the {@link select} instruction.\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled\n *\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n * @returns This function returns itself so that it may be chained\n * (e.g. `property('name', ctx.name)('title', ctx.title)`)\n *\n * @codeGenApi\n */\nfunction ɵɵproperty(propName, value, sanitizer) {\n    const lView = getLView();\n    const bindingIndex = nextBindingIndex();\n    if (bindingUpdated(lView, bindingIndex, value)) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, false);\n        ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);\n    }\n    return ɵɵproperty;\n}\n/**\n * Given `<div style=\"...\" my-dir>` and `MyDir` with `@Input('style')` we need to write to\n * directive input.\n */\nfunction setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased) {\n    const inputs = tNode.inputs;\n    const property = isClassBased ? 'class' : 'style';\n    // We support both 'class' and `className` hence the fallback.\n    setInputsForProperty(tView, lView, inputs[property], property, value);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction elementStartFirstCreatePass(index, tView, lView, native, name, attrsIndex, localRefsIndex) {\n    ngDevMode && assertFirstCreatePass(tView);\n    ngDevMode && ngDevMode.firstCreatePass++;\n    const tViewConsts = tView.consts;\n    const attrs = getConstant(tViewConsts, attrsIndex);\n    const tNode = getOrCreateTNode(tView, index, 2 /* TNodeType.Element */, name, attrs);\n    const hasDirectives = resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex));\n    if (ngDevMode) {\n        validateElementIsKnown(native, lView, tNode.value, tView.schemas, hasDirectives);\n    }\n    if (tNode.attrs !== null) {\n        computeStaticStyling(tNode, tNode.attrs, false);\n    }\n    if (tNode.mergedAttrs !== null) {\n        computeStaticStyling(tNode, tNode.mergedAttrs, true);\n    }\n    if (tView.queries !== null) {\n        tView.queries.elementStart(tView, tNode);\n    }\n    return tNode;\n}\n/**\n * Create DOM element. The instruction must later be followed by `elementEnd()` call.\n *\n * @param index Index of the element in the LView array\n * @param name Name of the DOM Node\n * @param attrsIndex Index of the element's attributes in the `consts` array.\n * @param localRefsIndex Index of the element's local references in the `consts` array.\n * @returns This function returns itself so that it may be chained.\n *\n * Attributes and localRefs are passed as an array of strings where elements with an even index\n * hold an attribute name and elements with an odd index hold an attribute value, ex.:\n * ['id', 'warning5', 'class', 'alert']\n *\n * @codeGenApi\n */\nfunction ɵɵelementStart(index, name, attrsIndex, localRefsIndex) {\n    const lView = getLView();\n    const tView = getTView();\n    const adjustedIndex = HEADER_OFFSET + index;\n    ngDevMode &&\n        assertEqual(getBindingIndex(), tView.bindingStartIndex, 'elements should be created before any bindings');\n    ngDevMode && assertIndexInRange(lView, adjustedIndex);\n    const renderer = lView[RENDERER];\n    const native = lView[adjustedIndex] = createElementNode(renderer, name, getNamespace$1());\n    const tNode = tView.firstCreatePass ?\n        elementStartFirstCreatePass(adjustedIndex, tView, lView, native, name, attrsIndex, localRefsIndex) :\n        tView.data[adjustedIndex];\n    setCurrentTNode(tNode, true);\n    const mergedAttrs = tNode.mergedAttrs;\n    if (mergedAttrs !== null) {\n        setUpAttributes(renderer, native, mergedAttrs);\n    }\n    const classes = tNode.classes;\n    if (classes !== null) {\n        writeDirectClass(renderer, native, classes);\n    }\n    const styles = tNode.styles;\n    if (styles !== null) {\n        writeDirectStyle(renderer, native, styles);\n    }\n    if ((tNode.flags & 64 /* TNodeFlags.isDetached */) !== 64 /* TNodeFlags.isDetached */) {\n        // In the i18n case, the translation may have removed this element, so only add it if it is not\n        // detached. See `TNodeType.Placeholder` and `LFrame.inI18n` for more context.\n        appendChild(tView, lView, native, tNode);\n    }\n    // any immediate children of a component or template container must be pre-emptively\n    // monkey-patched with the component view data so that the element can be inspected\n    // later on using any element discovery utility methods (see `element_discovery.ts`)\n    if (getElementDepthCount() === 0) {\n        attachPatchData(native, lView);\n    }\n    increaseElementDepthCount();\n    if (isDirectiveHost(tNode)) {\n        createDirectivesInstances(tView, lView, tNode);\n        executeContentQueries(tView, tNode, lView);\n    }\n    if (localRefsIndex !== null) {\n        saveResolvedLocalsInData(lView, tNode);\n    }\n    return ɵɵelementStart;\n}\n/**\n * Mark the end of the element.\n * @returns This function returns itself so that it may be chained.\n *\n * @codeGenApi\n */\nfunction ɵɵelementEnd() {\n    let currentTNode = getCurrentTNode();\n    ngDevMode && assertDefined(currentTNode, 'No parent node to close.');\n    if (isCurrentTNodeParent()) {\n        setCurrentTNodeAsNotParent();\n    }\n    else {\n        ngDevMode && assertHasParent(getCurrentTNode());\n        currentTNode = currentTNode.parent;\n        setCurrentTNode(currentTNode, false);\n    }\n    const tNode = currentTNode;\n    ngDevMode && assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */);\n    decreaseElementDepthCount();\n    const tView = getTView();\n    if (tView.firstCreatePass) {\n        registerPostOrderHooks(tView, currentTNode);\n        if (isContentQueryHost(currentTNode)) {\n            tView.queries.elementEnd(currentTNode);\n        }\n    }\n    if (tNode.classesWithoutHost != null && hasClassInput(tNode)) {\n        setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.classesWithoutHost, true);\n    }\n    if (tNode.stylesWithoutHost != null && hasStyleInput(tNode)) {\n        setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.stylesWithoutHost, false);\n    }\n    return ɵɵelementEnd;\n}\n/**\n * Creates an empty element using {@link elementStart} and {@link elementEnd}\n *\n * @param index Index of the element in the data array\n * @param name Name of the DOM Node\n * @param attrsIndex Index of the element's attributes in the `consts` array.\n * @param localRefsIndex Index of the element's local references in the `consts` array.\n * @returns This function returns itself so that it may be chained.\n *\n * @codeGenApi\n */\nfunction ɵɵelement(index, name, attrsIndex, localRefsIndex) {\n    ɵɵelementStart(index, name, attrsIndex, localRefsIndex);\n    ɵɵelementEnd();\n    return ɵɵelement;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction elementContainerStartFirstCreatePass(index, tView, lView, attrsIndex, localRefsIndex) {\n    ngDevMode && ngDevMode.firstCreatePass++;\n    const tViewConsts = tView.consts;\n    const attrs = getConstant(tViewConsts, attrsIndex);\n    const tNode = getOrCreateTNode(tView, index, 8 /* TNodeType.ElementContainer */, 'ng-container', attrs);\n    // While ng-container doesn't necessarily support styling, we use the style context to identify\n    // and execute directives on the ng-container.\n    if (attrs !== null) {\n        computeStaticStyling(tNode, attrs, true);\n    }\n    const localRefs = getConstant(tViewConsts, localRefsIndex);\n    resolveDirectives(tView, lView, tNode, localRefs);\n    if (tView.queries !== null) {\n        tView.queries.elementStart(tView, tNode);\n    }\n    return tNode;\n}\n/**\n * Creates a logical container for other nodes (<ng-container>) backed by a comment node in the DOM.\n * The instruction must later be followed by `elementContainerEnd()` call.\n *\n * @param index Index of the element in the LView array\n * @param attrsIndex Index of the container attributes in the `consts` array.\n * @param localRefsIndex Index of the container's local references in the `consts` array.\n * @returns This function returns itself so that it may be chained.\n *\n * Even if this instruction accepts a set of attributes no actual attribute values are propagated to\n * the DOM (as a comment node can't have attributes). Attributes are here only for directive\n * matching purposes and setting initial inputs of directives.\n *\n * @codeGenApi\n */\nfunction ɵɵelementContainerStart(index, attrsIndex, localRefsIndex) {\n    const lView = getLView();\n    const tView = getTView();\n    const adjustedIndex = index + HEADER_OFFSET;\n    ngDevMode && assertIndexInRange(lView, adjustedIndex);\n    ngDevMode &&\n        assertEqual(getBindingIndex(), tView.bindingStartIndex, 'element containers should be created before any bindings');\n    const tNode = tView.firstCreatePass ?\n        elementContainerStartFirstCreatePass(adjustedIndex, tView, lView, attrsIndex, localRefsIndex) :\n        tView.data[adjustedIndex];\n    setCurrentTNode(tNode, true);\n    ngDevMode && ngDevMode.rendererCreateComment++;\n    const native = lView[adjustedIndex] =\n        lView[RENDERER].createComment(ngDevMode ? 'ng-container' : '');\n    appendChild(tView, lView, native, tNode);\n    attachPatchData(native, lView);\n    if (isDirectiveHost(tNode)) {\n        createDirectivesInstances(tView, lView, tNode);\n        executeContentQueries(tView, tNode, lView);\n    }\n    if (localRefsIndex != null) {\n        saveResolvedLocalsInData(lView, tNode);\n    }\n    return ɵɵelementContainerStart;\n}\n/**\n * Mark the end of the <ng-container>.\n * @returns This function returns itself so that it may be chained.\n *\n * @codeGenApi\n */\nfunction ɵɵelementContainerEnd() {\n    let currentTNode = getCurrentTNode();\n    const tView = getTView();\n    if (isCurrentTNodeParent()) {\n        setCurrentTNodeAsNotParent();\n    }\n    else {\n        ngDevMode && assertHasParent(currentTNode);\n        currentTNode = currentTNode.parent;\n        setCurrentTNode(currentTNode, false);\n    }\n    ngDevMode && assertTNodeType(currentTNode, 8 /* TNodeType.ElementContainer */);\n    if (tView.firstCreatePass) {\n        registerPostOrderHooks(tView, currentTNode);\n        if (isContentQueryHost(currentTNode)) {\n            tView.queries.elementEnd(currentTNode);\n        }\n    }\n    return ɵɵelementContainerEnd;\n}\n/**\n * Creates an empty logical container using {@link elementContainerStart}\n * and {@link elementContainerEnd}\n *\n * @param index Index of the element in the LView array\n * @param attrsIndex Index of the container attributes in the `consts` array.\n * @param localRefsIndex Index of the container's local references in the `consts` array.\n * @returns This function returns itself so that it may be chained.\n *\n * @codeGenApi\n */\nfunction ɵɵelementContainer(index, attrsIndex, localRefsIndex) {\n    ɵɵelementContainerStart(index, attrsIndex, localRefsIndex);\n    ɵɵelementContainerEnd();\n    return ɵɵelementContainer;\n}\n\n/**\n * Returns the current OpaqueViewState instance.\n *\n * Used in conjunction with the restoreView() instruction to save a snapshot\n * of the current view and restore it when listeners are invoked. This allows\n * walking the declaration view tree in listeners to get vars from parent views.\n *\n * @codeGenApi\n */\nfunction ɵɵgetCurrentView() {\n    return getLView();\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Determine if the argument is shaped like a Promise\n */\nfunction isPromise(obj) {\n    // allow any Promise/A+ compliant thenable.\n    // It's up to the caller to ensure that obj.then conforms to the spec\n    return !!obj && typeof obj.then === 'function';\n}\n/**\n * Determine if the argument is a Subscribable\n */\nfunction isSubscribable(obj) {\n    return !!obj && typeof obj.subscribe === 'function';\n}\n/**\n * Determine if the argument is an Observable\n *\n * Strictly this tests that the `obj` is `Subscribable`, since `Observable`\n * types need additional methods, such as `lift()`. But it is adequate for our\n * needs since within the Angular framework code we only ever need to use the\n * `subscribe()` method, and RxJS has mechanisms to wrap `Subscribable` objects\n * into `Observable` as needed.\n */\nconst isObservable = isSubscribable;\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Adds an event listener to the current node.\n *\n * If an output exists on one of the node's directives, it also subscribes to the output\n * and saves the subscription for later cleanup.\n *\n * @param eventName Name of the event\n * @param listenerFn The function to be called when event emits\n * @param useCapture Whether or not to use capture in event listener\n * @param eventTargetResolver Function that returns global target information in case this listener\n * should be attached to a global object like window, document or body\n *\n * @codeGenApi\n */\nfunction ɵɵlistener(eventName, listenerFn, useCapture, eventTargetResolver) {\n    const lView = getLView();\n    const tView = getTView();\n    const tNode = getCurrentTNode();\n    listenerInternal(tView, lView, lView[RENDERER], tNode, eventName, listenerFn, !!useCapture, eventTargetResolver);\n    return ɵɵlistener;\n}\n/**\n * Registers a synthetic host listener (e.g. `(@foo.start)`) on a component or directive.\n *\n * This instruction is for compatibility purposes and is designed to ensure that a\n * synthetic host listener (e.g. `@HostListener('@foo.start')`) properly gets rendered\n * in the component's renderer. Normally all host listeners are evaluated with the\n * parent component's renderer, but, in the case of animation @triggers, they need\n * to be evaluated with the sub component's renderer (because that's where the\n * animation triggers are defined).\n *\n * Do not use this instruction as a replacement for `listener`. This instruction\n * only exists to ensure compatibility with the ViewEngine's host binding behavior.\n *\n * @param eventName Name of the event\n * @param listenerFn The function to be called when event emits\n * @param useCapture Whether or not to use capture in event listener\n * @param eventTargetResolver Function that returns global target information in case this listener\n * should be attached to a global object like window, document or body\n *\n * @codeGenApi\n */\nfunction ɵɵsyntheticHostListener(eventName, listenerFn) {\n    const tNode = getCurrentTNode();\n    const lView = getLView();\n    const tView = getTView();\n    const currentDef = getCurrentDirectiveDef(tView.data);\n    const renderer = loadComponentRenderer(currentDef, tNode, lView);\n    listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn, false);\n    return ɵɵsyntheticHostListener;\n}\n/**\n * A utility function that checks if a given element has already an event handler registered for an\n * event with a specified name. The TView.cleanup data structure is used to find out which events\n * are registered for a given element.\n */\nfunction findExistingListener(tView, lView, eventName, tNodeIdx) {\n    const tCleanup = tView.cleanup;\n    if (tCleanup != null) {\n        for (let i = 0; i < tCleanup.length - 1; i += 2) {\n            const cleanupEventName = tCleanup[i];\n            if (cleanupEventName === eventName && tCleanup[i + 1] === tNodeIdx) {\n                // We have found a matching event name on the same node but it might not have been\n                // registered yet, so we must explicitly verify entries in the LView cleanup data\n                // structures.\n                const lCleanup = lView[CLEANUP];\n                const listenerIdxInLCleanup = tCleanup[i + 2];\n                return lCleanup.length > listenerIdxInLCleanup ? lCleanup[listenerIdxInLCleanup] : null;\n            }\n            // TView.cleanup can have a mix of 4-elements entries (for event handler cleanups) or\n            // 2-element entries (for directive and queries destroy hooks). As such we can encounter\n            // blocks of 4 or 2 items in the tView.cleanup and this is why we iterate over 2 elements\n            // first and jump another 2 elements if we detect listeners cleanup (4 elements). Also check\n            // documentation of TView.cleanup for more details of this data structure layout.\n            if (typeof cleanupEventName === 'string') {\n                i += 2;\n            }\n        }\n    }\n    return null;\n}\nfunction listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn, useCapture, eventTargetResolver) {\n    const isTNodeDirectiveHost = isDirectiveHost(tNode);\n    const firstCreatePass = tView.firstCreatePass;\n    const tCleanup = firstCreatePass && getOrCreateTViewCleanup(tView);\n    const context = lView[CONTEXT];\n    // When the ɵɵlistener instruction was generated and is executed we know that there is either a\n    // native listener or a directive output on this element. As such we we know that we will have to\n    // register a listener and store its cleanup function on LView.\n    const lCleanup = getOrCreateLViewCleanup(lView);\n    ngDevMode && assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */ | 12 /* TNodeType.AnyContainer */);\n    let processOutputs = true;\n    // Adding a native event listener is applicable when:\n    // - The corresponding TNode represents a DOM element.\n    // - The event target has a resolver (usually resulting in a global object,\n    //   such as `window` or `document`).\n    if ((tNode.type & 3 /* TNodeType.AnyRNode */) || eventTargetResolver) {\n        const native = getNativeByTNode(tNode, lView);\n        const target = eventTargetResolver ? eventTargetResolver(native) : native;\n        const lCleanupIndex = lCleanup.length;\n        const idxOrTargetGetter = eventTargetResolver ?\n            (_lView) => eventTargetResolver(unwrapRNode(_lView[tNode.index])) :\n            tNode.index;\n        // In order to match current behavior, native DOM event listeners must be added for all\n        // events (including outputs).\n        if (isProceduralRenderer(renderer)) {\n            // There might be cases where multiple directives on the same element try to register an event\n            // handler function for the same event. In this situation we want to avoid registration of\n            // several native listeners as each registration would be intercepted by NgZone and\n            // trigger change detection. This would mean that a single user action would result in several\n            // change detections being invoked. To avoid this situation we want to have only one call to\n            // native handler registration (for the same element and same type of event).\n            //\n            // In order to have just one native event handler in presence of multiple handler functions,\n            // we just register a first handler function as a native event listener and then chain\n            // (coalesce) other handler functions on top of the first native handler function.\n            let existingListener = null;\n            // Please note that the coalescing described here doesn't happen for events specifying an\n            // alternative target (ex. (document:click)) - this is to keep backward compatibility with the\n            // view engine.\n            // Also, we don't have to search for existing listeners is there are no directives\n            // matching on a given node as we can't register multiple event handlers for the same event in\n            // a template (this would mean having duplicate attributes).\n            if (!eventTargetResolver && isTNodeDirectiveHost) {\n                existingListener = findExistingListener(tView, lView, eventName, tNode.index);\n            }\n            if (existingListener !== null) {\n                // Attach a new listener to coalesced listeners list, maintaining the order in which\n                // listeners are registered. For performance reasons, we keep a reference to the last\n                // listener in that list (in `__ngLastListenerFn__` field), so we can avoid going through\n                // the entire set each time we need to add a new listener.\n                const lastListenerFn = existingListener.__ngLastListenerFn__ || existingListener;\n                lastListenerFn.__ngNextListenerFn__ = listenerFn;\n                existingListener.__ngLastListenerFn__ = listenerFn;\n                processOutputs = false;\n            }\n            else {\n                listenerFn = wrapListener(tNode, lView, context, listenerFn, false /** preventDefault */);\n                const cleanupFn = renderer.listen(target, eventName, listenerFn);\n                ngDevMode && ngDevMode.rendererAddEventListener++;\n                lCleanup.push(listenerFn, cleanupFn);\n                tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, lCleanupIndex + 1);\n            }\n        }\n        else {\n            listenerFn = wrapListener(tNode, lView, context, listenerFn, true /** preventDefault */);\n            target.addEventListener(eventName, listenerFn, useCapture);\n            ngDevMode && ngDevMode.rendererAddEventListener++;\n            lCleanup.push(listenerFn);\n            tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, useCapture);\n        }\n    }\n    else {\n        // Even if there is no native listener to add, we still need to wrap the listener so that OnPush\n        // ancestors are marked dirty when an event occurs.\n        listenerFn = wrapListener(tNode, lView, context, listenerFn, false /** preventDefault */);\n    }\n    // subscribe to directive outputs\n    const outputs = tNode.outputs;\n    let props;\n    if (processOutputs && outputs !== null && (props = outputs[eventName])) {\n        const propsLength = props.length;\n        if (propsLength) {\n            for (let i = 0; i < propsLength; i += 2) {\n                const index = props[i];\n                ngDevMode && assertIndexInRange(lView, index);\n                const minifiedName = props[i + 1];\n                const directiveInstance = lView[index];\n                const output = directiveInstance[minifiedName];\n                if (ngDevMode && !isObservable(output)) {\n                    throw new Error(`@Output ${minifiedName} not initialized in '${directiveInstance.constructor.name}'.`);\n                }\n                const subscription = output.subscribe(listenerFn);\n                const idx = lCleanup.length;\n                lCleanup.push(listenerFn, subscription);\n                tCleanup && tCleanup.push(eventName, tNode.index, idx, -(idx + 1));\n            }\n        }\n    }\n}\nfunction executeListenerWithErrorHandling(lView, context, listenerFn, e) {\n    try {\n        profiler(6 /* ProfilerEvent.OutputStart */, context, listenerFn);\n        // Only explicitly returning false from a listener should preventDefault\n        return listenerFn(e) !== false;\n    }\n    catch (error) {\n        handleError(lView, error);\n        return false;\n    }\n    finally {\n        profiler(7 /* ProfilerEvent.OutputEnd */, context, listenerFn);\n    }\n}\n/**\n * Wraps an event listener with a function that marks ancestors dirty and prevents default behavior,\n * if applicable.\n *\n * @param tNode The TNode associated with this listener\n * @param lView The LView that contains this listener\n * @param listenerFn The listener function to call\n * @param wrapWithPreventDefault Whether or not to prevent default behavior\n * (the procedural renderer does this already, so in those cases, we should skip)\n */\nfunction wrapListener(tNode, lView, context, listenerFn, wrapWithPreventDefault) {\n    // Note: we are performing most of the work in the listener function itself\n    // to optimize listener registration.\n    return function wrapListenerIn_markDirtyAndPreventDefault(e) {\n        // Ivy uses `Function` as a special token that allows us to unwrap the function\n        // so that it can be invoked programmatically by `DebugNode.triggerEventHandler`.\n        if (e === Function) {\n            return listenerFn;\n        }\n        // In order to be backwards compatible with View Engine, events on component host nodes\n        // must also mark the component view itself dirty (i.e. the view that it owns).\n        const startView = tNode.flags & 2 /* TNodeFlags.isComponentHost */ ?\n            getComponentLViewByIndex(tNode.index, lView) :\n            lView;\n        markViewDirty(startView);\n        let result = executeListenerWithErrorHandling(lView, context, listenerFn, e);\n        // A just-invoked listener function might have coalesced listeners so we need to check for\n        // their presence and invoke as needed.\n        let nextListenerFn = wrapListenerIn_markDirtyAndPreventDefault.__ngNextListenerFn__;\n        while (nextListenerFn) {\n            // We should prevent default if any of the listeners explicitly return false\n            result = executeListenerWithErrorHandling(lView, context, nextListenerFn, e) && result;\n            nextListenerFn = nextListenerFn.__ngNextListenerFn__;\n        }\n        if (wrapWithPreventDefault && result === false) {\n            e.preventDefault();\n            // Necessary for legacy browsers that don't support preventDefault (e.g. IE)\n            e.returnValue = false;\n        }\n        return result;\n    };\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Retrieves a context at the level specified and saves it as the global, contextViewData.\n * Will get the next level up if level is not specified.\n *\n * This is used to save contexts of parent views so they can be bound in embedded views, or\n * in conjunction with reference() to bind a ref from a parent view.\n *\n * @param level The relative level of the view from which to grab context compared to contextVewData\n * @returns context\n *\n * @codeGenApi\n */\nfunction ɵɵnextContext(level = 1) {\n    return nextContextImpl(level);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Checks a given node against matching projection slots and returns the\n * determined slot index. Returns \"null\" if no slot matched the given node.\n *\n * This function takes into account the parsed ngProjectAs selector from the\n * node's attributes. If present, it will check whether the ngProjectAs selector\n * matches any of the projection slot selectors.\n */\nfunction matchingProjectionSlotIndex(tNode, projectionSlots) {\n    let wildcardNgContentIndex = null;\n    const ngProjectAsAttrVal = getProjectAsAttrValue(tNode);\n    for (let i = 0; i < projectionSlots.length; i++) {\n        const slotValue = projectionSlots[i];\n        // The last wildcard projection slot should match all nodes which aren't matching\n        // any selector. This is necessary to be backwards compatible with view engine.\n        if (slotValue === '*') {\n            wildcardNgContentIndex = i;\n            continue;\n        }\n        // If we ran into an `ngProjectAs` attribute, we should match its parsed selector\n        // to the list of selectors, otherwise we fall back to matching against the node.\n        if (ngProjectAsAttrVal === null ?\n            isNodeMatchingSelectorList(tNode, slotValue, /* isProjectionMode */ true) :\n            isSelectorInSelectorList(ngProjectAsAttrVal, slotValue)) {\n            return i; // first matching selector \"captures\" a given node\n        }\n    }\n    return wildcardNgContentIndex;\n}\n/**\n * Instruction to distribute projectable nodes among <ng-content> occurrences in a given template.\n * It takes all the selectors from the entire component's template and decides where\n * each projected node belongs (it re-distributes nodes among \"buckets\" where each \"bucket\" is\n * backed by a selector).\n *\n * This function requires CSS selectors to be provided in 2 forms: parsed (by a compiler) and text,\n * un-parsed form.\n *\n * The parsed form is needed for efficient matching of a node against a given CSS selector.\n * The un-parsed, textual form is needed for support of the ngProjectAs attribute.\n *\n * Having a CSS selector in 2 different formats is not ideal, but alternatives have even more\n * drawbacks:\n * - having only a textual form would require runtime parsing of CSS selectors;\n * - we can't have only a parsed as we can't re-construct textual form from it (as entered by a\n * template author).\n *\n * @param projectionSlots? A collection of projection slots. A projection slot can be based\n *        on a parsed CSS selectors or set to the wildcard selector (\"*\") in order to match\n *        all nodes which do not match any selector. If not specified, a single wildcard\n *        selector projection slot will be defined.\n *\n * @codeGenApi\n */\nfunction ɵɵprojectionDef(projectionSlots) {\n    const componentNode = getLView()[DECLARATION_COMPONENT_VIEW][T_HOST];\n    if (!componentNode.projection) {\n        // If no explicit projection slots are defined, fall back to a single\n        // projection slot with the wildcard selector.\n        const numProjectionSlots = projectionSlots ? projectionSlots.length : 1;\n        const projectionHeads = componentNode.projection =\n            newArray(numProjectionSlots, null);\n        const tails = projectionHeads.slice();\n        let componentChild = componentNode.child;\n        while (componentChild !== null) {\n            const slotIndex = projectionSlots ? matchingProjectionSlotIndex(componentChild, projectionSlots) : 0;\n            if (slotIndex !== null) {\n                if (tails[slotIndex]) {\n                    tails[slotIndex].projectionNext = componentChild;\n                }\n                else {\n                    projectionHeads[slotIndex] = componentChild;\n                }\n                tails[slotIndex] = componentChild;\n            }\n            componentChild = componentChild.next;\n        }\n    }\n}\n/**\n * Inserts previously re-distributed projected nodes. This instruction must be preceded by a call\n * to the projectionDef instruction.\n *\n * @param nodeIndex\n * @param selectorIndex:\n *        - 0 when the selector is `*` (or unspecified as this is the default value),\n *        - 1 based index of the selector from the {@link projectionDef}\n *\n * @codeGenApi\n */\nfunction ɵɵprojection(nodeIndex, selectorIndex = 0, attrs) {\n    const lView = getLView();\n    const tView = getTView();\n    const tProjectionNode = getOrCreateTNode(tView, HEADER_OFFSET + nodeIndex, 16 /* TNodeType.Projection */, null, attrs || null);\n    // We can't use viewData[HOST_NODE] because projection nodes can be nested in embedded views.\n    if (tProjectionNode.projection === null)\n        tProjectionNode.projection = selectorIndex;\n    // `<ng-content>` has no content\n    setCurrentTNodeAsNotParent();\n    if ((tProjectionNode.flags & 64 /* TNodeFlags.isDetached */) !== 64 /* TNodeFlags.isDetached */) {\n        // re-distribution of projectable nodes is stored on a component's view level\n        applyProjection(tView, lView, tProjectionNode);\n    }\n}\n\n/**\n *\n * Update an interpolated property on an element with a lone bound value\n *\n * Used when the value passed to a property has 1 interpolated value in it, an no additional text\n * surrounds that interpolated value:\n *\n * ```html\n * <div title=\"{{v0}}\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate('title', v0);\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵpropertyInterpolate(propName, v0, sanitizer) {\n    ɵɵpropertyInterpolate1(propName, '', v0, '', sanitizer);\n    return ɵɵpropertyInterpolate;\n}\n/**\n *\n * Update an interpolated property on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate1('title', 'prefix', v0, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵpropertyInterpolate1(propName, prefix, v0, suffix, sanitizer) {\n    const lView = getLView();\n    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n        ngDevMode &&\n            storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 1, prefix, suffix);\n    }\n    return ɵɵpropertyInterpolate1;\n}\n/**\n *\n * Update an interpolated property on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate2('title', 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵpropertyInterpolate2(propName, prefix, v0, i0, v1, suffix, sanitizer) {\n    const lView = getLView();\n    const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n        ngDevMode &&\n            storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 2, prefix, i0, suffix);\n    }\n    return ɵɵpropertyInterpolate2;\n}\n/**\n *\n * Update an interpolated property on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate3(\n * 'title', 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵpropertyInterpolate3(propName, prefix, v0, i0, v1, i1, v2, suffix, sanitizer) {\n    const lView = getLView();\n    const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n        ngDevMode &&\n            storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 3, prefix, i0, i1, suffix);\n    }\n    return ɵɵpropertyInterpolate3;\n}\n/**\n *\n * Update an interpolated property on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate4(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵpropertyInterpolate4(propName, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, sanitizer) {\n    const lView = getLView();\n    const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n        ngDevMode &&\n            storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 4, prefix, i0, i1, i2, suffix);\n    }\n    return ɵɵpropertyInterpolate4;\n}\n/**\n *\n * Update an interpolated property on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate5(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵpropertyInterpolate5(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, sanitizer) {\n    const lView = getLView();\n    const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n        ngDevMode &&\n            storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 5, prefix, i0, i1, i2, i3, suffix);\n    }\n    return ɵɵpropertyInterpolate5;\n}\n/**\n *\n * Update an interpolated property on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate6(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵpropertyInterpolate6(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, sanitizer) {\n    const lView = getLView();\n    const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n        ngDevMode &&\n            storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 6, prefix, i0, i1, i2, i3, i4, suffix);\n    }\n    return ɵɵpropertyInterpolate6;\n}\n/**\n *\n * Update an interpolated property on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate7(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵpropertyInterpolate7(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer) {\n    const lView = getLView();\n    const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n        ngDevMode &&\n            storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 7, prefix, i0, i1, i2, i3, i4, i5, suffix);\n    }\n    return ɵɵpropertyInterpolate7;\n}\n/**\n *\n * Update an interpolated property on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolate8(\n *  'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵpropertyInterpolate8(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer) {\n    const lView = getLView();\n    const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n        ngDevMode &&\n            storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 8, prefix, i0, i1, i2, i3, i4, i5, i6, suffix);\n    }\n    return ɵɵpropertyInterpolate8;\n}\n/**\n * Update an interpolated property on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * ɵɵpropertyInterpolateV(\n *  'title', ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update.\n * @param values The collection of values and the strings inbetween those values, beginning with a\n * string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵpropertyInterpolateV(propName, values, sanitizer) {\n    const lView = getLView();\n    const interpolatedValue = interpolationV(lView, values);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n        if (ngDevMode) {\n            const interpolationInBetween = [values[0]]; // prefix\n            for (let i = 2; i < values.length; i += 2) {\n                interpolationInBetween.push(values[i]);\n            }\n            storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);\n        }\n    }\n    return ɵɵpropertyInterpolateV;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * NOTE: The word `styling` is used interchangeably as style or class styling.\n *\n * This file contains code to link styling instructions together so that they can be replayed in\n * priority order. The file exists because Ivy styling instruction execution order does not match\n * that of the priority order. The purpose of this code is to create a linked list so that the\n * instructions can be traversed in priority order when computing the styles.\n *\n * Assume we are dealing with the following code:\n * ```\n * @Component({\n *   template: `\n *     <my-cmp [style]=\" {color: '#001'} \"\n *             [style.color]=\" #002 \"\n *             dir-style-color-1\n *             dir-style-color-2> `\n * })\n * class ExampleComponent {\n *   static ngComp = ... {\n *     ...\n *     // Compiler ensures that `ɵɵstyleProp` is after `ɵɵstyleMap`\n *     ɵɵstyleMap({color: '#001'});\n *     ɵɵstyleProp('color', '#002');\n *     ...\n *   }\n * }\n *\n * @Directive({\n *   selector: `[dir-style-color-1]',\n * })\n * class Style1Directive {\n *   @HostBinding('style') style = {color: '#005'};\n *   @HostBinding('style.color') color = '#006';\n *\n *   static ngDir = ... {\n *     ...\n *     // Compiler ensures that `ɵɵstyleProp` is after `ɵɵstyleMap`\n *     ɵɵstyleMap({color: '#005'});\n *     ɵɵstyleProp('color', '#006');\n *     ...\n *   }\n * }\n *\n * @Directive({\n *   selector: `[dir-style-color-2]',\n * })\n * class Style2Directive {\n *   @HostBinding('style') style = {color: '#007'};\n *   @HostBinding('style.color') color = '#008';\n *\n *   static ngDir = ... {\n *     ...\n *     // Compiler ensures that `ɵɵstyleProp` is after `ɵɵstyleMap`\n *     ɵɵstyleMap({color: '#007'});\n *     ɵɵstyleProp('color', '#008');\n *     ...\n *   }\n * }\n *\n * @Directive({\n *   selector: `my-cmp',\n * })\n * class MyComponent {\n *   @HostBinding('style') style = {color: '#003'};\n *   @HostBinding('style.color') color = '#004';\n *\n *   static ngComp = ... {\n *     ...\n *     // Compiler ensures that `ɵɵstyleProp` is after `ɵɵstyleMap`\n *     ɵɵstyleMap({color: '#003'});\n *     ɵɵstyleProp('color', '#004');\n *     ...\n *   }\n * }\n * ```\n *\n * The Order of instruction execution is:\n *\n * NOTE: the comment binding location is for illustrative purposes only.\n *\n * ```\n * // Template: (ExampleComponent)\n *     ɵɵstyleMap({color: '#001'});   // Binding index: 10\n *     ɵɵstyleProp('color', '#002');  // Binding index: 12\n * // MyComponent\n *     ɵɵstyleMap({color: '#003'});   // Binding index: 20\n *     ɵɵstyleProp('color', '#004');  // Binding index: 22\n * // Style1Directive\n *     ɵɵstyleMap({color: '#005'});   // Binding index: 24\n *     ɵɵstyleProp('color', '#006');  // Binding index: 26\n * // Style2Directive\n *     ɵɵstyleMap({color: '#007'});   // Binding index: 28\n *     ɵɵstyleProp('color', '#008');  // Binding index: 30\n * ```\n *\n * The correct priority order of concatenation is:\n *\n * ```\n * // MyComponent\n *     ɵɵstyleMap({color: '#003'});   // Binding index: 20\n *     ɵɵstyleProp('color', '#004');  // Binding index: 22\n * // Style1Directive\n *     ɵɵstyleMap({color: '#005'});   // Binding index: 24\n *     ɵɵstyleProp('color', '#006');  // Binding index: 26\n * // Style2Directive\n *     ɵɵstyleMap({color: '#007'});   // Binding index: 28\n *     ɵɵstyleProp('color', '#008');  // Binding index: 30\n * // Template: (ExampleComponent)\n *     ɵɵstyleMap({color: '#001'});   // Binding index: 10\n *     ɵɵstyleProp('color', '#002');  // Binding index: 12\n * ```\n *\n * What color should be rendered?\n *\n * Once the items are correctly sorted in the list, the answer is simply the last item in the\n * concatenation list which is `#002`.\n *\n * To do so we keep a linked list of all of the bindings which pertain to this element.\n * Notice that the bindings are inserted in the order of execution, but the `TView.data` allows\n * us to traverse them in the order of priority.\n *\n * |Idx|`TView.data`|`LView`          | Notes\n * |---|------------|-----------------|--------------\n * |...|            |                 |\n * |10 |`null`      |`{color: '#001'}`| `ɵɵstyleMap('color', {color: '#001'})`\n * |11 |`30 | 12`   | ...             |\n * |12 |`color`     |`'#002'`         | `ɵɵstyleProp('color', '#002')`\n * |13 |`10 | 0`    | ...             |\n * |...|            |                 |\n * |20 |`null`      |`{color: '#003'}`| `ɵɵstyleMap('color', {color: '#003'})`\n * |21 |`0 | 22`    | ...             |\n * |22 |`color`     |`'#004'`         | `ɵɵstyleProp('color', '#004')`\n * |23 |`20 | 24`   | ...             |\n * |24 |`null`      |`{color: '#005'}`| `ɵɵstyleMap('color', {color: '#005'})`\n * |25 |`22 | 26`   | ...             |\n * |26 |`color`     |`'#006'`         | `ɵɵstyleProp('color', '#006')`\n * |27 |`24 | 28`   | ...             |\n * |28 |`null`      |`{color: '#007'}`| `ɵɵstyleMap('color', {color: '#007'})`\n * |29 |`26 | 30`   | ...             |\n * |30 |`color`     |`'#008'`         | `ɵɵstyleProp('color', '#008')`\n * |31 |`28 | 10`   | ...             |\n *\n * The above data structure allows us to re-concatenate the styling no matter which data binding\n * changes.\n *\n * NOTE: in addition to keeping track of next/previous index the `TView.data` also stores prev/next\n * duplicate bit. The duplicate bit if true says there either is a binding with the same name or\n * there is a map (which may contain the name). This information is useful in knowing if other\n * styles with higher priority need to be searched for overwrites.\n *\n * NOTE: See `should support example in 'tnode_linked_list.ts' documentation` in\n * `tnode_linked_list_spec.ts` for working example.\n */\nlet __unused_const_as_closure_does_not_like_standalone_comment_blocks__;\n/**\n * Insert new `tStyleValue` at `TData` and link existing style bindings such that we maintain linked\n * list of styles and compute the duplicate flag.\n *\n * Note: this function is executed during `firstUpdatePass` only to populate the `TView.data`.\n *\n * The function works by keeping track of `tStylingRange` which contains two pointers pointing to\n * the head/tail of the template portion of the styles.\n *  - if `isHost === false` (we are template) then insertion is at tail of `TStylingRange`\n *  - if `isHost === true` (we are host binding) then insertion is at head of `TStylingRange`\n *\n * @param tData The `TData` to insert into.\n * @param tNode `TNode` associated with the styling element.\n * @param tStylingKey See `TStylingKey`.\n * @param index location of where `tStyleValue` should be stored (and linked into list.)\n * @param isHostBinding `true` if the insertion is for a `hostBinding`. (insertion is in front of\n *               template.)\n * @param isClassBinding True if the associated `tStylingKey` as a `class` styling.\n *                       `tNode.classBindings` should be used (or `tNode.styleBindings` otherwise.)\n */\nfunction insertTStylingBinding(tData, tNode, tStylingKeyWithStatic, index, isHostBinding, isClassBinding) {\n    ngDevMode && assertFirstUpdatePass(getTView());\n    let tBindings = isClassBinding ? tNode.classBindings : tNode.styleBindings;\n    let tmplHead = getTStylingRangePrev(tBindings);\n    let tmplTail = getTStylingRangeNext(tBindings);\n    tData[index] = tStylingKeyWithStatic;\n    let isKeyDuplicateOfStatic = false;\n    let tStylingKey;\n    if (Array.isArray(tStylingKeyWithStatic)) {\n        // We are case when the `TStylingKey` contains static fields as well.\n        const staticKeyValueArray = tStylingKeyWithStatic;\n        tStylingKey = staticKeyValueArray[1]; // unwrap.\n        // We need to check if our key is present in the static so that we can mark it as duplicate.\n        if (tStylingKey === null ||\n            keyValueArrayIndexOf(staticKeyValueArray, tStylingKey) > 0) {\n            // tStylingKey is present in the statics, need to mark it as duplicate.\n            isKeyDuplicateOfStatic = true;\n        }\n    }\n    else {\n        tStylingKey = tStylingKeyWithStatic;\n    }\n    if (isHostBinding) {\n        // We are inserting host bindings\n        // If we don't have template bindings then `tail` is 0.\n        const hasTemplateBindings = tmplTail !== 0;\n        // This is important to know because that means that the `head` can't point to the first\n        // template bindings (there are none.) Instead the head points to the tail of the template.\n        if (hasTemplateBindings) {\n            // template head's \"prev\" will point to last host binding or to 0 if no host bindings yet\n            const previousNode = getTStylingRangePrev(tData[tmplHead + 1]);\n            tData[index + 1] = toTStylingRange(previousNode, tmplHead);\n            // if a host binding has already been registered, we need to update the next of that host\n            // binding to point to this one\n            if (previousNode !== 0) {\n                // We need to update the template-tail value to point to us.\n                tData[previousNode + 1] =\n                    setTStylingRangeNext(tData[previousNode + 1], index);\n            }\n            // The \"previous\" of the template binding head should point to this host binding\n            tData[tmplHead + 1] = setTStylingRangePrev(tData[tmplHead + 1], index);\n        }\n        else {\n            tData[index + 1] = toTStylingRange(tmplHead, 0);\n            // if a host binding has already been registered, we need to update the next of that host\n            // binding to point to this one\n            if (tmplHead !== 0) {\n                // We need to update the template-tail value to point to us.\n                tData[tmplHead + 1] = setTStylingRangeNext(tData[tmplHead + 1], index);\n            }\n            // if we don't have template, the head points to template-tail, and needs to be advanced.\n            tmplHead = index;\n        }\n    }\n    else {\n        // We are inserting in template section.\n        // We need to set this binding's \"previous\" to the current template tail\n        tData[index + 1] = toTStylingRange(tmplTail, 0);\n        ngDevMode &&\n            assertEqual(tmplHead !== 0 && tmplTail === 0, false, 'Adding template bindings after hostBindings is not allowed.');\n        if (tmplHead === 0) {\n            tmplHead = index;\n        }\n        else {\n            // We need to update the previous value \"next\" to point to this binding\n            tData[tmplTail + 1] = setTStylingRangeNext(tData[tmplTail + 1], index);\n        }\n        tmplTail = index;\n    }\n    // Now we need to update / compute the duplicates.\n    // Starting with our location search towards head (least priority)\n    if (isKeyDuplicateOfStatic) {\n        tData[index + 1] = setTStylingRangePrevDuplicate(tData[index + 1]);\n    }\n    markDuplicates(tData, tStylingKey, index, true, isClassBinding);\n    markDuplicates(tData, tStylingKey, index, false, isClassBinding);\n    markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding);\n    tBindings = toTStylingRange(tmplHead, tmplTail);\n    if (isClassBinding) {\n        tNode.classBindings = tBindings;\n    }\n    else {\n        tNode.styleBindings = tBindings;\n    }\n}\n/**\n * Look into the residual styling to see if the current `tStylingKey` is duplicate of residual.\n *\n * @param tNode `TNode` where the residual is stored.\n * @param tStylingKey `TStylingKey` to store.\n * @param tData `TData` associated with the current `LView`.\n * @param index location of where `tStyleValue` should be stored (and linked into list.)\n * @param isClassBinding True if the associated `tStylingKey` as a `class` styling.\n *                       `tNode.classBindings` should be used (or `tNode.styleBindings` otherwise.)\n */\nfunction markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding) {\n    const residual = isClassBinding ? tNode.residualClasses : tNode.residualStyles;\n    if (residual != null /* or undefined */ && typeof tStylingKey == 'string' &&\n        keyValueArrayIndexOf(residual, tStylingKey) >= 0) {\n        // We have duplicate in the residual so mark ourselves as duplicate.\n        tData[index + 1] = setTStylingRangeNextDuplicate(tData[index + 1]);\n    }\n}\n/**\n * Marks `TStyleValue`s as duplicates if another style binding in the list has the same\n * `TStyleValue`.\n *\n * NOTE: this function is intended to be called twice once with `isPrevDir` set to `true` and once\n * with it set to `false` to search both the previous as well as next items in the list.\n *\n * No duplicate case\n * ```\n *   [style.color]\n *   [style.width.px] <<- index\n *   [style.height.px]\n * ```\n *\n * In the above case adding `[style.width.px]` to the existing `[style.color]` produces no\n * duplicates because `width` is not found in any other part of the linked list.\n *\n * Duplicate case\n * ```\n *   [style.color]\n *   [style.width.em]\n *   [style.width.px] <<- index\n * ```\n * In the above case adding `[style.width.px]` will produce a duplicate with `[style.width.em]`\n * because `width` is found in the chain.\n *\n * Map case 1\n * ```\n *   [style.width.px]\n *   [style.color]\n *   [style]  <<- index\n * ```\n * In the above case adding `[style]` will produce a duplicate with any other bindings because\n * `[style]` is a Map and as such is fully dynamic and could produce `color` or `width`.\n *\n * Map case 2\n * ```\n *   [style]\n *   [style.width.px]\n *   [style.color]  <<- index\n * ```\n * In the above case adding `[style.color]` will produce a duplicate because there is already a\n * `[style]` binding which is a Map and as such is fully dynamic and could produce `color` or\n * `width`.\n *\n * NOTE: Once `[style]` (Map) is added into the system all things are mapped as duplicates.\n * NOTE: We use `style` as example, but same logic is applied to `class`es as well.\n *\n * @param tData `TData` where the linked list is stored.\n * @param tStylingKey `TStylingKeyPrimitive` which contains the value to compare to other keys in\n *        the linked list.\n * @param index Starting location in the linked list to search from\n * @param isPrevDir Direction.\n *        - `true` for previous (lower priority);\n *        - `false` for next (higher priority).\n */\nfunction markDuplicates(tData, tStylingKey, index, isPrevDir, isClassBinding) {\n    const tStylingAtIndex = tData[index + 1];\n    const isMap = tStylingKey === null;\n    let cursor = isPrevDir ? getTStylingRangePrev(tStylingAtIndex) : getTStylingRangeNext(tStylingAtIndex);\n    let foundDuplicate = false;\n    // We keep iterating as long as we have a cursor\n    // AND either:\n    // - we found what we are looking for, OR\n    // - we are a map in which case we have to continue searching even after we find what we were\n    //   looking for since we are a wild card and everything needs to be flipped to duplicate.\n    while (cursor !== 0 && (foundDuplicate === false || isMap)) {\n        ngDevMode && assertIndexInRange(tData, cursor);\n        const tStylingValueAtCursor = tData[cursor];\n        const tStyleRangeAtCursor = tData[cursor + 1];\n        if (isStylingMatch(tStylingValueAtCursor, tStylingKey)) {\n            foundDuplicate = true;\n            tData[cursor + 1] = isPrevDir ? setTStylingRangeNextDuplicate(tStyleRangeAtCursor) :\n                setTStylingRangePrevDuplicate(tStyleRangeAtCursor);\n        }\n        cursor = isPrevDir ? getTStylingRangePrev(tStyleRangeAtCursor) :\n            getTStylingRangeNext(tStyleRangeAtCursor);\n    }\n    if (foundDuplicate) {\n        // if we found a duplicate, than mark ourselves.\n        tData[index + 1] = isPrevDir ? setTStylingRangePrevDuplicate(tStylingAtIndex) :\n            setTStylingRangeNextDuplicate(tStylingAtIndex);\n    }\n}\n/**\n * Determines if two `TStylingKey`s are a match.\n *\n * When computing whether a binding contains a duplicate, we need to compare if the instruction\n * `TStylingKey` has a match.\n *\n * Here are examples of `TStylingKey`s which match given `tStylingKeyCursor` is:\n * - `color`\n *    - `color`    // Match another color\n *    - `null`     // That means that `tStylingKey` is a `classMap`/`styleMap` instruction\n *    - `['', 'color', 'other', true]` // wrapped `color` so match\n *    - `['', null, 'other', true]`       // wrapped `null` so match\n *    - `['', 'width', 'color', 'value']` // wrapped static value contains a match on `'color'`\n * - `null`       // `tStylingKeyCursor` always match as it is `classMap`/`styleMap` instruction\n *\n * @param tStylingKeyCursor\n * @param tStylingKey\n */\nfunction isStylingMatch(tStylingKeyCursor, tStylingKey) {\n    ngDevMode &&\n        assertNotEqual(Array.isArray(tStylingKey), true, 'Expected that \\'tStylingKey\\' has been unwrapped');\n    if (tStylingKeyCursor === null || // If the cursor is `null` it means that we have map at that\n        // location so we must assume that we have a match.\n        tStylingKey == null || // If `tStylingKey` is `null` then it is a map therefor assume that it\n        // contains a match.\n        (Array.isArray(tStylingKeyCursor) ? tStylingKeyCursor[1] : tStylingKeyCursor) ===\n            tStylingKey // If the keys match explicitly than we are a match.\n    ) {\n        return true;\n    }\n    else if (Array.isArray(tStylingKeyCursor) && typeof tStylingKey === 'string') {\n        // if we did not find a match, but `tStylingKeyCursor` is `KeyValueArray` that means cursor has\n        // statics and we need to check those as well.\n        return keyValueArrayIndexOf(tStylingKeyCursor, tStylingKey) >=\n            0; // see if we are matching the key\n    }\n    return false;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Global state of the parser. (This makes parser non-reentrant, but that is not an issue)\nconst parserState = {\n    textEnd: 0,\n    key: 0,\n    keyEnd: 0,\n    value: 0,\n    valueEnd: 0,\n};\n/**\n * Retrieves the last parsed `key` of style.\n * @param text the text to substring the key from.\n */\nfunction getLastParsedKey(text) {\n    return text.substring(parserState.key, parserState.keyEnd);\n}\n/**\n * Retrieves the last parsed `value` of style.\n * @param text the text to substring the key from.\n */\nfunction getLastParsedValue(text) {\n    return text.substring(parserState.value, parserState.valueEnd);\n}\n/**\n * Initializes `className` string for parsing and parses the first token.\n *\n * This function is intended to be used in this format:\n * ```\n * for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {\n *   const key = getLastParsedKey();\n *   ...\n * }\n * ```\n * @param text `className` to parse\n * @returns index where the next invocation of `parseClassNameNext` should resume.\n */\nfunction parseClassName(text) {\n    resetParserState(text);\n    return parseClassNameNext(text, consumeWhitespace(text, 0, parserState.textEnd));\n}\n/**\n * Parses next `className` token.\n *\n * This function is intended to be used in this format:\n * ```\n * for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {\n *   const key = getLastParsedKey();\n *   ...\n * }\n * ```\n *\n * @param text `className` to parse\n * @param index where the parsing should resume.\n * @returns index where the next invocation of `parseClassNameNext` should resume.\n */\nfunction parseClassNameNext(text, index) {\n    const end = parserState.textEnd;\n    if (end === index) {\n        return -1;\n    }\n    index = parserState.keyEnd = consumeClassToken(text, parserState.key = index, end);\n    return consumeWhitespace(text, index, end);\n}\n/**\n * Initializes `cssText` string for parsing and parses the first key/values.\n *\n * This function is intended to be used in this format:\n * ```\n * for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i))) {\n *   const key = getLastParsedKey();\n *   const value = getLastParsedValue();\n *   ...\n * }\n * ```\n * @param text `cssText` to parse\n * @returns index where the next invocation of `parseStyleNext` should resume.\n */\nfunction parseStyle(text) {\n    resetParserState(text);\n    return parseStyleNext(text, consumeWhitespace(text, 0, parserState.textEnd));\n}\n/**\n * Parses the next `cssText` key/values.\n *\n * This function is intended to be used in this format:\n * ```\n * for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i))) {\n *   const key = getLastParsedKey();\n *   const value = getLastParsedValue();\n *   ...\n * }\n *\n * @param text `cssText` to parse\n * @param index where the parsing should resume.\n * @returns index where the next invocation of `parseStyleNext` should resume.\n */\nfunction parseStyleNext(text, startIndex) {\n    const end = parserState.textEnd;\n    let index = parserState.key = consumeWhitespace(text, startIndex, end);\n    if (end === index) {\n        // we reached an end so just quit\n        return -1;\n    }\n    index = parserState.keyEnd = consumeStyleKey(text, index, end);\n    index = consumeSeparator(text, index, end, 58 /* CharCode.COLON */);\n    index = parserState.value = consumeWhitespace(text, index, end);\n    index = parserState.valueEnd = consumeStyleValue(text, index, end);\n    return consumeSeparator(text, index, end, 59 /* CharCode.SEMI_COLON */);\n}\n/**\n * Reset the global state of the styling parser.\n * @param text The styling text to parse.\n */\nfunction resetParserState(text) {\n    parserState.key = 0;\n    parserState.keyEnd = 0;\n    parserState.value = 0;\n    parserState.valueEnd = 0;\n    parserState.textEnd = text.length;\n}\n/**\n * Returns index of next non-whitespace character.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index of next non-whitespace character (May be the same as `start` if no whitespace at\n *          that location.)\n */\nfunction consumeWhitespace(text, startIndex, endIndex) {\n    while (startIndex < endIndex && text.charCodeAt(startIndex) <= 32 /* CharCode.SPACE */) {\n        startIndex++;\n    }\n    return startIndex;\n}\n/**\n * Returns index of last char in class token.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after last char in class token.\n */\nfunction consumeClassToken(text, startIndex, endIndex) {\n    while (startIndex < endIndex && text.charCodeAt(startIndex) > 32 /* CharCode.SPACE */) {\n        startIndex++;\n    }\n    return startIndex;\n}\n/**\n * Consumes all of the characters belonging to style key and token.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after last style key character.\n */\nfunction consumeStyleKey(text, startIndex, endIndex) {\n    let ch;\n    while (startIndex < endIndex &&\n        ((ch = text.charCodeAt(startIndex)) === 45 /* CharCode.DASH */ || ch === 95 /* CharCode.UNDERSCORE */ ||\n            ((ch & -33 /* CharCode.UPPER_CASE */) >= 65 /* CharCode.A */ && (ch & -33 /* CharCode.UPPER_CASE */) <= 90 /* CharCode.Z */) ||\n            (ch >= 48 /* CharCode.ZERO */ && ch <= 57 /* CharCode.NINE */))) {\n        startIndex++;\n    }\n    return startIndex;\n}\n/**\n * Consumes all whitespace and the separator `:` after the style key.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after separator and surrounding whitespace.\n */\nfunction consumeSeparator(text, startIndex, endIndex, separator) {\n    startIndex = consumeWhitespace(text, startIndex, endIndex);\n    if (startIndex < endIndex) {\n        if (ngDevMode && text.charCodeAt(startIndex) !== separator) {\n            malformedStyleError(text, String.fromCharCode(separator), startIndex);\n        }\n        startIndex++;\n    }\n    return startIndex;\n}\n/**\n * Consumes style value honoring `url()` and `\"\"` text.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after last style value character.\n */\nfunction consumeStyleValue(text, startIndex, endIndex) {\n    let ch1 = -1; // 1st previous character\n    let ch2 = -1; // 2nd previous character\n    let ch3 = -1; // 3rd previous character\n    let i = startIndex;\n    let lastChIndex = i;\n    while (i < endIndex) {\n        const ch = text.charCodeAt(i++);\n        if (ch === 59 /* CharCode.SEMI_COLON */) {\n            return lastChIndex;\n        }\n        else if (ch === 34 /* CharCode.DOUBLE_QUOTE */ || ch === 39 /* CharCode.SINGLE_QUOTE */) {\n            lastChIndex = i = consumeQuotedText(text, ch, i, endIndex);\n        }\n        else if (startIndex ===\n            i - 4 && // We have seen only 4 characters so far \"URL(\" (Ignore \"foo_URL()\")\n            ch3 === 85 /* CharCode.U */ &&\n            ch2 === 82 /* CharCode.R */ && ch1 === 76 /* CharCode.L */ && ch === 40 /* CharCode.OPEN_PAREN */) {\n            lastChIndex = i = consumeQuotedText(text, 41 /* CharCode.CLOSE_PAREN */, i, endIndex);\n        }\n        else if (ch > 32 /* CharCode.SPACE */) {\n            // if we have a non-whitespace character then capture its location\n            lastChIndex = i;\n        }\n        ch3 = ch2;\n        ch2 = ch1;\n        ch1 = ch & -33 /* CharCode.UPPER_CASE */;\n    }\n    return lastChIndex;\n}\n/**\n * Consumes all of the quoted characters.\n *\n * @param text Text to scan\n * @param quoteCharCode CharCode of either `\"` or `'` quote or `)` for `url(...)`.\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after quoted characters.\n */\nfunction consumeQuotedText(text, quoteCharCode, startIndex, endIndex) {\n    let ch1 = -1; // 1st previous character\n    let index = startIndex;\n    while (index < endIndex) {\n        const ch = text.charCodeAt(index++);\n        if (ch == quoteCharCode && ch1 !== 92 /* CharCode.BACK_SLASH */) {\n            return index;\n        }\n        if (ch == 92 /* CharCode.BACK_SLASH */ && ch1 === 92 /* CharCode.BACK_SLASH */) {\n            // two back slashes cancel each other out. For example `\"\\\\\"` should properly end the\n            // quotation. (It should not assume that the last `\"` is escaped.)\n            ch1 = 0;\n        }\n        else {\n            ch1 = ch;\n        }\n    }\n    throw ngDevMode ? malformedStyleError(text, String.fromCharCode(quoteCharCode), endIndex) :\n        new Error();\n}\nfunction malformedStyleError(text, expecting, index) {\n    ngDevMode && assertEqual(typeof text === 'string', true, 'String expected here');\n    throw throwError(`Malformed style at location ${index} in string '` + text.substring(0, index) + '[>>' +\n        text.substring(index, index + 1) + '<<]' + text.slice(index + 1) +\n        `'. Expecting '${expecting}'.`);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Update a style binding on an element with the provided value.\n *\n * If the style value is falsy then it will be removed from the element\n * (or assigned a different value depending if there are any styles placed\n * on the element with `styleMap` or any static styles that are\n * present from when the element was created with `styling`).\n *\n * Note that the styling element is updated as part of `stylingApply`.\n *\n * @param prop A valid CSS property.\n * @param value New value to write (`null` or an empty string to remove).\n * @param suffix Optional suffix. Used with scalar values to add unit such as `px`.\n *\n * Note that this will apply the provided style value to the host element if this function is called\n * within a host binding function.\n *\n * @codeGenApi\n */\nfunction ɵɵstyleProp(prop, value, suffix) {\n    checkStylingProperty(prop, value, suffix, false);\n    return ɵɵstyleProp;\n}\n/**\n * Update a class binding on an element with the provided value.\n *\n * This instruction is meant to handle the `[class.foo]=\"exp\"` case and,\n * therefore, the class binding itself must already be allocated using\n * `styling` within the creation block.\n *\n * @param prop A valid CSS class (only one).\n * @param value A true/false value which will turn the class on or off.\n *\n * Note that this will apply the provided class value to the host element if this function\n * is called within a host binding function.\n *\n * @codeGenApi\n */\nfunction ɵɵclassProp(className, value) {\n    checkStylingProperty(className, value, null, true);\n    return ɵɵclassProp;\n}\n/**\n * Update style bindings using an object literal on an element.\n *\n * This instruction is meant to apply styling via the `[style]=\"exp\"` template bindings.\n * When styles are applied to the element they will then be updated with respect to\n * any styles/classes set via `styleProp`. If any styles are set to falsy\n * then they will be removed from the element.\n *\n * Note that the styling instruction will not be applied until `stylingApply` is called.\n *\n * @param styles A key/value style map of the styles that will be applied to the given element.\n *        Any missing styles (that have already been applied to the element beforehand) will be\n *        removed (unset) from the element's styling.\n *\n * Note that this will apply the provided styleMap value to the host element if this function\n * is called within a host binding.\n *\n * @codeGenApi\n */\nfunction ɵɵstyleMap(styles) {\n    checkStylingMap(styleKeyValueArraySet, styleStringParser, styles, false);\n}\n/**\n * Parse text as style and add values to KeyValueArray.\n *\n * This code is pulled out to a separate function so that it can be tree shaken away if it is not\n * needed. It is only referenced from `ɵɵstyleMap`.\n *\n * @param keyValueArray KeyValueArray to add parsed values to.\n * @param text text to parse.\n */\nfunction styleStringParser(keyValueArray, text) {\n    for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i)) {\n        styleKeyValueArraySet(keyValueArray, getLastParsedKey(text), getLastParsedValue(text));\n    }\n}\n/**\n * Update class bindings using an object literal or class-string on an element.\n *\n * This instruction is meant to apply styling via the `[class]=\"exp\"` template bindings.\n * When classes are applied to the element they will then be updated with\n * respect to any styles/classes set via `classProp`. If any\n * classes are set to falsy then they will be removed from the element.\n *\n * Note that the styling instruction will not be applied until `stylingApply` is called.\n * Note that this will the provided classMap value to the host element if this function is called\n * within a host binding.\n *\n * @param classes A key/value map or string of CSS classes that will be added to the\n *        given element. Any missing classes (that have already been applied to the element\n *        beforehand) will be removed (unset) from the element's list of CSS classes.\n *\n * @codeGenApi\n */\nfunction ɵɵclassMap(classes) {\n    checkStylingMap(keyValueArraySet, classStringParser, classes, true);\n}\n/**\n * Parse text as class and add values to KeyValueArray.\n *\n * This code is pulled out to a separate function so that it can be tree shaken away if it is not\n * needed. It is only referenced from `ɵɵclassMap`.\n *\n * @param keyValueArray KeyValueArray to add parsed values to.\n * @param text text to parse.\n */\nfunction classStringParser(keyValueArray, text) {\n    for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {\n        keyValueArraySet(keyValueArray, getLastParsedKey(text), true);\n    }\n}\n/**\n * Common code between `ɵɵclassProp` and `ɵɵstyleProp`.\n *\n * @param prop property name.\n * @param value binding value.\n * @param suffix suffix for the property (e.g. `em` or `px`)\n * @param isClassBased `true` if `class` change (`false` if `style`)\n */\nfunction checkStylingProperty(prop, value, suffix, isClassBased) {\n    const lView = getLView();\n    const tView = getTView();\n    // Styling instructions use 2 slots per binding.\n    // 1. one for the value / TStylingKey\n    // 2. one for the intermittent-value / TStylingRange\n    const bindingIndex = incrementBindingIndex(2);\n    if (tView.firstUpdatePass) {\n        stylingFirstUpdatePass(tView, prop, bindingIndex, isClassBased);\n    }\n    if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {\n        const tNode = tView.data[getSelectedIndex()];\n        updateStyling(tView, tNode, lView, lView[RENDERER], prop, lView[bindingIndex + 1] = normalizeSuffix(value, suffix), isClassBased, bindingIndex);\n    }\n}\n/**\n * Common code between `ɵɵclassMap` and `ɵɵstyleMap`.\n *\n * @param keyValueArraySet (See `keyValueArraySet` in \"util/array_utils\") Gets passed in as a\n *        function so that `style` can be processed. This is done for tree shaking purposes.\n * @param stringParser Parser used to parse `value` if `string`. (Passed in as `style` and `class`\n *        have different parsers.)\n * @param value bound value from application\n * @param isClassBased `true` if `class` change (`false` if `style`)\n */\nfunction checkStylingMap(keyValueArraySet, stringParser, value, isClassBased) {\n    const tView = getTView();\n    const bindingIndex = incrementBindingIndex(2);\n    if (tView.firstUpdatePass) {\n        stylingFirstUpdatePass(tView, null, bindingIndex, isClassBased);\n    }\n    const lView = getLView();\n    if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {\n        // `getSelectedIndex()` should be here (rather than in instruction) so that it is guarded by the\n        // if so as not to read unnecessarily.\n        const tNode = tView.data[getSelectedIndex()];\n        if (hasStylingInputShadow(tNode, isClassBased) && !isInHostBindings(tView, bindingIndex)) {\n            if (ngDevMode) {\n                // verify that if we are shadowing then `TData` is appropriately marked so that we skip\n                // processing this binding in styling resolution.\n                const tStylingKey = tView.data[bindingIndex];\n                assertEqual(Array.isArray(tStylingKey) ? tStylingKey[1] : tStylingKey, false, 'Styling linked list shadow input should be marked as \\'false\\'');\n            }\n            // VE does not concatenate the static portion like we are doing here.\n            // Instead VE just ignores the static completely if dynamic binding is present.\n            // Because of locality we have already set the static portion because we don't know if there\n            // is a dynamic portion until later. If we would ignore the static portion it would look like\n            // the binding has removed it. This would confuse `[ngStyle]`/`[ngClass]` to do the wrong\n            // thing as it would think that the static portion was removed. For this reason we\n            // concatenate it so that `[ngStyle]`/`[ngClass]`  can continue to work on changed.\n            let staticPrefix = isClassBased ? tNode.classesWithoutHost : tNode.stylesWithoutHost;\n            ngDevMode && isClassBased === false && staticPrefix !== null &&\n                assertEqual(staticPrefix.endsWith(';'), true, 'Expecting static portion to end with \\';\\'');\n            if (staticPrefix !== null) {\n                // We want to make sure that falsy values of `value` become empty strings.\n                value = concatStringsWithSpace(staticPrefix, value ? value : '');\n            }\n            // Given `<div [style] my-dir>` such that `my-dir` has `@Input('style')`.\n            // This takes over the `[style]` binding. (Same for `[class]`)\n            setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased);\n        }\n        else {\n            updateStylingMap(tView, tNode, lView, lView[RENDERER], lView[bindingIndex + 1], lView[bindingIndex + 1] = toStylingKeyValueArray(keyValueArraySet, stringParser, value), isClassBased, bindingIndex);\n        }\n    }\n}\n/**\n * Determines when the binding is in `hostBindings` section\n *\n * @param tView Current `TView`\n * @param bindingIndex index of binding which we would like if it is in `hostBindings`\n */\nfunction isInHostBindings(tView, bindingIndex) {\n    // All host bindings are placed after the expando section.\n    return bindingIndex >= tView.expandoStartIndex;\n}\n/**\n * Collects the necessary information to insert the binding into a linked list of style bindings\n * using `insertTStylingBinding`.\n *\n * @param tView `TView` where the binding linked list will be stored.\n * @param tStylingKey Property/key of the binding.\n * @param bindingIndex Index of binding associated with the `prop`\n * @param isClassBased `true` if `class` change (`false` if `style`)\n */\nfunction stylingFirstUpdatePass(tView, tStylingKey, bindingIndex, isClassBased) {\n    ngDevMode && assertFirstUpdatePass(tView);\n    const tData = tView.data;\n    if (tData[bindingIndex + 1] === null) {\n        // The above check is necessary because we don't clear first update pass until first successful\n        // (no exception) template execution. This prevents the styling instruction from double adding\n        // itself to the list.\n        // `getSelectedIndex()` should be here (rather than in instruction) so that it is guarded by the\n        // if so as not to read unnecessarily.\n        const tNode = tData[getSelectedIndex()];\n        ngDevMode && assertDefined(tNode, 'TNode expected');\n        const isHostBindings = isInHostBindings(tView, bindingIndex);\n        if (hasStylingInputShadow(tNode, isClassBased) && tStylingKey === null && !isHostBindings) {\n            // `tStylingKey === null` implies that we are either `[style]` or `[class]` binding.\n            // If there is a directive which uses `@Input('style')` or `@Input('class')` than\n            // we need to neutralize this binding since that directive is shadowing it.\n            // We turn this into a noop by setting the key to `false`\n            tStylingKey = false;\n        }\n        tStylingKey = wrapInStaticStylingKey(tData, tNode, tStylingKey, isClassBased);\n        insertTStylingBinding(tData, tNode, tStylingKey, bindingIndex, isHostBindings, isClassBased);\n    }\n}\n/**\n * Adds static styling information to the binding if applicable.\n *\n * The linked list of styles not only stores the list and keys, but also stores static styling\n * information on some of the keys. This function determines if the key should contain the styling\n * information and computes it.\n *\n * See `TStylingStatic` for more details.\n *\n * @param tData `TData` where the linked list is stored.\n * @param tNode `TNode` for which the styling is being computed.\n * @param stylingKey `TStylingKeyPrimitive` which may need to be wrapped into `TStylingKey`\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction wrapInStaticStylingKey(tData, tNode, stylingKey, isClassBased) {\n    const hostDirectiveDef = getCurrentDirectiveDef(tData);\n    let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;\n    if (hostDirectiveDef === null) {\n        // We are in template node.\n        // If template node already had styling instruction then it has already collected the static\n        // styling and there is no need to collect them again. We know that we are the first styling\n        // instruction because the `TNode.*Bindings` points to 0 (nothing has been inserted yet).\n        const isFirstStylingInstructionInTemplate = (isClassBased ? tNode.classBindings : tNode.styleBindings) === 0;\n        if (isFirstStylingInstructionInTemplate) {\n            // It would be nice to be able to get the statics from `mergeAttrs`, however, at this point\n            // they are already merged and it would not be possible to figure which property belongs where\n            // in the priority.\n            stylingKey = collectStylingFromDirectives(null, tData, tNode, stylingKey, isClassBased);\n            stylingKey = collectStylingFromTAttrs(stylingKey, tNode.attrs, isClassBased);\n            // We know that if we have styling binding in template we can't have residual.\n            residual = null;\n        }\n    }\n    else {\n        // We are in host binding node and there was no binding instruction in template node.\n        // This means that we need to compute the residual.\n        const directiveStylingLast = tNode.directiveStylingLast;\n        const isFirstStylingInstructionInHostBinding = directiveStylingLast === -1 || tData[directiveStylingLast] !== hostDirectiveDef;\n        if (isFirstStylingInstructionInHostBinding) {\n            stylingKey =\n                collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased);\n            if (residual === null) {\n                // - If `null` than either:\n                //    - Template styling instruction already ran and it has consumed the static\n                //      styling into its `TStylingKey` and so there is no need to update residual. Instead\n                //      we need to update the `TStylingKey` associated with the first template node\n                //      instruction. OR\n                //    - Some other styling instruction ran and determined that there are no residuals\n                let templateStylingKey = getTemplateHeadTStylingKey(tData, tNode, isClassBased);\n                if (templateStylingKey !== undefined && Array.isArray(templateStylingKey)) {\n                    // Only recompute if `templateStylingKey` had static values. (If no static value found\n                    // then there is nothing to do since this operation can only produce less static keys, not\n                    // more.)\n                    templateStylingKey = collectStylingFromDirectives(null, tData, tNode, templateStylingKey[1] /* unwrap previous statics */, isClassBased);\n                    templateStylingKey =\n                        collectStylingFromTAttrs(templateStylingKey, tNode.attrs, isClassBased);\n                    setTemplateHeadTStylingKey(tData, tNode, isClassBased, templateStylingKey);\n                }\n            }\n            else {\n                // We only need to recompute residual if it is not `null`.\n                // - If existing residual (implies there was no template styling). This means that some of\n                //   the statics may have moved from the residual to the `stylingKey` and so we have to\n                //   recompute.\n                // - If `undefined` this is the first time we are running.\n                residual = collectResidual(tData, tNode, isClassBased);\n            }\n        }\n    }\n    if (residual !== undefined) {\n        isClassBased ? (tNode.residualClasses = residual) : (tNode.residualStyles = residual);\n    }\n    return stylingKey;\n}\n/**\n * Retrieve the `TStylingKey` for the template styling instruction.\n *\n * This is needed since `hostBinding` styling instructions are inserted after the template\n * instruction. While the template instruction needs to update the residual in `TNode` the\n * `hostBinding` instructions need to update the `TStylingKey` of the template instruction because\n * the template instruction is downstream from the `hostBindings` instructions.\n *\n * @param tData `TData` where the linked list is stored.\n * @param tNode `TNode` for which the styling is being computed.\n * @param isClassBased `true` if `class` (`false` if `style`)\n * @return `TStylingKey` if found or `undefined` if not found.\n */\nfunction getTemplateHeadTStylingKey(tData, tNode, isClassBased) {\n    const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;\n    if (getTStylingRangeNext(bindings) === 0) {\n        // There does not seem to be a styling instruction in the `template`.\n        return undefined;\n    }\n    return tData[getTStylingRangePrev(bindings)];\n}\n/**\n * Update the `TStylingKey` of the first template instruction in `TNode`.\n *\n * Logically `hostBindings` styling instructions are of lower priority than that of the template.\n * However, they execute after the template styling instructions. This means that they get inserted\n * in front of the template styling instructions.\n *\n * If we have a template styling instruction and a new `hostBindings` styling instruction is\n * executed it means that it may need to steal static fields from the template instruction. This\n * method allows us to update the first template instruction `TStylingKey` with a new value.\n *\n * Assume:\n * ```\n * <div my-dir style=\"color: red\" [style.color]=\"tmplExp\"></div>\n *\n * @Directive({\n *   host: {\n *     'style': 'width: 100px',\n *     '[style.color]': 'dirExp',\n *   }\n * })\n * class MyDir {}\n * ```\n *\n * when `[style.color]=\"tmplExp\"` executes it creates this data structure.\n * ```\n *  ['', 'color', 'color', 'red', 'width', '100px'],\n * ```\n *\n * The reason for this is that the template instruction does not know if there are styling\n * instructions and must assume that there are none and must collect all of the static styling.\n * (both\n * `color' and 'width`)\n *\n * When `'[style.color]': 'dirExp',` executes we need to insert a new data into the linked list.\n * ```\n *  ['', 'color', 'width', '100px'],  // newly inserted\n *  ['', 'color', 'color', 'red', 'width', '100px'], // this is wrong\n * ```\n *\n * Notice that the template statics is now wrong as it incorrectly contains `width` so we need to\n * update it like so:\n * ```\n *  ['', 'color', 'width', '100px'],\n *  ['', 'color', 'color', 'red'],    // UPDATE\n * ```\n *\n * @param tData `TData` where the linked list is stored.\n * @param tNode `TNode` for which the styling is being computed.\n * @param isClassBased `true` if `class` (`false` if `style`)\n * @param tStylingKey New `TStylingKey` which is replacing the old one.\n */\nfunction setTemplateHeadTStylingKey(tData, tNode, isClassBased, tStylingKey) {\n    const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;\n    ngDevMode &&\n        assertNotEqual(getTStylingRangeNext(bindings), 0, 'Expecting to have at least one template styling binding.');\n    tData[getTStylingRangePrev(bindings)] = tStylingKey;\n}\n/**\n * Collect all static values after the current `TNode.directiveStylingLast` index.\n *\n * Collect the remaining styling information which has not yet been collected by an existing\n * styling instruction.\n *\n * @param tData `TData` where the `DirectiveDefs` are stored.\n * @param tNode `TNode` which contains the directive range.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction collectResidual(tData, tNode, isClassBased) {\n    let residual = undefined;\n    const directiveEnd = tNode.directiveEnd;\n    ngDevMode &&\n        assertNotEqual(tNode.directiveStylingLast, -1, 'By the time this function gets called at least one hostBindings-node styling instruction must have executed.');\n    // We add `1 + tNode.directiveStart` because we need to skip the current directive (as we are\n    // collecting things after the last `hostBindings` directive which had a styling instruction.)\n    for (let i = 1 + tNode.directiveStylingLast; i < directiveEnd; i++) {\n        const attrs = tData[i].hostAttrs;\n        residual = collectStylingFromTAttrs(residual, attrs, isClassBased);\n    }\n    return collectStylingFromTAttrs(residual, tNode.attrs, isClassBased);\n}\n/**\n * Collect the static styling information with lower priority than `hostDirectiveDef`.\n *\n * (This is opposite of residual styling.)\n *\n * @param hostDirectiveDef `DirectiveDef` for which we want to collect lower priority static\n *        styling. (Or `null` if template styling)\n * @param tData `TData` where the linked list is stored.\n * @param tNode `TNode` for which the styling is being computed.\n * @param stylingKey Existing `TStylingKey` to update or wrap.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased) {\n    // We need to loop because there can be directives which have `hostAttrs` but don't have\n    // `hostBindings` so this loop catches up to the current directive..\n    let currentDirective = null;\n    const directiveEnd = tNode.directiveEnd;\n    let directiveStylingLast = tNode.directiveStylingLast;\n    if (directiveStylingLast === -1) {\n        directiveStylingLast = tNode.directiveStart;\n    }\n    else {\n        directiveStylingLast++;\n    }\n    while (directiveStylingLast < directiveEnd) {\n        currentDirective = tData[directiveStylingLast];\n        ngDevMode && assertDefined(currentDirective, 'expected to be defined');\n        stylingKey = collectStylingFromTAttrs(stylingKey, currentDirective.hostAttrs, isClassBased);\n        if (currentDirective === hostDirectiveDef)\n            break;\n        directiveStylingLast++;\n    }\n    if (hostDirectiveDef !== null) {\n        // we only advance the styling cursor if we are collecting data from host bindings.\n        // Template executes before host bindings and so if we would update the index,\n        // host bindings would not get their statics.\n        tNode.directiveStylingLast = directiveStylingLast;\n    }\n    return stylingKey;\n}\n/**\n * Convert `TAttrs` into `TStylingStatic`.\n *\n * @param stylingKey existing `TStylingKey` to update or wrap.\n * @param attrs `TAttributes` to process.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction collectStylingFromTAttrs(stylingKey, attrs, isClassBased) {\n    const desiredMarker = isClassBased ? 1 /* AttributeMarker.Classes */ : 2 /* AttributeMarker.Styles */;\n    let currentMarker = -1 /* AttributeMarker.ImplicitAttributes */;\n    if (attrs !== null) {\n        for (let i = 0; i < attrs.length; i++) {\n            const item = attrs[i];\n            if (typeof item === 'number') {\n                currentMarker = item;\n            }\n            else {\n                if (currentMarker === desiredMarker) {\n                    if (!Array.isArray(stylingKey)) {\n                        stylingKey = stylingKey === undefined ? [] : ['', stylingKey];\n                    }\n                    keyValueArraySet(stylingKey, item, isClassBased ? true : attrs[++i]);\n                }\n            }\n        }\n    }\n    return stylingKey === undefined ? null : stylingKey;\n}\n/**\n * Convert user input to `KeyValueArray`.\n *\n * This function takes user input which could be `string`, Object literal, or iterable and converts\n * it into a consistent representation. The output of this is `KeyValueArray` (which is an array\n * where\n * even indexes contain keys and odd indexes contain values for those keys).\n *\n * The advantage of converting to `KeyValueArray` is that we can perform diff in an input\n * independent\n * way.\n * (ie we can compare `foo bar` to `['bar', 'baz'] and determine a set of changes which need to be\n * applied)\n *\n * The fact that `KeyValueArray` is sorted is very important because it allows us to compute the\n * difference in linear fashion without the need to allocate any additional data.\n *\n * For example if we kept this as a `Map` we would have to iterate over previous `Map` to determine\n * which values need to be deleted, over the new `Map` to determine additions, and we would have to\n * keep additional `Map` to keep track of duplicates or items which have not yet been visited.\n *\n * @param keyValueArraySet (See `keyValueArraySet` in \"util/array_utils\") Gets passed in as a\n *        function so that `style` can be processed. This is done\n *        for tree shaking purposes.\n * @param stringParser The parser is passed in so that it will be tree shakable. See\n *        `styleStringParser` and `classStringParser`\n * @param value The value to parse/convert to `KeyValueArray`\n */\nfunction toStylingKeyValueArray(keyValueArraySet, stringParser, value) {\n    if (value == null /*|| value === undefined */ || value === '')\n        return EMPTY_ARRAY;\n    const styleKeyValueArray = [];\n    const unwrappedValue = unwrapSafeValue(value);\n    if (Array.isArray(unwrappedValue)) {\n        for (let i = 0; i < unwrappedValue.length; i++) {\n            keyValueArraySet(styleKeyValueArray, unwrappedValue[i], true);\n        }\n    }\n    else if (typeof unwrappedValue === 'object') {\n        for (const key in unwrappedValue) {\n            if (unwrappedValue.hasOwnProperty(key)) {\n                keyValueArraySet(styleKeyValueArray, key, unwrappedValue[key]);\n            }\n        }\n    }\n    else if (typeof unwrappedValue === 'string') {\n        stringParser(styleKeyValueArray, unwrappedValue);\n    }\n    else {\n        ngDevMode &&\n            throwError('Unsupported styling type ' + typeof unwrappedValue + ': ' + unwrappedValue);\n    }\n    return styleKeyValueArray;\n}\n/**\n * Set a `value` for a `key`.\n *\n * See: `keyValueArraySet` for details\n *\n * @param keyValueArray KeyValueArray to add to.\n * @param key Style key to add.\n * @param value The value to set.\n */\nfunction styleKeyValueArraySet(keyValueArray, key, value) {\n    keyValueArraySet(keyValueArray, key, unwrapSafeValue(value));\n}\n/**\n * Update map based styling.\n *\n * Map based styling could be anything which contains more than one binding. For example `string`,\n * or object literal. Dealing with all of these types would complicate the logic so\n * instead this function expects that the complex input is first converted into normalized\n * `KeyValueArray`. The advantage of normalization is that we get the values sorted, which makes it\n * very cheap to compute deltas between the previous and current value.\n *\n * @param tView Associated `TView.data` contains the linked list of binding priorities.\n * @param tNode `TNode` where the binding is located.\n * @param lView `LView` contains the values associated with other styling binding at this `TNode`.\n * @param renderer Renderer to use if any updates.\n * @param oldKeyValueArray Previous value represented as `KeyValueArray`\n * @param newKeyValueArray Current value represented as `KeyValueArray`\n * @param isClassBased `true` if `class` (`false` if `style`)\n * @param bindingIndex Binding index of the binding.\n */\nfunction updateStylingMap(tView, tNode, lView, renderer, oldKeyValueArray, newKeyValueArray, isClassBased, bindingIndex) {\n    if (oldKeyValueArray === NO_CHANGE) {\n        // On first execution the oldKeyValueArray is NO_CHANGE => treat it as empty KeyValueArray.\n        oldKeyValueArray = EMPTY_ARRAY;\n    }\n    let oldIndex = 0;\n    let newIndex = 0;\n    let oldKey = 0 < oldKeyValueArray.length ? oldKeyValueArray[0] : null;\n    let newKey = 0 < newKeyValueArray.length ? newKeyValueArray[0] : null;\n    while (oldKey !== null || newKey !== null) {\n        ngDevMode && assertLessThan(oldIndex, 999, 'Are we stuck in infinite loop?');\n        ngDevMode && assertLessThan(newIndex, 999, 'Are we stuck in infinite loop?');\n        const oldValue = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex + 1] : undefined;\n        const newValue = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex + 1] : undefined;\n        let setKey = null;\n        let setValue = undefined;\n        if (oldKey === newKey) {\n            // UPDATE: Keys are equal => new value is overwriting old value.\n            oldIndex += 2;\n            newIndex += 2;\n            if (oldValue !== newValue) {\n                setKey = newKey;\n                setValue = newValue;\n            }\n        }\n        else if (newKey === null || oldKey !== null && oldKey < newKey) {\n            // DELETE: oldKey key is missing or we did not find the oldKey in the newValue\n            // (because the keyValueArray is sorted and `newKey` is found later alphabetically).\n            // `\"background\" < \"color\"` so we need to delete `\"background\"` because it is not found in the\n            // new array.\n            oldIndex += 2;\n            setKey = oldKey;\n        }\n        else {\n            // CREATE: newKey's is earlier alphabetically than oldKey's (or no oldKey) => we have new key.\n            // `\"color\" > \"background\"` so we need to add `color` because it is in new array but not in\n            // old array.\n            ngDevMode && assertDefined(newKey, 'Expecting to have a valid key');\n            newIndex += 2;\n            setKey = newKey;\n            setValue = newValue;\n        }\n        if (setKey !== null) {\n            updateStyling(tView, tNode, lView, renderer, setKey, setValue, isClassBased, bindingIndex);\n        }\n        oldKey = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex] : null;\n        newKey = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex] : null;\n    }\n}\n/**\n * Update a simple (property name) styling.\n *\n * This function takes `prop` and updates the DOM to that value. The function takes the binding\n * value as well as binding priority into consideration to determine which value should be written\n * to DOM. (For example it may be determined that there is a higher priority overwrite which blocks\n * the DOM write, or if the value goes to `undefined` a lower priority overwrite may be consulted.)\n *\n * @param tView Associated `TView.data` contains the linked list of binding priorities.\n * @param tNode `TNode` where the binding is located.\n * @param lView `LView` contains the values associated with other styling binding at this `TNode`.\n * @param renderer Renderer to use if any updates.\n * @param prop Either style property name or a class name.\n * @param value Either style value for `prop` or `true`/`false` if `prop` is class.\n * @param isClassBased `true` if `class` (`false` if `style`)\n * @param bindingIndex Binding index of the binding.\n */\nfunction updateStyling(tView, tNode, lView, renderer, prop, value, isClassBased, bindingIndex) {\n    if (!(tNode.type & 3 /* TNodeType.AnyRNode */)) {\n        // It is possible to have styling on non-elements (such as ng-container).\n        // This is rare, but it does happen. In such a case, just ignore the binding.\n        return;\n    }\n    const tData = tView.data;\n    const tRange = tData[bindingIndex + 1];\n    const higherPriorityValue = getTStylingRangeNextDuplicate(tRange) ?\n        findStylingValue(tData, tNode, lView, prop, getTStylingRangeNext(tRange), isClassBased) :\n        undefined;\n    if (!isStylingValuePresent(higherPriorityValue)) {\n        // We don't have a next duplicate, or we did not find a duplicate value.\n        if (!isStylingValuePresent(value)) {\n            // We should delete current value or restore to lower priority value.\n            if (getTStylingRangePrevDuplicate(tRange)) {\n                // We have a possible prev duplicate, let's retrieve it.\n                value = findStylingValue(tData, null, lView, prop, bindingIndex, isClassBased);\n            }\n        }\n        const rNode = getNativeByIndex(getSelectedIndex(), lView);\n        applyStyling(renderer, isClassBased, rNode, prop, value);\n    }\n}\n/**\n * Search for styling value with higher priority which is overwriting current value, or a\n * value of lower priority to which we should fall back if the value is `undefined`.\n *\n * When value is being applied at a location, related values need to be consulted.\n * - If there is a higher priority binding, we should be using that one instead.\n *   For example `<div  [style]=\"{color:exp1}\" [style.color]=\"exp2\">` change to `exp1`\n *   requires that we check `exp2` to see if it is set to value other than `undefined`.\n * - If there is a lower priority binding and we are changing to `undefined`\n *   For example `<div  [style]=\"{color:exp1}\" [style.color]=\"exp2\">` change to `exp2` to\n *   `undefined` requires that we check `exp1` (and static values) and use that as new value.\n *\n * NOTE: The styling stores two values.\n * 1. The raw value which came from the application is stored at `index + 0` location. (This value\n *    is used for dirty checking).\n * 2. The normalized value is stored at `index + 1`.\n *\n * @param tData `TData` used for traversing the priority.\n * @param tNode `TNode` to use for resolving static styling. Also controls search direction.\n *   - `TNode` search next and quit as soon as `isStylingValuePresent(value)` is true.\n *      If no value found consult `tNode.residualStyle`/`tNode.residualClass` for default value.\n *   - `null` search prev and go all the way to end. Return last value where\n *     `isStylingValuePresent(value)` is true.\n * @param lView `LView` used for retrieving the actual values.\n * @param prop Property which we are interested in.\n * @param index Starting index in the linked list of styling bindings where the search should start.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction findStylingValue(tData, tNode, lView, prop, index, isClassBased) {\n    // `TNode` to use for resolving static styling. Also controls search direction.\n    //   - `TNode` search next and quit as soon as `isStylingValuePresent(value)` is true.\n    //      If no value found consult `tNode.residualStyle`/`tNode.residualClass` for default value.\n    //   - `null` search prev and go all the way to end. Return last value where\n    //     `isStylingValuePresent(value)` is true.\n    const isPrevDirection = tNode === null;\n    let value = undefined;\n    while (index > 0) {\n        const rawKey = tData[index];\n        const containsStatics = Array.isArray(rawKey);\n        // Unwrap the key if we contain static values.\n        const key = containsStatics ? rawKey[1] : rawKey;\n        const isStylingMap = key === null;\n        let valueAtLViewIndex = lView[index + 1];\n        if (valueAtLViewIndex === NO_CHANGE) {\n            // In firstUpdatePass the styling instructions create a linked list of styling.\n            // On subsequent passes it is possible for a styling instruction to try to read a binding\n            // which\n            // has not yet executed. In that case we will find `NO_CHANGE` and we should assume that\n            // we have `undefined` (or empty array in case of styling-map instruction) instead. This\n            // allows the resolution to apply the value (which may later be overwritten when the\n            // binding actually executes.)\n            valueAtLViewIndex = isStylingMap ? EMPTY_ARRAY : undefined;\n        }\n        let currentValue = isStylingMap ? keyValueArrayGet(valueAtLViewIndex, prop) :\n            key === prop ? valueAtLViewIndex : undefined;\n        if (containsStatics && !isStylingValuePresent(currentValue)) {\n            currentValue = keyValueArrayGet(rawKey, prop);\n        }\n        if (isStylingValuePresent(currentValue)) {\n            value = currentValue;\n            if (isPrevDirection) {\n                return value;\n            }\n        }\n        const tRange = tData[index + 1];\n        index = isPrevDirection ? getTStylingRangePrev(tRange) : getTStylingRangeNext(tRange);\n    }\n    if (tNode !== null) {\n        // in case where we are going in next direction AND we did not find anything, we need to\n        // consult residual styling\n        let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;\n        if (residual != null /** OR residual !=== undefined */) {\n            value = keyValueArrayGet(residual, prop);\n        }\n    }\n    return value;\n}\n/**\n * Determines if the binding value should be used (or if the value is 'undefined' and hence priority\n * resolution should be used.)\n *\n * @param value Binding style value.\n */\nfunction isStylingValuePresent(value) {\n    // Currently only `undefined` value is considered non-binding. That is `undefined` says I don't\n    // have an opinion as to what this binding should be and you should consult other bindings by\n    // priority to determine the valid value.\n    // This is extracted into a single function so that we have a single place to control this.\n    return value !== undefined;\n}\n/**\n * Normalizes and/or adds a suffix to the value.\n *\n * If value is `null`/`undefined` no suffix is added\n * @param value\n * @param suffix\n */\nfunction normalizeSuffix(value, suffix) {\n    if (value == null /** || value === undefined */) {\n        // do nothing\n    }\n    else if (typeof suffix === 'string') {\n        value = value + suffix;\n    }\n    else if (typeof value === 'object') {\n        value = stringify(unwrapSafeValue(value));\n    }\n    return value;\n}\n/**\n * Tests if the `TNode` has input shadow.\n *\n * An input shadow is when a directive steals (shadows) the input by using `@Input('style')` or\n * `@Input('class')` as input.\n *\n * @param tNode `TNode` which we would like to see if it has shadow.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction hasStylingInputShadow(tNode, isClassBased) {\n    return (tNode.flags & (isClassBased ? 16 /* TNodeFlags.hasClassInput */ : 32 /* TNodeFlags.hasStyleInput */)) !== 0;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Create static text node\n *\n * @param index Index of the node in the data array\n * @param value Static string value to write.\n *\n * @codeGenApi\n */\nfunction ɵɵtext(index, value = '') {\n    const lView = getLView();\n    const tView = getTView();\n    const adjustedIndex = index + HEADER_OFFSET;\n    ngDevMode &&\n        assertEqual(getBindingIndex(), tView.bindingStartIndex, 'text nodes should be created before any bindings');\n    ngDevMode && assertIndexInRange(lView, adjustedIndex);\n    const tNode = tView.firstCreatePass ?\n        getOrCreateTNode(tView, adjustedIndex, 1 /* TNodeType.Text */, value, null) :\n        tView.data[adjustedIndex];\n    const textNative = lView[adjustedIndex] = createTextNode(lView[RENDERER], value);\n    appendChild(tView, lView, textNative, tNode);\n    // Text nodes are self closing.\n    setCurrentTNode(tNode, false);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n *\n * Update text content with a lone bound value\n *\n * Used when a text node has 1 interpolated value in it, an no additional text\n * surrounds that interpolated value:\n *\n * ```html\n * <div>{{v0}}</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate(v0);\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nfunction ɵɵtextInterpolate(v0) {\n    ɵɵtextInterpolate1('', v0, '');\n    return ɵɵtextInterpolate;\n}\n/**\n *\n * Update text content with single bound value surrounded by other text.\n *\n * Used when a text node has 1 interpolated value in it:\n *\n * ```html\n * <div>prefix{{v0}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate1('prefix', v0, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nfunction ɵɵtextInterpolate1(prefix, v0, suffix) {\n    const lView = getLView();\n    const interpolated = interpolation1(lView, prefix, v0, suffix);\n    if (interpolated !== NO_CHANGE) {\n        textBindingInternal(lView, getSelectedIndex(), interpolated);\n    }\n    return ɵɵtextInterpolate1;\n}\n/**\n *\n * Update text content with 2 bound values surrounded by other text.\n *\n * Used when a text node has 2 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate2('prefix', v0, '-', v1, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nfunction ɵɵtextInterpolate2(prefix, v0, i0, v1, suffix) {\n    const lView = getLView();\n    const interpolated = interpolation2(lView, prefix, v0, i0, v1, suffix);\n    if (interpolated !== NO_CHANGE) {\n        textBindingInternal(lView, getSelectedIndex(), interpolated);\n    }\n    return ɵɵtextInterpolate2;\n}\n/**\n *\n * Update text content with 3 bound values surrounded by other text.\n *\n * Used when a text node has 3 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate3(\n * 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nfunction ɵɵtextInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {\n    const lView = getLView();\n    const interpolated = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n    if (interpolated !== NO_CHANGE) {\n        textBindingInternal(lView, getSelectedIndex(), interpolated);\n    }\n    return ɵɵtextInterpolate3;\n}\n/**\n *\n * Update text content with 4 bound values surrounded by other text.\n *\n * Used when a text node has 4 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate4(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see ɵɵtextInterpolateV\n * @codeGenApi\n */\nfunction ɵɵtextInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {\n    const lView = getLView();\n    const interpolated = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n    if (interpolated !== NO_CHANGE) {\n        textBindingInternal(lView, getSelectedIndex(), interpolated);\n    }\n    return ɵɵtextInterpolate4;\n}\n/**\n *\n * Update text content with 5 bound values surrounded by other text.\n *\n * Used when a text node has 5 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate5(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nfunction ɵɵtextInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {\n    const lView = getLView();\n    const interpolated = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n    if (interpolated !== NO_CHANGE) {\n        textBindingInternal(lView, getSelectedIndex(), interpolated);\n    }\n    return ɵɵtextInterpolate5;\n}\n/**\n *\n * Update text content with 6 bound values surrounded by other text.\n *\n * Used when a text node has 6 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate6(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change. @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nfunction ɵɵtextInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {\n    const lView = getLView();\n    const interpolated = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n    if (interpolated !== NO_CHANGE) {\n        textBindingInternal(lView, getSelectedIndex(), interpolated);\n    }\n    return ɵɵtextInterpolate6;\n}\n/**\n *\n * Update text content with 7 bound values surrounded by other text.\n *\n * Used when a text node has 7 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate7(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nfunction ɵɵtextInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {\n    const lView = getLView();\n    const interpolated = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n    if (interpolated !== NO_CHANGE) {\n        textBindingInternal(lView, getSelectedIndex(), interpolated);\n    }\n    return ɵɵtextInterpolate7;\n}\n/**\n *\n * Update text content with 8 bound values surrounded by other text.\n *\n * Used when a text node has 8 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate8(\n *  'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nfunction ɵɵtextInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {\n    const lView = getLView();\n    const interpolated = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n    if (interpolated !== NO_CHANGE) {\n        textBindingInternal(lView, getSelectedIndex(), interpolated);\n    }\n    return ɵɵtextInterpolate8;\n}\n/**\n * Update text content with 9 or more bound values other surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolateV(\n *  ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *.\n * @param values The collection of values and the strings in between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n *\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵtextInterpolateV(values) {\n    const lView = getLView();\n    const interpolated = interpolationV(lView, values);\n    if (interpolated !== NO_CHANGE) {\n        textBindingInternal(lView, getSelectedIndex(), interpolated);\n    }\n    return ɵɵtextInterpolateV;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n *\n * Update an interpolated class on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate1('prefix', v0, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵclassMapInterpolate1(prefix, v0, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate2('prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵclassMapInterpolate2(prefix, v0, i0, v1, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate3(\n * 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵclassMapInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate4(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵclassMapInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate5(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵclassMapInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate6(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵclassMapInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate7(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵclassMapInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolate8(\n *  'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵclassMapInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n * Update an interpolated class on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵclassMapInterpolateV(\n *  ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @codeGenApi\n */\nfunction ɵɵclassMapInterpolateV(values) {\n    const lView = getLView();\n    const interpolatedValue = interpolationV(lView, values);\n    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n *\n * Update an interpolated style on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div style=\"key: {{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate1('key: ', v0, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵstyleMapInterpolate1(prefix, v0, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n    ɵɵstyleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate2('key: ', v0, '; key1: ', v1, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵstyleMapInterpolate2(prefix, v0, i0, v1, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n    ɵɵstyleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key2: {{v1}}; key2: {{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate3(\n *     'key: ', v0, '; key1: ', v1, '; key2: ', v2, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵstyleMapInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n    ɵɵstyleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate4(\n *     'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵstyleMapInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n    ɵɵstyleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate5(\n *     'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵstyleMapInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n    ɵɵstyleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}};\n *             key5: {{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate6(\n *    'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *    'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵstyleMapInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n    ɵɵstyleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}; key5: {{v5}};\n *             key6: {{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate7(\n *    'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *    '; key6: ', v6, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵstyleMapInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n    ɵɵstyleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}; key5: {{v5}};\n *             key6: {{v6}}; key7: {{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolate8(\n *    'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *    '; key6: ', v6, '; key7: ', v7, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction ɵɵstyleMapInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n    ɵɵstyleMap(interpolatedValue);\n}\n/**\n * Update an interpolated style on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  class=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}; key5: {{v5}};\n *         key6: {{v6}}; key7: {{v7}}; key8: {{v8}}; key9: {{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstyleMapInterpolateV(\n *    ['key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *     '; key6: ', v6, '; key7: ', v7, '; key8: ', v8, '; key9: ', v9, 'suffix']);\n * ```\n *.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '; key2: ', value1, '; key2: ', value2, ..., value99, 'suffix']`)\n * @codeGenApi\n */\nfunction ɵɵstyleMapInterpolateV(values) {\n    const lView = getLView();\n    const interpolatedValue = interpolationV(lView, values);\n    ɵɵstyleMap(interpolatedValue);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n *\n * Update an interpolated style property on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate1(0, 'prefix', v0, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵstylePropInterpolate1(prop, prefix, v0, suffix, valueSuffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n    return ɵɵstylePropInterpolate1;\n}\n/**\n *\n * Update an interpolated style property on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate2(0, 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵstylePropInterpolate2(prop, prefix, v0, i0, v1, suffix, valueSuffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n    return ɵɵstylePropInterpolate2;\n}\n/**\n *\n * Update an interpolated style property on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate3(0, 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵstylePropInterpolate3(prop, prefix, v0, i0, v1, i1, v2, suffix, valueSuffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n    return ɵɵstylePropInterpolate3;\n}\n/**\n *\n * Update an interpolated style property on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate4(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵstylePropInterpolate4(prop, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, valueSuffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n    return ɵɵstylePropInterpolate4;\n}\n/**\n *\n * Update an interpolated style property on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate5(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵstylePropInterpolate5(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, valueSuffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n    return ɵɵstylePropInterpolate5;\n}\n/**\n *\n * Update an interpolated style property on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate6(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵstylePropInterpolate6(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, valueSuffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n    return ɵɵstylePropInterpolate6;\n}\n/**\n *\n * Update an interpolated style property on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate7(\n *    0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵstylePropInterpolate7(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, valueSuffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n    return ɵɵstylePropInterpolate7;\n}\n/**\n *\n * Update an interpolated style property on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolate8(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6,\n * '-', v7, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵstylePropInterpolate8(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, valueSuffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n    return ɵɵstylePropInterpolate8;\n}\n/**\n * Update an interpolated style property on an element with 9 or more bound values surrounded by\n * text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\">\n * </div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵstylePropInterpolateV(\n *  0, ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`..\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction ɵɵstylePropInterpolateV(prop, values, valueSuffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolationV(lView, values);\n    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n    return ɵɵstylePropInterpolateV;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Update a property on a host element. Only applies to native node properties, not inputs.\n *\n * Operates on the element selected by index via the {@link select} instruction.\n *\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n * @returns This function returns itself so that it may be chained\n * (e.g. `property('name', ctx.name)('title', ctx.title)`)\n *\n * @codeGenApi\n */\nfunction ɵɵhostProperty(propName, value, sanitizer) {\n    const lView = getLView();\n    const bindingIndex = nextBindingIndex();\n    if (bindingUpdated(lView, bindingIndex, value)) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, true);\n        ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);\n    }\n    return ɵɵhostProperty;\n}\n/**\n * Updates a synthetic host binding (e.g. `[@foo]`) on a component or directive.\n *\n * This instruction is for compatibility purposes and is designed to ensure that a\n * synthetic host binding (e.g. `@HostBinding('@foo')`) properly gets rendered in\n * the component's renderer. Normally all host bindings are evaluated with the parent\n * component's renderer, but, in the case of animation @triggers, they need to be\n * evaluated with the sub component's renderer (because that's where the animation\n * triggers are defined).\n *\n * Do not use this instruction as a replacement for `elementProperty`. This instruction\n * only exists to ensure compatibility with the ViewEngine's host binding behavior.\n *\n * @param index The index of the element to update in the data array\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n *\n * @codeGenApi\n */\nfunction ɵɵsyntheticHostProperty(propName, value, sanitizer) {\n    const lView = getLView();\n    const bindingIndex = nextBindingIndex();\n    if (bindingUpdated(lView, bindingIndex, value)) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        const currentDef = getCurrentDirectiveDef(tView.data);\n        const renderer = loadComponentRenderer(currentDef, tNode, lView);\n        elementPropertyInternal(tView, tNode, lView, propName, value, renderer, sanitizer, true);\n        ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);\n    }\n    return ɵɵsyntheticHostProperty;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * NOTE: changes to the `ngI18nClosureMode` name must be synced with `compiler-cli/src/tooling.ts`.\n */\nif (typeof ngI18nClosureMode === 'undefined') {\n    // These property accesses can be ignored because ngI18nClosureMode will be set to false\n    // when optimizing code and the whole if statement will be dropped.\n    // Make sure to refer to ngI18nClosureMode as ['ngI18nClosureMode'] for closure.\n    // NOTE: we need to have it in IIFE so that the tree-shaker is happy.\n    (function () {\n        // tslint:disable-next-line:no-toplevel-property-access\n        _global$1['ngI18nClosureMode'] =\n            // TODO(FW-1250): validate that this actually, you know, works.\n            // tslint:disable-next-line:no-toplevel-property-access\n            typeof goog !== 'undefined' && typeof goog.getMsg === 'function';\n    })();\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// THIS CODE IS GENERATED - DO NOT MODIFY.\nconst u = undefined;\nfunction plural(val) {\n    const n = val, i = Math.floor(Math.abs(val)), v = val.toString().replace(/^[^.]*\\.?/, '').length;\n    if (i === 1 && v === 0)\n        return 1;\n    return 5;\n}\nvar localeEn = [\"en\", [[\"a\", \"p\"], [\"AM\", \"PM\"], u], [[\"AM\", \"PM\"], u, u], [[\"S\", \"M\", \"T\", \"W\", \"T\", \"F\", \"S\"], [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"], [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"], [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\"]], u, [[\"J\", \"F\", \"M\", \"A\", \"M\", \"J\", \"J\", \"A\", \"S\", \"O\", \"N\", \"D\"], [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"], [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"]], u, [[\"B\", \"A\"], [\"BC\", \"AD\"], [\"Before Christ\", \"Anno Domini\"]], 0, [6, 0], [\"M/d/yy\", \"MMM d, y\", \"MMMM d, y\", \"EEEE, MMMM d, y\"], [\"h:mm a\", \"h:mm:ss a\", \"h:mm:ss a z\", \"h:mm:ss a zzzz\"], [\"{1}, {0}\", u, \"{1} 'at' {0}\", u], [\".\", \",\", \";\", \"%\", \"+\", \"-\", \"E\", \"×\", \"‰\", \"∞\", \"NaN\", \":\"], [\"#,##0.###\", \"#,##0%\", \"¤#,##0.00\", \"#E0\"], \"USD\", \"$\", \"US Dollar\", {}, \"ltr\", plural];\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * This const is used to store the locale data registered with `registerLocaleData`\n */\nlet LOCALE_DATA = {};\n/**\n * Register locale data to be used internally by Angular. See the\n * [\"I18n guide\"](guide/i18n-common-format-data-locale) to know how to import additional locale\n * data.\n *\n * The signature `registerLocaleData(data: any, extraData?: any)` is deprecated since v5.1\n */\nfunction registerLocaleData(data, localeId, extraData) {\n    if (typeof localeId !== 'string') {\n        extraData = localeId;\n        localeId = data[LocaleDataIndex.LocaleId];\n    }\n    localeId = localeId.toLowerCase().replace(/_/g, '-');\n    LOCALE_DATA[localeId] = data;\n    if (extraData) {\n        LOCALE_DATA[localeId][LocaleDataIndex.ExtraData] = extraData;\n    }\n}\n/**\n * Finds the locale data for a given locale.\n *\n * @param locale The locale code.\n * @returns The locale data.\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n-overview)\n */\nfunction findLocaleData(locale) {\n    const normalizedLocale = normalizeLocale(locale);\n    let match = getLocaleData(normalizedLocale);\n    if (match) {\n        return match;\n    }\n    // let's try to find a parent locale\n    const parentLocale = normalizedLocale.split('-')[0];\n    match = getLocaleData(parentLocale);\n    if (match) {\n        return match;\n    }\n    if (parentLocale === 'en') {\n        return localeEn;\n    }\n    throw new Error(`Missing locale data for the locale \"${locale}\".`);\n}\n/**\n * Retrieves the default currency code for the given locale.\n *\n * The default is defined as the first currency which is still in use.\n *\n * @param locale The code of the locale whose currency code we want.\n * @returns The code of the default currency for the given locale.\n *\n */\nfunction getLocaleCurrencyCode(locale) {\n    const data = findLocaleData(locale);\n    return data[LocaleDataIndex.CurrencyCode] || null;\n}\n/**\n * Retrieves the plural function used by ICU expressions to determine the plural case to use\n * for a given locale.\n * @param locale A locale code for the locale format rules to use.\n * @returns The plural function for the locale.\n * @see `NgPlural`\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n-overview)\n */\nfunction getLocalePluralCase(locale) {\n    const data = findLocaleData(locale);\n    return data[LocaleDataIndex.PluralCase];\n}\n/**\n * Helper function to get the given `normalizedLocale` from `LOCALE_DATA`\n * or from the global `ng.common.locale`.\n */\nfunction getLocaleData(normalizedLocale) {\n    if (!(normalizedLocale in LOCALE_DATA)) {\n        LOCALE_DATA[normalizedLocale] = _global$1.ng && _global$1.ng.common && _global$1.ng.common.locales &&\n            _global$1.ng.common.locales[normalizedLocale];\n    }\n    return LOCALE_DATA[normalizedLocale];\n}\n/**\n * Helper function to remove all the locale data from `LOCALE_DATA`.\n */\nfunction unregisterAllLocaleData() {\n    LOCALE_DATA = {};\n}\n/**\n * Index of each type of locale data from the locale data array\n */\nvar LocaleDataIndex;\n(function (LocaleDataIndex) {\n    LocaleDataIndex[LocaleDataIndex[\"LocaleId\"] = 0] = \"LocaleId\";\n    LocaleDataIndex[LocaleDataIndex[\"DayPeriodsFormat\"] = 1] = \"DayPeriodsFormat\";\n    LocaleDataIndex[LocaleDataIndex[\"DayPeriodsStandalone\"] = 2] = \"DayPeriodsStandalone\";\n    LocaleDataIndex[LocaleDataIndex[\"DaysFormat\"] = 3] = \"DaysFormat\";\n    LocaleDataIndex[LocaleDataIndex[\"DaysStandalone\"] = 4] = \"DaysStandalone\";\n    LocaleDataIndex[LocaleDataIndex[\"MonthsFormat\"] = 5] = \"MonthsFormat\";\n    LocaleDataIndex[LocaleDataIndex[\"MonthsStandalone\"] = 6] = \"MonthsStandalone\";\n    LocaleDataIndex[LocaleDataIndex[\"Eras\"] = 7] = \"Eras\";\n    LocaleDataIndex[LocaleDataIndex[\"FirstDayOfWeek\"] = 8] = \"FirstDayOfWeek\";\n    LocaleDataIndex[LocaleDataIndex[\"WeekendRange\"] = 9] = \"WeekendRange\";\n    LocaleDataIndex[LocaleDataIndex[\"DateFormat\"] = 10] = \"DateFormat\";\n    LocaleDataIndex[LocaleDataIndex[\"TimeFormat\"] = 11] = \"TimeFormat\";\n    LocaleDataIndex[LocaleDataIndex[\"DateTimeFormat\"] = 12] = \"DateTimeFormat\";\n    LocaleDataIndex[LocaleDataIndex[\"NumberSymbols\"] = 13] = \"NumberSymbols\";\n    LocaleDataIndex[LocaleDataIndex[\"NumberFormats\"] = 14] = \"NumberFormats\";\n    LocaleDataIndex[LocaleDataIndex[\"CurrencyCode\"] = 15] = \"CurrencyCode\";\n    LocaleDataIndex[LocaleDataIndex[\"CurrencySymbol\"] = 16] = \"CurrencySymbol\";\n    LocaleDataIndex[LocaleDataIndex[\"CurrencyName\"] = 17] = \"CurrencyName\";\n    LocaleDataIndex[LocaleDataIndex[\"Currencies\"] = 18] = \"Currencies\";\n    LocaleDataIndex[LocaleDataIndex[\"Directionality\"] = 19] = \"Directionality\";\n    LocaleDataIndex[LocaleDataIndex[\"PluralCase\"] = 20] = \"PluralCase\";\n    LocaleDataIndex[LocaleDataIndex[\"ExtraData\"] = 21] = \"ExtraData\";\n})(LocaleDataIndex || (LocaleDataIndex = {}));\n/**\n * Returns the canonical form of a locale name - lowercase with `_` replaced with `-`.\n */\nfunction normalizeLocale(locale) {\n    return locale.toLowerCase().replace(/_/g, '-');\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst pluralMapping = ['zero', 'one', 'two', 'few', 'many'];\n/**\n * Returns the plural case based on the locale\n */\nfunction getPluralCase(value, locale) {\n    const plural = getLocalePluralCase(locale)(parseInt(value, 10));\n    const result = pluralMapping[plural];\n    return (result !== undefined) ? result : 'other';\n}\n/**\n * The locale id that the application is using by default (for translations and ICU expressions).\n */\nconst DEFAULT_LOCALE_ID = 'en-US';\n/**\n * USD currency code that the application uses by default for CurrencyPipe when no\n * DEFAULT_CURRENCY_CODE is provided.\n */\nconst USD_CURRENCY_CODE = 'USD';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Marks that the next string is an element name.\n *\n * See `I18nMutateOpCodes` documentation.\n */\nconst ELEMENT_MARKER = {\n    marker: 'element'\n};\n/**\n * Marks that the next string is comment text need for ICU.\n *\n * See `I18nMutateOpCodes` documentation.\n */\nconst ICU_MARKER = {\n    marker: 'ICU'\n};\n/**\n * See `I18nCreateOpCodes`\n */\nvar I18nCreateOpCode;\n(function (I18nCreateOpCode) {\n    /**\n     * Number of bits to shift index so that it can be combined with the `APPEND_EAGERLY` and\n     * `COMMENT`.\n     */\n    I18nCreateOpCode[I18nCreateOpCode[\"SHIFT\"] = 2] = \"SHIFT\";\n    /**\n     * Should the node be appended to parent imedditatly after creation.\n     */\n    I18nCreateOpCode[I18nCreateOpCode[\"APPEND_EAGERLY\"] = 1] = \"APPEND_EAGERLY\";\n    /**\n     * If set the node should be comment (rather than a text) node.\n     */\n    I18nCreateOpCode[I18nCreateOpCode[\"COMMENT\"] = 2] = \"COMMENT\";\n})(I18nCreateOpCode || (I18nCreateOpCode = {}));\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nconst unusedValueExportToPlacateAjd$2 = 1;\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * The locale id that the application is currently using (for translations and ICU expressions).\n * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine\n * but is now defined as a global value.\n */\nlet LOCALE_ID = DEFAULT_LOCALE_ID;\n/**\n * Sets the locale id that will be used for translations and ICU expressions.\n * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine\n * but is now defined as a global value.\n *\n * @param localeId\n */\nfunction setLocaleId(localeId) {\n    assertDefined(localeId, `Expected localeId to be defined`);\n    if (typeof localeId === 'string') {\n        LOCALE_ID = localeId.toLowerCase().replace(/_/g, '-');\n    }\n}\n/**\n * Gets the locale id that will be used for translations and ICU expressions.\n * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine\n * but is now defined as a global value.\n */\nfunction getLocaleId() {\n    return LOCALE_ID;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Find a node in front of which `currentTNode` should be inserted (takes i18n into account).\n *\n * This method determines the `RNode` in front of which we should insert the `currentRNode`. This\n * takes `TNode.insertBeforeIndex` into account.\n *\n * @param parentTNode parent `TNode`\n * @param currentTNode current `TNode` (The node which we would like to insert into the DOM)\n * @param lView current `LView`\n */\nfunction getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView) {\n    const tNodeInsertBeforeIndex = currentTNode.insertBeforeIndex;\n    const insertBeforeIndex = Array.isArray(tNodeInsertBeforeIndex) ? tNodeInsertBeforeIndex[0] : tNodeInsertBeforeIndex;\n    if (insertBeforeIndex === null) {\n        return getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView);\n    }\n    else {\n        ngDevMode && assertIndexInRange(lView, insertBeforeIndex);\n        return unwrapRNode(lView[insertBeforeIndex]);\n    }\n}\n/**\n * Process `TNode.insertBeforeIndex` by adding i18n text nodes.\n *\n * See `TNode.insertBeforeIndex`\n */\nfunction processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRElement) {\n    const tNodeInsertBeforeIndex = childTNode.insertBeforeIndex;\n    if (Array.isArray(tNodeInsertBeforeIndex)) {\n        // An array indicates that there are i18n nodes that need to be added as children of this\n        // `childRNode`. These i18n nodes were created before this `childRNode` was available and so\n        // only now can be added. The first element of the array is the normal index where we should\n        // insert the `childRNode`. Additional elements are the extra nodes to be added as children of\n        // `childRNode`.\n        ngDevMode && assertDomNode(childRNode);\n        let i18nParent = childRNode;\n        let anchorRNode = null;\n        if (!(childTNode.type & 3 /* TNodeType.AnyRNode */)) {\n            anchorRNode = i18nParent;\n            i18nParent = parentRElement;\n        }\n        if (i18nParent !== null && (childTNode.flags & 2 /* TNodeFlags.isComponentHost */) === 0) {\n            for (let i = 1; i < tNodeInsertBeforeIndex.length; i++) {\n                // No need to `unwrapRNode` because all of the indexes point to i18n text nodes.\n                // see `assertDomNode` below.\n                const i18nChild = lView[tNodeInsertBeforeIndex[i]];\n                nativeInsertBefore(renderer, i18nParent, i18nChild, anchorRNode, false);\n            }\n        }\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Add `tNode` to `previousTNodes` list and update relevant `TNode`s in `previousTNodes` list\n * `tNode.insertBeforeIndex`.\n *\n * Things to keep in mind:\n * 1. All i18n text nodes are encoded as `TNodeType.Element` and are created eagerly by the\n *    `ɵɵi18nStart` instruction.\n * 2. All `TNodeType.Placeholder` `TNodes` are elements which will be created later by\n *    `ɵɵelementStart` instruction.\n * 3. `ɵɵelementStart` instruction will create `TNode`s in the ascending `TNode.index` order. (So a\n *    smaller index `TNode` is guaranteed to be created before a larger one)\n *\n * We use the above three invariants to determine `TNode.insertBeforeIndex`.\n *\n * In an ideal world `TNode.insertBeforeIndex` would always be `TNode.next.index`. However,\n * this will not work because `TNode.next.index` may be larger than `TNode.index` which means that\n * the next node is not yet created and therefore we can't insert in front of it.\n *\n * Rule1: `TNode.insertBeforeIndex = null` if `TNode.next === null` (Initial condition, as we don't\n *        know if there will be further `TNode`s inserted after.)\n * Rule2: If `previousTNode` is created after the `tNode` being inserted, then\n *        `previousTNode.insertBeforeNode = tNode.index` (So when a new `tNode` is added we check\n *        previous to see if we can update its `insertBeforeTNode`)\n *\n * See `TNode.insertBeforeIndex` for more context.\n *\n * @param previousTNodes A list of previous TNodes so that we can easily traverse `TNode`s in\n *     reverse order. (If `TNode` would have `previous` this would not be necessary.)\n * @param newTNode A TNode to add to the `previousTNodes` list.\n */\nfunction addTNodeAndUpdateInsertBeforeIndex(previousTNodes, newTNode) {\n    // Start with Rule1\n    ngDevMode &&\n        assertEqual(newTNode.insertBeforeIndex, null, 'We expect that insertBeforeIndex is not set');\n    previousTNodes.push(newTNode);\n    if (previousTNodes.length > 1) {\n        for (let i = previousTNodes.length - 2; i >= 0; i--) {\n            const existingTNode = previousTNodes[i];\n            // Text nodes are created eagerly and so they don't need their `indexBeforeIndex` updated.\n            // It is safe to ignore them.\n            if (!isI18nText(existingTNode)) {\n                if (isNewTNodeCreatedBefore(existingTNode, newTNode) &&\n                    getInsertBeforeIndex(existingTNode) === null) {\n                    // If it was created before us in time, (and it does not yet have `insertBeforeIndex`)\n                    // then add the `insertBeforeIndex`.\n                    setInsertBeforeIndex(existingTNode, newTNode.index);\n                }\n            }\n        }\n    }\n}\nfunction isI18nText(tNode) {\n    return !(tNode.type & 64 /* TNodeType.Placeholder */);\n}\nfunction isNewTNodeCreatedBefore(existingTNode, newTNode) {\n    return isI18nText(newTNode) || existingTNode.index > newTNode.index;\n}\nfunction getInsertBeforeIndex(tNode) {\n    const index = tNode.insertBeforeIndex;\n    return Array.isArray(index) ? index[0] : index;\n}\nfunction setInsertBeforeIndex(tNode, value) {\n    const index = tNode.insertBeforeIndex;\n    if (Array.isArray(index)) {\n        // Array is stored if we have to insert child nodes. See `TNode.insertBeforeIndex`\n        index[0] = value;\n    }\n    else {\n        setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);\n        tNode.insertBeforeIndex = value;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Retrieve `TIcu` at a given `index`.\n *\n * The `TIcu` can be stored either directly (if it is nested ICU) OR\n * it is stored inside tho `TIcuContainer` if it is top level ICU.\n *\n * The reason for this is that the top level ICU need a `TNode` so that they are part of the render\n * tree, but nested ICU's have no TNode, because we don't know ahead of time if the nested ICU is\n * expressed (parent ICU may have selected a case which does not contain it.)\n *\n * @param tView Current `TView`.\n * @param index Index where the value should be read from.\n */\nfunction getTIcu(tView, index) {\n    const value = tView.data[index];\n    if (value === null || typeof value === 'string')\n        return null;\n    if (ngDevMode &&\n        !(value.hasOwnProperty('tViews') || value.hasOwnProperty('currentCaseLViewIndex'))) {\n        throwError('We expect to get \\'null\\'|\\'TIcu\\'|\\'TIcuContainer\\', but got: ' + value);\n    }\n    // Here the `value.hasOwnProperty('currentCaseLViewIndex')` is a polymorphic read as it can be\n    // either TIcu or TIcuContainerNode. This is not ideal, but we still think it is OK because it\n    // will be just two cases which fits into the browser inline cache (inline cache can take up to\n    // 4)\n    const tIcu = value.hasOwnProperty('currentCaseLViewIndex') ? value :\n        value.value;\n    ngDevMode && assertTIcu(tIcu);\n    return tIcu;\n}\n/**\n * Store `TIcu` at a give `index`.\n *\n * The `TIcu` can be stored either directly (if it is nested ICU) OR\n * it is stored inside tho `TIcuContainer` if it is top level ICU.\n *\n * The reason for this is that the top level ICU need a `TNode` so that they are part of the render\n * tree, but nested ICU's have no TNode, because we don't know ahead of time if the nested ICU is\n * expressed (parent ICU may have selected a case which does not contain it.)\n *\n * @param tView Current `TView`.\n * @param index Index where the value should be stored at in `Tview.data`\n * @param tIcu The TIcu to store.\n */\nfunction setTIcu(tView, index, tIcu) {\n    const tNode = tView.data[index];\n    ngDevMode &&\n        assertEqual(tNode === null || tNode.hasOwnProperty('tViews'), true, 'We expect to get \\'null\\'|\\'TIcuContainer\\'');\n    if (tNode === null) {\n        tView.data[index] = tIcu;\n    }\n    else {\n        ngDevMode && assertTNodeType(tNode, 32 /* TNodeType.Icu */);\n        tNode.value = tIcu;\n    }\n}\n/**\n * Set `TNode.insertBeforeIndex` taking the `Array` into account.\n *\n * See `TNode.insertBeforeIndex`\n */\nfunction setTNodeInsertBeforeIndex(tNode, index) {\n    ngDevMode && assertTNode(tNode);\n    let insertBeforeIndex = tNode.insertBeforeIndex;\n    if (insertBeforeIndex === null) {\n        setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);\n        insertBeforeIndex = tNode.insertBeforeIndex =\n            [null /* may be updated to number later */, index];\n    }\n    else {\n        assertEqual(Array.isArray(insertBeforeIndex), true, 'Expecting array here');\n        insertBeforeIndex.push(index);\n    }\n}\n/**\n * Create `TNode.type=TNodeType.Placeholder` node.\n *\n * See `TNodeType.Placeholder` for more information.\n */\nfunction createTNodePlaceholder(tView, previousTNodes, index) {\n    const tNode = createTNodeAtIndex(tView, index, 64 /* TNodeType.Placeholder */, null, null);\n    addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tNode);\n    return tNode;\n}\n/**\n * Returns current ICU case.\n *\n * ICU cases are stored as index into the `TIcu.cases`.\n * At times it is necessary to communicate that the ICU case just switched and that next ICU update\n * should update all bindings regardless of the mask. In such a case the we store negative numbers\n * for cases which have just been switched. This function removes the negative flag.\n */\nfunction getCurrentICUCaseIndex(tIcu, lView) {\n    const currentCase = lView[tIcu.currentCaseLViewIndex];\n    return currentCase === null ? currentCase : (currentCase < 0 ? ~currentCase : currentCase);\n}\nfunction getParentFromIcuCreateOpCode(mergedCode) {\n    return mergedCode >>> 17 /* IcuCreateOpCode.SHIFT_PARENT */;\n}\nfunction getRefFromIcuCreateOpCode(mergedCode) {\n    return (mergedCode & 131070 /* IcuCreateOpCode.MASK_REF */) >>> 1 /* IcuCreateOpCode.SHIFT_REF */;\n}\nfunction getInstructionFromIcuCreateOpCode(mergedCode) {\n    return mergedCode & 1 /* IcuCreateOpCode.MASK_INSTRUCTION */;\n}\nfunction icuCreateOpCode(opCode, parentIdx, refIdx) {\n    ngDevMode && assertGreaterThanOrEqual(parentIdx, 0, 'Missing parent index');\n    ngDevMode && assertGreaterThan(refIdx, 0, 'Missing ref index');\n    return opCode | parentIdx << 17 /* IcuCreateOpCode.SHIFT_PARENT */ | refIdx << 1 /* IcuCreateOpCode.SHIFT_REF */;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Keep track of which input bindings in `ɵɵi18nExp` have changed.\n *\n * This is used to efficiently update expressions in i18n only when the corresponding input has\n * changed.\n *\n * 1) Each bit represents which of the `ɵɵi18nExp` has changed.\n * 2) There are 32 bits allowed in JS.\n * 3) Bit 32 is special as it is shared for all changes past 32. (In other words if you have more\n * than 32 `ɵɵi18nExp` then all changes past 32nd `ɵɵi18nExp` will be mapped to same bit. This means\n * that we may end up changing more than we need to. But i18n expressions with 32 bindings is rare\n * so in practice it should not be an issue.)\n */\nlet changeMask = 0b0;\n/**\n * Keeps track of which bit needs to be updated in `changeMask`\n *\n * This value gets incremented on every call to `ɵɵi18nExp`\n */\nlet changeMaskCounter = 0;\n/**\n * Keep track of which input bindings in `ɵɵi18nExp` have changed.\n *\n * `setMaskBit` gets invoked by each call to `ɵɵi18nExp`.\n *\n * @param hasChange did `ɵɵi18nExp` detect a change.\n */\nfunction setMaskBit(hasChange) {\n    if (hasChange) {\n        changeMask = changeMask | (1 << Math.min(changeMaskCounter, 31));\n    }\n    changeMaskCounter++;\n}\nfunction applyI18n(tView, lView, index) {\n    if (changeMaskCounter > 0) {\n        ngDevMode && assertDefined(tView, `tView should be defined`);\n        const tI18n = tView.data[index];\n        // When `index` points to an `ɵɵi18nAttributes` then we have an array otherwise `TI18n`\n        const updateOpCodes = Array.isArray(tI18n) ? tI18n : tI18n.update;\n        const bindingsStartIndex = getBindingIndex() - changeMaskCounter - 1;\n        applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask);\n    }\n    // Reset changeMask & maskBit to default for the next update cycle\n    changeMask = 0b0;\n    changeMaskCounter = 0;\n}\n/**\n * Apply `I18nCreateOpCodes` op-codes as stored in `TI18n.create`.\n *\n * Creates text (and comment) nodes which are internationalized.\n *\n * @param lView Current lView\n * @param createOpCodes Set of op-codes to apply\n * @param parentRNode Parent node (so that direct children can be added eagerly) or `null` if it is\n *     a root node.\n * @param insertInFrontOf DOM node that should be used as an anchor.\n */\nfunction applyCreateOpCodes(lView, createOpCodes, parentRNode, insertInFrontOf) {\n    const renderer = lView[RENDERER];\n    for (let i = 0; i < createOpCodes.length; i++) {\n        const opCode = createOpCodes[i++];\n        const text = createOpCodes[i];\n        const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;\n        const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;\n        const index = opCode >>> I18nCreateOpCode.SHIFT;\n        let rNode = lView[index];\n        if (rNode === null) {\n            // We only create new DOM nodes if they don't already exist: If ICU switches case back to a\n            // case which was already instantiated, no need to create new DOM nodes.\n            rNode = lView[index] =\n                isComment ? renderer.createComment(text) : createTextNode(renderer, text);\n        }\n        if (appendNow && parentRNode !== null) {\n            nativeInsertBefore(renderer, parentRNode, rNode, insertInFrontOf, false);\n        }\n    }\n}\n/**\n * Apply `I18nMutateOpCodes` OpCodes.\n *\n * @param tView Current `TView`\n * @param mutableOpCodes Mutable OpCodes to process\n * @param lView Current `LView`\n * @param anchorRNode place where the i18n node should be inserted.\n */\nfunction applyMutableOpCodes(tView, mutableOpCodes, lView, anchorRNode) {\n    ngDevMode && assertDomNode(anchorRNode);\n    const renderer = lView[RENDERER];\n    // `rootIdx` represents the node into which all inserts happen.\n    let rootIdx = null;\n    // `rootRNode` represents the real node into which we insert. This can be different from\n    // `lView[rootIdx]` if we have projection.\n    //  - null we don't have a parent (as can be the case in when we are inserting into a root of\n    //    LView which has no parent.)\n    //  - `RElement` The element representing the root after taking projection into account.\n    let rootRNode;\n    for (let i = 0; i < mutableOpCodes.length; i++) {\n        const opCode = mutableOpCodes[i];\n        if (typeof opCode == 'string') {\n            const textNodeIndex = mutableOpCodes[++i];\n            if (lView[textNodeIndex] === null) {\n                ngDevMode && ngDevMode.rendererCreateTextNode++;\n                ngDevMode && assertIndexInRange(lView, textNodeIndex);\n                lView[textNodeIndex] = createTextNode(renderer, opCode);\n            }\n        }\n        else if (typeof opCode == 'number') {\n            switch (opCode & 1 /* IcuCreateOpCode.MASK_INSTRUCTION */) {\n                case 0 /* IcuCreateOpCode.AppendChild */:\n                    const parentIdx = getParentFromIcuCreateOpCode(opCode);\n                    if (rootIdx === null) {\n                        // The first operation should save the `rootIdx` because the first operation\n                        // must insert into the root. (Only subsequent operations can insert into a dynamic\n                        // parent)\n                        rootIdx = parentIdx;\n                        rootRNode = nativeParentNode(renderer, anchorRNode);\n                    }\n                    let insertInFrontOf;\n                    let parentRNode;\n                    if (parentIdx === rootIdx) {\n                        insertInFrontOf = anchorRNode;\n                        parentRNode = rootRNode;\n                    }\n                    else {\n                        insertInFrontOf = null;\n                        parentRNode = unwrapRNode(lView[parentIdx]);\n                    }\n                    // FIXME(misko): Refactor with `processI18nText`\n                    if (parentRNode !== null) {\n                        // This can happen if the `LView` we are adding to is not attached to a parent `LView`.\n                        // In such a case there is no \"root\" we can attach to. This is fine, as we still need to\n                        // create the elements. When the `LView` gets later added to a parent these \"root\" nodes\n                        // get picked up and added.\n                        ngDevMode && assertDomNode(parentRNode);\n                        const refIdx = getRefFromIcuCreateOpCode(opCode);\n                        ngDevMode && assertGreaterThan(refIdx, HEADER_OFFSET, 'Missing ref');\n                        // `unwrapRNode` is not needed here as all of these point to RNodes as part of the i18n\n                        // which can't have components.\n                        const child = lView[refIdx];\n                        ngDevMode && assertDomNode(child);\n                        nativeInsertBefore(renderer, parentRNode, child, insertInFrontOf, false);\n                        const tIcu = getTIcu(tView, refIdx);\n                        if (tIcu !== null && typeof tIcu === 'object') {\n                            // If we just added a comment node which has ICU then that ICU may have already been\n                            // rendered and therefore we need to re-add it here.\n                            ngDevMode && assertTIcu(tIcu);\n                            const caseIndex = getCurrentICUCaseIndex(tIcu, lView);\n                            if (caseIndex !== null) {\n                                applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, lView[tIcu.anchorIdx]);\n                            }\n                        }\n                    }\n                    break;\n                case 1 /* IcuCreateOpCode.Attr */:\n                    const elementNodeIndex = opCode >>> 1 /* IcuCreateOpCode.SHIFT_REF */;\n                    const attrName = mutableOpCodes[++i];\n                    const attrValue = mutableOpCodes[++i];\n                    // This code is used for ICU expressions only, since we don't support\n                    // directives/components in ICUs, we don't need to worry about inputs here\n                    setElementAttribute(renderer, getNativeByIndex(elementNodeIndex, lView), null, null, attrName, attrValue, null);\n                    break;\n                default:\n                    if (ngDevMode) {\n                        throw new RuntimeError(700 /* RuntimeErrorCode.INVALID_I18N_STRUCTURE */, `Unable to determine the type of mutate operation for \"${opCode}\"`);\n                    }\n            }\n        }\n        else {\n            switch (opCode) {\n                case ICU_MARKER:\n                    const commentValue = mutableOpCodes[++i];\n                    const commentNodeIndex = mutableOpCodes[++i];\n                    if (lView[commentNodeIndex] === null) {\n                        ngDevMode &&\n                            assertEqual(typeof commentValue, 'string', `Expected \"${commentValue}\" to be a comment node value`);\n                        ngDevMode && ngDevMode.rendererCreateComment++;\n                        ngDevMode && assertIndexInExpandoRange(lView, commentNodeIndex);\n                        const commentRNode = lView[commentNodeIndex] =\n                            createCommentNode(renderer, commentValue);\n                        // FIXME(misko): Attaching patch data is only needed for the root (Also add tests)\n                        attachPatchData(commentRNode, lView);\n                    }\n                    break;\n                case ELEMENT_MARKER:\n                    const tagName = mutableOpCodes[++i];\n                    const elementNodeIndex = mutableOpCodes[++i];\n                    if (lView[elementNodeIndex] === null) {\n                        ngDevMode &&\n                            assertEqual(typeof tagName, 'string', `Expected \"${tagName}\" to be an element node tag name`);\n                        ngDevMode && ngDevMode.rendererCreateElement++;\n                        ngDevMode && assertIndexInExpandoRange(lView, elementNodeIndex);\n                        const elementRNode = lView[elementNodeIndex] =\n                            createElementNode(renderer, tagName, null);\n                        // FIXME(misko): Attaching patch data is only needed for the root (Also add tests)\n                        attachPatchData(elementRNode, lView);\n                    }\n                    break;\n                default:\n                    ngDevMode &&\n                        throwError(`Unable to determine the type of mutate operation for \"${opCode}\"`);\n            }\n        }\n    }\n}\n/**\n * Apply `I18nUpdateOpCodes` OpCodes\n *\n * @param tView Current `TView`\n * @param lView Current `LView`\n * @param updateOpCodes OpCodes to process\n * @param bindingsStartIndex Location of the first `ɵɵi18nApply`\n * @param changeMask Each bit corresponds to a `ɵɵi18nExp` (Counting backwards from\n *     `bindingsStartIndex`)\n */\nfunction applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask) {\n    for (let i = 0; i < updateOpCodes.length; i++) {\n        // bit code to check if we should apply the next update\n        const checkBit = updateOpCodes[i];\n        // Number of opCodes to skip until next set of update codes\n        const skipCodes = updateOpCodes[++i];\n        if (checkBit & changeMask) {\n            // The value has been updated since last checked\n            let value = '';\n            for (let j = i + 1; j <= (i + skipCodes); j++) {\n                const opCode = updateOpCodes[j];\n                if (typeof opCode == 'string') {\n                    value += opCode;\n                }\n                else if (typeof opCode == 'number') {\n                    if (opCode < 0) {\n                        // Negative opCode represent `i18nExp` values offset.\n                        value += renderStringify(lView[bindingsStartIndex - opCode]);\n                    }\n                    else {\n                        const nodeIndex = (opCode >>> 2 /* I18nUpdateOpCode.SHIFT_REF */);\n                        switch (opCode & 3 /* I18nUpdateOpCode.MASK_OPCODE */) {\n                            case 1 /* I18nUpdateOpCode.Attr */:\n                                const propName = updateOpCodes[++j];\n                                const sanitizeFn = updateOpCodes[++j];\n                                const tNodeOrTagName = tView.data[nodeIndex];\n                                ngDevMode && assertDefined(tNodeOrTagName, 'Experting TNode or string');\n                                if (typeof tNodeOrTagName === 'string') {\n                                    // IF we don't have a `TNode`, then we are an element in ICU (as ICU content does\n                                    // not have TNode), in which case we know that there are no directives, and hence\n                                    // we use attribute setting.\n                                    setElementAttribute(lView[RENDERER], lView[nodeIndex], null, tNodeOrTagName, propName, value, sanitizeFn);\n                                }\n                                else {\n                                    elementPropertyInternal(tView, tNodeOrTagName, lView, propName, value, lView[RENDERER], sanitizeFn, false);\n                                }\n                                break;\n                            case 0 /* I18nUpdateOpCode.Text */:\n                                const rText = lView[nodeIndex];\n                                rText !== null && updateTextNode(lView[RENDERER], rText, value);\n                                break;\n                            case 2 /* I18nUpdateOpCode.IcuSwitch */:\n                                applyIcuSwitchCase(tView, getTIcu(tView, nodeIndex), lView, value);\n                                break;\n                            case 3 /* I18nUpdateOpCode.IcuUpdate */:\n                                applyIcuUpdateCase(tView, getTIcu(tView, nodeIndex), bindingsStartIndex, lView);\n                                break;\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            const opCode = updateOpCodes[i + 1];\n            if (opCode > 0 && (opCode & 3 /* I18nUpdateOpCode.MASK_OPCODE */) === 3 /* I18nUpdateOpCode.IcuUpdate */) {\n                // Special case for the `icuUpdateCase`. It could be that the mask did not match, but\n                // we still need to execute `icuUpdateCase` because the case has changed recently due to\n                // previous `icuSwitchCase` instruction. (`icuSwitchCase` and `icuUpdateCase` always come in\n                // pairs.)\n                const nodeIndex = (opCode >>> 2 /* I18nUpdateOpCode.SHIFT_REF */);\n                const tIcu = getTIcu(tView, nodeIndex);\n                const currentIndex = lView[tIcu.currentCaseLViewIndex];\n                if (currentIndex < 0) {\n                    applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView);\n                }\n            }\n        }\n        i += skipCodes;\n    }\n}\n/**\n * Apply OpCodes associated with updating an existing ICU.\n *\n * @param tView Current `TView`\n * @param tIcu Current `TIcu`\n * @param bindingsStartIndex Location of the first `ɵɵi18nApply`\n * @param lView Current `LView`\n */\nfunction applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView) {\n    ngDevMode && assertIndexInRange(lView, tIcu.currentCaseLViewIndex);\n    let activeCaseIndex = lView[tIcu.currentCaseLViewIndex];\n    if (activeCaseIndex !== null) {\n        let mask = changeMask;\n        if (activeCaseIndex < 0) {\n            // Clear the flag.\n            // Negative number means that the ICU was freshly created and we need to force the update.\n            activeCaseIndex = lView[tIcu.currentCaseLViewIndex] = ~activeCaseIndex;\n            // -1 is same as all bits on, which simulates creation since it marks all bits dirty\n            mask = -1;\n        }\n        applyUpdateOpCodes(tView, lView, tIcu.update[activeCaseIndex], bindingsStartIndex, mask);\n    }\n}\n/**\n * Apply OpCodes associated with switching a case on ICU.\n *\n * This involves tearing down existing case and than building up a new case.\n *\n * @param tView Current `TView`\n * @param tIcu Current `TIcu`\n * @param lView Current `LView`\n * @param value Value of the case to update to.\n */\nfunction applyIcuSwitchCase(tView, tIcu, lView, value) {\n    // Rebuild a new case for this ICU\n    const caseIndex = getCaseIndex(tIcu, value);\n    let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);\n    if (activeCaseIndex !== caseIndex) {\n        applyIcuSwitchCaseRemove(tView, tIcu, lView);\n        lView[tIcu.currentCaseLViewIndex] = caseIndex === null ? null : ~caseIndex;\n        if (caseIndex !== null) {\n            // Add the nodes for the new case\n            const anchorRNode = lView[tIcu.anchorIdx];\n            if (anchorRNode) {\n                ngDevMode && assertDomNode(anchorRNode);\n                applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, anchorRNode);\n            }\n        }\n    }\n}\n/**\n * Apply OpCodes associated with tearing ICU case.\n *\n * This involves tearing down existing case and than building up a new case.\n *\n * @param tView Current `TView`\n * @param tIcu Current `TIcu`\n * @param lView Current `LView`\n */\nfunction applyIcuSwitchCaseRemove(tView, tIcu, lView) {\n    let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);\n    if (activeCaseIndex !== null) {\n        const removeCodes = tIcu.remove[activeCaseIndex];\n        for (let i = 0; i < removeCodes.length; i++) {\n            const nodeOrIcuIndex = removeCodes[i];\n            if (nodeOrIcuIndex > 0) {\n                // Positive numbers are `RNode`s.\n                const rNode = getNativeByIndex(nodeOrIcuIndex, lView);\n                rNode !== null && nativeRemoveNode(lView[RENDERER], rNode);\n            }\n            else {\n                // Negative numbers are ICUs\n                applyIcuSwitchCaseRemove(tView, getTIcu(tView, ~nodeOrIcuIndex), lView);\n            }\n        }\n    }\n}\n/**\n * Returns the index of the current case of an ICU expression depending on the main binding value\n *\n * @param icuExpression\n * @param bindingValue The value of the main binding used by this ICU expression\n */\nfunction getCaseIndex(icuExpression, bindingValue) {\n    let index = icuExpression.cases.indexOf(bindingValue);\n    if (index === -1) {\n        switch (icuExpression.type) {\n            case 1 /* IcuType.plural */: {\n                const resolvedCase = getPluralCase(bindingValue, getLocaleId());\n                index = icuExpression.cases.indexOf(resolvedCase);\n                if (index === -1 && resolvedCase !== 'other') {\n                    index = icuExpression.cases.indexOf('other');\n                }\n                break;\n            }\n            case 0 /* IcuType.select */: {\n                index = icuExpression.cases.indexOf('other');\n                break;\n            }\n        }\n    }\n    return index === -1 ? null : index;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction loadIcuContainerVisitor() {\n    const _stack = [];\n    let _index = -1;\n    let _lView;\n    let _removes;\n    /**\n     * Retrieves a set of root nodes from `TIcu.remove`. Used by `TNodeType.ICUContainer`\n     * to determine which root belong to the ICU.\n     *\n     * Example of usage.\n     * ```\n     * const nextRNode = icuContainerIteratorStart(tIcuContainerNode, lView);\n     * let rNode: RNode|null;\n     * while(rNode = nextRNode()) {\n     *   console.log(rNode);\n     * }\n     * ```\n     *\n     * @param tIcuContainerNode Current `TIcuContainerNode`\n     * @param lView `LView` where the `RNode`s should be looked up.\n     */\n    function icuContainerIteratorStart(tIcuContainerNode, lView) {\n        _lView = lView;\n        while (_stack.length)\n            _stack.pop();\n        ngDevMode && assertTNodeForLView(tIcuContainerNode, lView);\n        enterIcu(tIcuContainerNode.value, lView);\n        return icuContainerIteratorNext;\n    }\n    function enterIcu(tIcu, lView) {\n        _index = 0;\n        const currentCase = getCurrentICUCaseIndex(tIcu, lView);\n        if (currentCase !== null) {\n            ngDevMode && assertNumberInRange(currentCase, 0, tIcu.cases.length - 1);\n            _removes = tIcu.remove[currentCase];\n        }\n        else {\n            _removes = EMPTY_ARRAY;\n        }\n    }\n    function icuContainerIteratorNext() {\n        if (_index < _removes.length) {\n            const removeOpCode = _removes[_index++];\n            ngDevMode && assertNumber(removeOpCode, 'Expecting OpCode number');\n            if (removeOpCode > 0) {\n                const rNode = _lView[removeOpCode];\n                ngDevMode && assertDomNode(rNode);\n                return rNode;\n            }\n            else {\n                _stack.push(_index, _removes);\n                // ICUs are represented by negative indices\n                const tIcuIndex = ~removeOpCode;\n                const tIcu = _lView[TVIEW].data[tIcuIndex];\n                ngDevMode && assertTIcu(tIcu);\n                enterIcu(tIcu, _lView);\n                return icuContainerIteratorNext();\n            }\n        }\n        else {\n            if (_stack.length === 0) {\n                return null;\n            }\n            else {\n                _removes = _stack.pop();\n                _index = _stack.pop();\n                return icuContainerIteratorNext();\n            }\n        }\n    }\n    return icuContainerIteratorStart;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Converts `I18nCreateOpCodes` array into a human readable format.\n *\n * This function is attached to the `I18nCreateOpCodes.debug` property if `ngDevMode` is enabled.\n * This function provides a human readable view of the opcodes. This is useful when debugging the\n * application as well as writing more readable tests.\n *\n * @param this `I18nCreateOpCodes` if attached as a method.\n * @param opcodes `I18nCreateOpCodes` if invoked as a function.\n */\nfunction i18nCreateOpCodesToString(opcodes) {\n    const createOpCodes = opcodes || (Array.isArray(this) ? this : []);\n    let lines = [];\n    for (let i = 0; i < createOpCodes.length; i++) {\n        const opCode = createOpCodes[i++];\n        const text = createOpCodes[i];\n        const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;\n        const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;\n        const index = opCode >>> I18nCreateOpCode.SHIFT;\n        lines.push(`lView[${index}] = document.${isComment ? 'createComment' : 'createText'}(${JSON.stringify(text)});`);\n        if (appendNow) {\n            lines.push(`parent.appendChild(lView[${index}]);`);\n        }\n    }\n    return lines;\n}\n/**\n * Converts `I18nUpdateOpCodes` array into a human readable format.\n *\n * This function is attached to the `I18nUpdateOpCodes.debug` property if `ngDevMode` is enabled.\n * This function provides a human readable view of the opcodes. This is useful when debugging the\n * application as well as writing more readable tests.\n *\n * @param this `I18nUpdateOpCodes` if attached as a method.\n * @param opcodes `I18nUpdateOpCodes` if invoked as a function.\n */\nfunction i18nUpdateOpCodesToString(opcodes) {\n    const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));\n    let lines = [];\n    function consumeOpCode(value) {\n        const ref = value >>> 2 /* I18nUpdateOpCode.SHIFT_REF */;\n        const opCode = value & 3 /* I18nUpdateOpCode.MASK_OPCODE */;\n        switch (opCode) {\n            case 0 /* I18nUpdateOpCode.Text */:\n                return `(lView[${ref}] as Text).textContent = $$$`;\n            case 1 /* I18nUpdateOpCode.Attr */:\n                const attrName = parser.consumeString();\n                const sanitizationFn = parser.consumeFunction();\n                const value = sanitizationFn ? `(${sanitizationFn})($$$)` : '$$$';\n                return `(lView[${ref}] as Element).setAttribute('${attrName}', ${value})`;\n            case 2 /* I18nUpdateOpCode.IcuSwitch */:\n                return `icuSwitchCase(${ref}, $$$)`;\n            case 3 /* I18nUpdateOpCode.IcuUpdate */:\n                return `icuUpdateCase(${ref})`;\n        }\n        throw new Error('unexpected OpCode');\n    }\n    while (parser.hasMore()) {\n        let mask = parser.consumeNumber();\n        let size = parser.consumeNumber();\n        const end = parser.i + size;\n        const statements = [];\n        let statement = '';\n        while (parser.i < end) {\n            let value = parser.consumeNumberOrString();\n            if (typeof value === 'string') {\n                statement += value;\n            }\n            else if (value < 0) {\n                // Negative numbers are ref indexes\n                // Here `i` refers to current binding index. It is to signify that the value is relative,\n                // rather than absolute.\n                statement += '${lView[i' + value + ']}';\n            }\n            else {\n                // Positive numbers are operations.\n                const opCodeText = consumeOpCode(value);\n                statements.push(opCodeText.replace('$$$', '`' + statement + '`') + ';');\n                statement = '';\n            }\n        }\n        lines.push(`if (mask & 0b${mask.toString(2)}) { ${statements.join(' ')} }`);\n    }\n    return lines;\n}\n/**\n * Converts `I18nCreateOpCodes` array into a human readable format.\n *\n * This function is attached to the `I18nCreateOpCodes.debug` if `ngDevMode` is enabled. This\n * function provides a human readable view of the opcodes. This is useful when debugging the\n * application as well as writing more readable tests.\n *\n * @param this `I18nCreateOpCodes` if attached as a method.\n * @param opcodes `I18nCreateOpCodes` if invoked as a function.\n */\nfunction icuCreateOpCodesToString(opcodes) {\n    const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));\n    let lines = [];\n    function consumeOpCode(opCode) {\n        const parent = getParentFromIcuCreateOpCode(opCode);\n        const ref = getRefFromIcuCreateOpCode(opCode);\n        switch (getInstructionFromIcuCreateOpCode(opCode)) {\n            case 0 /* IcuCreateOpCode.AppendChild */:\n                return `(lView[${parent}] as Element).appendChild(lView[${lastRef}])`;\n            case 1 /* IcuCreateOpCode.Attr */:\n                return `(lView[${ref}] as Element).setAttribute(\"${parser.consumeString()}\", \"${parser.consumeString()}\")`;\n        }\n        throw new Error('Unexpected OpCode: ' + getInstructionFromIcuCreateOpCode(opCode));\n    }\n    let lastRef = -1;\n    while (parser.hasMore()) {\n        let value = parser.consumeNumberStringOrMarker();\n        if (value === ICU_MARKER) {\n            const text = parser.consumeString();\n            lastRef = parser.consumeNumber();\n            lines.push(`lView[${lastRef}] = document.createComment(\"${text}\")`);\n        }\n        else if (value === ELEMENT_MARKER) {\n            const text = parser.consumeString();\n            lastRef = parser.consumeNumber();\n            lines.push(`lView[${lastRef}] = document.createElement(\"${text}\")`);\n        }\n        else if (typeof value === 'string') {\n            lastRef = parser.consumeNumber();\n            lines.push(`lView[${lastRef}] = document.createTextNode(\"${value}\")`);\n        }\n        else if (typeof value === 'number') {\n            const line = consumeOpCode(value);\n            line && lines.push(line);\n        }\n        else {\n            throw new Error('Unexpected value');\n        }\n    }\n    return lines;\n}\n/**\n * Converts `I18nRemoveOpCodes` array into a human readable format.\n *\n * This function is attached to the `I18nRemoveOpCodes.debug` if `ngDevMode` is enabled. This\n * function provides a human readable view of the opcodes. This is useful when debugging the\n * application as well as writing more readable tests.\n *\n * @param this `I18nRemoveOpCodes` if attached as a method.\n * @param opcodes `I18nRemoveOpCodes` if invoked as a function.\n */\nfunction i18nRemoveOpCodesToString(opcodes) {\n    const removeCodes = opcodes || (Array.isArray(this) ? this : []);\n    let lines = [];\n    for (let i = 0; i < removeCodes.length; i++) {\n        const nodeOrIcuIndex = removeCodes[i];\n        if (nodeOrIcuIndex > 0) {\n            // Positive numbers are `RNode`s.\n            lines.push(`remove(lView[${nodeOrIcuIndex}])`);\n        }\n        else {\n            // Negative numbers are ICUs\n            lines.push(`removeNestedICU(${~nodeOrIcuIndex})`);\n        }\n    }\n    return lines;\n}\nclass OpCodeParser {\n    constructor(codes) {\n        this.i = 0;\n        this.codes = codes;\n    }\n    hasMore() {\n        return this.i < this.codes.length;\n    }\n    consumeNumber() {\n        let value = this.codes[this.i++];\n        assertNumber(value, 'expecting number in OpCode');\n        return value;\n    }\n    consumeString() {\n        let value = this.codes[this.i++];\n        assertString(value, 'expecting string in OpCode');\n        return value;\n    }\n    consumeFunction() {\n        let value = this.codes[this.i++];\n        if (value === null || typeof value === 'function') {\n            return value;\n        }\n        throw new Error('expecting function in OpCode');\n    }\n    consumeNumberOrString() {\n        let value = this.codes[this.i++];\n        if (typeof value === 'string') {\n            return value;\n        }\n        assertNumber(value, 'expecting number or string in OpCode');\n        return value;\n    }\n    consumeNumberStringOrMarker() {\n        let value = this.codes[this.i++];\n        if (typeof value === 'string' || typeof value === 'number' || value == ICU_MARKER ||\n            value == ELEMENT_MARKER) {\n            return value;\n        }\n        assertNumber(value, 'expecting number, string, ICU_MARKER or ELEMENT_MARKER in OpCode');\n        return value;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst BINDING_REGEXP = /�(\\d+):?\\d*�/gi;\nconst ICU_REGEXP = /({\\s*�\\d+:?\\d*�\\s*,\\s*\\S{6}\\s*,[\\s\\S]*})/gi;\nconst NESTED_ICU = /�(\\d+)�/;\nconst ICU_BLOCK_REGEXP = /^\\s*(�\\d+:?\\d*�)\\s*,\\s*(select|plural)\\s*,/;\nconst MARKER = `�`;\nconst SUBTEMPLATE_REGEXP = /�\\/?\\*(\\d+:\\d+)�/gi;\nconst PH_REGEXP = /�(\\/?[#*]\\d+):?\\d*�/gi;\n/**\n * Angular Dart introduced &ngsp; as a placeholder for non-removable space, see:\n * https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart#L25-L32\n * In Angular Dart &ngsp; is converted to the 0xE500 PUA (Private Use Areas) unicode character\n * and later on replaced by a space. We are re-implementing the same idea here, since translations\n * might contain this special character.\n */\nconst NGSP_UNICODE_REGEXP = /\\uE500/g;\nfunction replaceNgsp(value) {\n    return value.replace(NGSP_UNICODE_REGEXP, ' ');\n}\n/**\n * Create dynamic nodes from i18n translation block.\n *\n * - Text nodes are created synchronously\n * - TNodes are linked into tree lazily\n *\n * @param tView Current `TView`\n * @parentTNodeIndex index to the parent TNode of this i18n block\n * @param lView Current `LView`\n * @param index Index of `ɵɵi18nStart` instruction.\n * @param message Message to translate.\n * @param subTemplateIndex Index into the sub template of message translation. (ie in case of\n *     `ngIf`) (-1 otherwise)\n */\nfunction i18nStartFirstCreatePass(tView, parentTNodeIndex, lView, index, message, subTemplateIndex) {\n    const rootTNode = getCurrentParentTNode();\n    const createOpCodes = [];\n    const updateOpCodes = [];\n    const existingTNodeStack = [[]];\n    if (ngDevMode) {\n        attachDebugGetter(createOpCodes, i18nCreateOpCodesToString);\n        attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n    }\n    message = getTranslationForTemplate(message, subTemplateIndex);\n    const msgParts = replaceNgsp(message).split(PH_REGEXP);\n    for (let i = 0; i < msgParts.length; i++) {\n        let value = msgParts[i];\n        if ((i & 1) === 0) {\n            // Even indexes are text (including bindings & ICU expressions)\n            const parts = i18nParseTextIntoPartsAndICU(value);\n            for (let j = 0; j < parts.length; j++) {\n                let part = parts[j];\n                if ((j & 1) === 0) {\n                    // `j` is odd therefore `part` is string\n                    const text = part;\n                    ngDevMode && assertString(text, 'Parsed ICU part should be string');\n                    if (text !== '') {\n                        i18nStartFirstCreatePassProcessTextNode(tView, rootTNode, existingTNodeStack[0], createOpCodes, updateOpCodes, lView, text);\n                    }\n                }\n                else {\n                    // `j` is Even therefor `part` is an `ICUExpression`\n                    const icuExpression = part;\n                    // Verify that ICU expression has the right shape. Translations might contain invalid\n                    // constructions (while original messages were correct), so ICU parsing at runtime may\n                    // not succeed (thus `icuExpression` remains a string).\n                    // Note: we intentionally retain the error here by not using `ngDevMode`, because\n                    // the value can change based on the locale and users aren't guaranteed to hit\n                    // an invalid string while they're developing.\n                    if (typeof icuExpression !== 'object') {\n                        throw new Error(`Unable to parse ICU expression in \"${message}\" message.`);\n                    }\n                    const icuContainerTNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodeStack[0], lView, createOpCodes, ngDevMode ? `ICU ${index}:${icuExpression.mainBinding}` : '', true);\n                    const icuNodeIndex = icuContainerTNode.index;\n                    ngDevMode &&\n                        assertGreaterThanOrEqual(icuNodeIndex, HEADER_OFFSET, 'Index must be in absolute LView offset');\n                    icuStart(tView, lView, updateOpCodes, parentTNodeIndex, icuExpression, icuNodeIndex);\n                }\n            }\n        }\n        else {\n            // Odd indexes are placeholders (elements and sub-templates)\n            // At this point value is something like: '/#1:2' (originally coming from '�/#1:2�')\n            const isClosing = value.charCodeAt(0) === 47 /* CharCode.SLASH */;\n            const type = value.charCodeAt(isClosing ? 1 : 0);\n            ngDevMode && assertOneOf(type, 42 /* CharCode.STAR */, 35 /* CharCode.HASH */);\n            const index = HEADER_OFFSET + Number.parseInt(value.substring((isClosing ? 2 : 1)));\n            if (isClosing) {\n                existingTNodeStack.shift();\n                setCurrentTNode(getCurrentParentTNode(), false);\n            }\n            else {\n                const tNode = createTNodePlaceholder(tView, existingTNodeStack[0], index);\n                existingTNodeStack.unshift([]);\n                setCurrentTNode(tNode, true);\n            }\n        }\n    }\n    tView.data[index] = {\n        create: createOpCodes,\n        update: updateOpCodes,\n    };\n}\n/**\n * Allocate space in i18n Range add create OpCode instruction to create a text or comment node.\n *\n * @param tView Current `TView` needed to allocate space in i18n range.\n * @param rootTNode Root `TNode` of the i18n block. This node determines if the new TNode will be\n *     added as part of the `i18nStart` instruction or as part of the `TNode.insertBeforeIndex`.\n * @param existingTNodes internal state for `addTNodeAndUpdateInsertBeforeIndex`.\n * @param lView Current `LView` needed to allocate space in i18n range.\n * @param createOpCodes Array storing `I18nCreateOpCodes` where new opCodes will be added.\n * @param text Text to be added when the `Text` or `Comment` node will be created.\n * @param isICU true if a `Comment` node for ICU (instead of `Text`) node should be created.\n */\nfunction createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, text, isICU) {\n    const i18nNodeIdx = allocExpando(tView, lView, 1, null);\n    let opCode = i18nNodeIdx << I18nCreateOpCode.SHIFT;\n    let parentTNode = getCurrentParentTNode();\n    if (rootTNode === parentTNode) {\n        // FIXME(misko): A null `parentTNode` should represent when we fall of the `LView` boundary.\n        // (there is no parent), but in some circumstances (because we are inconsistent about how we set\n        // `previousOrParentTNode`) it could point to `rootTNode` So this is a work around.\n        parentTNode = null;\n    }\n    if (parentTNode === null) {\n        // If we don't have a parent that means that we can eagerly add nodes.\n        // If we have a parent than these nodes can't be added now (as the parent has not been created\n        // yet) and instead the `parentTNode` is responsible for adding it. See\n        // `TNode.insertBeforeIndex`\n        opCode |= I18nCreateOpCode.APPEND_EAGERLY;\n    }\n    if (isICU) {\n        opCode |= I18nCreateOpCode.COMMENT;\n        ensureIcuContainerVisitorLoaded(loadIcuContainerVisitor);\n    }\n    createOpCodes.push(opCode, text === null ? '' : text);\n    // We store `{{?}}` so that when looking at debug `TNodeType.template` we can see where the\n    // bindings are.\n    const tNode = createTNodeAtIndex(tView, i18nNodeIdx, isICU ? 32 /* TNodeType.Icu */ : 1 /* TNodeType.Text */, text === null ? (ngDevMode ? '{{?}}' : '') : text, null);\n    addTNodeAndUpdateInsertBeforeIndex(existingTNodes, tNode);\n    const tNodeIdx = tNode.index;\n    setCurrentTNode(tNode, false /* Text nodes are self closing */);\n    if (parentTNode !== null && rootTNode !== parentTNode) {\n        // We are a child of deeper node (rather than a direct child of `i18nStart` instruction.)\n        // We have to make sure to add ourselves to the parent.\n        setTNodeInsertBeforeIndex(parentTNode, tNodeIdx);\n    }\n    return tNode;\n}\n/**\n * Processes text node in i18n block.\n *\n * Text nodes can have:\n * - Create instruction in `createOpCodes` for creating the text node.\n * - Allocate spec for text node in i18n range of `LView`\n * - If contains binding:\n *    - bindings => allocate space in i18n range of `LView` to store the binding value.\n *    - populate `updateOpCodes` with update instructions.\n *\n * @param tView Current `TView`\n * @param rootTNode Root `TNode` of the i18n block. This node determines if the new TNode will\n *     be added as part of the `i18nStart` instruction or as part of the\n *     `TNode.insertBeforeIndex`.\n * @param existingTNodes internal state for `addTNodeAndUpdateInsertBeforeIndex`.\n * @param createOpCodes Location where the creation OpCodes will be stored.\n * @param lView Current `LView`\n * @param text The translated text (which may contain binding)\n */\nfunction i18nStartFirstCreatePassProcessTextNode(tView, rootTNode, existingTNodes, createOpCodes, updateOpCodes, lView, text) {\n    const hasBinding = text.match(BINDING_REGEXP);\n    const tNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, hasBinding ? null : text, false);\n    if (hasBinding) {\n        generateBindingUpdateOpCodes(updateOpCodes, text, tNode.index, null, 0, null);\n    }\n}\n/**\n * See `i18nAttributes` above.\n */\nfunction i18nAttributesFirstPass(tView, index, values) {\n    const previousElement = getCurrentTNode();\n    const previousElementIndex = previousElement.index;\n    const updateOpCodes = [];\n    if (ngDevMode) {\n        attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n    }\n    if (tView.firstCreatePass && tView.data[index] === null) {\n        for (let i = 0; i < values.length; i += 2) {\n            const attrName = values[i];\n            const message = values[i + 1];\n            if (message !== '') {\n                // Check if attribute value contains an ICU and throw an error if that's the case.\n                // ICUs in element attributes are not supported.\n                // Note: we intentionally retain the error here by not using `ngDevMode`, because\n                // the `value` can change based on the locale and users aren't guaranteed to hit\n                // an invalid string while they're developing.\n                if (ICU_REGEXP.test(message)) {\n                    throw new Error(`ICU expressions are not supported in attributes. Message: \"${message}\".`);\n                }\n                // i18n attributes that hit this code path are guaranteed to have bindings, because\n                // the compiler treats static i18n attributes as regular attribute bindings.\n                // Since this may not be the first i18n attribute on this element we need to pass in how\n                // many previous bindings there have already been.\n                generateBindingUpdateOpCodes(updateOpCodes, message, previousElementIndex, attrName, countBindings(updateOpCodes), null);\n            }\n        }\n        tView.data[index] = updateOpCodes;\n    }\n}\n/**\n * Generate the OpCodes to update the bindings of a string.\n *\n * @param updateOpCodes Place where the update opcodes will be stored.\n * @param str The string containing the bindings.\n * @param destinationNode Index of the destination node which will receive the binding.\n * @param attrName Name of the attribute, if the string belongs to an attribute.\n * @param sanitizeFn Sanitization function used to sanitize the string after update, if necessary.\n * @param bindingStart The lView index of the next expression that can be bound via an opCode.\n * @returns The mask value for these bindings\n */\nfunction generateBindingUpdateOpCodes(updateOpCodes, str, destinationNode, attrName, bindingStart, sanitizeFn) {\n    ngDevMode &&\n        assertGreaterThanOrEqual(destinationNode, HEADER_OFFSET, 'Index must be in absolute LView offset');\n    const maskIndex = updateOpCodes.length; // Location of mask\n    const sizeIndex = maskIndex + 1; // location of size for skipping\n    updateOpCodes.push(null, null); // Alloc space for mask and size\n    const startIndex = maskIndex + 2; // location of first allocation.\n    if (ngDevMode) {\n        attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n    }\n    const textParts = str.split(BINDING_REGEXP);\n    let mask = 0;\n    for (let j = 0; j < textParts.length; j++) {\n        const textValue = textParts[j];\n        if (j & 1) {\n            // Odd indexes are bindings\n            const bindingIndex = bindingStart + parseInt(textValue, 10);\n            updateOpCodes.push(-1 - bindingIndex);\n            mask = mask | toMaskBit(bindingIndex);\n        }\n        else if (textValue !== '') {\n            // Even indexes are text\n            updateOpCodes.push(textValue);\n        }\n    }\n    updateOpCodes.push(destinationNode << 2 /* I18nUpdateOpCode.SHIFT_REF */ |\n        (attrName ? 1 /* I18nUpdateOpCode.Attr */ : 0 /* I18nUpdateOpCode.Text */));\n    if (attrName) {\n        updateOpCodes.push(attrName, sanitizeFn);\n    }\n    updateOpCodes[maskIndex] = mask;\n    updateOpCodes[sizeIndex] = updateOpCodes.length - startIndex;\n    return mask;\n}\n/**\n * Count the number of bindings in the given `opCodes`.\n *\n * It could be possible to speed this up, by passing the number of bindings found back from\n * `generateBindingUpdateOpCodes()` to `i18nAttributesFirstPass()` but this would then require more\n * complexity in the code and/or transient objects to be created.\n *\n * Since this function is only called once when the template is instantiated, is trivial in the\n * first instance (since `opCodes` will be an empty array), and it is not common for elements to\n * contain multiple i18n bound attributes, it seems like this is a reasonable compromise.\n */\nfunction countBindings(opCodes) {\n    let count = 0;\n    for (let i = 0; i < opCodes.length; i++) {\n        const opCode = opCodes[i];\n        // Bindings are negative numbers.\n        if (typeof opCode === 'number' && opCode < 0) {\n            count++;\n        }\n    }\n    return count;\n}\n/**\n * Convert binding index to mask bit.\n *\n * Each index represents a single bit on the bit-mask. Because bit-mask only has 32 bits, we make\n * the 32nd bit share all masks for all bindings higher than 32. Since it is extremely rare to\n * have more than 32 bindings this will be hit very rarely. The downside of hitting this corner\n * case is that we will execute binding code more often than necessary. (penalty of performance)\n */\nfunction toMaskBit(bindingIndex) {\n    return 1 << Math.min(bindingIndex, 31);\n}\nfunction isRootTemplateMessage(subTemplateIndex) {\n    return subTemplateIndex === -1;\n}\n/**\n * Removes everything inside the sub-templates of a message.\n */\nfunction removeInnerTemplateTranslation(message) {\n    let match;\n    let res = '';\n    let index = 0;\n    let inTemplate = false;\n    let tagMatched;\n    while ((match = SUBTEMPLATE_REGEXP.exec(message)) !== null) {\n        if (!inTemplate) {\n            res += message.substring(index, match.index + match[0].length);\n            tagMatched = match[1];\n            inTemplate = true;\n        }\n        else {\n            if (match[0] === `${MARKER}/*${tagMatched}${MARKER}`) {\n                index = match.index;\n                inTemplate = false;\n            }\n        }\n    }\n    ngDevMode &&\n        assertEqual(inTemplate, false, `Tag mismatch: unable to find the end of the sub-template in the translation \"${message}\"`);\n    res += message.slice(index);\n    return res;\n}\n/**\n * Extracts a part of a message and removes the rest.\n *\n * This method is used for extracting a part of the message associated with a template. A\n * translated message can span multiple templates.\n *\n * Example:\n * ```\n * <div i18n>Translate <span *ngIf>me</span>!</div>\n * ```\n *\n * @param message The message to crop\n * @param subTemplateIndex Index of the sub-template to extract. If undefined it returns the\n * external template and removes all sub-templates.\n */\nfunction getTranslationForTemplate(message, subTemplateIndex) {\n    if (isRootTemplateMessage(subTemplateIndex)) {\n        // We want the root template message, ignore all sub-templates\n        return removeInnerTemplateTranslation(message);\n    }\n    else {\n        // We want a specific sub-template\n        const start = message.indexOf(`:${subTemplateIndex}${MARKER}`) + 2 + subTemplateIndex.toString().length;\n        const end = message.search(new RegExp(`${MARKER}\\\\/\\\\*\\\\d+:${subTemplateIndex}${MARKER}`));\n        return removeInnerTemplateTranslation(message.substring(start, end));\n    }\n}\n/**\n * Generate the OpCodes for ICU expressions.\n *\n * @param icuExpression\n * @param index Index where the anchor is stored and an optional `TIcuContainerNode`\n *   - `lView[anchorIdx]` points to a `Comment` node representing the anchor for the ICU.\n *   - `tView.data[anchorIdx]` points to the `TIcuContainerNode` if ICU is root (`null` otherwise)\n */\nfunction icuStart(tView, lView, updateOpCodes, parentIdx, icuExpression, anchorIdx) {\n    ngDevMode && assertDefined(icuExpression, 'ICU expression must be defined');\n    let bindingMask = 0;\n    const tIcu = {\n        type: icuExpression.type,\n        currentCaseLViewIndex: allocExpando(tView, lView, 1, null),\n        anchorIdx,\n        cases: [],\n        create: [],\n        remove: [],\n        update: []\n    };\n    addUpdateIcuSwitch(updateOpCodes, icuExpression, anchorIdx);\n    setTIcu(tView, anchorIdx, tIcu);\n    const values = icuExpression.values;\n    for (let i = 0; i < values.length; i++) {\n        // Each value is an array of strings & other ICU expressions\n        const valueArr = values[i];\n        const nestedIcus = [];\n        for (let j = 0; j < valueArr.length; j++) {\n            const value = valueArr[j];\n            if (typeof value !== 'string') {\n                // It is an nested ICU expression\n                const icuIndex = nestedIcus.push(value) - 1;\n                // Replace nested ICU expression by a comment node\n                valueArr[j] = `<!--�${icuIndex}�-->`;\n            }\n        }\n        bindingMask = parseIcuCase(tView, tIcu, lView, updateOpCodes, parentIdx, icuExpression.cases[i], valueArr.join(''), nestedIcus) |\n            bindingMask;\n    }\n    if (bindingMask) {\n        addUpdateIcuUpdate(updateOpCodes, bindingMask, anchorIdx);\n    }\n}\n/**\n * Parses text containing an ICU expression and produces a JSON object for it.\n * Original code from closure library, modified for Angular.\n *\n * @param pattern Text containing an ICU expression that needs to be parsed.\n *\n */\nfunction parseICUBlock(pattern) {\n    const cases = [];\n    const values = [];\n    let icuType = 1 /* IcuType.plural */;\n    let mainBinding = 0;\n    pattern = pattern.replace(ICU_BLOCK_REGEXP, function (str, binding, type) {\n        if (type === 'select') {\n            icuType = 0 /* IcuType.select */;\n        }\n        else {\n            icuType = 1 /* IcuType.plural */;\n        }\n        mainBinding = parseInt(binding.slice(1), 10);\n        return '';\n    });\n    const parts = i18nParseTextIntoPartsAndICU(pattern);\n    // Looking for (key block)+ sequence. One of the keys has to be \"other\".\n    for (let pos = 0; pos < parts.length;) {\n        let key = parts[pos++].trim();\n        if (icuType === 1 /* IcuType.plural */) {\n            // Key can be \"=x\", we just want \"x\"\n            key = key.replace(/\\s*(?:=)?(\\w+)\\s*/, '$1');\n        }\n        if (key.length) {\n            cases.push(key);\n        }\n        const blocks = i18nParseTextIntoPartsAndICU(parts[pos++]);\n        if (cases.length > values.length) {\n            values.push(blocks);\n        }\n    }\n    // TODO(ocombe): support ICU expressions in attributes, see #21615\n    return { type: icuType, mainBinding: mainBinding, cases, values };\n}\n/**\n * Breaks pattern into strings and top level {...} blocks.\n * Can be used to break a message into text and ICU expressions, or to break an ICU expression\n * into keys and cases. Original code from closure library, modified for Angular.\n *\n * @param pattern (sub)Pattern to be broken.\n * @returns An `Array<string|IcuExpression>` where:\n *   - odd positions: `string` => text between ICU expressions\n *   - even positions: `ICUExpression` => ICU expression parsed into `ICUExpression` record.\n */\nfunction i18nParseTextIntoPartsAndICU(pattern) {\n    if (!pattern) {\n        return [];\n    }\n    let prevPos = 0;\n    const braceStack = [];\n    const results = [];\n    const braces = /[{}]/g;\n    // lastIndex doesn't get set to 0 so we have to.\n    braces.lastIndex = 0;\n    let match;\n    while (match = braces.exec(pattern)) {\n        const pos = match.index;\n        if (match[0] == '}') {\n            braceStack.pop();\n            if (braceStack.length == 0) {\n                // End of the block.\n                const block = pattern.substring(prevPos, pos);\n                if (ICU_BLOCK_REGEXP.test(block)) {\n                    results.push(parseICUBlock(block));\n                }\n                else {\n                    results.push(block);\n                }\n                prevPos = pos + 1;\n            }\n        }\n        else {\n            if (braceStack.length == 0) {\n                const substring = pattern.substring(prevPos, pos);\n                results.push(substring);\n                prevPos = pos + 1;\n            }\n            braceStack.push('{');\n        }\n    }\n    const substring = pattern.substring(prevPos);\n    results.push(substring);\n    return results;\n}\n/**\n * Parses a node, its children and its siblings, and generates the mutate & update OpCodes.\n *\n */\nfunction parseIcuCase(tView, tIcu, lView, updateOpCodes, parentIdx, caseName, unsafeCaseHtml, nestedIcus) {\n    const create = [];\n    const remove = [];\n    const update = [];\n    if (ngDevMode) {\n        attachDebugGetter(create, icuCreateOpCodesToString);\n        attachDebugGetter(remove, i18nRemoveOpCodesToString);\n        attachDebugGetter(update, i18nUpdateOpCodesToString);\n    }\n    tIcu.cases.push(caseName);\n    tIcu.create.push(create);\n    tIcu.remove.push(remove);\n    tIcu.update.push(update);\n    const inertBodyHelper = getInertBodyHelper(getDocument());\n    const inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeCaseHtml);\n    ngDevMode && assertDefined(inertBodyElement, 'Unable to generate inert body element');\n    const inertRootNode = getTemplateContent(inertBodyElement) || inertBodyElement;\n    if (inertRootNode) {\n        return walkIcuTree(tView, tIcu, lView, updateOpCodes, create, remove, update, inertRootNode, parentIdx, nestedIcus, 0);\n    }\n    else {\n        return 0;\n    }\n}\nfunction walkIcuTree(tView, tIcu, lView, sharedUpdateOpCodes, create, remove, update, parentNode, parentIdx, nestedIcus, depth) {\n    let bindingMask = 0;\n    let currentNode = parentNode.firstChild;\n    while (currentNode) {\n        const newIndex = allocExpando(tView, lView, 1, null);\n        switch (currentNode.nodeType) {\n            case Node.ELEMENT_NODE:\n                const element = currentNode;\n                const tagName = element.tagName.toLowerCase();\n                if (VALID_ELEMENTS.hasOwnProperty(tagName)) {\n                    addCreateNodeAndAppend(create, ELEMENT_MARKER, tagName, parentIdx, newIndex);\n                    tView.data[newIndex] = tagName;\n                    const elAttrs = element.attributes;\n                    for (let i = 0; i < elAttrs.length; i++) {\n                        const attr = elAttrs.item(i);\n                        const lowerAttrName = attr.name.toLowerCase();\n                        const hasBinding = !!attr.value.match(BINDING_REGEXP);\n                        // we assume the input string is safe, unless it's using a binding\n                        if (hasBinding) {\n                            if (VALID_ATTRS.hasOwnProperty(lowerAttrName)) {\n                                if (URI_ATTRS[lowerAttrName]) {\n                                    generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, _sanitizeUrl);\n                                }\n                                else if (SRCSET_ATTRS[lowerAttrName]) {\n                                    generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, sanitizeSrcset);\n                                }\n                                else {\n                                    generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, null);\n                                }\n                            }\n                            else {\n                                ngDevMode &&\n                                    console.warn(`WARNING: ignoring unsafe attribute value ` +\n                                        `${lowerAttrName} on element ${tagName} ` +\n                                        `(see https://g.co/ng/security#xss)`);\n                            }\n                        }\n                        else {\n                            addCreateAttribute(create, newIndex, attr);\n                        }\n                    }\n                    // Parse the children of this node (if any)\n                    bindingMask = walkIcuTree(tView, tIcu, lView, sharedUpdateOpCodes, create, remove, update, currentNode, newIndex, nestedIcus, depth + 1) |\n                        bindingMask;\n                    addRemoveNode(remove, newIndex, depth);\n                }\n                break;\n            case Node.TEXT_NODE:\n                const value = currentNode.textContent || '';\n                const hasBinding = value.match(BINDING_REGEXP);\n                addCreateNodeAndAppend(create, null, hasBinding ? '' : value, parentIdx, newIndex);\n                addRemoveNode(remove, newIndex, depth);\n                if (hasBinding) {\n                    bindingMask =\n                        generateBindingUpdateOpCodes(update, value, newIndex, null, 0, null) | bindingMask;\n                }\n                break;\n            case Node.COMMENT_NODE:\n                // Check if the comment node is a placeholder for a nested ICU\n                const isNestedIcu = NESTED_ICU.exec(currentNode.textContent || '');\n                if (isNestedIcu) {\n                    const nestedIcuIndex = parseInt(isNestedIcu[1], 10);\n                    const icuExpression = nestedIcus[nestedIcuIndex];\n                    // Create the comment node that will anchor the ICU expression\n                    addCreateNodeAndAppend(create, ICU_MARKER, ngDevMode ? `nested ICU ${nestedIcuIndex}` : '', parentIdx, newIndex);\n                    icuStart(tView, lView, sharedUpdateOpCodes, parentIdx, icuExpression, newIndex);\n                    addRemoveNestedIcu(remove, newIndex, depth);\n                }\n                break;\n        }\n        currentNode = currentNode.nextSibling;\n    }\n    return bindingMask;\n}\nfunction addRemoveNode(remove, index, depth) {\n    if (depth === 0) {\n        remove.push(index);\n    }\n}\nfunction addRemoveNestedIcu(remove, index, depth) {\n    if (depth === 0) {\n        remove.push(~index); // remove ICU at `index`\n        remove.push(index); // remove ICU comment at `index`\n    }\n}\nfunction addUpdateIcuSwitch(update, icuExpression, index) {\n    update.push(toMaskBit(icuExpression.mainBinding), 2, -1 - icuExpression.mainBinding, index << 2 /* I18nUpdateOpCode.SHIFT_REF */ | 2 /* I18nUpdateOpCode.IcuSwitch */);\n}\nfunction addUpdateIcuUpdate(update, bindingMask, index) {\n    update.push(bindingMask, 1, index << 2 /* I18nUpdateOpCode.SHIFT_REF */ | 3 /* I18nUpdateOpCode.IcuUpdate */);\n}\nfunction addCreateNodeAndAppend(create, marker, text, appendToParentIdx, createAtIdx) {\n    if (marker !== null) {\n        create.push(marker);\n    }\n    create.push(text, createAtIdx, icuCreateOpCode(0 /* IcuCreateOpCode.AppendChild */, appendToParentIdx, createAtIdx));\n}\nfunction addCreateAttribute(create, newIndex, attr) {\n    create.push(newIndex << 1 /* IcuCreateOpCode.SHIFT_REF */ | 1 /* IcuCreateOpCode.Attr */, attr.name, attr.value);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// i18nPostprocess consts\nconst ROOT_TEMPLATE_ID = 0;\nconst PP_MULTI_VALUE_PLACEHOLDERS_REGEXP = /\\[(�.+?�?)\\]/;\nconst PP_PLACEHOLDERS_REGEXP = /\\[(�.+?�?)\\]|(�\\/?\\*\\d+:\\d+�)/g;\nconst PP_ICU_VARS_REGEXP = /({\\s*)(VAR_(PLURAL|SELECT)(_\\d+)?)(\\s*,)/g;\nconst PP_ICU_PLACEHOLDERS_REGEXP = /{([A-Z0-9_]+)}/g;\nconst PP_ICUS_REGEXP = /�I18N_EXP_(ICU(_\\d+)?)�/g;\nconst PP_CLOSE_TEMPLATE_REGEXP = /\\/\\*/;\nconst PP_TEMPLATE_ID_REGEXP = /\\d+\\:(\\d+)/;\n/**\n * Handles message string post-processing for internationalization.\n *\n * Handles message string post-processing by transforming it from intermediate\n * format (that might contain some markers that we need to replace) to the final\n * form, consumable by i18nStart instruction. Post processing steps include:\n *\n * 1. Resolve all multi-value cases (like [�*1:1��#2:1�|�#4:1�|�5�])\n * 2. Replace all ICU vars (like \"VAR_PLURAL\")\n * 3. Replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n * 4. Replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�)\n *    in case multiple ICUs have the same placeholder name\n *\n * @param message Raw translation string for post processing\n * @param replacements Set of replacements that should be applied\n *\n * @returns Transformed string that can be consumed by i18nStart instruction\n *\n * @codeGenApi\n */\nfunction i18nPostprocess(message, replacements = {}) {\n    /**\n     * Step 1: resolve all multi-value placeholders like [�#5�|�*1:1��#2:1�|�#4:1�]\n     *\n     * Note: due to the way we process nested templates (BFS), multi-value placeholders are typically\n     * grouped by templates, for example: [�#5�|�#6�|�#1:1�|�#3:2�] where �#5� and �#6� belong to root\n     * template, �#1:1� belong to nested template with index 1 and �#1:2� - nested template with index\n     * 3. However in real templates the order might be different: i.e. �#1:1� and/or �#3:2� may go in\n     * front of �#6�. The post processing step restores the right order by keeping track of the\n     * template id stack and looks for placeholders that belong to the currently active template.\n     */\n    let result = message;\n    if (PP_MULTI_VALUE_PLACEHOLDERS_REGEXP.test(message)) {\n        const matches = {};\n        const templateIdsStack = [ROOT_TEMPLATE_ID];\n        result = result.replace(PP_PLACEHOLDERS_REGEXP, (m, phs, tmpl) => {\n            const content = phs || tmpl;\n            const placeholders = matches[content] || [];\n            if (!placeholders.length) {\n                content.split('|').forEach((placeholder) => {\n                    const match = placeholder.match(PP_TEMPLATE_ID_REGEXP);\n                    const templateId = match ? parseInt(match[1], 10) : ROOT_TEMPLATE_ID;\n                    const isCloseTemplateTag = PP_CLOSE_TEMPLATE_REGEXP.test(placeholder);\n                    placeholders.push([templateId, isCloseTemplateTag, placeholder]);\n                });\n                matches[content] = placeholders;\n            }\n            if (!placeholders.length) {\n                throw new Error(`i18n postprocess: unmatched placeholder - ${content}`);\n            }\n            const currentTemplateId = templateIdsStack[templateIdsStack.length - 1];\n            let idx = 0;\n            // find placeholder index that matches current template id\n            for (let i = 0; i < placeholders.length; i++) {\n                if (placeholders[i][0] === currentTemplateId) {\n                    idx = i;\n                    break;\n                }\n            }\n            // update template id stack based on the current tag extracted\n            const [templateId, isCloseTemplateTag, placeholder] = placeholders[idx];\n            if (isCloseTemplateTag) {\n                templateIdsStack.pop();\n            }\n            else if (currentTemplateId !== templateId) {\n                templateIdsStack.push(templateId);\n            }\n            // remove processed tag from the list\n            placeholders.splice(idx, 1);\n            return placeholder;\n        });\n    }\n    // return current result if no replacements specified\n    if (!Object.keys(replacements).length) {\n        return result;\n    }\n    /**\n     * Step 2: replace all ICU vars (like \"VAR_PLURAL\")\n     */\n    result = result.replace(PP_ICU_VARS_REGEXP, (match, start, key, _type, _idx, end) => {\n        return replacements.hasOwnProperty(key) ? `${start}${replacements[key]}${end}` : match;\n    });\n    /**\n     * Step 3: replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n     */\n    result = result.replace(PP_ICU_PLACEHOLDERS_REGEXP, (match, key) => {\n        return replacements.hasOwnProperty(key) ? replacements[key] : match;\n    });\n    /**\n     * Step 4: replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�) in case\n     * multiple ICUs have the same placeholder name\n     */\n    result = result.replace(PP_ICUS_REGEXP, (match, key) => {\n        if (replacements.hasOwnProperty(key)) {\n            const list = replacements[key];\n            if (!list.length) {\n                throw new Error(`i18n postprocess: unmatched ICU - ${match} with key: ${key}`);\n            }\n            return list.shift();\n        }\n        return match;\n    });\n    return result;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Marks a block of text as translatable.\n *\n * The instructions `i18nStart` and `i18nEnd` mark the translation block in the template.\n * The translation `message` is the value which is locale specific. The translation string may\n * contain placeholders which associate inner elements and sub-templates within the translation.\n *\n * The translation `message` placeholders are:\n * - `�{index}(:{block})�`: *Binding Placeholder*: Marks a location where an expression will be\n *   interpolated into. The placeholder `index` points to the expression binding index. An optional\n *   `block` that matches the sub-template in which it was declared.\n * - `�#{index}(:{block})�`/`�/#{index}(:{block})�`: *Element Placeholder*:  Marks the beginning\n *   and end of DOM element that were embedded in the original translation block. The placeholder\n *   `index` points to the element index in the template instructions set. An optional `block` that\n *   matches the sub-template in which it was declared.\n * - `�*{index}:{block}�`/`�/*{index}:{block}�`: *Sub-template Placeholder*: Sub-templates must be\n *   split up and translated separately in each angular template function. The `index` points to the\n *   `template` instruction index. A `block` that matches the sub-template in which it was declared.\n *\n * @param index A unique index of the translation in the static block.\n * @param messageIndex An index of the translation message from the `def.consts` array.\n * @param subTemplateIndex Optional sub-template index in the `message`.\n *\n * @codeGenApi\n */\nfunction ɵɵi18nStart(index, messageIndex, subTemplateIndex = -1) {\n    const tView = getTView();\n    const lView = getLView();\n    const adjustedIndex = HEADER_OFFSET + index;\n    ngDevMode && assertDefined(tView, `tView should be defined`);\n    const message = getConstant(tView.consts, messageIndex);\n    const parentTNode = getCurrentParentTNode();\n    if (tView.firstCreatePass) {\n        i18nStartFirstCreatePass(tView, parentTNode === null ? 0 : parentTNode.index, lView, adjustedIndex, message, subTemplateIndex);\n    }\n    const tI18n = tView.data[adjustedIndex];\n    const sameViewParentTNode = parentTNode === lView[T_HOST] ? null : parentTNode;\n    const parentRNode = getClosestRElement(tView, sameViewParentTNode, lView);\n    // If `parentTNode` is an `ElementContainer` than it has `<!--ng-container--->`.\n    // When we do inserts we have to make sure to insert in front of `<!--ng-container--->`.\n    const insertInFrontOf = parentTNode && (parentTNode.type & 8 /* TNodeType.ElementContainer */) ?\n        lView[parentTNode.index] :\n        null;\n    applyCreateOpCodes(lView, tI18n.create, parentRNode, insertInFrontOf);\n    setInI18nBlock(true);\n}\n/**\n * Translates a translation block marked by `i18nStart` and `i18nEnd`. It inserts the text/ICU nodes\n * into the render tree, moves the placeholder nodes and removes the deleted nodes.\n *\n * @codeGenApi\n */\nfunction ɵɵi18nEnd() {\n    setInI18nBlock(false);\n}\n/**\n *\n * Use this instruction to create a translation block that doesn't contain any placeholder.\n * It calls both {@link i18nStart} and {@link i18nEnd} in one instruction.\n *\n * The translation `message` is the value which is locale specific. The translation string may\n * contain placeholders which associate inner elements and sub-templates within the translation.\n *\n * The translation `message` placeholders are:\n * - `�{index}(:{block})�`: *Binding Placeholder*: Marks a location where an expression will be\n *   interpolated into. The placeholder `index` points to the expression binding index. An optional\n *   `block` that matches the sub-template in which it was declared.\n * - `�#{index}(:{block})�`/`�/#{index}(:{block})�`: *Element Placeholder*:  Marks the beginning\n *   and end of DOM element that were embedded in the original translation block. The placeholder\n *   `index` points to the element index in the template instructions set. An optional `block` that\n *   matches the sub-template in which it was declared.\n * - `�*{index}:{block}�`/`�/*{index}:{block}�`: *Sub-template Placeholder*: Sub-templates must be\n *   split up and translated separately in each angular template function. The `index` points to the\n *   `template` instruction index. A `block` that matches the sub-template in which it was declared.\n *\n * @param index A unique index of the translation in the static block.\n * @param messageIndex An index of the translation message from the `def.consts` array.\n * @param subTemplateIndex Optional sub-template index in the `message`.\n *\n * @codeGenApi\n */\nfunction ɵɵi18n(index, messageIndex, subTemplateIndex) {\n    ɵɵi18nStart(index, messageIndex, subTemplateIndex);\n    ɵɵi18nEnd();\n}\n/**\n * Marks a list of attributes as translatable.\n *\n * @param index A unique index in the static block\n * @param values\n *\n * @codeGenApi\n */\nfunction ɵɵi18nAttributes(index, attrsIndex) {\n    const tView = getTView();\n    ngDevMode && assertDefined(tView, `tView should be defined`);\n    const attrs = getConstant(tView.consts, attrsIndex);\n    i18nAttributesFirstPass(tView, index + HEADER_OFFSET, attrs);\n}\n/**\n * Stores the values of the bindings during each update cycle in order to determine if we need to\n * update the translated nodes.\n *\n * @param value The binding's value\n * @returns This function returns itself so that it may be chained\n * (e.g. `i18nExp(ctx.name)(ctx.title)`)\n *\n * @codeGenApi\n */\nfunction ɵɵi18nExp(value) {\n    const lView = getLView();\n    setMaskBit(bindingUpdated(lView, nextBindingIndex(), value));\n    return ɵɵi18nExp;\n}\n/**\n * Updates a translation block or an i18n attribute when the bindings have changed.\n *\n * @param index Index of either {@link i18nStart} (translation block) or {@link i18nAttributes}\n * (i18n attribute) on which it should update the content.\n *\n * @codeGenApi\n */\nfunction ɵɵi18nApply(index) {\n    applyI18n(getTView(), getLView(), index + HEADER_OFFSET);\n}\n/**\n * Handles message string post-processing for internationalization.\n *\n * Handles message string post-processing by transforming it from intermediate\n * format (that might contain some markers that we need to replace) to the final\n * form, consumable by i18nStart instruction. Post processing steps include:\n *\n * 1. Resolve all multi-value cases (like [�*1:1��#2:1�|�#4:1�|�5�])\n * 2. Replace all ICU vars (like \"VAR_PLURAL\")\n * 3. Replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n * 4. Replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�)\n *    in case multiple ICUs have the same placeholder name\n *\n * @param message Raw translation string for post processing\n * @param replacements Set of replacements that should be applied\n *\n * @returns Transformed string that can be consumed by i18nStart instruction\n *\n * @codeGenApi\n */\nfunction ɵɵi18nPostprocess(message, replacements = {}) {\n    return i18nPostprocess(message, replacements);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Resolves the providers which are defined in the DirectiveDef.\n *\n * When inserting the tokens and the factories in their respective arrays, we can assume that\n * this method is called first for the component (if any), and then for other directives on the same\n * node.\n * As a consequence,the providers are always processed in that order:\n * 1) The view providers of the component\n * 2) The providers of the component\n * 3) The providers of the other directives\n * This matches the structure of the injectables arrays of a view (for each node).\n * So the tokens and the factories can be pushed at the end of the arrays, except\n * in one case for multi providers.\n *\n * @param def the directive definition\n * @param providers: Array of `providers`.\n * @param viewProviders: Array of `viewProviders`.\n */\nfunction providersResolver(def, providers, viewProviders) {\n    const tView = getTView();\n    if (tView.firstCreatePass) {\n        const isComponent = isComponentDef(def);\n        // The list of view providers is processed first, and the flags are updated\n        resolveProvider(viewProviders, tView.data, tView.blueprint, isComponent, true);\n        // Then, the list of providers is processed, and the flags are updated\n        resolveProvider(providers, tView.data, tView.blueprint, isComponent, false);\n    }\n}\n/**\n * Resolves a provider and publishes it to the DI system.\n */\nfunction resolveProvider(provider, tInjectables, lInjectablesBlueprint, isComponent, isViewProvider) {\n    provider = resolveForwardRef(provider);\n    if (Array.isArray(provider)) {\n        // Recursively call `resolveProvider`\n        // Recursion is OK in this case because this code will not be in hot-path once we implement\n        // cloning of the initial state.\n        for (let i = 0; i < provider.length; i++) {\n            resolveProvider(provider[i], tInjectables, lInjectablesBlueprint, isComponent, isViewProvider);\n        }\n    }\n    else {\n        const tView = getTView();\n        const lView = getLView();\n        let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider.provide);\n        let providerFactory = providerToFactory(provider);\n        const tNode = getCurrentTNode();\n        const beginIndex = tNode.providerIndexes & 1048575 /* TNodeProviderIndexes.ProvidersStartIndexMask */;\n        const endIndex = tNode.directiveStart;\n        const cptViewProvidersCount = tNode.providerIndexes >> 20 /* TNodeProviderIndexes.CptViewProvidersCountShift */;\n        if (isTypeProvider(provider) || !provider.multi) {\n            // Single provider case: the factory is created and pushed immediately\n            const factory = new NodeInjectorFactory(providerFactory, isViewProvider, ɵɵdirectiveInject);\n            const existingFactoryIndex = indexOf(token, tInjectables, isViewProvider ? beginIndex : beginIndex + cptViewProvidersCount, endIndex);\n            if (existingFactoryIndex === -1) {\n                diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);\n                registerDestroyHooksIfSupported(tView, provider, tInjectables.length);\n                tInjectables.push(token);\n                tNode.directiveStart++;\n                tNode.directiveEnd++;\n                if (isViewProvider) {\n                    tNode.providerIndexes += 1048576 /* TNodeProviderIndexes.CptViewProvidersCountShifter */;\n                }\n                lInjectablesBlueprint.push(factory);\n                lView.push(factory);\n            }\n            else {\n                lInjectablesBlueprint[existingFactoryIndex] = factory;\n                lView[existingFactoryIndex] = factory;\n            }\n        }\n        else {\n            // Multi provider case:\n            // We create a multi factory which is going to aggregate all the values.\n            // Since the output of such a factory depends on content or view injection,\n            // we create two of them, which are linked together.\n            //\n            // The first one (for view providers) is always in the first block of the injectables array,\n            // and the second one (for providers) is always in the second block.\n            // This is important because view providers have higher priority. When a multi token\n            // is being looked up, the view providers should be found first.\n            // Note that it is not possible to have a multi factory in the third block (directive block).\n            //\n            // The algorithm to process multi providers is as follows:\n            // 1) If the multi provider comes from the `viewProviders` of the component:\n            //   a) If the special view providers factory doesn't exist, it is created and pushed.\n            //   b) Else, the multi provider is added to the existing multi factory.\n            // 2) If the multi provider comes from the `providers` of the component or of another\n            // directive:\n            //   a) If the multi factory doesn't exist, it is created and provider pushed into it.\n            //      It is also linked to the multi factory for view providers, if it exists.\n            //   b) Else, the multi provider is added to the existing multi factory.\n            const existingProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex + cptViewProvidersCount, endIndex);\n            const existingViewProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex, beginIndex + cptViewProvidersCount);\n            const doesProvidersFactoryExist = existingProvidersFactoryIndex >= 0 &&\n                lInjectablesBlueprint[existingProvidersFactoryIndex];\n            const doesViewProvidersFactoryExist = existingViewProvidersFactoryIndex >= 0 &&\n                lInjectablesBlueprint[existingViewProvidersFactoryIndex];\n            if (isViewProvider && !doesViewProvidersFactoryExist ||\n                !isViewProvider && !doesProvidersFactoryExist) {\n                // Cases 1.a and 2.a\n                diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);\n                const factory = multiFactory(isViewProvider ? multiViewProvidersFactoryResolver : multiProvidersFactoryResolver, lInjectablesBlueprint.length, isViewProvider, isComponent, providerFactory);\n                if (!isViewProvider && doesViewProvidersFactoryExist) {\n                    lInjectablesBlueprint[existingViewProvidersFactoryIndex].providerFactory = factory;\n                }\n                registerDestroyHooksIfSupported(tView, provider, tInjectables.length, 0);\n                tInjectables.push(token);\n                tNode.directiveStart++;\n                tNode.directiveEnd++;\n                if (isViewProvider) {\n                    tNode.providerIndexes += 1048576 /* TNodeProviderIndexes.CptViewProvidersCountShifter */;\n                }\n                lInjectablesBlueprint.push(factory);\n                lView.push(factory);\n            }\n            else {\n                // Cases 1.b and 2.b\n                const indexInFactory = multiFactoryAdd(lInjectablesBlueprint[isViewProvider ? existingViewProvidersFactoryIndex :\n                    existingProvidersFactoryIndex], providerFactory, !isViewProvider && isComponent);\n                registerDestroyHooksIfSupported(tView, provider, existingProvidersFactoryIndex > -1 ? existingProvidersFactoryIndex :\n                    existingViewProvidersFactoryIndex, indexInFactory);\n            }\n            if (!isViewProvider && isComponent && doesViewProvidersFactoryExist) {\n                lInjectablesBlueprint[existingViewProvidersFactoryIndex].componentProviders++;\n            }\n        }\n    }\n}\n/**\n * Registers the `ngOnDestroy` hook of a provider, if the provider supports destroy hooks.\n * @param tView `TView` in which to register the hook.\n * @param provider Provider whose hook should be registered.\n * @param contextIndex Index under which to find the context for the hook when it's being invoked.\n * @param indexInFactory Only required for `multi` providers. Index of the provider in the multi\n * provider factory.\n */\nfunction registerDestroyHooksIfSupported(tView, provider, contextIndex, indexInFactory) {\n    const providerIsTypeProvider = isTypeProvider(provider);\n    const providerIsClassProvider = isClassProvider(provider);\n    if (providerIsTypeProvider || providerIsClassProvider) {\n        // Resolve forward references as `useClass` can hold a forward reference.\n        const classToken = providerIsClassProvider ? resolveForwardRef(provider.useClass) : provider;\n        const prototype = classToken.prototype;\n        const ngOnDestroy = prototype.ngOnDestroy;\n        if (ngOnDestroy) {\n            const hooks = tView.destroyHooks || (tView.destroyHooks = []);\n            if (!providerIsTypeProvider && provider.multi) {\n                ngDevMode &&\n                    assertDefined(indexInFactory, 'indexInFactory when registering multi factory destroy hook');\n                const existingCallbacksIndex = hooks.indexOf(contextIndex);\n                if (existingCallbacksIndex === -1) {\n                    hooks.push(contextIndex, [indexInFactory, ngOnDestroy]);\n                }\n                else {\n                    hooks[existingCallbacksIndex + 1].push(indexInFactory, ngOnDestroy);\n                }\n            }\n            else {\n                hooks.push(contextIndex, ngOnDestroy);\n            }\n        }\n    }\n}\n/**\n * Add a factory in a multi factory.\n * @returns Index at which the factory was inserted.\n */\nfunction multiFactoryAdd(multiFactory, factory, isComponentProvider) {\n    if (isComponentProvider) {\n        multiFactory.componentProviders++;\n    }\n    return multiFactory.multi.push(factory) - 1;\n}\n/**\n * Returns the index of item in the array, but only in the begin to end range.\n */\nfunction indexOf(item, arr, begin, end) {\n    for (let i = begin; i < end; i++) {\n        if (arr[i] === item)\n            return i;\n    }\n    return -1;\n}\n/**\n * Use this with `multi` `providers`.\n */\nfunction multiProvidersFactoryResolver(_, tData, lData, tNode) {\n    return multiResolve(this.multi, []);\n}\n/**\n * Use this with `multi` `viewProviders`.\n *\n * This factory knows how to concatenate itself with the existing `multi` `providers`.\n */\nfunction multiViewProvidersFactoryResolver(_, tData, lView, tNode) {\n    const factories = this.multi;\n    let result;\n    if (this.providerFactory) {\n        const componentCount = this.providerFactory.componentProviders;\n        const multiProviders = getNodeInjectable(lView, lView[TVIEW], this.providerFactory.index, tNode);\n        // Copy the section of the array which contains `multi` `providers` from the component\n        result = multiProviders.slice(0, componentCount);\n        // Insert the `viewProvider` instances.\n        multiResolve(factories, result);\n        // Copy the section of the array which contains `multi` `providers` from other directives\n        for (let i = componentCount; i < multiProviders.length; i++) {\n            result.push(multiProviders[i]);\n        }\n    }\n    else {\n        result = [];\n        // Insert the `viewProvider` instances.\n        multiResolve(factories, result);\n    }\n    return result;\n}\n/**\n * Maps an array of factories into an array of values.\n */\nfunction multiResolve(factories, result) {\n    for (let i = 0; i < factories.length; i++) {\n        const factory = factories[i];\n        result.push(factory());\n    }\n    return result;\n}\n/**\n * Creates a multi factory.\n */\nfunction multiFactory(factoryFn, index, isViewProvider, isComponent, f) {\n    const factory = new NodeInjectorFactory(factoryFn, isViewProvider, ɵɵdirectiveInject);\n    factory.multi = [];\n    factory.index = index;\n    factory.componentProviders = 0;\n    multiFactoryAdd(factory, f, isComponent && !isViewProvider);\n    return factory;\n}\n\n/**\n * This feature resolves the providers of a directive (or component),\n * and publish them into the DI system, making it visible to others for injection.\n *\n * For example:\n * ```ts\n * class ComponentWithProviders {\n *   constructor(private greeter: GreeterDE) {}\n *\n *   static ɵcmp = defineComponent({\n *     type: ComponentWithProviders,\n *     selectors: [['component-with-providers']],\n *    factory: () => new ComponentWithProviders(directiveInject(GreeterDE as any)),\n *    decls: 1,\n *    vars: 1,\n *    template: function(fs: RenderFlags, ctx: ComponentWithProviders) {\n *      if (fs & RenderFlags.Create) {\n *        ɵɵtext(0);\n *      }\n *      if (fs & RenderFlags.Update) {\n *        ɵɵtextInterpolate(ctx.greeter.greet());\n *      }\n *    },\n *    features: [ɵɵProvidersFeature([GreeterDE])]\n *  });\n * }\n * ```\n *\n * @param definition\n *\n * @codeGenApi\n */\nfunction ɵɵProvidersFeature(providers, viewProviders = []) {\n    return (definition) => {\n        definition.providersResolver =\n            (def, processProvidersFn) => {\n                return providersResolver(def, //\n                processProvidersFn ? processProvidersFn(providers) : providers, //\n                viewProviders);\n            };\n    };\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction noComponentFactoryError(component) {\n    const error = Error(`No component factory found for ${stringify(component)}. Did you add it to @NgModule.entryComponents?`);\n    error[ERROR_COMPONENT] = component;\n    return error;\n}\nconst ERROR_COMPONENT = 'ngComponent';\nfunction getComponent(error) {\n    return error[ERROR_COMPONENT];\n}\nclass _NullComponentFactoryResolver {\n    resolveComponentFactory(component) {\n        throw noComponentFactoryError(component);\n    }\n}\n/**\n * A simple registry that maps `Components` to generated `ComponentFactory` classes\n * that can be used to create instances of components.\n * Use to obtain the factory for a given component type,\n * then use the factory's `create()` method to create a component of that type.\n *\n * Note: since v13, dynamic component creation via\n * [`ViewContainerRef.createComponent`](api/core/ViewContainerRef#createComponent)\n * does **not** require resolving component factory: component class can be used directly.\n *\n * @publicApi\n *\n * @deprecated Angular no longer requires Component factories. Please use other APIs where\n *     Component class can be used directly.\n */\nclass ComponentFactoryResolver$1 {\n}\nComponentFactoryResolver$1.NULL = ( /* @__PURE__ */new _NullComponentFactoryResolver());\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Represents an instance of an `NgModule` created by an `NgModuleFactory`.\n * Provides access to the `NgModule` instance and related objects.\n *\n * @publicApi\n */\nclass NgModuleRef$1 {\n}\n/**\n * @publicApi\n *\n * @deprecated\n * This class was mostly used as a part of ViewEngine-based JIT API and is no longer needed in Ivy\n * JIT mode. See [JIT API changes due to ViewEngine deprecation](guide/deprecations#jit-api-changes)\n * for additional context. Angular provides APIs that accept NgModule classes directly (such as\n * [PlatformRef.bootstrapModule](api/core/PlatformRef#bootstrapModule) and\n * [createNgModuleRef](api/core/createNgModuleRef)), consider switching to those APIs instead of\n * using factory-based ones.\n */\nclass NgModuleFactory$1 {\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Represents a component created by a `ComponentFactory`.\n * Provides access to the component instance and related objects,\n * and provides the means of destroying the instance.\n *\n * @publicApi\n */\nclass ComponentRef$1 {\n}\n/**\n * Base class for a factory that can create a component dynamically.\n * Instantiate a factory for a given type of component with `resolveComponentFactory()`.\n * Use the resulting `ComponentFactory.create()` method to create a component of that type.\n *\n * @see [Dynamic Components](guide/dynamic-component-loader)\n *\n * @publicApi\n *\n * @deprecated Angular no longer requires Component factories. Please use other APIs where\n *     Component class can be used directly.\n */\nclass ComponentFactory$1 {\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Creates an ElementRef from the most recent node.\n *\n * @returns The ElementRef instance to use\n */\nfunction injectElementRef() {\n    return createElementRef(getCurrentTNode(), getLView());\n}\n/**\n * Creates an ElementRef given a node.\n *\n * @param tNode The node for which you'd like an ElementRef\n * @param lView The view to which the node belongs\n * @returns The ElementRef instance to use\n */\nfunction createElementRef(tNode, lView) {\n    return new ElementRef(getNativeByTNode(tNode, lView));\n}\n/**\n * A wrapper around a native element inside of a View.\n *\n * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM\n * element.\n *\n * @security Permitting direct access to the DOM can make your application more vulnerable to\n * XSS attacks. Carefully review any use of `ElementRef` in your code. For more detail, see the\n * [Security Guide](https://g.co/ng/security).\n *\n * @publicApi\n */\n// Note: We don't expose things like `Injector`, `ViewContainer`, ... here,\n// i.e. users have to ask for what they need. With that, we can build better analysis tools\n// and could do better codegen in the future.\nclass ElementRef {\n    constructor(nativeElement) {\n        this.nativeElement = nativeElement;\n    }\n}\n/**\n * @internal\n * @nocollapse\n */\nElementRef.__NG_ELEMENT_ID__ = injectElementRef;\n/**\n * Unwraps `ElementRef` and return the `nativeElement`.\n *\n * @param value value to unwrap\n * @returns `nativeElement` if `ElementRef` otherwise returns value as is.\n */\nfunction unwrapElementRef(value) {\n    return value instanceof ElementRef ? value.nativeElement : value;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst Renderer2Interceptor = new InjectionToken('Renderer2Interceptor');\n/**\n * Creates and initializes a custom renderer that implements the `Renderer2` base class.\n *\n * @publicApi\n */\nclass RendererFactory2 {\n}\n/**\n * Extend this base class to implement custom rendering. By default, Angular\n * renders a template into DOM. You can use custom rendering to intercept\n * rendering calls, or to render to something other than DOM.\n *\n * Create your custom renderer using `RendererFactory2`.\n *\n * Use a custom renderer to bypass Angular's templating and\n * make custom UI changes that can't be expressed declaratively.\n * For example if you need to set a property or an attribute whose name is\n * not statically known, use the `setProperty()` or\n * `setAttribute()` method.\n *\n * @publicApi\n */\nclass Renderer2 {\n}\n/**\n * @internal\n * @nocollapse\n */\nRenderer2.__NG_ELEMENT_ID__ = () => injectRenderer2();\n/** Returns a Renderer2 (or throws when application was bootstrapped with Renderer3) */\nfunction getOrCreateRenderer2(lView) {\n    const renderer = lView[RENDERER];\n    if (ngDevMode && !isProceduralRenderer(renderer)) {\n        throw new Error('Cannot inject Renderer2 when the application uses Renderer3!');\n    }\n    return renderer;\n}\n/** Injects a Renderer2 for the current component. */\nfunction injectRenderer2() {\n    // We need the Renderer to be based on the component that it's being injected into, however since\n    // DI happens before we've entered its view, `getLView` will return the parent view instead.\n    const lView = getLView();\n    const tNode = getCurrentTNode();\n    const nodeAtIndex = getComponentLViewByIndex(tNode.index, lView);\n    return getOrCreateRenderer2(isLView(nodeAtIndex) ? nodeAtIndex : lView);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Sanitizer is used by the views to sanitize potentially dangerous values.\n *\n * @publicApi\n */\nclass Sanitizer {\n}\n/** @nocollapse */\nSanitizer.ɵprov = ɵɵdefineInjectable({\n    token: Sanitizer,\n    providedIn: 'root',\n    factory: () => null,\n});\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @description Represents the version of Angular\n *\n * @publicApi\n */\nclass Version {\n    constructor(full) {\n        this.full = full;\n        this.major = full.split('.')[0];\n        this.minor = full.split('.')[1];\n        this.patch = full.split('.').slice(2).join('.');\n    }\n}\n/**\n * @publicApi\n */\nconst VERSION = new Version('14.0.3');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// This default value is when checking the hierarchy for a token.\n//\n// It means both:\n// - the token is not provided by the current injector,\n// - only the element injectors should be checked (ie do not check module injectors\n//\n//          mod1\n//         /\n//       el1   mod2\n//         \\  /\n//         el2\n//\n// When requesting el2.injector.get(token), we should check in the following order and return the\n// first found value:\n// - el2.injector.get(token, default)\n// - el1.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) -> do not check the module\n// - mod2.injector.get(token, default)\nconst NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction collectNativeNodes(tView, lView, tNode, result, isProjection = false) {\n    while (tNode !== null) {\n        ngDevMode &&\n            assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */ | 12 /* TNodeType.AnyContainer */ | 16 /* TNodeType.Projection */ | 32 /* TNodeType.Icu */);\n        const lNode = lView[tNode.index];\n        if (lNode !== null) {\n            result.push(unwrapRNode(lNode));\n        }\n        // A given lNode can represent either a native node or a LContainer (when it is a host of a\n        // ViewContainerRef). When we find a LContainer we need to descend into it to collect root nodes\n        // from the views in this container.\n        if (isLContainer(lNode)) {\n            for (let i = CONTAINER_HEADER_OFFSET; i < lNode.length; i++) {\n                const lViewInAContainer = lNode[i];\n                const lViewFirstChildTNode = lViewInAContainer[TVIEW].firstChild;\n                if (lViewFirstChildTNode !== null) {\n                    collectNativeNodes(lViewInAContainer[TVIEW], lViewInAContainer, lViewFirstChildTNode, result);\n                }\n            }\n        }\n        const tNodeType = tNode.type;\n        if (tNodeType & 8 /* TNodeType.ElementContainer */) {\n            collectNativeNodes(tView, lView, tNode.child, result);\n        }\n        else if (tNodeType & 32 /* TNodeType.Icu */) {\n            const nextRNode = icuContainerIterate(tNode, lView);\n            let rNode;\n            while (rNode = nextRNode()) {\n                result.push(rNode);\n            }\n        }\n        else if (tNodeType & 16 /* TNodeType.Projection */) {\n            const nodesInSlot = getProjectionNodes(lView, tNode);\n            if (Array.isArray(nodesInSlot)) {\n                result.push(...nodesInSlot);\n            }\n            else {\n                const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);\n                ngDevMode && assertParentView(parentView);\n                collectNativeNodes(parentView[TVIEW], parentView, nodesInSlot, result, true);\n            }\n        }\n        tNode = isProjection ? tNode.projectionNext : tNode.next;\n    }\n    return result;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass ViewRef {\n    constructor(\n    /**\n     * This represents `LView` associated with the component when ViewRef is a ChangeDetectorRef.\n     *\n     * When ViewRef is created for a dynamic component, this also represents the `LView` for the\n     * component.\n     *\n     * For a \"regular\" ViewRef created for an embedded view, this is the `LView` for the embedded\n     * view.\n     *\n     * @internal\n     */\n    _lView, \n    /**\n     * This represents the `LView` associated with the point where `ChangeDetectorRef` was\n     * requested.\n     *\n     * This may be different from `_lView` if the `_cdRefInjectingView` is an embedded view.\n     */\n    _cdRefInjectingView) {\n        this._lView = _lView;\n        this._cdRefInjectingView = _cdRefInjectingView;\n        this._appRef = null;\n        this._attachedToViewContainer = false;\n    }\n    get rootNodes() {\n        const lView = this._lView;\n        const tView = lView[TVIEW];\n        return collectNativeNodes(tView, lView, tView.firstChild, []);\n    }\n    get context() {\n        return this._lView[CONTEXT];\n    }\n    set context(value) {\n        this._lView[CONTEXT] = value;\n    }\n    get destroyed() {\n        return (this._lView[FLAGS] & 128 /* LViewFlags.Destroyed */) === 128 /* LViewFlags.Destroyed */;\n    }\n    destroy() {\n        if (this._appRef) {\n            this._appRef.detachView(this);\n        }\n        else if (this._attachedToViewContainer) {\n            const parent = this._lView[PARENT];\n            if (isLContainer(parent)) {\n                const viewRefs = parent[VIEW_REFS];\n                const index = viewRefs ? viewRefs.indexOf(this) : -1;\n                if (index > -1) {\n                    ngDevMode &&\n                        assertEqual(index, parent.indexOf(this._lView) - CONTAINER_HEADER_OFFSET, 'An attached view should be in the same position within its container as its ViewRef in the VIEW_REFS array.');\n                    detachView(parent, index);\n                    removeFromArray(viewRefs, index);\n                }\n            }\n            this._attachedToViewContainer = false;\n        }\n        destroyLView(this._lView[TVIEW], this._lView);\n    }\n    onDestroy(callback) {\n        storeCleanupWithContext(this._lView[TVIEW], this._lView, null, callback);\n    }\n    /**\n     * Marks a view and all of its ancestors dirty.\n     *\n     * This can be used to ensure an {@link ChangeDetectionStrategy#OnPush OnPush} component is\n     * checked when it needs to be re-rendered but the two normal triggers haven't marked it\n     * dirty (i.e. inputs haven't changed and events haven't fired in the view).\n     *\n     * <!-- TODO: Add a link to a chapter on OnPush components -->\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * ```typescript\n     * @Component({\n     *   selector: 'app-root',\n     *   template: `Number of ticks: {{numberOfTicks}}`\n     *   changeDetection: ChangeDetectionStrategy.OnPush,\n     * })\n     * class AppComponent {\n     *   numberOfTicks = 0;\n     *\n     *   constructor(private ref: ChangeDetectorRef) {\n     *     setInterval(() => {\n     *       this.numberOfTicks++;\n     *       // the following is required, otherwise the view will not be updated\n     *       this.ref.markForCheck();\n     *     }, 1000);\n     *   }\n     * }\n     * ```\n     */\n    markForCheck() {\n        markViewDirty(this._cdRefInjectingView || this._lView);\n    }\n    /**\n     * Detaches the view from the change detection tree.\n     *\n     * Detached views will not be checked during change detection runs until they are\n     * re-attached, even if they are dirty. `detach` can be used in combination with\n     * {@link ChangeDetectorRef#detectChanges detectChanges} to implement local change\n     * detection checks.\n     *\n     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n     * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * The following example defines a component with a large list of readonly data.\n     * Imagine the data changes constantly, many times per second. For performance reasons,\n     * we want to check and update the list every five seconds. We can do that by detaching\n     * the component's change detector and doing a local check every five seconds.\n     *\n     * ```typescript\n     * class DataProvider {\n     *   // in a real application the returned data will be different every time\n     *   get data() {\n     *     return [1,2,3,4,5];\n     *   }\n     * }\n     *\n     * @Component({\n     *   selector: 'giant-list',\n     *   template: `\n     *     <li *ngFor=\"let d of dataProvider.data\">Data {{d}}</li>\n     *   `,\n     * })\n     * class GiantList {\n     *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {\n     *     ref.detach();\n     *     setInterval(() => {\n     *       this.ref.detectChanges();\n     *     }, 5000);\n     *   }\n     * }\n     *\n     * @Component({\n     *   selector: 'app',\n     *   providers: [DataProvider],\n     *   template: `\n     *     <giant-list><giant-list>\n     *   `,\n     * })\n     * class App {\n     * }\n     * ```\n     */\n    detach() {\n        this._lView[FLAGS] &= ~64 /* LViewFlags.Attached */;\n    }\n    /**\n     * Re-attaches a view to the change detection tree.\n     *\n     * This can be used to re-attach views that were previously detached from the tree\n     * using {@link ChangeDetectorRef#detach detach}. Views are attached to the tree by default.\n     *\n     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * The following example creates a component displaying `live` data. The component will detach\n     * its change detector from the main change detector tree when the component's live property\n     * is set to false.\n     *\n     * ```typescript\n     * class DataProvider {\n     *   data = 1;\n     *\n     *   constructor() {\n     *     setInterval(() => {\n     *       this.data = this.data * 2;\n     *     }, 500);\n     *   }\n     * }\n     *\n     * @Component({\n     *   selector: 'live-data',\n     *   inputs: ['live'],\n     *   template: 'Data: {{dataProvider.data}}'\n     * })\n     * class LiveData {\n     *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {}\n     *\n     *   set live(value) {\n     *     if (value) {\n     *       this.ref.reattach();\n     *     } else {\n     *       this.ref.detach();\n     *     }\n     *   }\n     * }\n     *\n     * @Component({\n     *   selector: 'app-root',\n     *   providers: [DataProvider],\n     *   template: `\n     *     Live Update: <input type=\"checkbox\" [(ngModel)]=\"live\">\n     *     <live-data [live]=\"live\"><live-data>\n     *   `,\n     * })\n     * class AppComponent {\n     *   live = true;\n     * }\n     * ```\n     */\n    reattach() {\n        this._lView[FLAGS] |= 64 /* LViewFlags.Attached */;\n    }\n    /**\n     * Checks the view and its children.\n     *\n     * This can also be used in combination with {@link ChangeDetectorRef#detach detach} to implement\n     * local change detection checks.\n     *\n     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n     * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * The following example defines a component with a large list of readonly data.\n     * Imagine, the data changes constantly, many times per second. For performance reasons,\n     * we want to check and update the list every five seconds.\n     *\n     * We can do that by detaching the component's change detector and doing a local change detection\n     * check every five seconds.\n     *\n     * See {@link ChangeDetectorRef#detach detach} for more information.\n     */\n    detectChanges() {\n        detectChangesInternal(this._lView[TVIEW], this._lView, this.context);\n    }\n    /**\n     * Checks the change detector and its children, and throws if any changes are detected.\n     *\n     * This is used in development mode to verify that running change detection doesn't\n     * introduce other changes.\n     */\n    checkNoChanges() {\n        if (ngDevMode) {\n            checkNoChangesInternal(this._lView[TVIEW], this._lView, this.context);\n        }\n    }\n    attachToViewContainerRef() {\n        if (this._appRef) {\n            throw new RuntimeError(902 /* RuntimeErrorCode.VIEW_ALREADY_ATTACHED */, ngDevMode && 'This view is already attached directly to the ApplicationRef!');\n        }\n        this._attachedToViewContainer = true;\n    }\n    detachFromAppRef() {\n        this._appRef = null;\n        renderDetachView(this._lView[TVIEW], this._lView);\n    }\n    attachToAppRef(appRef) {\n        if (this._attachedToViewContainer) {\n            throw new RuntimeError(902 /* RuntimeErrorCode.VIEW_ALREADY_ATTACHED */, ngDevMode && 'This view is already attached to a ViewContainer!');\n        }\n        this._appRef = appRef;\n    }\n}\n/** @internal */\nclass RootViewRef extends ViewRef {\n    constructor(_view) {\n        super(_view);\n        this._view = _view;\n    }\n    detectChanges() {\n        detectChangesInRootView(this._view);\n    }\n    checkNoChanges() {\n        if (ngDevMode) {\n            checkNoChangesInRootView(this._view);\n        }\n    }\n    get context() {\n        return null;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass ComponentFactoryResolver extends ComponentFactoryResolver$1 {\n    /**\n     * @param ngModule The NgModuleRef to which all resolved factories are bound.\n     */\n    constructor(ngModule) {\n        super();\n        this.ngModule = ngModule;\n    }\n    resolveComponentFactory(component) {\n        ngDevMode && assertComponentType(component);\n        const componentDef = getComponentDef$1(component);\n        return new ComponentFactory(componentDef, this.ngModule);\n    }\n}\nfunction toRefArray(map) {\n    const array = [];\n    for (let nonMinified in map) {\n        if (map.hasOwnProperty(nonMinified)) {\n            const minified = map[nonMinified];\n            array.push({ propName: minified, templateName: nonMinified });\n        }\n    }\n    return array;\n}\nfunction getNamespace(elementName) {\n    const name = elementName.toLowerCase();\n    return name === 'svg' ? SVG_NAMESPACE : (name === 'math' ? MATH_ML_NAMESPACE : null);\n}\n/**\n * Injector that looks up a value using a specific injector, before falling back to the module\n * injector. Used primarily when creating components or embedded views dynamically.\n */\nclass ChainedInjector {\n    constructor(injector, parentInjector) {\n        this.injector = injector;\n        this.parentInjector = parentInjector;\n    }\n    get(token, notFoundValue, flags) {\n        const value = this.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, flags);\n        if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR ||\n            notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {\n            // Return the value from the root element injector when\n            // - it provides it\n            //   (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)\n            // - the module injector should not be checked\n            //   (notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)\n            return value;\n        }\n        return this.parentInjector.get(token, notFoundValue, flags);\n    }\n}\n/**\n * Render3 implementation of {@link viewEngine_ComponentFactory}.\n */\nclass ComponentFactory extends ComponentFactory$1 {\n    /**\n     * @param componentDef The component definition.\n     * @param ngModule The NgModuleRef to which the factory is bound.\n     */\n    constructor(componentDef, ngModule) {\n        super();\n        this.componentDef = componentDef;\n        this.ngModule = ngModule;\n        this.componentType = componentDef.type;\n        this.selector = stringifyCSSSelectorList(componentDef.selectors);\n        this.ngContentSelectors =\n            componentDef.ngContentSelectors ? componentDef.ngContentSelectors : [];\n        this.isBoundToModule = !!ngModule;\n    }\n    get inputs() {\n        return toRefArray(this.componentDef.inputs);\n    }\n    get outputs() {\n        return toRefArray(this.componentDef.outputs);\n    }\n    create(injector, projectableNodes, rootSelectorOrNode, environmentInjector) {\n        environmentInjector = environmentInjector || this.ngModule;\n        let realEnvironmentInjector = environmentInjector instanceof EnvironmentInjector ?\n            environmentInjector :\n            environmentInjector === null || environmentInjector === void 0 ? void 0 : environmentInjector.injector;\n        if (realEnvironmentInjector && this.componentDef.getStandaloneInjector !== null) {\n            realEnvironmentInjector = this.componentDef.getStandaloneInjector(realEnvironmentInjector) ||\n                realEnvironmentInjector;\n        }\n        const rootViewInjector = realEnvironmentInjector ? new ChainedInjector(injector, realEnvironmentInjector) : injector;\n        const rendererFactory = rootViewInjector.get(RendererFactory2, domRendererFactory3);\n        const sanitizer = rootViewInjector.get(Sanitizer, null);\n        const hostRenderer = rendererFactory.createRenderer(null, this.componentDef);\n        // Determine a tag name used for creating host elements when this component is created\n        // dynamically. Default to 'div' if this component did not specify any tag name in its selector.\n        const elementName = this.componentDef.selectors[0][0] || 'div';\n        const hostRNode = rootSelectorOrNode ?\n            locateHostElement(hostRenderer, rootSelectorOrNode, this.componentDef.encapsulation) :\n            createElementNode(rendererFactory.createRenderer(null, this.componentDef), elementName, getNamespace(elementName));\n        const rootFlags = this.componentDef.onPush ? 32 /* LViewFlags.Dirty */ | 256 /* LViewFlags.IsRoot */ :\n            16 /* LViewFlags.CheckAlways */ | 256 /* LViewFlags.IsRoot */;\n        const rootContext = createRootContext();\n        // Create the root view. Uses empty TView and ContentTemplate.\n        const rootTView = createTView(0 /* TViewType.Root */, null, null, 1, 0, null, null, null, null, null);\n        const rootLView = createLView(null, rootTView, rootContext, rootFlags, null, null, rendererFactory, hostRenderer, sanitizer, rootViewInjector, null);\n        // rootView is the parent when bootstrapping\n        // TODO(misko): it looks like we are entering view here but we don't really need to as\n        // `renderView` does that. However as the code is written it is needed because\n        // `createRootComponentView` and `createRootComponent` both read global state. Fixing those\n        // issues would allow us to drop this.\n        enterView(rootLView);\n        let component;\n        let tElementNode;\n        try {\n            const componentView = createRootComponentView(hostRNode, this.componentDef, rootLView, rendererFactory, hostRenderer);\n            if (hostRNode) {\n                if (rootSelectorOrNode) {\n                    setUpAttributes(hostRenderer, hostRNode, ['ng-version', VERSION.full]);\n                }\n                else {\n                    // If host element is created as a part of this function call (i.e. `rootSelectorOrNode`\n                    // is not defined), also apply attributes and classes extracted from component selector.\n                    // Extract attributes and classes from the first selector only to match VE behavior.\n                    const { attrs, classes } = extractAttrsAndClassesFromSelector(this.componentDef.selectors[0]);\n                    if (attrs) {\n                        setUpAttributes(hostRenderer, hostRNode, attrs);\n                    }\n                    if (classes && classes.length > 0) {\n                        writeDirectClass(hostRenderer, hostRNode, classes.join(' '));\n                    }\n                }\n            }\n            tElementNode = getTNode(rootTView, HEADER_OFFSET);\n            if (projectableNodes !== undefined) {\n                const projection = tElementNode.projection = [];\n                for (let i = 0; i < this.ngContentSelectors.length; i++) {\n                    const nodesforSlot = projectableNodes[i];\n                    // Projectable nodes can be passed as array of arrays or an array of iterables (ngUpgrade\n                    // case). Here we do normalize passed data structure to be an array of arrays to avoid\n                    // complex checks down the line.\n                    // We also normalize the length of the passed in projectable nodes (to match the number of\n                    // <ng-container> slots defined by a component).\n                    projection.push(nodesforSlot != null ? Array.from(nodesforSlot) : null);\n                }\n            }\n            // TODO: should LifecycleHooksFeature and other host features be generated by the compiler and\n            // executed here?\n            // Angular 5 reference: https://stackblitz.com/edit/lifecycle-hooks-vcref\n            component = createRootComponent(componentView, this.componentDef, rootLView, rootContext, [LifecycleHooksFeature]);\n            renderView(rootTView, rootLView, null);\n        }\n        finally {\n            leaveView();\n        }\n        return new ComponentRef(this.componentType, component, createElementRef(tElementNode, rootLView), rootLView, tElementNode);\n    }\n}\nconst componentFactoryResolver = new ComponentFactoryResolver();\n/**\n * Creates a ComponentFactoryResolver and stores it on the injector. Or, if the\n * ComponentFactoryResolver\n * already exists, retrieves the existing ComponentFactoryResolver.\n *\n * @returns The ComponentFactoryResolver instance to use\n */\nfunction injectComponentFactoryResolver() {\n    return componentFactoryResolver;\n}\n/**\n * Represents an instance of a Component created via a {@link ComponentFactory}.\n *\n * `ComponentRef` provides access to the Component Instance as well other objects related to this\n * Component Instance and allows you to destroy the Component Instance via the {@link #destroy}\n * method.\n *\n */\nclass ComponentRef extends ComponentRef$1 {\n    constructor(componentType, instance, location, _rootLView, _tNode) {\n        super();\n        this.location = location;\n        this._rootLView = _rootLView;\n        this._tNode = _tNode;\n        this.instance = instance;\n        this.hostView = this.changeDetectorRef = new RootViewRef(_rootLView);\n        this.componentType = componentType;\n    }\n    get injector() {\n        return new NodeInjector(this._tNode, this._rootLView);\n    }\n    destroy() {\n        this.hostView.destroy();\n    }\n    onDestroy(callback) {\n        this.hostView.onDestroy(callback);\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Returns a new NgModuleRef instance based on the NgModule class and parent injector provided.\n * @param ngModule NgModule class.\n * @param parentInjector Optional injector instance to use as a parent for the module injector. If\n *     not provided, `NullInjector` will be used instead.\n * @publicApi\n */\nfunction createNgModuleRef(ngModule, parentInjector) {\n    return new NgModuleRef(ngModule, parentInjector !== null && parentInjector !== void 0 ? parentInjector : null);\n}\nclass NgModuleRef extends NgModuleRef$1 {\n    constructor(ngModuleType, _parent) {\n        super();\n        this._parent = _parent;\n        // tslint:disable-next-line:require-internal-with-underscore\n        this._bootstrapComponents = [];\n        this.injector = this;\n        this.destroyCbs = [];\n        // When bootstrapping a module we have a dependency graph that looks like this:\n        // ApplicationRef -> ComponentFactoryResolver -> NgModuleRef. The problem is that if the\n        // module being resolved tries to inject the ComponentFactoryResolver, it'll create a\n        // circular dependency which will result in a runtime error, because the injector doesn't\n        // exist yet. We work around the issue by creating the ComponentFactoryResolver ourselves\n        // and providing it, rather than letting the injector resolve it.\n        this.componentFactoryResolver = new ComponentFactoryResolver(this);\n        const ngModuleDef = getNgModuleDef(ngModuleType);\n        ngDevMode &&\n            assertDefined(ngModuleDef, `NgModule '${stringify(ngModuleType)}' is not a subtype of 'NgModuleType'.`);\n        this._bootstrapComponents = maybeUnwrapFn$1(ngModuleDef.bootstrap);\n        this._r3Injector = createInjectorWithoutInjectorInstances(ngModuleType, _parent, [\n            { provide: NgModuleRef$1, useValue: this }, {\n                provide: ComponentFactoryResolver$1,\n                useValue: this.componentFactoryResolver\n            }\n        ], stringify(ngModuleType), new Set(['environment']));\n        // We need to resolve the injector types separately from the injector creation, because\n        // the module might be trying to use this ref in its constructor for DI which will cause a\n        // circular error that will eventually error out, because the injector isn't created yet.\n        this._r3Injector.resolveInjectorInitializers();\n        this.instance = this.get(ngModuleType);\n    }\n    get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, injectFlags = InjectFlags.Default) {\n        if (token === Injector || token === NgModuleRef$1 || token === INJECTOR) {\n            return this;\n        }\n        return this._r3Injector.get(token, notFoundValue, injectFlags);\n    }\n    destroy() {\n        ngDevMode && assertDefined(this.destroyCbs, 'NgModule already destroyed');\n        const injector = this._r3Injector;\n        !injector.destroyed && injector.destroy();\n        this.destroyCbs.forEach(fn => fn());\n        this.destroyCbs = null;\n    }\n    onDestroy(callback) {\n        ngDevMode && assertDefined(this.destroyCbs, 'NgModule already destroyed');\n        this.destroyCbs.push(callback);\n    }\n}\nclass NgModuleFactory extends NgModuleFactory$1 {\n    constructor(moduleType) {\n        super();\n        this.moduleType = moduleType;\n    }\n    create(parentInjector) {\n        return new NgModuleRef(this.moduleType, parentInjector);\n    }\n}\nclass EnvironmentNgModuleRefAdapter extends NgModuleRef$1 {\n    constructor(providers, parent, source) {\n        super();\n        this.componentFactoryResolver = new ComponentFactoryResolver(this);\n        this.instance = null;\n        const injector = new R3Injector([\n            ...providers,\n            { provide: NgModuleRef$1, useValue: this },\n            { provide: ComponentFactoryResolver$1, useValue: this.componentFactoryResolver },\n        ], parent || getNullInjector(), source, new Set(['environment']));\n        this.injector = injector;\n        injector.resolveInjectorInitializers();\n    }\n    destroy() {\n        this.injector.destroy();\n    }\n    onDestroy(callback) {\n        this.injector.onDestroy(callback);\n    }\n}\n/**\n * Create a new environment injector.\n *\n * @publicApi\n * @developerPreview\n */\nfunction createEnvironmentInjector(providers, parent = null, debugName = null) {\n    const adapter = new EnvironmentNgModuleRefAdapter(providers, parent, debugName);\n    return adapter.injector;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A service used by the framework to create instances of standalone injectors. Those injectors are\n * created on demand in case of dynamic component instantiation and contain ambient providers\n * collected from the imports graph rooted at a given standalone component.\n */\nclass StandaloneService {\n    constructor(_injector) {\n        this._injector = _injector;\n        this.cachedInjectors = new Map();\n    }\n    getOrCreateStandaloneInjector(componentDef) {\n        if (!componentDef.standalone) {\n            return null;\n        }\n        if (!this.cachedInjectors.has(componentDef.id)) {\n            const providers = internalImportProvidersFrom(false, componentDef.type);\n            const standaloneInjector = providers.length > 0 ?\n                createEnvironmentInjector([providers], this._injector, `Standalone[${componentDef.type.name}]`) :\n                null;\n            this.cachedInjectors.set(componentDef.id, standaloneInjector);\n        }\n        return this.cachedInjectors.get(componentDef.id);\n    }\n    ngOnDestroy() {\n        try {\n            for (const injector of this.cachedInjectors.values()) {\n                if (injector !== null) {\n                    injector.destroy();\n                }\n            }\n        }\n        finally {\n            this.cachedInjectors.clear();\n        }\n    }\n}\n/** @nocollapse */\nStandaloneService.ɵprov = ɵɵdefineInjectable({\n    token: StandaloneService,\n    providedIn: 'environment',\n    factory: () => new StandaloneService(ɵɵinject(EnvironmentInjector)),\n});\n/**\n * A feature that acts as a setup code for the {@link StandaloneService}.\n *\n * The most important responsaibility of this feature is to expose the \"getStandaloneInjector\"\n * function (an entry points to a standalone injector creation) on a component definition object. We\n * go through the features infrastructure to make sure that the standalone injector creation logic\n * is tree-shakable and not included in applications that don't use standalone components.\n *\n * @codeGenApi\n */\nfunction ɵɵStandaloneFeature(definition) {\n    definition.getStandaloneInjector = (parentInjector) => {\n        return parentInjector.get(StandaloneService).getOrCreateStandaloneInjector(definition);\n    };\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Adds decorator, constructor, and property metadata to a given type via static metadata fields\n * on the type.\n *\n * These metadata fields can later be read with Angular's `ReflectionCapabilities` API.\n *\n * Calls to `setClassMetadata` can be guarded by ngDevMode, resulting in the metadata assignments\n * being tree-shaken away during production builds.\n */\nfunction setClassMetadata(type, decorators, ctorParameters, propDecorators) {\n    return noSideEffects(() => {\n        const clazz = type;\n        if (decorators !== null) {\n            if (clazz.hasOwnProperty('decorators') && clazz.decorators !== undefined) {\n                clazz.decorators.push(...decorators);\n            }\n            else {\n                clazz.decorators = decorators;\n            }\n        }\n        if (ctorParameters !== null) {\n            // Rather than merging, clobber the existing parameters. If other projects exist which\n            // use tsickle-style annotations and reflect over them in the same way, this could\n            // cause issues, but that is vanishingly unlikely.\n            clazz.ctorParameters = ctorParameters;\n        }\n        if (propDecorators !== null) {\n            // The property decorator objects are merged as it is possible different fields have\n            // different decorator types. Decorators on individual fields are not merged, as it's\n            // also incredibly unlikely that a field will be decorated both with an Angular\n            // decorator and a non-Angular decorator that's also been downleveled.\n            if (clazz.hasOwnProperty('propDecorators') && clazz.propDecorators !== undefined) {\n                clazz.propDecorators = Object.assign(Object.assign({}, clazz.propDecorators), propDecorators);\n            }\n            else {\n                clazz.propDecorators = propDecorators;\n            }\n        }\n    });\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Bindings for pure functions are stored after regular bindings.\n *\n * |-------decls------|---------vars---------|                 |----- hostVars (dir1) ------|\n * ------------------------------------------------------------------------------------------\n * | nodes/refs/pipes | bindings | fn slots  | injector | dir1 | host bindings | host slots |\n * ------------------------------------------------------------------------------------------\n *                    ^                      ^\n *      TView.bindingStartIndex      TView.expandoStartIndex\n *\n * Pure function instructions are given an offset from the binding root. Adding the offset to the\n * binding root gives the first index where the bindings are stored. In component views, the binding\n * root is the bindingStartIndex. In host bindings, the binding root is the expandoStartIndex +\n * any directive instances + any hostVars in directives evaluated before it.\n *\n * See VIEW_DATA.md for more information about host binding resolution.\n */\n/**\n * If the value hasn't been saved, calls the pure function to store and return the\n * value. If it has been saved, returns the saved value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn Function that returns a value\n * @param thisArg Optional calling context of pureFn\n * @returns value\n *\n * @codeGenApi\n */\nfunction ɵɵpureFunction0(slotOffset, pureFn, thisArg) {\n    const bindingIndex = getBindingRoot() + slotOffset;\n    const lView = getLView();\n    return lView[bindingIndex] === NO_CHANGE ?\n        updateBinding(lView, bindingIndex, thisArg ? pureFn.call(thisArg) : pureFn()) :\n        getBinding(lView, bindingIndex);\n}\n/**\n * If the value of the provided exp has changed, calls the pure function to return\n * an updated value. Or if the value has not changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn Function that returns an updated value\n * @param exp Updated expression value\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction ɵɵpureFunction1(slotOffset, pureFn, exp, thisArg) {\n    return pureFunction1Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp, thisArg);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction ɵɵpureFunction2(slotOffset, pureFn, exp1, exp2, thisArg) {\n    return pureFunction2Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, thisArg);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction ɵɵpureFunction3(slotOffset, pureFn, exp1, exp2, exp3, thisArg) {\n    return pureFunction3Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, thisArg);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction ɵɵpureFunction4(slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {\n    return pureFunction4Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction ɵɵpureFunction5(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, thisArg) {\n    const bindingIndex = getBindingRoot() + slotOffset;\n    const lView = getLView();\n    const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n    return bindingUpdated(lView, bindingIndex + 4, exp5) || different ?\n        updateBinding(lView, bindingIndex + 5, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5) :\n            pureFn(exp1, exp2, exp3, exp4, exp5)) :\n        getBinding(lView, bindingIndex + 5);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param exp6\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction ɵɵpureFunction6(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, thisArg) {\n    const bindingIndex = getBindingRoot() + slotOffset;\n    const lView = getLView();\n    const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n    return bindingUpdated2(lView, bindingIndex + 4, exp5, exp6) || different ?\n        updateBinding(lView, bindingIndex + 6, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6) :\n            pureFn(exp1, exp2, exp3, exp4, exp5, exp6)) :\n        getBinding(lView, bindingIndex + 6);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param exp6\n * @param exp7\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction ɵɵpureFunction7(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, thisArg) {\n    const bindingIndex = getBindingRoot() + slotOffset;\n    const lView = getLView();\n    let different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n    return bindingUpdated3(lView, bindingIndex + 4, exp5, exp6, exp7) || different ?\n        updateBinding(lView, bindingIndex + 7, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7) :\n            pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7)) :\n        getBinding(lView, bindingIndex + 7);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param exp6\n * @param exp7\n * @param exp8\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction ɵɵpureFunction8(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8, thisArg) {\n    const bindingIndex = getBindingRoot() + slotOffset;\n    const lView = getLView();\n    const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n    return bindingUpdated4(lView, bindingIndex + 4, exp5, exp6, exp7, exp8) || different ?\n        updateBinding(lView, bindingIndex + 8, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8) :\n            pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8)) :\n        getBinding(lView, bindingIndex + 8);\n}\n/**\n * pureFunction instruction that can support any number of bindings.\n *\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn A pure function that takes binding values and builds an object or array\n * containing those values.\n * @param exps An array of binding values\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction ɵɵpureFunctionV(slotOffset, pureFn, exps, thisArg) {\n    return pureFunctionVInternal(getLView(), getBindingRoot(), slotOffset, pureFn, exps, thisArg);\n}\n/**\n * Results of a pure function invocation are stored in LView in a dedicated slot that is initialized\n * to NO_CHANGE. In rare situations a pure pipe might throw an exception on the very first\n * invocation and not produce any valid results. In this case LView would keep holding the NO_CHANGE\n * value. The NO_CHANGE is not something that we can use in expressions / bindings thus we convert\n * it to `undefined`.\n */\nfunction getPureFunctionReturnValue(lView, returnValueIndex) {\n    ngDevMode && assertIndexInRange(lView, returnValueIndex);\n    const lastReturnValue = lView[returnValueIndex];\n    return lastReturnValue === NO_CHANGE ? undefined : lastReturnValue;\n}\n/**\n * If the value of the provided exp has changed, calls the pure function to return\n * an updated value. Or if the value has not changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn Function that returns an updated value\n * @param exp Updated expression value\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nfunction pureFunction1Internal(lView, bindingRoot, slotOffset, pureFn, exp, thisArg) {\n    const bindingIndex = bindingRoot + slotOffset;\n    return bindingUpdated(lView, bindingIndex, exp) ?\n        updateBinding(lView, bindingIndex + 1, thisArg ? pureFn.call(thisArg, exp) : pureFn(exp)) :\n        getPureFunctionReturnValue(lView, bindingIndex + 1);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nfunction pureFunction2Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, thisArg) {\n    const bindingIndex = bindingRoot + slotOffset;\n    return bindingUpdated2(lView, bindingIndex, exp1, exp2) ?\n        updateBinding(lView, bindingIndex + 2, thisArg ? pureFn.call(thisArg, exp1, exp2) : pureFn(exp1, exp2)) :\n        getPureFunctionReturnValue(lView, bindingIndex + 2);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nfunction pureFunction3Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, thisArg) {\n    const bindingIndex = bindingRoot + slotOffset;\n    return bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) ?\n        updateBinding(lView, bindingIndex + 3, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3) : pureFn(exp1, exp2, exp3)) :\n        getPureFunctionReturnValue(lView, bindingIndex + 3);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n */\nfunction pureFunction4Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {\n    const bindingIndex = bindingRoot + slotOffset;\n    return bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) ?\n        updateBinding(lView, bindingIndex + 4, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4) : pureFn(exp1, exp2, exp3, exp4)) :\n        getPureFunctionReturnValue(lView, bindingIndex + 4);\n}\n/**\n * pureFunction instruction that can support any number of bindings.\n *\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn A pure function that takes binding values and builds an object or array\n * containing those values.\n * @param exps An array of binding values\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nfunction pureFunctionVInternal(lView, bindingRoot, slotOffset, pureFn, exps, thisArg) {\n    let bindingIndex = bindingRoot + slotOffset;\n    let different = false;\n    for (let i = 0; i < exps.length; i++) {\n        bindingUpdated(lView, bindingIndex++, exps[i]) && (different = true);\n    }\n    return different ? updateBinding(lView, bindingIndex, pureFn.apply(thisArg, exps)) :\n        getPureFunctionReturnValue(lView, bindingIndex);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Create a pipe.\n *\n * @param index Pipe index where the pipe will be stored.\n * @param pipeName The name of the pipe\n * @returns T the instance of the pipe.\n *\n * @codeGenApi\n */\nfunction ɵɵpipe(index, pipeName) {\n    const tView = getTView();\n    let pipeDef;\n    const adjustedIndex = index + HEADER_OFFSET;\n    if (tView.firstCreatePass) {\n        // The `getPipeDef` throws if a pipe with a given name is not found\n        // (so we use non-null assertion below).\n        pipeDef = getPipeDef(pipeName, tView.pipeRegistry);\n        tView.data[adjustedIndex] = pipeDef;\n        if (pipeDef.onDestroy) {\n            (tView.destroyHooks || (tView.destroyHooks = [])).push(adjustedIndex, pipeDef.onDestroy);\n        }\n    }\n    else {\n        pipeDef = tView.data[adjustedIndex];\n    }\n    const pipeFactory = pipeDef.factory || (pipeDef.factory = getFactoryDef(pipeDef.type, true));\n    const previousInjectImplementation = setInjectImplementation(ɵɵdirectiveInject);\n    try {\n        // DI for pipes is supposed to behave like directives when placed on a component\n        // host node, which means that we have to disable access to `viewProviders`.\n        const previousIncludeViewProviders = setIncludeViewProviders(false);\n        const pipeInstance = pipeFactory();\n        setIncludeViewProviders(previousIncludeViewProviders);\n        store(tView, getLView(), adjustedIndex, pipeInstance);\n        return pipeInstance;\n    }\n    finally {\n        // we have to restore the injector implementation in finally, just in case the creation of the\n        // pipe throws an error.\n        setInjectImplementation(previousInjectImplementation);\n    }\n}\n/**\n * Searches the pipe registry for a pipe with the given name. If one is found,\n * returns the pipe. Otherwise, an error is thrown because the pipe cannot be resolved.\n *\n * @param name Name of pipe to resolve\n * @param registry Full list of available pipes\n * @returns Matching PipeDef\n */\nfunction getPipeDef(name, registry) {\n    if (registry) {\n        for (let i = registry.length - 1; i >= 0; i--) {\n            const pipeDef = registry[i];\n            if (name === pipeDef.name) {\n                return pipeDef;\n            }\n        }\n    }\n    if (ngDevMode) {\n        throw new RuntimeError(-302 /* RuntimeErrorCode.PIPE_NOT_FOUND */, getPipeNotFoundErrorMessage(name));\n    }\n}\n/**\n * Generates a helpful error message for the user when a pipe is not found.\n *\n * @param name Name of the missing pipe\n * @returns The error message\n */\nfunction getPipeNotFoundErrorMessage(name) {\n    const lView = getLView();\n    const declarationLView = lView[DECLARATION_COMPONENT_VIEW];\n    const context = declarationLView[CONTEXT];\n    const hostIsStandalone = isHostComponentStandalone(lView);\n    const componentInfoMessage = context ? ` in the '${context.constructor.name}' component` : '';\n    const verifyMessage = `Verify that it is ${hostIsStandalone ? 'included in the \\'@Component.imports\\' of this component' :\n        'declared or imported in this module'}`;\n    const errorMessage = `The pipe '${name}' could not be found${componentInfoMessage}. ${verifyMessage}`;\n    return errorMessage;\n}\n/**\n * Invokes a pipe with 1 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n *\n * @codeGenApi\n */\nfunction ɵɵpipeBind1(index, slotOffset, v1) {\n    const adjustedIndex = index + HEADER_OFFSET;\n    const lView = getLView();\n    const pipeInstance = load(lView, adjustedIndex);\n    return isPure(lView, adjustedIndex) ?\n        pureFunction1Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, pipeInstance) :\n        pipeInstance.transform(v1);\n}\n/**\n * Invokes a pipe with 2 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n *\n * @codeGenApi\n */\nfunction ɵɵpipeBind2(index, slotOffset, v1, v2) {\n    const adjustedIndex = index + HEADER_OFFSET;\n    const lView = getLView();\n    const pipeInstance = load(lView, adjustedIndex);\n    return isPure(lView, adjustedIndex) ?\n        pureFunction2Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, pipeInstance) :\n        pipeInstance.transform(v1, v2);\n}\n/**\n * Invokes a pipe with 3 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n * @param v3 4rd argument to {@link PipeTransform#transform}.\n *\n * @codeGenApi\n */\nfunction ɵɵpipeBind3(index, slotOffset, v1, v2, v3) {\n    const adjustedIndex = index + HEADER_OFFSET;\n    const lView = getLView();\n    const pipeInstance = load(lView, adjustedIndex);\n    return isPure(lView, adjustedIndex) ?\n        pureFunction3Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, pipeInstance) :\n        pipeInstance.transform(v1, v2, v3);\n}\n/**\n * Invokes a pipe with 4 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n * @param v3 3rd argument to {@link PipeTransform#transform}.\n * @param v4 4th argument to {@link PipeTransform#transform}.\n *\n * @codeGenApi\n */\nfunction ɵɵpipeBind4(index, slotOffset, v1, v2, v3, v4) {\n    const adjustedIndex = index + HEADER_OFFSET;\n    const lView = getLView();\n    const pipeInstance = load(lView, adjustedIndex);\n    return isPure(lView, adjustedIndex) ? pureFunction4Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, v4, pipeInstance) :\n        pipeInstance.transform(v1, v2, v3, v4);\n}\n/**\n * Invokes a pipe with variable number of arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param values Array of arguments to pass to {@link PipeTransform#transform} method.\n *\n * @codeGenApi\n */\nfunction ɵɵpipeBindV(index, slotOffset, values) {\n    const adjustedIndex = index + HEADER_OFFSET;\n    const lView = getLView();\n    const pipeInstance = load(lView, adjustedIndex);\n    return isPure(lView, adjustedIndex) ?\n        pureFunctionVInternal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, values, pipeInstance) :\n        pipeInstance.transform.apply(pipeInstance, values);\n}\nfunction isPure(lView, index) {\n    return lView[TVIEW].data[index].pure;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass EventEmitter_ extends Subject {\n    constructor(isAsync = false) {\n        super();\n        this.__isAsync = isAsync;\n    }\n    emit(value) {\n        super.next(value);\n    }\n    subscribe(observerOrNext, error, complete) {\n        var _a, _b, _c;\n        let nextFn = observerOrNext;\n        let errorFn = error || (() => null);\n        let completeFn = complete;\n        if (observerOrNext && typeof observerOrNext === 'object') {\n            const observer = observerOrNext;\n            nextFn = (_a = observer.next) === null || _a === void 0 ? void 0 : _a.bind(observer);\n            errorFn = (_b = observer.error) === null || _b === void 0 ? void 0 : _b.bind(observer);\n            completeFn = (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.bind(observer);\n        }\n        if (this.__isAsync) {\n            errorFn = _wrapInTimeout(errorFn);\n            if (nextFn) {\n                nextFn = _wrapInTimeout(nextFn);\n            }\n            if (completeFn) {\n                completeFn = _wrapInTimeout(completeFn);\n            }\n        }\n        const sink = super.subscribe({ next: nextFn, error: errorFn, complete: completeFn });\n        if (observerOrNext instanceof Subscription) {\n            observerOrNext.add(sink);\n        }\n        return sink;\n    }\n}\nfunction _wrapInTimeout(fn) {\n    return (value) => {\n        setTimeout(fn, undefined, value);\n    };\n}\n/**\n * @publicApi\n */\nconst EventEmitter = EventEmitter_;\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction symbolIterator() {\n    return this._results[getSymbolIterator()]();\n}\n/**\n * An unmodifiable list of items that Angular keeps up to date when the state\n * of the application changes.\n *\n * The type of object that {@link ViewChildren}, {@link ContentChildren}, and {@link QueryList}\n * provide.\n *\n * Implements an iterable interface, therefore it can be used in both ES6\n * javascript `for (var i of items)` loops as well as in Angular templates with\n * `*ngFor=\"let i of myList\"`.\n *\n * Changes can be observed by subscribing to the changes `Observable`.\n *\n * NOTE: In the future this class will implement an `Observable` interface.\n *\n * @usageNotes\n * ### Example\n * ```typescript\n * @Component({...})\n * class Container {\n *   @ViewChildren(Item) items:QueryList<Item>;\n * }\n * ```\n *\n * @publicApi\n */\nclass QueryList {\n    /**\n     * @param emitDistinctChangesOnly Whether `QueryList.changes` should fire only when actual change\n     *     has occurred. Or if it should fire when query is recomputed. (recomputing could resolve in\n     *     the same result)\n     */\n    constructor(_emitDistinctChangesOnly = false) {\n        this._emitDistinctChangesOnly = _emitDistinctChangesOnly;\n        this.dirty = true;\n        this._results = [];\n        this._changesDetected = false;\n        this._changes = null;\n        this.length = 0;\n        this.first = undefined;\n        this.last = undefined;\n        // This function should be declared on the prototype, but doing so there will cause the class\n        // declaration to have side-effects and become not tree-shakable. For this reason we do it in\n        // the constructor.\n        // [getSymbolIterator()](): Iterator<T> { ... }\n        const symbol = getSymbolIterator();\n        const proto = QueryList.prototype;\n        if (!proto[symbol])\n            proto[symbol] = symbolIterator;\n    }\n    /**\n     * Returns `Observable` of `QueryList` notifying the subscriber of changes.\n     */\n    get changes() {\n        return this._changes || (this._changes = new EventEmitter());\n    }\n    /**\n     * Returns the QueryList entry at `index`.\n     */\n    get(index) {\n        return this._results[index];\n    }\n    /**\n     * See\n     * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\n     */\n    map(fn) {\n        return this._results.map(fn);\n    }\n    /**\n     * See\n     * [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)\n     */\n    filter(fn) {\n        return this._results.filter(fn);\n    }\n    /**\n     * See\n     * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)\n     */\n    find(fn) {\n        return this._results.find(fn);\n    }\n    /**\n     * See\n     * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)\n     */\n    reduce(fn, init) {\n        return this._results.reduce(fn, init);\n    }\n    /**\n     * See\n     * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)\n     */\n    forEach(fn) {\n        this._results.forEach(fn);\n    }\n    /**\n     * See\n     * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)\n     */\n    some(fn) {\n        return this._results.some(fn);\n    }\n    /**\n     * Returns a copy of the internal results list as an Array.\n     */\n    toArray() {\n        return this._results.slice();\n    }\n    toString() {\n        return this._results.toString();\n    }\n    /**\n     * Updates the stored data of the query list, and resets the `dirty` flag to `false`, so that\n     * on change detection, it will not notify of changes to the queries, unless a new change\n     * occurs.\n     *\n     * @param resultsTree The query results to store\n     * @param identityAccessor Optional function for extracting stable object identity from a value\n     *    in the array. This function is executed for each element of the query result list while\n     *    comparing current query list with the new one (provided as a first argument of the `reset`\n     *    function) to detect if the lists are different. If the function is not provided, elements\n     *    are compared as is (without any pre-processing).\n     */\n    reset(resultsTree, identityAccessor) {\n        // Cast to `QueryListInternal` so that we can mutate fields which are readonly for the usage of\n        // QueryList (but not for QueryList itself.)\n        const self = this;\n        self.dirty = false;\n        const newResultFlat = flatten$1(resultsTree);\n        if (this._changesDetected = !arrayEquals(self._results, newResultFlat, identityAccessor)) {\n            self._results = newResultFlat;\n            self.length = newResultFlat.length;\n            self.last = newResultFlat[this.length - 1];\n            self.first = newResultFlat[0];\n        }\n    }\n    /**\n     * Triggers a change event by emitting on the `changes` {@link EventEmitter}.\n     */\n    notifyOnChanges() {\n        if (this._changes && (this._changesDetected || !this._emitDistinctChangesOnly))\n            this._changes.emit(this);\n    }\n    /** internal */\n    setDirty() {\n        this.dirty = true;\n    }\n    /** internal */\n    destroy() {\n        this.changes.complete();\n        this.changes.unsubscribe();\n    }\n}\nSymbol.iterator;\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Represents an embedded template that can be used to instantiate embedded views.\n * To instantiate embedded views based on a template, use the `ViewContainerRef`\n * method `createEmbeddedView()`.\n *\n * Access a `TemplateRef` instance by placing a directive on an `<ng-template>`\n * element (or directive prefixed with `*`). The `TemplateRef` for the embedded view\n * is injected into the constructor of the directive,\n * using the `TemplateRef` token.\n *\n * You can also use a `Query` to find a `TemplateRef` associated with\n * a component or a directive.\n *\n * @see `ViewContainerRef`\n * @see [Navigate the Component Tree with DI](guide/dependency-injection-navtree)\n *\n * @publicApi\n */\nclass TemplateRef {\n}\n/**\n * @internal\n * @nocollapse\n */\nTemplateRef.__NG_ELEMENT_ID__ = injectTemplateRef;\nconst ViewEngineTemplateRef = TemplateRef;\n// TODO(alxhub): combine interface and implementation. Currently this is challenging since something\n// in g3 depends on them being separate.\nconst R3TemplateRef = class TemplateRef extends ViewEngineTemplateRef {\n    constructor(_declarationLView, _declarationTContainer, elementRef) {\n        super();\n        this._declarationLView = _declarationLView;\n        this._declarationTContainer = _declarationTContainer;\n        this.elementRef = elementRef;\n    }\n    createEmbeddedView(context, injector) {\n        const embeddedTView = this._declarationTContainer.tViews;\n        const embeddedLView = createLView(this._declarationLView, embeddedTView, context, 16 /* LViewFlags.CheckAlways */, null, embeddedTView.declTNode, null, null, null, null, injector || null);\n        const declarationLContainer = this._declarationLView[this._declarationTContainer.index];\n        ngDevMode && assertLContainer(declarationLContainer);\n        embeddedLView[DECLARATION_LCONTAINER] = declarationLContainer;\n        const declarationViewLQueries = this._declarationLView[QUERIES];\n        if (declarationViewLQueries !== null) {\n            embeddedLView[QUERIES] = declarationViewLQueries.createEmbeddedView(embeddedTView);\n        }\n        renderView(embeddedTView, embeddedLView, context);\n        return new ViewRef(embeddedLView);\n    }\n};\n/**\n * Creates a TemplateRef given a node.\n *\n * @returns The TemplateRef instance to use\n */\nfunction injectTemplateRef() {\n    return createTemplateRef(getCurrentTNode(), getLView());\n}\n/**\n * Creates a TemplateRef and stores it on the injector.\n *\n * @param hostTNode The node on which a TemplateRef is requested\n * @param hostLView The `LView` to which the node belongs\n * @returns The TemplateRef instance or null if we can't create a TemplateRef on a given node type\n */\nfunction createTemplateRef(hostTNode, hostLView) {\n    if (hostTNode.type & 4 /* TNodeType.Container */) {\n        ngDevMode && assertDefined(hostTNode.tViews, 'TView must be allocated');\n        return new R3TemplateRef(hostLView, hostTNode, createElementRef(hostTNode, hostLView));\n    }\n    return null;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Represents a container where one or more views can be attached to a component.\n *\n * Can contain *host views* (created by instantiating a\n * component with the `createComponent()` method), and *embedded views*\n * (created by instantiating a `TemplateRef` with the `createEmbeddedView()` method).\n *\n * A view container instance can contain other view containers,\n * creating a [view hierarchy](guide/glossary#view-tree).\n *\n * @see `ComponentRef`\n * @see `EmbeddedViewRef`\n *\n * @publicApi\n */\nclass ViewContainerRef {\n}\n/**\n * @internal\n * @nocollapse\n */\nViewContainerRef.__NG_ELEMENT_ID__ = injectViewContainerRef;\n/**\n * Creates a ViewContainerRef and stores it on the injector. Or, if the ViewContainerRef\n * already exists, retrieves the existing ViewContainerRef.\n *\n * @returns The ViewContainerRef instance to use\n */\nfunction injectViewContainerRef() {\n    const previousTNode = getCurrentTNode();\n    return createContainerRef(previousTNode, getLView());\n}\nconst VE_ViewContainerRef = ViewContainerRef;\n// TODO(alxhub): cleaning up this indirection triggers a subtle bug in Closure in g3. Once the fix\n// for that lands, this can be cleaned up.\nconst R3ViewContainerRef = class ViewContainerRef extends VE_ViewContainerRef {\n    constructor(_lContainer, _hostTNode, _hostLView) {\n        super();\n        this._lContainer = _lContainer;\n        this._hostTNode = _hostTNode;\n        this._hostLView = _hostLView;\n    }\n    get element() {\n        return createElementRef(this._hostTNode, this._hostLView);\n    }\n    get injector() {\n        return new NodeInjector(this._hostTNode, this._hostLView);\n    }\n    /** @deprecated No replacement */\n    get parentInjector() {\n        const parentLocation = getParentInjectorLocation(this._hostTNode, this._hostLView);\n        if (hasParentInjector(parentLocation)) {\n            const parentView = getParentInjectorView(parentLocation, this._hostLView);\n            const injectorIndex = getParentInjectorIndex(parentLocation);\n            ngDevMode && assertNodeInjector(parentView, injectorIndex);\n            const parentTNode = parentView[TVIEW].data[injectorIndex + 8 /* NodeInjectorOffset.TNODE */];\n            return new NodeInjector(parentTNode, parentView);\n        }\n        else {\n            return new NodeInjector(null, this._hostLView);\n        }\n    }\n    clear() {\n        while (this.length > 0) {\n            this.remove(this.length - 1);\n        }\n    }\n    get(index) {\n        const viewRefs = getViewRefs(this._lContainer);\n        return viewRefs !== null && viewRefs[index] || null;\n    }\n    get length() {\n        return this._lContainer.length - CONTAINER_HEADER_OFFSET;\n    }\n    createEmbeddedView(templateRef, context, indexOrOptions) {\n        let index;\n        let injector;\n        if (typeof indexOrOptions === 'number') {\n            index = indexOrOptions;\n        }\n        else if (indexOrOptions != null) {\n            index = indexOrOptions.index;\n            injector = indexOrOptions.injector;\n        }\n        const viewRef = templateRef.createEmbeddedView(context || {}, injector);\n        this.insert(viewRef, index);\n        return viewRef;\n    }\n    createComponent(componentFactoryOrType, indexOrOptions, injector, projectableNodes, environmentInjector) {\n        const isComponentFactory = componentFactoryOrType && !isType(componentFactoryOrType);\n        let index;\n        // This function supports 2 signatures and we need to handle options correctly for both:\n        //   1. When first argument is a Component type. This signature also requires extra\n        //      options to be provided as as object (more ergonomic option).\n        //   2. First argument is a Component factory. In this case extra options are represented as\n        //      positional arguments. This signature is less ergonomic and will be deprecated.\n        if (isComponentFactory) {\n            if (ngDevMode) {\n                assertEqual(typeof indexOrOptions !== 'object', true, 'It looks like Component factory was provided as the first argument ' +\n                    'and an options object as the second argument. This combination of arguments ' +\n                    'is incompatible. You can either change the first argument to provide Component ' +\n                    'type or change the second argument to be a number (representing an index at ' +\n                    'which to insert the new component\\'s host view into this container)');\n            }\n            index = indexOrOptions;\n        }\n        else {\n            if (ngDevMode) {\n                assertDefined(getComponentDef$1(componentFactoryOrType), `Provided Component class doesn't contain Component definition. ` +\n                    `Please check whether provided class has @Component decorator.`);\n                assertEqual(typeof indexOrOptions !== 'number', true, 'It looks like Component type was provided as the first argument ' +\n                    'and a number (representing an index at which to insert the new component\\'s ' +\n                    'host view into this container as the second argument. This combination of arguments ' +\n                    'is incompatible. Please use an object as the second argument instead.');\n            }\n            const options = (indexOrOptions || {});\n            if (ngDevMode && options.environmentInjector && options.ngModuleRef) {\n                throwError(`Cannot pass both environmentInjector and ngModuleRef options to createComponent().`);\n            }\n            index = options.index;\n            injector = options.injector;\n            projectableNodes = options.projectableNodes;\n            environmentInjector = options.environmentInjector || options.ngModuleRef;\n        }\n        const componentFactory = isComponentFactory ?\n            componentFactoryOrType :\n            new ComponentFactory(getComponentDef$1(componentFactoryOrType));\n        const contextInjector = injector || this.parentInjector;\n        // If an `NgModuleRef` is not provided explicitly, try retrieving it from the DI tree.\n        if (!environmentInjector && componentFactory.ngModule == null) {\n            // For the `ComponentFactory` case, entering this logic is very unlikely, since we expect that\n            // an instance of a `ComponentFactory`, resolved via `ComponentFactoryResolver` would have an\n            // `ngModule` field. This is possible in some test scenarios and potentially in some JIT-based\n            // use-cases. For the `ComponentFactory` case we preserve backwards-compatibility and try\n            // using a provided injector first, then fall back to the parent injector of this\n            // `ViewContainerRef` instance.\n            //\n            // For the factory-less case, it's critical to establish a connection with the module\n            // injector tree (by retrieving an instance of an `NgModuleRef` and accessing its injector),\n            // so that a component can use DI tokens provided in MgModules. For this reason, we can not\n            // rely on the provided injector, since it might be detached from the DI tree (for example, if\n            // it was created via `Injector.create` without specifying a parent injector, or if an\n            // injector is retrieved from an `NgModuleRef` created via `createNgModuleRef` using an\n            // NgModule outside of a module tree). Instead, we always use `ViewContainerRef`'s parent\n            // injector, which is normally connected to the DI tree, which includes module injector\n            // subtree.\n            const _injector = isComponentFactory ? contextInjector : this.parentInjector;\n            // DO NOT REFACTOR. The code here used to have a `injector.get(NgModuleRef, null) ||\n            // undefined` expression which seems to cause internal google apps to fail. This is documented\n            // in the following internal bug issue: go/b/142967802\n            const result = _injector.get(EnvironmentInjector, null);\n            if (result) {\n                environmentInjector = result;\n            }\n        }\n        const componentRef = componentFactory.create(contextInjector, projectableNodes, undefined, environmentInjector);\n        this.insert(componentRef.hostView, index);\n        return componentRef;\n    }\n    insert(viewRef, index) {\n        const lView = viewRef._lView;\n        const tView = lView[TVIEW];\n        if (ngDevMode && viewRef.destroyed) {\n            throw new Error('Cannot insert a destroyed View in a ViewContainer!');\n        }\n        if (viewAttachedToContainer(lView)) {\n            // If view is already attached, detach it first so we clean up references appropriately.\n            const prevIdx = this.indexOf(viewRef);\n            // A view might be attached either to this or a different container. The `prevIdx` for\n            // those cases will be:\n            // equal to -1 for views attached to this ViewContainerRef\n            // >= 0 for views attached to a different ViewContainerRef\n            if (prevIdx !== -1) {\n                this.detach(prevIdx);\n            }\n            else {\n                const prevLContainer = lView[PARENT];\n                ngDevMode &&\n                    assertEqual(isLContainer(prevLContainer), true, 'An attached view should have its PARENT point to a container.');\n                // We need to re-create a R3ViewContainerRef instance since those are not stored on\n                // LView (nor anywhere else).\n                const prevVCRef = new R3ViewContainerRef(prevLContainer, prevLContainer[T_HOST], prevLContainer[PARENT]);\n                prevVCRef.detach(prevVCRef.indexOf(viewRef));\n            }\n        }\n        // Logical operation of adding `LView` to `LContainer`\n        const adjustedIdx = this._adjustIndex(index);\n        const lContainer = this._lContainer;\n        insertView(tView, lView, lContainer, adjustedIdx);\n        // Physical operation of adding the DOM nodes.\n        const beforeNode = getBeforeNodeForView(adjustedIdx, lContainer);\n        const renderer = lView[RENDERER];\n        const parentRNode = nativeParentNode(renderer, lContainer[NATIVE]);\n        if (parentRNode !== null) {\n            addViewToContainer(tView, lContainer[T_HOST], renderer, lView, parentRNode, beforeNode);\n        }\n        viewRef.attachToViewContainerRef();\n        addToArray(getOrCreateViewRefs(lContainer), adjustedIdx, viewRef);\n        return viewRef;\n    }\n    move(viewRef, newIndex) {\n        if (ngDevMode && viewRef.destroyed) {\n            throw new Error('Cannot move a destroyed View in a ViewContainer!');\n        }\n        return this.insert(viewRef, newIndex);\n    }\n    indexOf(viewRef) {\n        const viewRefsArr = getViewRefs(this._lContainer);\n        return viewRefsArr !== null ? viewRefsArr.indexOf(viewRef) : -1;\n    }\n    remove(index) {\n        const adjustedIdx = this._adjustIndex(index, -1);\n        const detachedView = detachView(this._lContainer, adjustedIdx);\n        if (detachedView) {\n            // Before destroying the view, remove it from the container's array of `ViewRef`s.\n            // This ensures the view container length is updated before calling\n            // `destroyLView`, which could recursively call view container methods that\n            // rely on an accurate container length.\n            // (e.g. a method on this view container being called by a child directive's OnDestroy\n            // lifecycle hook)\n            removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx);\n            destroyLView(detachedView[TVIEW], detachedView);\n        }\n    }\n    detach(index) {\n        const adjustedIdx = this._adjustIndex(index, -1);\n        const view = detachView(this._lContainer, adjustedIdx);\n        const wasDetached = view && removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx) != null;\n        return wasDetached ? new ViewRef(view) : null;\n    }\n    _adjustIndex(index, shift = 0) {\n        if (index == null) {\n            return this.length + shift;\n        }\n        if (ngDevMode) {\n            assertGreaterThan(index, -1, `ViewRef index must be positive, got ${index}`);\n            // +1 because it's legal to insert at the end.\n            assertLessThan(index, this.length + 1 + shift, 'index');\n        }\n        return index;\n    }\n};\nfunction getViewRefs(lContainer) {\n    return lContainer[VIEW_REFS];\n}\nfunction getOrCreateViewRefs(lContainer) {\n    return (lContainer[VIEW_REFS] || (lContainer[VIEW_REFS] = []));\n}\n/**\n * Creates a ViewContainerRef and stores it on the injector.\n *\n * @param ViewContainerRefToken The ViewContainerRef type\n * @param ElementRefToken The ElementRef type\n * @param hostTNode The node that is requesting a ViewContainerRef\n * @param hostLView The view to which the node belongs\n * @returns The ViewContainerRef instance to use\n */\nfunction createContainerRef(hostTNode, hostLView) {\n    ngDevMode && assertTNodeType(hostTNode, 12 /* TNodeType.AnyContainer */ | 3 /* TNodeType.AnyRNode */);\n    let lContainer;\n    const slotValue = hostLView[hostTNode.index];\n    if (isLContainer(slotValue)) {\n        // If the host is a container, we don't need to create a new LContainer\n        lContainer = slotValue;\n    }\n    else {\n        let commentNode;\n        // If the host is an element container, the native host element is guaranteed to be a\n        // comment and we can reuse that comment as anchor element for the new LContainer.\n        // The comment node in question is already part of the DOM structure so we don't need to append\n        // it again.\n        if (hostTNode.type & 8 /* TNodeType.ElementContainer */) {\n            commentNode = unwrapRNode(slotValue);\n        }\n        else {\n            // If the host is a regular element, we have to insert a comment node manually which will\n            // be used as an anchor when inserting elements. In this specific case we use low-level DOM\n            // manipulation to insert it.\n            const renderer = hostLView[RENDERER];\n            ngDevMode && ngDevMode.rendererCreateComment++;\n            commentNode = renderer.createComment(ngDevMode ? 'container' : '');\n            const hostNative = getNativeByTNode(hostTNode, hostLView);\n            const parentOfHostNative = nativeParentNode(renderer, hostNative);\n            nativeInsertBefore(renderer, parentOfHostNative, commentNode, nativeNextSibling(renderer, hostNative), false);\n        }\n        hostLView[hostTNode.index] = lContainer =\n            createLContainer(slotValue, hostLView, commentNode, hostTNode);\n        addToViewTree(hostLView, lContainer);\n    }\n    return new R3ViewContainerRef(lContainer, hostTNode, hostLView);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nconst unusedValueExportToPlacateAjd$1 = 1;\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nconst unusedValueExportToPlacateAjd = 1;\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst unusedValueToPlacateAjd = unusedValueExportToPlacateAjd$1 + unusedValueExportToPlacateAjd$5 + unusedValueExportToPlacateAjd$4 + unusedValueExportToPlacateAjd;\nclass LQuery_ {\n    constructor(queryList) {\n        this.queryList = queryList;\n        this.matches = null;\n    }\n    clone() {\n        return new LQuery_(this.queryList);\n    }\n    setDirty() {\n        this.queryList.setDirty();\n    }\n}\nclass LQueries_ {\n    constructor(queries = []) {\n        this.queries = queries;\n    }\n    createEmbeddedView(tView) {\n        const tQueries = tView.queries;\n        if (tQueries !== null) {\n            const noOfInheritedQueries = tView.contentQueries !== null ? tView.contentQueries[0] : tQueries.length;\n            const viewLQueries = [];\n            // An embedded view has queries propagated from a declaration view at the beginning of the\n            // TQueries collection and up until a first content query declared in the embedded view. Only\n            // propagated LQueries are created at this point (LQuery corresponding to declared content\n            // queries will be instantiated from the content query instructions for each directive).\n            for (let i = 0; i < noOfInheritedQueries; i++) {\n                const tQuery = tQueries.getByIndex(i);\n                const parentLQuery = this.queries[tQuery.indexInDeclarationView];\n                viewLQueries.push(parentLQuery.clone());\n            }\n            return new LQueries_(viewLQueries);\n        }\n        return null;\n    }\n    insertView(tView) {\n        this.dirtyQueriesWithMatches(tView);\n    }\n    detachView(tView) {\n        this.dirtyQueriesWithMatches(tView);\n    }\n    dirtyQueriesWithMatches(tView) {\n        for (let i = 0; i < this.queries.length; i++) {\n            if (getTQuery(tView, i).matches !== null) {\n                this.queries[i].setDirty();\n            }\n        }\n    }\n}\nclass TQueryMetadata_ {\n    constructor(predicate, flags, read = null) {\n        this.predicate = predicate;\n        this.flags = flags;\n        this.read = read;\n    }\n}\nclass TQueries_ {\n    constructor(queries = []) {\n        this.queries = queries;\n    }\n    elementStart(tView, tNode) {\n        ngDevMode &&\n            assertFirstCreatePass(tView, 'Queries should collect results on the first template pass only');\n        for (let i = 0; i < this.queries.length; i++) {\n            this.queries[i].elementStart(tView, tNode);\n        }\n    }\n    elementEnd(tNode) {\n        for (let i = 0; i < this.queries.length; i++) {\n            this.queries[i].elementEnd(tNode);\n        }\n    }\n    embeddedTView(tNode) {\n        let queriesForTemplateRef = null;\n        for (let i = 0; i < this.length; i++) {\n            const childQueryIndex = queriesForTemplateRef !== null ? queriesForTemplateRef.length : 0;\n            const tqueryClone = this.getByIndex(i).embeddedTView(tNode, childQueryIndex);\n            if (tqueryClone) {\n                tqueryClone.indexInDeclarationView = i;\n                if (queriesForTemplateRef !== null) {\n                    queriesForTemplateRef.push(tqueryClone);\n                }\n                else {\n                    queriesForTemplateRef = [tqueryClone];\n                }\n            }\n        }\n        return queriesForTemplateRef !== null ? new TQueries_(queriesForTemplateRef) : null;\n    }\n    template(tView, tNode) {\n        ngDevMode &&\n            assertFirstCreatePass(tView, 'Queries should collect results on the first template pass only');\n        for (let i = 0; i < this.queries.length; i++) {\n            this.queries[i].template(tView, tNode);\n        }\n    }\n    getByIndex(index) {\n        ngDevMode && assertIndexInRange(this.queries, index);\n        return this.queries[index];\n    }\n    get length() {\n        return this.queries.length;\n    }\n    track(tquery) {\n        this.queries.push(tquery);\n    }\n}\nclass TQuery_ {\n    constructor(metadata, nodeIndex = -1) {\n        this.metadata = metadata;\n        this.matches = null;\n        this.indexInDeclarationView = -1;\n        this.crossesNgTemplate = false;\n        /**\n         * A flag indicating if a given query still applies to nodes it is crossing. We use this flag\n         * (alongside with _declarationNodeIndex) to know when to stop applying content queries to\n         * elements in a template.\n         */\n        this._appliesToNextNode = true;\n        this._declarationNodeIndex = nodeIndex;\n    }\n    elementStart(tView, tNode) {\n        if (this.isApplyingToNode(tNode)) {\n            this.matchTNode(tView, tNode);\n        }\n    }\n    elementEnd(tNode) {\n        if (this._declarationNodeIndex === tNode.index) {\n            this._appliesToNextNode = false;\n        }\n    }\n    template(tView, tNode) {\n        this.elementStart(tView, tNode);\n    }\n    embeddedTView(tNode, childQueryIndex) {\n        if (this.isApplyingToNode(tNode)) {\n            this.crossesNgTemplate = true;\n            // A marker indicating a `<ng-template>` element (a placeholder for query results from\n            // embedded views created based on this `<ng-template>`).\n            this.addMatch(-tNode.index, childQueryIndex);\n            return new TQuery_(this.metadata);\n        }\n        return null;\n    }\n    isApplyingToNode(tNode) {\n        if (this._appliesToNextNode &&\n            (this.metadata.flags & 1 /* QueryFlags.descendants */) !== 1 /* QueryFlags.descendants */) {\n            const declarationNodeIdx = this._declarationNodeIndex;\n            let parent = tNode.parent;\n            // Determine if a given TNode is a \"direct\" child of a node on which a content query was\n            // declared (only direct children of query's host node can match with the descendants: false\n            // option). There are 3 main use-case / conditions to consider here:\n            // - <needs-target><i #target></i></needs-target>: here <i #target> parent node is a query\n            // host node;\n            // - <needs-target><ng-template [ngIf]=\"true\"><i #target></i></ng-template></needs-target>:\n            // here <i #target> parent node is null;\n            // - <needs-target><ng-container><i #target></i></ng-container></needs-target>: here we need\n            // to go past `<ng-container>` to determine <i #target> parent node (but we shouldn't traverse\n            // up past the query's host node!).\n            while (parent !== null && (parent.type & 8 /* TNodeType.ElementContainer */) &&\n                parent.index !== declarationNodeIdx) {\n                parent = parent.parent;\n            }\n            return declarationNodeIdx === (parent !== null ? parent.index : -1);\n        }\n        return this._appliesToNextNode;\n    }\n    matchTNode(tView, tNode) {\n        const predicate = this.metadata.predicate;\n        if (Array.isArray(predicate)) {\n            for (let i = 0; i < predicate.length; i++) {\n                const name = predicate[i];\n                this.matchTNodeWithReadOption(tView, tNode, getIdxOfMatchingSelector(tNode, name));\n                // Also try matching the name to a provider since strings can be used as DI tokens too.\n                this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, name, false, false));\n            }\n        }\n        else {\n            if (predicate === TemplateRef) {\n                if (tNode.type & 4 /* TNodeType.Container */) {\n                    this.matchTNodeWithReadOption(tView, tNode, -1);\n                }\n            }\n            else {\n                this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, predicate, false, false));\n            }\n        }\n    }\n    matchTNodeWithReadOption(tView, tNode, nodeMatchIdx) {\n        if (nodeMatchIdx !== null) {\n            const read = this.metadata.read;\n            if (read !== null) {\n                if (read === ElementRef || read === ViewContainerRef ||\n                    read === TemplateRef && (tNode.type & 4 /* TNodeType.Container */)) {\n                    this.addMatch(tNode.index, -2);\n                }\n                else {\n                    const directiveOrProviderIdx = locateDirectiveOrProvider(tNode, tView, read, false, false);\n                    if (directiveOrProviderIdx !== null) {\n                        this.addMatch(tNode.index, directiveOrProviderIdx);\n                    }\n                }\n            }\n            else {\n                this.addMatch(tNode.index, nodeMatchIdx);\n            }\n        }\n    }\n    addMatch(tNodeIdx, matchIdx) {\n        if (this.matches === null) {\n            this.matches = [tNodeIdx, matchIdx];\n        }\n        else {\n            this.matches.push(tNodeIdx, matchIdx);\n        }\n    }\n}\n/**\n * Iterates over local names for a given node and returns directive index\n * (or -1 if a local name points to an element).\n *\n * @param tNode static data of a node to check\n * @param selector selector to match\n * @returns directive index, -1 or null if a selector didn't match any of the local names\n */\nfunction getIdxOfMatchingSelector(tNode, selector) {\n    const localNames = tNode.localNames;\n    if (localNames !== null) {\n        for (let i = 0; i < localNames.length; i += 2) {\n            if (localNames[i] === selector) {\n                return localNames[i + 1];\n            }\n        }\n    }\n    return null;\n}\nfunction createResultByTNodeType(tNode, currentView) {\n    if (tNode.type & (3 /* TNodeType.AnyRNode */ | 8 /* TNodeType.ElementContainer */)) {\n        return createElementRef(tNode, currentView);\n    }\n    else if (tNode.type & 4 /* TNodeType.Container */) {\n        return createTemplateRef(tNode, currentView);\n    }\n    return null;\n}\nfunction createResultForNode(lView, tNode, matchingIdx, read) {\n    if (matchingIdx === -1) {\n        // if read token and / or strategy is not specified, detect it using appropriate tNode type\n        return createResultByTNodeType(tNode, lView);\n    }\n    else if (matchingIdx === -2) {\n        // read a special token from a node injector\n        return createSpecialToken(lView, tNode, read);\n    }\n    else {\n        // read a token\n        return getNodeInjectable(lView, lView[TVIEW], matchingIdx, tNode);\n    }\n}\nfunction createSpecialToken(lView, tNode, read) {\n    if (read === ElementRef) {\n        return createElementRef(tNode, lView);\n    }\n    else if (read === TemplateRef) {\n        return createTemplateRef(tNode, lView);\n    }\n    else if (read === ViewContainerRef) {\n        ngDevMode && assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */ | 12 /* TNodeType.AnyContainer */);\n        return createContainerRef(tNode, lView);\n    }\n    else {\n        ngDevMode &&\n            throwError(`Special token to read should be one of ElementRef, TemplateRef or ViewContainerRef but got ${stringify(read)}.`);\n    }\n}\n/**\n * A helper function that creates query results for a given view. This function is meant to do the\n * processing once and only once for a given view instance (a set of results for a given view\n * doesn't change).\n */\nfunction materializeViewResults(tView, lView, tQuery, queryIndex) {\n    const lQuery = lView[QUERIES].queries[queryIndex];\n    if (lQuery.matches === null) {\n        const tViewData = tView.data;\n        const tQueryMatches = tQuery.matches;\n        const result = [];\n        for (let i = 0; i < tQueryMatches.length; i += 2) {\n            const matchedNodeIdx = tQueryMatches[i];\n            if (matchedNodeIdx < 0) {\n                // we at the <ng-template> marker which might have results in views created based on this\n                // <ng-template> - those results will be in separate views though, so here we just leave\n                // null as a placeholder\n                result.push(null);\n            }\n            else {\n                ngDevMode && assertIndexInRange(tViewData, matchedNodeIdx);\n                const tNode = tViewData[matchedNodeIdx];\n                result.push(createResultForNode(lView, tNode, tQueryMatches[i + 1], tQuery.metadata.read));\n            }\n        }\n        lQuery.matches = result;\n    }\n    return lQuery.matches;\n}\n/**\n * A helper function that collects (already materialized) query results from a tree of views,\n * starting with a provided LView.\n */\nfunction collectQueryResults(tView, lView, queryIndex, result) {\n    const tQuery = tView.queries.getByIndex(queryIndex);\n    const tQueryMatches = tQuery.matches;\n    if (tQueryMatches !== null) {\n        const lViewResults = materializeViewResults(tView, lView, tQuery, queryIndex);\n        for (let i = 0; i < tQueryMatches.length; i += 2) {\n            const tNodeIdx = tQueryMatches[i];\n            if (tNodeIdx > 0) {\n                result.push(lViewResults[i / 2]);\n            }\n            else {\n                const childQueryIndex = tQueryMatches[i + 1];\n                const declarationLContainer = lView[-tNodeIdx];\n                ngDevMode && assertLContainer(declarationLContainer);\n                // collect matches for views inserted in this container\n                for (let i = CONTAINER_HEADER_OFFSET; i < declarationLContainer.length; i++) {\n                    const embeddedLView = declarationLContainer[i];\n                    if (embeddedLView[DECLARATION_LCONTAINER] === embeddedLView[PARENT]) {\n                        collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);\n                    }\n                }\n                // collect matches for views created from this declaration container and inserted into\n                // different containers\n                if (declarationLContainer[MOVED_VIEWS] !== null) {\n                    const embeddedLViews = declarationLContainer[MOVED_VIEWS];\n                    for (let i = 0; i < embeddedLViews.length; i++) {\n                        const embeddedLView = embeddedLViews[i];\n                        collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);\n                    }\n                }\n            }\n        }\n    }\n    return result;\n}\n/**\n * Refreshes a query by combining matches from all active views and removing matches from deleted\n * views.\n *\n * @returns `true` if a query got dirty during change detection or if this is a static query\n * resolving in creation mode, `false` otherwise.\n *\n * @codeGenApi\n */\nfunction ɵɵqueryRefresh(queryList) {\n    const lView = getLView();\n    const tView = getTView();\n    const queryIndex = getCurrentQueryIndex();\n    setCurrentQueryIndex(queryIndex + 1);\n    const tQuery = getTQuery(tView, queryIndex);\n    if (queryList.dirty &&\n        (isCreationMode(lView) ===\n            ((tQuery.metadata.flags & 2 /* QueryFlags.isStatic */) === 2 /* QueryFlags.isStatic */))) {\n        if (tQuery.matches === null) {\n            queryList.reset([]);\n        }\n        else {\n            const result = tQuery.crossesNgTemplate ?\n                collectQueryResults(tView, lView, queryIndex, []) :\n                materializeViewResults(tView, lView, tQuery, queryIndex);\n            queryList.reset(result, unwrapElementRef);\n            queryList.notifyOnChanges();\n        }\n        return true;\n    }\n    return false;\n}\n/**\n * Creates new QueryList, stores the reference in LView and returns QueryList.\n *\n * @param predicate The type for which the query will search\n * @param flags Flags associated with the query\n * @param read What to save in the query\n *\n * @codeGenApi\n */\nfunction ɵɵviewQuery(predicate, flags, read) {\n    ngDevMode && assertNumber(flags, 'Expecting flags');\n    const tView = getTView();\n    if (tView.firstCreatePass) {\n        createTQuery(tView, new TQueryMetadata_(predicate, flags, read), -1);\n        if ((flags & 2 /* QueryFlags.isStatic */) === 2 /* QueryFlags.isStatic */) {\n            tView.staticViewQueries = true;\n        }\n    }\n    createLQuery(tView, getLView(), flags);\n}\n/**\n * Registers a QueryList, associated with a content query, for later refresh (part of a view\n * refresh).\n *\n * @param directiveIndex Current directive index\n * @param predicate The type for which the query will search\n * @param flags Flags associated with the query\n * @param read What to save in the query\n * @returns QueryList<T>\n *\n * @codeGenApi\n */\nfunction ɵɵcontentQuery(directiveIndex, predicate, flags, read) {\n    ngDevMode && assertNumber(flags, 'Expecting flags');\n    const tView = getTView();\n    if (tView.firstCreatePass) {\n        const tNode = getCurrentTNode();\n        createTQuery(tView, new TQueryMetadata_(predicate, flags, read), tNode.index);\n        saveContentQueryAndDirectiveIndex(tView, directiveIndex);\n        if ((flags & 2 /* QueryFlags.isStatic */) === 2 /* QueryFlags.isStatic */) {\n            tView.staticContentQueries = true;\n        }\n    }\n    createLQuery(tView, getLView(), flags);\n}\n/**\n * Loads a QueryList corresponding to the current view or content query.\n *\n * @codeGenApi\n */\nfunction ɵɵloadQuery() {\n    return loadQueryInternal(getLView(), getCurrentQueryIndex());\n}\nfunction loadQueryInternal(lView, queryIndex) {\n    ngDevMode &&\n        assertDefined(lView[QUERIES], 'LQueries should be defined when trying to load a query');\n    ngDevMode && assertIndexInRange(lView[QUERIES].queries, queryIndex);\n    return lView[QUERIES].queries[queryIndex].queryList;\n}\nfunction createLQuery(tView, lView, flags) {\n    const queryList = new QueryList((flags & 4 /* QueryFlags.emitDistinctChangesOnly */) === 4 /* QueryFlags.emitDistinctChangesOnly */);\n    storeCleanupWithContext(tView, lView, queryList, queryList.destroy);\n    if (lView[QUERIES] === null)\n        lView[QUERIES] = new LQueries_();\n    lView[QUERIES].queries.push(new LQuery_(queryList));\n}\nfunction createTQuery(tView, metadata, nodeIndex) {\n    if (tView.queries === null)\n        tView.queries = new TQueries_();\n    tView.queries.track(new TQuery_(metadata, nodeIndex));\n}\nfunction saveContentQueryAndDirectiveIndex(tView, directiveIndex) {\n    const tViewContentQueries = tView.contentQueries || (tView.contentQueries = []);\n    const lastSavedDirectiveIndex = tViewContentQueries.length ? tViewContentQueries[tViewContentQueries.length - 1] : -1;\n    if (directiveIndex !== lastSavedDirectiveIndex) {\n        tViewContentQueries.push(tView.queries.length - 1, directiveIndex);\n    }\n}\nfunction getTQuery(tView, index) {\n    ngDevMode && assertDefined(tView.queries, 'TQueries must be defined to retrieve a TQuery');\n    return tView.queries.getByIndex(index);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Retrieves `TemplateRef` instance from `Injector` when a local reference is placed on the\n * `<ng-template>` element.\n *\n * @codeGenApi\n */\nfunction ɵɵtemplateRefExtractor(tNode, lView) {\n    return createTemplateRef(tNode, lView);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A mapping of the @angular/core API surface used in generated expressions to the actual symbols.\n *\n * This should be kept up to date with the public exports of @angular/core.\n */\nconst angularCoreEnv = (() => ({\n    'ɵɵattribute': ɵɵattribute,\n    'ɵɵattributeInterpolate1': ɵɵattributeInterpolate1,\n    'ɵɵattributeInterpolate2': ɵɵattributeInterpolate2,\n    'ɵɵattributeInterpolate3': ɵɵattributeInterpolate3,\n    'ɵɵattributeInterpolate4': ɵɵattributeInterpolate4,\n    'ɵɵattributeInterpolate5': ɵɵattributeInterpolate5,\n    'ɵɵattributeInterpolate6': ɵɵattributeInterpolate6,\n    'ɵɵattributeInterpolate7': ɵɵattributeInterpolate7,\n    'ɵɵattributeInterpolate8': ɵɵattributeInterpolate8,\n    'ɵɵattributeInterpolateV': ɵɵattributeInterpolateV,\n    'ɵɵdefineComponent': ɵɵdefineComponent,\n    'ɵɵdefineDirective': ɵɵdefineDirective,\n    'ɵɵdefineInjectable': ɵɵdefineInjectable,\n    'ɵɵdefineInjector': ɵɵdefineInjector,\n    'ɵɵdefineNgModule': ɵɵdefineNgModule,\n    'ɵɵdefinePipe': ɵɵdefinePipe,\n    'ɵɵdirectiveInject': ɵɵdirectiveInject,\n    'ɵɵgetInheritedFactory': ɵɵgetInheritedFactory,\n    'ɵɵinject': ɵɵinject,\n    'ɵɵinjectAttribute': ɵɵinjectAttribute,\n    'ɵɵinvalidFactory': ɵɵinvalidFactory,\n    'ɵɵinvalidFactoryDep': ɵɵinvalidFactoryDep,\n    'ɵɵtemplateRefExtractor': ɵɵtemplateRefExtractor,\n    'ɵɵresetView': ɵɵresetView,\n    'ɵɵNgOnChangesFeature': ɵɵNgOnChangesFeature,\n    'ɵɵProvidersFeature': ɵɵProvidersFeature,\n    'ɵɵCopyDefinitionFeature': ɵɵCopyDefinitionFeature,\n    'ɵɵInheritDefinitionFeature': ɵɵInheritDefinitionFeature,\n    'ɵɵStandaloneFeature': ɵɵStandaloneFeature,\n    'ɵɵnextContext': ɵɵnextContext,\n    'ɵɵnamespaceHTML': ɵɵnamespaceHTML,\n    'ɵɵnamespaceMathML': ɵɵnamespaceMathML,\n    'ɵɵnamespaceSVG': ɵɵnamespaceSVG,\n    'ɵɵenableBindings': ɵɵenableBindings,\n    'ɵɵdisableBindings': ɵɵdisableBindings,\n    'ɵɵelementStart': ɵɵelementStart,\n    'ɵɵelementEnd': ɵɵelementEnd,\n    'ɵɵelement': ɵɵelement,\n    'ɵɵelementContainerStart': ɵɵelementContainerStart,\n    'ɵɵelementContainerEnd': ɵɵelementContainerEnd,\n    'ɵɵelementContainer': ɵɵelementContainer,\n    'ɵɵpureFunction0': ɵɵpureFunction0,\n    'ɵɵpureFunction1': ɵɵpureFunction1,\n    'ɵɵpureFunction2': ɵɵpureFunction2,\n    'ɵɵpureFunction3': ɵɵpureFunction3,\n    'ɵɵpureFunction4': ɵɵpureFunction4,\n    'ɵɵpureFunction5': ɵɵpureFunction5,\n    'ɵɵpureFunction6': ɵɵpureFunction6,\n    'ɵɵpureFunction7': ɵɵpureFunction7,\n    'ɵɵpureFunction8': ɵɵpureFunction8,\n    'ɵɵpureFunctionV': ɵɵpureFunctionV,\n    'ɵɵgetCurrentView': ɵɵgetCurrentView,\n    'ɵɵrestoreView': ɵɵrestoreView,\n    'ɵɵlistener': ɵɵlistener,\n    'ɵɵprojection': ɵɵprojection,\n    'ɵɵsyntheticHostProperty': ɵɵsyntheticHostProperty,\n    'ɵɵsyntheticHostListener': ɵɵsyntheticHostListener,\n    'ɵɵpipeBind1': ɵɵpipeBind1,\n    'ɵɵpipeBind2': ɵɵpipeBind2,\n    'ɵɵpipeBind3': ɵɵpipeBind3,\n    'ɵɵpipeBind4': ɵɵpipeBind4,\n    'ɵɵpipeBindV': ɵɵpipeBindV,\n    'ɵɵprojectionDef': ɵɵprojectionDef,\n    'ɵɵhostProperty': ɵɵhostProperty,\n    'ɵɵproperty': ɵɵproperty,\n    'ɵɵpropertyInterpolate': ɵɵpropertyInterpolate,\n    'ɵɵpropertyInterpolate1': ɵɵpropertyInterpolate1,\n    'ɵɵpropertyInterpolate2': ɵɵpropertyInterpolate2,\n    'ɵɵpropertyInterpolate3': ɵɵpropertyInterpolate3,\n    'ɵɵpropertyInterpolate4': ɵɵpropertyInterpolate4,\n    'ɵɵpropertyInterpolate5': ɵɵpropertyInterpolate5,\n    'ɵɵpropertyInterpolate6': ɵɵpropertyInterpolate6,\n    'ɵɵpropertyInterpolate7': ɵɵpropertyInterpolate7,\n    'ɵɵpropertyInterpolate8': ɵɵpropertyInterpolate8,\n    'ɵɵpropertyInterpolateV': ɵɵpropertyInterpolateV,\n    'ɵɵpipe': ɵɵpipe,\n    'ɵɵqueryRefresh': ɵɵqueryRefresh,\n    'ɵɵviewQuery': ɵɵviewQuery,\n    'ɵɵloadQuery': ɵɵloadQuery,\n    'ɵɵcontentQuery': ɵɵcontentQuery,\n    'ɵɵreference': ɵɵreference,\n    'ɵɵclassMap': ɵɵclassMap,\n    'ɵɵclassMapInterpolate1': ɵɵclassMapInterpolate1,\n    'ɵɵclassMapInterpolate2': ɵɵclassMapInterpolate2,\n    'ɵɵclassMapInterpolate3': ɵɵclassMapInterpolate3,\n    'ɵɵclassMapInterpolate4': ɵɵclassMapInterpolate4,\n    'ɵɵclassMapInterpolate5': ɵɵclassMapInterpolate5,\n    'ɵɵclassMapInterpolate6': ɵɵclassMapInterpolate6,\n    'ɵɵclassMapInterpolate7': ɵɵclassMapInterpolate7,\n    'ɵɵclassMapInterpolate8': ɵɵclassMapInterpolate8,\n    'ɵɵclassMapInterpolateV': ɵɵclassMapInterpolateV,\n    'ɵɵstyleMap': ɵɵstyleMap,\n    'ɵɵstyleMapInterpolate1': ɵɵstyleMapInterpolate1,\n    'ɵɵstyleMapInterpolate2': ɵɵstyleMapInterpolate2,\n    'ɵɵstyleMapInterpolate3': ɵɵstyleMapInterpolate3,\n    'ɵɵstyleMapInterpolate4': ɵɵstyleMapInterpolate4,\n    'ɵɵstyleMapInterpolate5': ɵɵstyleMapInterpolate5,\n    'ɵɵstyleMapInterpolate6': ɵɵstyleMapInterpolate6,\n    'ɵɵstyleMapInterpolate7': ɵɵstyleMapInterpolate7,\n    'ɵɵstyleMapInterpolate8': ɵɵstyleMapInterpolate8,\n    'ɵɵstyleMapInterpolateV': ɵɵstyleMapInterpolateV,\n    'ɵɵstyleProp': ɵɵstyleProp,\n    'ɵɵstylePropInterpolate1': ɵɵstylePropInterpolate1,\n    'ɵɵstylePropInterpolate2': ɵɵstylePropInterpolate2,\n    'ɵɵstylePropInterpolate3': ɵɵstylePropInterpolate3,\n    'ɵɵstylePropInterpolate4': ɵɵstylePropInterpolate4,\n    'ɵɵstylePropInterpolate5': ɵɵstylePropInterpolate5,\n    'ɵɵstylePropInterpolate6': ɵɵstylePropInterpolate6,\n    'ɵɵstylePropInterpolate7': ɵɵstylePropInterpolate7,\n    'ɵɵstylePropInterpolate8': ɵɵstylePropInterpolate8,\n    'ɵɵstylePropInterpolateV': ɵɵstylePropInterpolateV,\n    'ɵɵclassProp': ɵɵclassProp,\n    'ɵɵadvance': ɵɵadvance,\n    'ɵɵtemplate': ɵɵtemplate,\n    'ɵɵtext': ɵɵtext,\n    'ɵɵtextInterpolate': ɵɵtextInterpolate,\n    'ɵɵtextInterpolate1': ɵɵtextInterpolate1,\n    'ɵɵtextInterpolate2': ɵɵtextInterpolate2,\n    'ɵɵtextInterpolate3': ɵɵtextInterpolate3,\n    'ɵɵtextInterpolate4': ɵɵtextInterpolate4,\n    'ɵɵtextInterpolate5': ɵɵtextInterpolate5,\n    'ɵɵtextInterpolate6': ɵɵtextInterpolate6,\n    'ɵɵtextInterpolate7': ɵɵtextInterpolate7,\n    'ɵɵtextInterpolate8': ɵɵtextInterpolate8,\n    'ɵɵtextInterpolateV': ɵɵtextInterpolateV,\n    'ɵɵi18n': ɵɵi18n,\n    'ɵɵi18nAttributes': ɵɵi18nAttributes,\n    'ɵɵi18nExp': ɵɵi18nExp,\n    'ɵɵi18nStart': ɵɵi18nStart,\n    'ɵɵi18nEnd': ɵɵi18nEnd,\n    'ɵɵi18nApply': ɵɵi18nApply,\n    'ɵɵi18nPostprocess': ɵɵi18nPostprocess,\n    'ɵɵresolveWindow': ɵɵresolveWindow,\n    'ɵɵresolveDocument': ɵɵresolveDocument,\n    'ɵɵresolveBody': ɵɵresolveBody,\n    'ɵɵsetComponentScope': ɵɵsetComponentScope,\n    'ɵɵsetNgModuleScope': ɵɵsetNgModuleScope,\n    'ɵɵregisterNgModuleType': registerNgModuleType,\n    'ɵɵsanitizeHtml': ɵɵsanitizeHtml,\n    'ɵɵsanitizeStyle': ɵɵsanitizeStyle,\n    'ɵɵsanitizeResourceUrl': ɵɵsanitizeResourceUrl,\n    'ɵɵsanitizeScript': ɵɵsanitizeScript,\n    'ɵɵsanitizeUrl': ɵɵsanitizeUrl,\n    'ɵɵsanitizeUrlOrResourceUrl': ɵɵsanitizeUrlOrResourceUrl,\n    'ɵɵtrustConstantHtml': ɵɵtrustConstantHtml,\n    'ɵɵtrustConstantResourceUrl': ɵɵtrustConstantResourceUrl,\n    'forwardRef': forwardRef,\n    'resolveForwardRef': resolveForwardRef,\n}))();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction patchModuleCompilation() {\n    // Does nothing, but exists as a target for patching.\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction isModuleWithProviders$1(value) {\n    return value.ngModule !== undefined;\n}\nfunction isNgModule$1(value) {\n    return !!getNgModuleDef(value);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst moduleQueue = [];\n/**\n * Enqueues moduleDef to be checked later to see if scope can be set on its\n * component declarations.\n */\nfunction enqueueModuleForDelayedScoping(moduleType, ngModule) {\n    moduleQueue.push({ moduleType, ngModule });\n}\nlet flushingModuleQueue = false;\n/**\n * Loops over queued module definitions, if a given module definition has all of its\n * declarations resolved, it dequeues that module definition and sets the scope on\n * its declarations.\n */\nfunction flushModuleScopingQueueAsMuchAsPossible() {\n    if (!flushingModuleQueue) {\n        flushingModuleQueue = true;\n        try {\n            for (let i = moduleQueue.length - 1; i >= 0; i--) {\n                const { moduleType, ngModule } = moduleQueue[i];\n                if (ngModule.declarations && ngModule.declarations.every(isResolvedDeclaration)) {\n                    // dequeue\n                    moduleQueue.splice(i, 1);\n                    setScopeOnDeclaredComponents(moduleType, ngModule);\n                }\n            }\n        }\n        finally {\n            flushingModuleQueue = false;\n        }\n    }\n}\n/**\n * Returns truthy if a declaration has resolved. If the declaration happens to be\n * an array of declarations, it will recurse to check each declaration in that array\n * (which may also be arrays).\n */\nfunction isResolvedDeclaration(declaration) {\n    if (Array.isArray(declaration)) {\n        return declaration.every(isResolvedDeclaration);\n    }\n    return !!resolveForwardRef(declaration);\n}\n/**\n * Compiles a module in JIT mode.\n *\n * This function automatically gets called when a class has a `@NgModule` decorator.\n */\nfunction compileNgModule(moduleType, ngModule = {}) {\n    patchModuleCompilation();\n    compileNgModuleDefs(moduleType, ngModule);\n    if (ngModule.id !== undefined) {\n        registerNgModuleType(moduleType, ngModule.id);\n    }\n    // Because we don't know if all declarations have resolved yet at the moment the\n    // NgModule decorator is executing, we're enqueueing the setting of module scope\n    // on its declarations to be run at a later time when all declarations for the module,\n    // including forward refs, have resolved.\n    enqueueModuleForDelayedScoping(moduleType, ngModule);\n}\n/**\n * Compiles and adds the `ɵmod`, `ɵfac` and `ɵinj` properties to the module class.\n *\n * It's possible to compile a module via this API which will allow duplicate declarations in its\n * root.\n */\nfunction compileNgModuleDefs(moduleType, ngModule, allowDuplicateDeclarationsInRoot = false) {\n    ngDevMode && assertDefined(moduleType, 'Required value moduleType');\n    ngDevMode && assertDefined(ngModule, 'Required value ngModule');\n    const declarations = flatten$1(ngModule.declarations || EMPTY_ARRAY);\n    let ngModuleDef = null;\n    Object.defineProperty(moduleType, NG_MOD_DEF, {\n        configurable: true,\n        get: () => {\n            if (ngModuleDef === null) {\n                if (ngDevMode && ngModule.imports && ngModule.imports.indexOf(moduleType) > -1) {\n                    // We need to assert this immediately, because allowing it to continue will cause it to\n                    // go into an infinite loop before we've reached the point where we throw all the errors.\n                    throw new Error(`'${stringifyForError(moduleType)}' module can't import itself`);\n                }\n                const compiler = getCompilerFacade({ usage: 0 /* JitCompilerUsage.Decorator */, kind: 'NgModule', type: moduleType });\n                ngModuleDef = compiler.compileNgModule(angularCoreEnv, `ng:///${moduleType.name}/ɵmod.js`, {\n                    type: moduleType,\n                    bootstrap: flatten$1(ngModule.bootstrap || EMPTY_ARRAY).map(resolveForwardRef),\n                    declarations: declarations.map(resolveForwardRef),\n                    imports: flatten$1(ngModule.imports || EMPTY_ARRAY)\n                        .map(resolveForwardRef)\n                        .map(expandModuleWithProviders),\n                    exports: flatten$1(ngModule.exports || EMPTY_ARRAY)\n                        .map(resolveForwardRef)\n                        .map(expandModuleWithProviders),\n                    schemas: ngModule.schemas ? flatten$1(ngModule.schemas) : null,\n                    id: ngModule.id || null,\n                });\n                // Set `schemas` on ngModuleDef to an empty array in JIT mode to indicate that runtime\n                // should verify that there are no unknown elements in a template. In AOT mode, that check\n                // happens at compile time and `schemas` information is not present on Component and Module\n                // defs after compilation (so the check doesn't happen the second time at runtime).\n                if (!ngModuleDef.schemas) {\n                    ngModuleDef.schemas = [];\n                }\n            }\n            return ngModuleDef;\n        }\n    });\n    let ngFactoryDef = null;\n    Object.defineProperty(moduleType, NG_FACTORY_DEF, {\n        get: () => {\n            if (ngFactoryDef === null) {\n                const compiler = getCompilerFacade({ usage: 0 /* JitCompilerUsage.Decorator */, kind: 'NgModule', type: moduleType });\n                ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${moduleType.name}/ɵfac.js`, {\n                    name: moduleType.name,\n                    type: moduleType,\n                    deps: reflectDependencies(moduleType),\n                    target: compiler.FactoryTarget.NgModule,\n                    typeArgumentCount: 0,\n                });\n            }\n            return ngFactoryDef;\n        },\n        // Make the property configurable in dev mode to allow overriding in tests\n        configurable: !!ngDevMode,\n    });\n    let ngInjectorDef = null;\n    Object.defineProperty(moduleType, NG_INJ_DEF, {\n        get: () => {\n            if (ngInjectorDef === null) {\n                ngDevMode &&\n                    verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot);\n                const meta = {\n                    name: moduleType.name,\n                    type: moduleType,\n                    providers: ngModule.providers || EMPTY_ARRAY,\n                    imports: [\n                        (ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef),\n                        (ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef),\n                    ],\n                };\n                const compiler = getCompilerFacade({ usage: 0 /* JitCompilerUsage.Decorator */, kind: 'NgModule', type: moduleType });\n                ngInjectorDef =\n                    compiler.compileInjector(angularCoreEnv, `ng:///${moduleType.name}/ɵinj.js`, meta);\n            }\n            return ngInjectorDef;\n        },\n        // Make the property configurable in dev mode to allow overriding in tests\n        configurable: !!ngDevMode,\n    });\n}\nfunction isStandalone(type) {\n    const def = getComponentDef$1(type) || getDirectiveDef(type) || getPipeDef$1(type);\n    return def !== null ? def.standalone : false;\n}\nfunction generateStandaloneInDeclarationsError(type, location) {\n    const prefix = `Unexpected \"${stringifyForError(type)}\" found in the \"declarations\" array of the`;\n    const suffix = `\"${stringifyForError(type)}\" is marked as standalone and can't be declared ` +\n        'in any NgModule - did you intend to import it instead (by adding it to the \"imports\" array)?';\n    return `${prefix} ${location}, ${suffix}`;\n}\nfunction verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot, importingModule) {\n    if (verifiedNgModule.get(moduleType))\n        return;\n    // skip verifications of standalone components, directives and pipes\n    if (isStandalone(moduleType))\n        return;\n    verifiedNgModule.set(moduleType, true);\n    moduleType = resolveForwardRef(moduleType);\n    let ngModuleDef;\n    if (importingModule) {\n        ngModuleDef = getNgModuleDef(moduleType);\n        if (!ngModuleDef) {\n            throw new Error(`Unexpected value '${moduleType.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);\n        }\n    }\n    else {\n        ngModuleDef = getNgModuleDef(moduleType, true);\n    }\n    const errors = [];\n    const declarations = maybeUnwrapFn$1(ngModuleDef.declarations);\n    const imports = maybeUnwrapFn$1(ngModuleDef.imports);\n    flatten$1(imports).map(unwrapModuleWithProvidersImports).forEach(modOrStandaloneCmpt => {\n        verifySemanticsOfNgModuleImport(modOrStandaloneCmpt, moduleType);\n        verifySemanticsOfNgModuleDef(modOrStandaloneCmpt, false, moduleType);\n    });\n    const exports = maybeUnwrapFn$1(ngModuleDef.exports);\n    declarations.forEach(verifyDeclarationsHaveDefinitions);\n    declarations.forEach(verifyDirectivesHaveSelector);\n    declarations.forEach((declarationType) => verifyNotStandalone(declarationType, moduleType));\n    const combinedDeclarations = [\n        ...declarations.map(resolveForwardRef),\n        ...flatten$1(imports.map(computeCombinedExports)).map(resolveForwardRef),\n    ];\n    exports.forEach(verifyExportsAreDeclaredOrReExported);\n    declarations.forEach(decl => verifyDeclarationIsUnique(decl, allowDuplicateDeclarationsInRoot));\n    declarations.forEach(verifyComponentEntryComponentsIsPartOfNgModule);\n    const ngModule = getAnnotation(moduleType, 'NgModule');\n    if (ngModule) {\n        ngModule.imports &&\n            flatten$1(ngModule.imports).map(unwrapModuleWithProvidersImports).forEach(mod => {\n                verifySemanticsOfNgModuleImport(mod, moduleType);\n                verifySemanticsOfNgModuleDef(mod, false, moduleType);\n            });\n        ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyCorrectBootstrapType);\n        ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyComponentIsPartOfNgModule);\n        ngModule.entryComponents &&\n            deepForEach(ngModule.entryComponents, verifyComponentIsPartOfNgModule);\n    }\n    // Throw Error if any errors were detected.\n    if (errors.length) {\n        throw new Error(errors.join('\\n'));\n    }\n    ////////////////////////////////////////////////////////////////////////////////////////////////\n    function verifyDeclarationsHaveDefinitions(type) {\n        type = resolveForwardRef(type);\n        const def = getComponentDef$1(type) || getDirectiveDef(type) || getPipeDef$1(type);\n        if (!def) {\n            errors.push(`Unexpected value '${stringifyForError(type)}' declared by the module '${stringifyForError(moduleType)}'. Please add a @Pipe/@Directive/@Component annotation.`);\n        }\n    }\n    function verifyDirectivesHaveSelector(type) {\n        type = resolveForwardRef(type);\n        const def = getDirectiveDef(type);\n        if (!getComponentDef$1(type) && def && def.selectors.length == 0) {\n            errors.push(`Directive ${stringifyForError(type)} has no selector, please add it!`);\n        }\n    }\n    function verifyNotStandalone(type, moduleType) {\n        type = resolveForwardRef(type);\n        const def = getComponentDef$1(type) || getDirectiveDef(type) || getPipeDef$1(type);\n        if (def === null || def === void 0 ? void 0 : def.standalone) {\n            const location = `\"${stringifyForError(moduleType)}\" NgModule`;\n            errors.push(generateStandaloneInDeclarationsError(type, location));\n        }\n    }\n    function verifyExportsAreDeclaredOrReExported(type) {\n        type = resolveForwardRef(type);\n        const kind = getComponentDef$1(type) && 'component' || getDirectiveDef(type) && 'directive' ||\n            getPipeDef$1(type) && 'pipe';\n        if (kind) {\n            // only checked if we are declared as Component, Directive, or Pipe\n            // Modules don't need to be declared or imported.\n            if (combinedDeclarations.lastIndexOf(type) === -1) {\n                // We are exporting something which we don't explicitly declare or import.\n                errors.push(`Can't export ${kind} ${stringifyForError(type)} from ${stringifyForError(moduleType)} as it was neither declared nor imported!`);\n            }\n        }\n    }\n    function verifyDeclarationIsUnique(type, suppressErrors) {\n        type = resolveForwardRef(type);\n        const existingModule = ownerNgModule.get(type);\n        if (existingModule && existingModule !== moduleType) {\n            if (!suppressErrors) {\n                const modules = [existingModule, moduleType].map(stringifyForError).sort();\n                errors.push(`Type ${stringifyForError(type)} is part of the declarations of 2 modules: ${modules[0]} and ${modules[1]}! ` +\n                    `Please consider moving ${stringifyForError(type)} to a higher module that imports ${modules[0]} and ${modules[1]}. ` +\n                    `You can also create a new NgModule that exports and includes ${stringifyForError(type)} then import that NgModule in ${modules[0]} and ${modules[1]}.`);\n            }\n        }\n        else {\n            // Mark type as having owner.\n            ownerNgModule.set(type, moduleType);\n        }\n    }\n    function verifyComponentIsPartOfNgModule(type) {\n        type = resolveForwardRef(type);\n        const existingModule = ownerNgModule.get(type);\n        if (!existingModule && !isStandalone(type)) {\n            errors.push(`Component ${stringifyForError(type)} is not part of any NgModule or the module has not been imported into your module.`);\n        }\n    }\n    function verifyCorrectBootstrapType(type) {\n        type = resolveForwardRef(type);\n        if (!getComponentDef$1(type)) {\n            errors.push(`${stringifyForError(type)} cannot be used as an entry component.`);\n        }\n        if (isStandalone(type)) {\n            // Note: this error should be the same as the\n            // `NGMODULE_BOOTSTRAP_IS_STANDALONE` one in AOT compiler.\n            errors.push(`The \\`${stringifyForError(type)}\\` class is a standalone component, which can ` +\n                `not be used in the \\`@NgModule.bootstrap\\` array. Use the \\`bootstrapApplication\\` ` +\n                `function for bootstrap instead.`);\n        }\n    }\n    function verifyComponentEntryComponentsIsPartOfNgModule(type) {\n        type = resolveForwardRef(type);\n        if (getComponentDef$1(type)) {\n            // We know we are component\n            const component = getAnnotation(type, 'Component');\n            if (component && component.entryComponents) {\n                deepForEach(component.entryComponents, verifyComponentIsPartOfNgModule);\n            }\n        }\n    }\n    function verifySemanticsOfNgModuleImport(type, importingModule) {\n        type = resolveForwardRef(type);\n        const directiveDef = getComponentDef$1(type) || getDirectiveDef(type);\n        if (directiveDef !== null && !directiveDef.standalone) {\n            throw new Error(`Unexpected directive '${type.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);\n        }\n        const pipeDef = getPipeDef$1(type);\n        if (pipeDef !== null && !pipeDef.standalone) {\n            throw new Error(`Unexpected pipe '${type.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);\n        }\n    }\n}\nfunction unwrapModuleWithProvidersImports(typeOrWithProviders) {\n    typeOrWithProviders = resolveForwardRef(typeOrWithProviders);\n    return typeOrWithProviders.ngModule || typeOrWithProviders;\n}\nfunction getAnnotation(type, name) {\n    let annotation = null;\n    collect(type.__annotations__);\n    collect(type.decorators);\n    return annotation;\n    function collect(annotations) {\n        if (annotations) {\n            annotations.forEach(readAnnotation);\n        }\n    }\n    function readAnnotation(decorator) {\n        if (!annotation) {\n            const proto = Object.getPrototypeOf(decorator);\n            if (proto.ngMetadataName == name) {\n                annotation = decorator;\n            }\n            else if (decorator.type) {\n                const proto = Object.getPrototypeOf(decorator.type);\n                if (proto.ngMetadataName == name) {\n                    annotation = decorator.args[0];\n                }\n            }\n        }\n    }\n}\n/**\n * Keep track of compiled components. This is needed because in tests we often want to compile the\n * same component with more than one NgModule. This would cause an error unless we reset which\n * NgModule the component belongs to. We keep the list of compiled components here so that the\n * TestBed can reset it later.\n */\nlet ownerNgModule = new WeakMap();\nlet verifiedNgModule = new WeakMap();\nfunction resetCompiledComponents() {\n    ownerNgModule = new WeakMap();\n    verifiedNgModule = new WeakMap();\n    moduleQueue.length = 0;\n}\n/**\n * Computes the combined declarations of explicit declarations, as well as declarations inherited by\n * traversing the exports of imported modules.\n * @param type\n */\nfunction computeCombinedExports(type) {\n    type = resolveForwardRef(type);\n    const ngModuleDef = getNgModuleDef(type);\n    // a standalone component, directive or pipe\n    if (ngModuleDef === null) {\n        return [type];\n    }\n    return [...flatten$1(maybeUnwrapFn$1(ngModuleDef.exports).map((type) => {\n            const ngModuleDef = getNgModuleDef(type);\n            if (ngModuleDef) {\n                verifySemanticsOfNgModuleDef(type, false);\n                return computeCombinedExports(type);\n            }\n            else {\n                return type;\n            }\n        }))];\n}\n/**\n * Some declared components may be compiled asynchronously, and thus may not have their\n * ɵcmp set yet. If this is the case, then a reference to the module is written into\n * the `ngSelectorScope` property of the declared type.\n */\nfunction setScopeOnDeclaredComponents(moduleType, ngModule) {\n    const declarations = flatten$1(ngModule.declarations || EMPTY_ARRAY);\n    const transitiveScopes = transitiveScopesFor(moduleType);\n    declarations.forEach(declaration => {\n        declaration = resolveForwardRef(declaration);\n        if (declaration.hasOwnProperty(NG_COMP_DEF)) {\n            // A `ɵcmp` field exists - go ahead and patch the component directly.\n            const component = declaration;\n            const componentDef = getComponentDef$1(component);\n            patchComponentDefWithScope(componentDef, transitiveScopes);\n        }\n        else if (!declaration.hasOwnProperty(NG_DIR_DEF) && !declaration.hasOwnProperty(NG_PIPE_DEF)) {\n            // Set `ngSelectorScope` for future reference when the component compilation finishes.\n            declaration.ngSelectorScope = moduleType;\n        }\n    });\n}\n/**\n * Patch the definition of a component with directives and pipes from the compilation scope of\n * a given module.\n */\nfunction patchComponentDefWithScope(componentDef, transitiveScopes) {\n    componentDef.directiveDefs = () => Array.from(transitiveScopes.compilation.directives)\n        .map(dir => dir.hasOwnProperty(NG_COMP_DEF) ? getComponentDef$1(dir) : getDirectiveDef(dir))\n        .filter(def => !!def);\n    componentDef.pipeDefs = () => Array.from(transitiveScopes.compilation.pipes).map(pipe => getPipeDef$1(pipe));\n    componentDef.schemas = transitiveScopes.schemas;\n    // Since we avoid Components/Directives/Pipes recompiling in case there are no overrides, we\n    // may face a problem where previously compiled defs available to a given Component/Directive\n    // are cached in TView and may become stale (in case any of these defs gets recompiled). In\n    // order to avoid this problem, we force fresh TView to be created.\n    componentDef.tView = null;\n}\n/**\n * Compute the pair of transitive scopes (compilation scope and exported scope) for a given type\n * (either a NgModule or a standalone component / directive / pipe).\n */\nfunction transitiveScopesFor(type) {\n    if (isNgModule$1(type)) {\n        return transitiveScopesForNgModule(type);\n    }\n    else if (isStandalone(type)) {\n        const directiveDef = getComponentDef$1(type) || getDirectiveDef(type);\n        if (directiveDef !== null) {\n            return {\n                schemas: null,\n                compilation: {\n                    directives: new Set(),\n                    pipes: new Set(),\n                },\n                exported: {\n                    directives: new Set([type]),\n                    pipes: new Set(),\n                },\n            };\n        }\n        const pipeDef = getPipeDef$1(type);\n        if (pipeDef !== null) {\n            return {\n                schemas: null,\n                compilation: {\n                    directives: new Set(),\n                    pipes: new Set(),\n                },\n                exported: {\n                    directives: new Set(),\n                    pipes: new Set([type]),\n                },\n            };\n        }\n    }\n    // TODO: change the error message to be more user-facing and take standalone into account\n    throw new Error(`${type.name} does not have a module def (ɵmod property)`);\n}\n/**\n * Compute the pair of transitive scopes (compilation scope and exported scope) for a given module.\n *\n * This operation is memoized and the result is cached on the module's definition. This function can\n * be called on modules with components that have not fully compiled yet, but the result should not\n * be used until they have.\n *\n * @param moduleType module that transitive scope should be calculated for.\n */\nfunction transitiveScopesForNgModule(moduleType) {\n    const def = getNgModuleDef(moduleType, true);\n    if (def.transitiveCompileScopes !== null) {\n        return def.transitiveCompileScopes;\n    }\n    const scopes = {\n        schemas: def.schemas || null,\n        compilation: {\n            directives: new Set(),\n            pipes: new Set(),\n        },\n        exported: {\n            directives: new Set(),\n            pipes: new Set(),\n        },\n    };\n    maybeUnwrapFn$1(def.imports).forEach((imported) => {\n        // When this module imports another, the imported module's exported directives and pipes are\n        // added to the compilation scope of this module.\n        const importedScope = transitiveScopesFor(imported);\n        importedScope.exported.directives.forEach(entry => scopes.compilation.directives.add(entry));\n        importedScope.exported.pipes.forEach(entry => scopes.compilation.pipes.add(entry));\n    });\n    maybeUnwrapFn$1(def.declarations).forEach(declared => {\n        const declaredWithDefs = declared;\n        if (getPipeDef$1(declaredWithDefs)) {\n            scopes.compilation.pipes.add(declared);\n        }\n        else {\n            // Either declared has a ɵcmp or ɵdir, or it's a component which hasn't\n            // had its template compiled yet. In either case, it gets added to the compilation's\n            // directives.\n            scopes.compilation.directives.add(declared);\n        }\n    });\n    maybeUnwrapFn$1(def.exports).forEach((exported) => {\n        const exportedType = exported;\n        // Either the type is a module, a pipe, or a component/directive (which may not have a\n        // ɵcmp as it might be compiled asynchronously).\n        if (isNgModule$1(exportedType)) {\n            // When this module exports another, the exported module's exported directives and pipes are\n            // added to both the compilation and exported scopes of this module.\n            const exportedScope = transitiveScopesFor(exportedType);\n            exportedScope.exported.directives.forEach(entry => {\n                scopes.compilation.directives.add(entry);\n                scopes.exported.directives.add(entry);\n            });\n            exportedScope.exported.pipes.forEach(entry => {\n                scopes.compilation.pipes.add(entry);\n                scopes.exported.pipes.add(entry);\n            });\n        }\n        else if (getPipeDef$1(exportedType)) {\n            scopes.exported.pipes.add(exportedType);\n        }\n        else {\n            scopes.exported.directives.add(exportedType);\n        }\n    });\n    def.transitiveCompileScopes = scopes;\n    return scopes;\n}\nfunction expandModuleWithProviders(value) {\n    if (isModuleWithProviders$1(value)) {\n        return value.ngModule;\n    }\n    return value;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nlet _nextReferenceId = 0;\nclass MetadataOverrider {\n    constructor() {\n        this._references = new Map();\n    }\n    /**\n     * Creates a new instance for the given metadata class\n     * based on an old instance and overrides.\n     */\n    overrideMetadata(metadataClass, oldMetadata, override) {\n        const props = {};\n        if (oldMetadata) {\n            _valueProps(oldMetadata).forEach((prop) => props[prop] = oldMetadata[prop]);\n        }\n        if (override.set) {\n            if (override.remove || override.add) {\n                throw new Error(`Cannot set and add/remove ${ɵstringify(metadataClass)} at the same time!`);\n            }\n            setMetadata(props, override.set);\n        }\n        if (override.remove) {\n            removeMetadata(props, override.remove, this._references);\n        }\n        if (override.add) {\n            addMetadata(props, override.add);\n        }\n        return new metadataClass(props);\n    }\n}\nfunction removeMetadata(metadata, remove, references) {\n    const removeObjects = new Set();\n    for (const prop in remove) {\n        const removeValue = remove[prop];\n        if (Array.isArray(removeValue)) {\n            removeValue.forEach((value) => {\n                removeObjects.add(_propHashKey(prop, value, references));\n            });\n        }\n        else {\n            removeObjects.add(_propHashKey(prop, removeValue, references));\n        }\n    }\n    for (const prop in metadata) {\n        const propValue = metadata[prop];\n        if (Array.isArray(propValue)) {\n            metadata[prop] = propValue.filter((value) => !removeObjects.has(_propHashKey(prop, value, references)));\n        }\n        else {\n            if (removeObjects.has(_propHashKey(prop, propValue, references))) {\n                metadata[prop] = undefined;\n            }\n        }\n    }\n}\nfunction addMetadata(metadata, add) {\n    for (const prop in add) {\n        const addValue = add[prop];\n        const propValue = metadata[prop];\n        if (propValue != null && Array.isArray(propValue)) {\n            metadata[prop] = propValue.concat(addValue);\n        }\n        else {\n            metadata[prop] = addValue;\n        }\n    }\n}\nfunction setMetadata(metadata, set) {\n    for (const prop in set) {\n        metadata[prop] = set[prop];\n    }\n}\nfunction _propHashKey(propName, propValue, references) {\n    let nextObjectId = 0;\n    const objectIds = new Map();\n    const replacer = (key, value) => {\n        if (value !== null && typeof value === 'object') {\n            if (objectIds.has(value)) {\n                return objectIds.get(value);\n            }\n            // Record an id for this object such that any later references use the object's id instead\n            // of the object itself, in order to break cyclic pointers in objects.\n            objectIds.set(value, `ɵobj#${nextObjectId++}`);\n            // The first time an object is seen the object itself is serialized.\n            return value;\n        }\n        else if (typeof value === 'function') {\n            value = _serializeReference(value, references);\n        }\n        return value;\n    };\n    return `${propName}:${JSON.stringify(propValue, replacer)}`;\n}\nfunction _serializeReference(ref, references) {\n    let id = references.get(ref);\n    if (!id) {\n        id = `${ɵstringify(ref)}${_nextReferenceId++}`;\n        references.set(ref, id);\n    }\n    return id;\n}\nfunction _valueProps(obj) {\n    const props = [];\n    // regular public props\n    Object.keys(obj).forEach((prop) => {\n        if (!prop.startsWith('_')) {\n            props.push(prop);\n        }\n    });\n    // getters\n    let proto = obj;\n    while (proto = Object.getPrototypeOf(proto)) {\n        Object.keys(proto).forEach((protoProp) => {\n            const desc = Object.getOwnPropertyDescriptor(proto, protoProp);\n            if (!protoProp.startsWith('_') && desc && 'get' in desc) {\n                props.push(protoProp);\n            }\n        });\n    }\n    return props;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst reflection = new ɵReflectionCapabilities();\n/**\n * Allows to override ivy metadata for tests (via the `TestBed`).\n */\nclass OverrideResolver {\n    constructor() {\n        this.overrides = new Map();\n        this.resolved = new Map();\n    }\n    addOverride(type, override) {\n        const overrides = this.overrides.get(type) || [];\n        overrides.push(override);\n        this.overrides.set(type, overrides);\n        this.resolved.delete(type);\n    }\n    setOverrides(overrides) {\n        this.overrides.clear();\n        overrides.forEach(([type, override]) => {\n            this.addOverride(type, override);\n        });\n    }\n    getAnnotation(type) {\n        const annotations = reflection.annotations(type);\n        // Try to find the nearest known Type annotation and make sure that this annotation is an\n        // instance of the type we are looking for, so we can use it for resolution. Note: there might\n        // be multiple known annotations found due to the fact that Components can extend Directives (so\n        // both Directive and Component annotations would be present), so we always check if the known\n        // annotation has the right type.\n        for (let i = annotations.length - 1; i >= 0; i--) {\n            const annotation = annotations[i];\n            const isKnownType = annotation instanceof Directive || annotation instanceof Component ||\n                annotation instanceof Pipe || annotation instanceof NgModule;\n            if (isKnownType) {\n                return annotation instanceof this.type ? annotation : null;\n            }\n        }\n        return null;\n    }\n    resolve(type) {\n        let resolved = this.resolved.get(type) || null;\n        if (!resolved) {\n            resolved = this.getAnnotation(type);\n            if (resolved) {\n                const overrides = this.overrides.get(type);\n                if (overrides) {\n                    const overrider = new MetadataOverrider();\n                    overrides.forEach(override => {\n                        resolved = overrider.overrideMetadata(this.type, resolved, override);\n                    });\n                }\n            }\n            this.resolved.set(type, resolved);\n        }\n        return resolved;\n    }\n}\nclass DirectiveResolver extends OverrideResolver {\n    get type() {\n        return Directive;\n    }\n}\nclass ComponentResolver extends OverrideResolver {\n    get type() {\n        return Component;\n    }\n}\nclass PipeResolver extends OverrideResolver {\n    get type() {\n        return Pipe;\n    }\n}\nclass NgModuleResolver extends OverrideResolver {\n    get type() {\n        return NgModule;\n    }\n}\n\nvar TestingModuleOverride;\n(function (TestingModuleOverride) {\n    TestingModuleOverride[TestingModuleOverride[\"DECLARATION\"] = 0] = \"DECLARATION\";\n    TestingModuleOverride[TestingModuleOverride[\"OVERRIDE_TEMPLATE\"] = 1] = \"OVERRIDE_TEMPLATE\";\n})(TestingModuleOverride || (TestingModuleOverride = {}));\nfunction isTestingModuleOverride(value) {\n    return value === TestingModuleOverride.DECLARATION ||\n        value === TestingModuleOverride.OVERRIDE_TEMPLATE;\n}\nfunction assertNoStandaloneComponents(types, resolver, location) {\n    types.forEach(type => {\n        const component = resolver.resolve(type);\n        if (component && component.standalone) {\n            throw new Error(generateStandaloneInDeclarationsError(type, location));\n        }\n    });\n}\nclass R3TestBedCompiler {\n    constructor(platform, additionalModuleTypes) {\n        this.platform = platform;\n        this.additionalModuleTypes = additionalModuleTypes;\n        this.originalComponentResolutionQueue = null;\n        // Testing module configuration\n        this.declarations = [];\n        this.imports = [];\n        this.providers = [];\n        this.schemas = [];\n        // Queues of components/directives/pipes that should be recompiled.\n        this.pendingComponents = new Set();\n        this.pendingDirectives = new Set();\n        this.pendingPipes = new Set();\n        // Keep track of all components and directives, so we can patch Providers onto defs later.\n        this.seenComponents = new Set();\n        this.seenDirectives = new Set();\n        // Keep track of overridden modules, so that we can collect all affected ones in the module tree.\n        this.overriddenModules = new Set();\n        // Store resolved styles for Components that have template overrides present and `styleUrls`\n        // defined at the same time.\n        this.existingComponentStyles = new Map();\n        this.resolvers = initResolvers();\n        this.componentToModuleScope = new Map();\n        // Map that keeps initial version of component/directive/pipe defs in case\n        // we compile a Type again, thus overriding respective static fields. This is\n        // required to make sure we restore defs to their initial states between test runs.\n        // Note: one class may have multiple defs (for example: ɵmod and ɵinj in case of an\n        // NgModule), store all of them in a map.\n        this.initialNgDefs = new Map();\n        // Array that keeps cleanup operations for initial versions of component/directive/pipe/module\n        // defs in case TestBed makes changes to the originals.\n        this.defCleanupOps = [];\n        this._injector = null;\n        this.compilerProviders = null;\n        this.providerOverrides = [];\n        this.rootProviderOverrides = [];\n        // Overrides for injectables with `{providedIn: SomeModule}` need to be tracked and added to that\n        // module's provider list.\n        this.providerOverridesByModule = new Map();\n        this.providerOverridesByToken = new Map();\n        this.scopesWithOverriddenProviders = new Set();\n        this.testModuleRef = null;\n        class DynamicTestModule {\n        }\n        this.testModuleType = DynamicTestModule;\n    }\n    setCompilerProviders(providers) {\n        this.compilerProviders = providers;\n        this._injector = null;\n    }\n    configureTestingModule(moduleDef) {\n        // Enqueue any compilation tasks for the directly declared component.\n        if (moduleDef.declarations !== undefined) {\n            // Verify that there are no standalone components\n            assertNoStandaloneComponents(moduleDef.declarations, this.resolvers.component, '\"TestBed.configureTestingModule\" call');\n            this.queueTypeArray(moduleDef.declarations, TestingModuleOverride.DECLARATION);\n            this.declarations.push(...moduleDef.declarations);\n        }\n        // Enqueue any compilation tasks for imported modules.\n        if (moduleDef.imports !== undefined) {\n            this.queueTypesFromModulesArray(moduleDef.imports);\n            this.imports.push(...moduleDef.imports);\n        }\n        if (moduleDef.providers !== undefined) {\n            this.providers.push(...moduleDef.providers);\n        }\n        if (moduleDef.schemas !== undefined) {\n            this.schemas.push(...moduleDef.schemas);\n        }\n    }\n    overrideModule(ngModule, override) {\n        this.overriddenModules.add(ngModule);\n        // Compile the module right away.\n        this.resolvers.module.addOverride(ngModule, override);\n        const metadata = this.resolvers.module.resolve(ngModule);\n        if (metadata === null) {\n            throw invalidTypeError(ngModule.name, 'NgModule');\n        }\n        this.recompileNgModule(ngModule, metadata);\n        // At this point, the module has a valid module def (ɵmod), but the override may have introduced\n        // new declarations or imported modules. Ingest any possible new types and add them to the\n        // current queue.\n        this.queueTypesFromModulesArray([ngModule]);\n    }\n    overrideComponent(component, override) {\n        this.verifyNoStandaloneFlagOverrides(component, override);\n        this.resolvers.component.addOverride(component, override);\n        this.pendingComponents.add(component);\n    }\n    overrideDirective(directive, override) {\n        this.verifyNoStandaloneFlagOverrides(directive, override);\n        this.resolvers.directive.addOverride(directive, override);\n        this.pendingDirectives.add(directive);\n    }\n    overridePipe(pipe, override) {\n        this.verifyNoStandaloneFlagOverrides(pipe, override);\n        this.resolvers.pipe.addOverride(pipe, override);\n        this.pendingPipes.add(pipe);\n    }\n    verifyNoStandaloneFlagOverrides(type, override) {\n        var _a, _b, _c;\n        if (((_a = override.add) === null || _a === void 0 ? void 0 : _a.hasOwnProperty('standalone')) || ((_b = override.set) === null || _b === void 0 ? void 0 : _b.hasOwnProperty('standalone')) ||\n            ((_c = override.remove) === null || _c === void 0 ? void 0 : _c.hasOwnProperty('standalone'))) {\n            throw new Error(`An override for the ${type.name} class has the \\`standalone\\` flag. ` +\n                `Changing the \\`standalone\\` flag via TestBed overrides is not supported.`);\n        }\n    }\n    overrideProvider(token, provider) {\n        let providerDef;\n        if (provider.useFactory !== undefined) {\n            providerDef = {\n                provide: token,\n                useFactory: provider.useFactory,\n                deps: provider.deps || [],\n                multi: provider.multi\n            };\n        }\n        else if (provider.useValue !== undefined) {\n            providerDef = { provide: token, useValue: provider.useValue, multi: provider.multi };\n        }\n        else {\n            providerDef = { provide: token };\n        }\n        const injectableDef = typeof token !== 'string' ? ɵgetInjectableDef(token) : null;\n        const providedIn = injectableDef === null ? null : resolveForwardRef$1(injectableDef.providedIn);\n        const overridesBucket = providedIn === 'root' ? this.rootProviderOverrides : this.providerOverrides;\n        overridesBucket.push(providerDef);\n        // Keep overrides grouped by token as well for fast lookups using token\n        this.providerOverridesByToken.set(token, providerDef);\n        if (injectableDef !== null && providedIn !== null && typeof providedIn !== 'string') {\n            const existingOverrides = this.providerOverridesByModule.get(providedIn);\n            if (existingOverrides !== undefined) {\n                existingOverrides.push(providerDef);\n            }\n            else {\n                this.providerOverridesByModule.set(providedIn, [providerDef]);\n            }\n        }\n    }\n    overrideTemplateUsingTestingModule(type, template) {\n        const def = type[ɵNG_COMP_DEF];\n        const hasStyleUrls = () => {\n            const metadata = this.resolvers.component.resolve(type);\n            return !!metadata.styleUrls && metadata.styleUrls.length > 0;\n        };\n        const overrideStyleUrls = !!def && !isComponentDefPendingResolution(type) && hasStyleUrls();\n        // In Ivy, compiling a component does not require knowing the module providing the\n        // component's scope, so overrideTemplateUsingTestingModule can be implemented purely via\n        // overrideComponent. Important: overriding template requires full Component re-compilation,\n        // which may fail in case styleUrls are also present (thus Component is considered as required\n        // resolution). In order to avoid this, we preemptively set styleUrls to an empty array,\n        // preserve current styles available on Component def and restore styles back once compilation\n        // is complete.\n        const override = overrideStyleUrls ? { template, styles: [], styleUrls: [] } : { template };\n        this.overrideComponent(type, { set: override });\n        if (overrideStyleUrls && def.styles && def.styles.length > 0) {\n            this.existingComponentStyles.set(type, def.styles);\n        }\n        // Set the component's scope to be the testing module.\n        this.componentToModuleScope.set(type, TestingModuleOverride.OVERRIDE_TEMPLATE);\n    }\n    compileComponents() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.clearComponentResolutionQueue();\n            // Run compilers for all queued types.\n            let needsAsyncResources = this.compileTypesSync();\n            // compileComponents() should not be async unless it needs to be.\n            if (needsAsyncResources) {\n                let resourceLoader;\n                let resolver = (url) => {\n                    if (!resourceLoader) {\n                        resourceLoader = this.injector.get(ResourceLoader);\n                    }\n                    return Promise.resolve(resourceLoader.get(url));\n                };\n                yield resolveComponentResources(resolver);\n            }\n        });\n    }\n    finalize() {\n        // One last compile\n        this.compileTypesSync();\n        // Create the testing module itself.\n        this.compileTestModule();\n        this.applyTransitiveScopes();\n        this.applyProviderOverrides();\n        // Patch previously stored `styles` Component values (taken from ɵcmp), in case these\n        // Components have `styleUrls` fields defined and template override was requested.\n        this.patchComponentsWithExistingStyles();\n        // Clear the componentToModuleScope map, so that future compilations don't reset the scope of\n        // every component.\n        this.componentToModuleScope.clear();\n        const parentInjector = this.platform.injector;\n        this.testModuleRef = new ɵRender3NgModuleRef(this.testModuleType, parentInjector);\n        // ApplicationInitStatus.runInitializers() is marked @internal to core.\n        // Cast it to any before accessing it.\n        this.testModuleRef.injector.get(ApplicationInitStatus).runInitializers();\n        // Set locale ID after running app initializers, since locale information might be updated while\n        // running initializers. This is also consistent with the execution order while bootstrapping an\n        // app (see `packages/core/src/application_ref.ts` file).\n        const localeId = this.testModuleRef.injector.get(LOCALE_ID$1, ɵDEFAULT_LOCALE_ID);\n        ɵsetLocaleId(localeId);\n        return this.testModuleRef;\n    }\n    /**\n     * @internal\n     */\n    _compileNgModuleSync(moduleType) {\n        this.queueTypesFromModulesArray([moduleType]);\n        this.compileTypesSync();\n        this.applyProviderOverrides();\n        this.applyProviderOverridesInScope(moduleType);\n        this.applyTransitiveScopes();\n    }\n    /**\n     * @internal\n     */\n    _compileNgModuleAsync(moduleType) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.queueTypesFromModulesArray([moduleType]);\n            yield this.compileComponents();\n            this.applyProviderOverrides();\n            this.applyProviderOverridesInScope(moduleType);\n            this.applyTransitiveScopes();\n        });\n    }\n    /**\n     * @internal\n     */\n    _getModuleResolver() {\n        return this.resolvers.module;\n    }\n    /**\n     * @internal\n     */\n    _getComponentFactories(moduleType) {\n        return maybeUnwrapFn(moduleType.ɵmod.declarations).reduce((factories, declaration) => {\n            const componentDef = declaration.ɵcmp;\n            componentDef && factories.push(new ɵRender3ComponentFactory(componentDef, this.testModuleRef));\n            return factories;\n        }, []);\n    }\n    compileTypesSync() {\n        // Compile all queued components, directives, pipes.\n        let needsAsyncResources = false;\n        this.pendingComponents.forEach(declaration => {\n            needsAsyncResources = needsAsyncResources || isComponentDefPendingResolution(declaration);\n            const metadata = this.resolvers.component.resolve(declaration);\n            if (metadata === null) {\n                throw invalidTypeError(declaration.name, 'Component');\n            }\n            this.maybeStoreNgDef(ɵNG_COMP_DEF, declaration);\n            ɵcompileComponent(declaration, metadata);\n        });\n        this.pendingComponents.clear();\n        this.pendingDirectives.forEach(declaration => {\n            const metadata = this.resolvers.directive.resolve(declaration);\n            if (metadata === null) {\n                throw invalidTypeError(declaration.name, 'Directive');\n            }\n            this.maybeStoreNgDef(ɵNG_DIR_DEF, declaration);\n            ɵcompileDirective(declaration, metadata);\n        });\n        this.pendingDirectives.clear();\n        this.pendingPipes.forEach(declaration => {\n            const metadata = this.resolvers.pipe.resolve(declaration);\n            if (metadata === null) {\n                throw invalidTypeError(declaration.name, 'Pipe');\n            }\n            this.maybeStoreNgDef(ɵNG_PIPE_DEF, declaration);\n            ɵcompilePipe(declaration, metadata);\n        });\n        this.pendingPipes.clear();\n        return needsAsyncResources;\n    }\n    applyTransitiveScopes() {\n        if (this.overriddenModules.size > 0) {\n            // Module overrides (via `TestBed.overrideModule`) might affect scopes that were previously\n            // calculated and stored in `transitiveCompileScopes`. If module overrides are present,\n            // collect all affected modules and reset scopes to force their re-calculation.\n            const testingModuleDef = this.testModuleType[ɵNG_MOD_DEF];\n            const affectedModules = this.collectModulesAffectedByOverrides(testingModuleDef.imports);\n            if (affectedModules.size > 0) {\n                affectedModules.forEach(moduleType => {\n                    this.storeFieldOfDefOnType(moduleType, ɵNG_MOD_DEF, 'transitiveCompileScopes');\n                    moduleType[ɵNG_MOD_DEF].transitiveCompileScopes = null;\n                });\n            }\n        }\n        const moduleToScope = new Map();\n        const getScopeOfModule = (moduleType) => {\n            if (!moduleToScope.has(moduleType)) {\n                const isTestingModule = isTestingModuleOverride(moduleType);\n                const realType = isTestingModule ? this.testModuleType : moduleType;\n                moduleToScope.set(moduleType, ɵtransitiveScopesFor(realType));\n            }\n            return moduleToScope.get(moduleType);\n        };\n        this.componentToModuleScope.forEach((moduleType, componentType) => {\n            const moduleScope = getScopeOfModule(moduleType);\n            this.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'directiveDefs');\n            this.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'pipeDefs');\n            // `tView` that is stored on component def contains information about directives and pipes\n            // that are in the scope of this component. Patching component scope will cause `tView` to be\n            // changed. Store original `tView` before patching scope, so the `tView` (including scope\n            // information) is restored back to its previous/original state before running next test.\n            this.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'tView');\n            ɵpatchComponentDefWithScope(componentType.ɵcmp, moduleScope);\n        });\n        this.componentToModuleScope.clear();\n    }\n    applyProviderOverrides() {\n        const maybeApplyOverrides = (field) => (type) => {\n            const resolver = field === ɵNG_COMP_DEF ? this.resolvers.component : this.resolvers.directive;\n            const metadata = resolver.resolve(type);\n            if (this.hasProviderOverrides(metadata.providers)) {\n                this.patchDefWithProviderOverrides(type, field);\n            }\n        };\n        this.seenComponents.forEach(maybeApplyOverrides(ɵNG_COMP_DEF));\n        this.seenDirectives.forEach(maybeApplyOverrides(ɵNG_DIR_DEF));\n        this.seenComponents.clear();\n        this.seenDirectives.clear();\n    }\n    /**\n     * Applies provider overrides to a given type (either an NgModule or a standalone component)\n     * and all imported NgModules and standalone components recursively.\n     */\n    applyProviderOverridesInScope(type) {\n        var _a;\n        const hasScope = isStandaloneComponent(type) || isNgModule(type);\n        // The function can be re-entered recursively while inspecting dependencies\n        // of an NgModule or a standalone component. Exit early if we come across a\n        // type that can not have a scope (directive or pipe) or the type is already\n        // processed earlier.\n        if (!hasScope || this.scopesWithOverriddenProviders.has(type)) {\n            return;\n        }\n        this.scopesWithOverriddenProviders.add(type);\n        // NOTE: the line below triggers JIT compilation of the module injector,\n        // which also invokes verification of the NgModule semantics, which produces\n        // detailed error messages. The fact that the code relies on this line being\n        // present here is suspicious and should be refactored in a way that the line\n        // below can be moved (for ex. after an early exit check below).\n        const injectorDef = type[ɵNG_INJ_DEF];\n        // No provider overrides, exit early.\n        if (this.providerOverridesByToken.size === 0)\n            return;\n        if (isStandaloneComponent(type)) {\n            // Visit all component dependencies and override providers there.\n            const def = getComponentDef(type);\n            const dependencies = maybeUnwrapFn((_a = def.dependencies) !== null && _a !== void 0 ? _a : []);\n            for (const dependency of dependencies) {\n                this.applyProviderOverridesInScope(dependency);\n            }\n        }\n        else {\n            const providers = [\n                ...injectorDef.providers,\n                ...(this.providerOverridesByModule.get(type) || [])\n            ];\n            if (this.hasProviderOverrides(providers)) {\n                this.maybeStoreNgDef(ɵNG_INJ_DEF, type);\n                this.storeFieldOfDefOnType(type, ɵNG_INJ_DEF, 'providers');\n                injectorDef.providers = this.getOverriddenProviders(providers);\n            }\n            // Apply provider overrides to imported modules recursively\n            const moduleDef = type[ɵNG_MOD_DEF];\n            const imports = maybeUnwrapFn(moduleDef.imports);\n            for (const importedModule of imports) {\n                this.applyProviderOverridesInScope(importedModule);\n            }\n            // Also override the providers on any ModuleWithProviders imports since those don't appear in\n            // the moduleDef.\n            for (const importedModule of flatten(injectorDef.imports)) {\n                if (isModuleWithProviders(importedModule)) {\n                    this.defCleanupOps.push({\n                        object: importedModule,\n                        fieldName: 'providers',\n                        originalValue: importedModule.providers\n                    });\n                    importedModule.providers = this.getOverriddenProviders(importedModule.providers);\n                }\n            }\n        }\n    }\n    patchComponentsWithExistingStyles() {\n        this.existingComponentStyles.forEach((styles, type) => type[ɵNG_COMP_DEF].styles = styles);\n        this.existingComponentStyles.clear();\n    }\n    queueTypeArray(arr, moduleType) {\n        for (const value of arr) {\n            if (Array.isArray(value)) {\n                this.queueTypeArray(value, moduleType);\n            }\n            else {\n                this.queueType(value, moduleType);\n            }\n        }\n    }\n    recompileNgModule(ngModule, metadata) {\n        // Cache the initial ngModuleDef as it will be overwritten.\n        this.maybeStoreNgDef(ɵNG_MOD_DEF, ngModule);\n        this.maybeStoreNgDef(ɵNG_INJ_DEF, ngModule);\n        ɵcompileNgModuleDefs(ngModule, metadata);\n    }\n    queueType(type, moduleType) {\n        const component = this.resolvers.component.resolve(type);\n        if (component) {\n            // Check whether a give Type has respective NG def (ɵcmp) and compile if def is\n            // missing. That might happen in case a class without any Angular decorators extends another\n            // class where Component/Directive/Pipe decorator is defined.\n            if (isComponentDefPendingResolution(type) || !type.hasOwnProperty(ɵNG_COMP_DEF)) {\n                this.pendingComponents.add(type);\n            }\n            this.seenComponents.add(type);\n            // Keep track of the module which declares this component, so later the component's scope\n            // can be set correctly. If the component has already been recorded here, then one of several\n            // cases is true:\n            // * the module containing the component was imported multiple times (common).\n            // * the component is declared in multiple modules (which is an error).\n            // * the component was in 'declarations' of the testing module, and also in an imported module\n            //   in which case the module scope will be TestingModuleOverride.DECLARATION.\n            // * overrideTemplateUsingTestingModule was called for the component in which case the module\n            //   scope will be TestingModuleOverride.OVERRIDE_TEMPLATE.\n            //\n            // If the component was previously in the testing module's 'declarations' (meaning the\n            // current value is TestingModuleOverride.DECLARATION), then `moduleType` is the component's\n            // real module, which was imported. This pattern is understood to mean that the component\n            // should use its original scope, but that the testing module should also contain the\n            // component in its scope.\n            //\n            // Note: standalone components have no associated NgModule, so the `moduleType` can be `null`.\n            if (moduleType !== null &&\n                (!this.componentToModuleScope.has(type) ||\n                    this.componentToModuleScope.get(type) === TestingModuleOverride.DECLARATION)) {\n                this.componentToModuleScope.set(type, moduleType);\n            }\n            return;\n        }\n        const directive = this.resolvers.directive.resolve(type);\n        if (directive) {\n            if (!type.hasOwnProperty(ɵNG_DIR_DEF)) {\n                this.pendingDirectives.add(type);\n            }\n            this.seenDirectives.add(type);\n            return;\n        }\n        const pipe = this.resolvers.pipe.resolve(type);\n        if (pipe && !type.hasOwnProperty(ɵNG_PIPE_DEF)) {\n            this.pendingPipes.add(type);\n            return;\n        }\n    }\n    queueTypesFromModulesArray(arr) {\n        // Because we may encounter the same NgModule while processing the imports and exports of an\n        // NgModule tree, we cache them in this set so we can skip ones that have already been seen\n        // encountered. In some test setups, this caching resulted in 10X runtime improvement.\n        const processedNgModuleDefs = new Set();\n        const queueTypesFromModulesArrayRecur = (arr) => {\n            var _a;\n            for (const value of arr) {\n                if (Array.isArray(value)) {\n                    queueTypesFromModulesArrayRecur(value);\n                }\n                else if (hasNgModuleDef(value)) {\n                    const def = value.ɵmod;\n                    if (processedNgModuleDefs.has(def)) {\n                        continue;\n                    }\n                    processedNgModuleDefs.add(def);\n                    // Look through declarations, imports, and exports, and queue\n                    // everything found there.\n                    this.queueTypeArray(maybeUnwrapFn(def.declarations), value);\n                    queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.imports));\n                    queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.exports));\n                }\n                else if (isModuleWithProviders(value)) {\n                    queueTypesFromModulesArrayRecur([value.ngModule]);\n                }\n                else if (isStandaloneComponent(value)) {\n                    this.queueType(value, null);\n                    const def = getComponentDef(value);\n                    const dependencies = maybeUnwrapFn((_a = def.dependencies) !== null && _a !== void 0 ? _a : []);\n                    dependencies.forEach((dependency) => {\n                        // Note: in AOT, the `dependencies` might also contain regular\n                        // (NgModule-based) Component, Directive and Pipes, so we handle\n                        // them separately and proceed with recursive process for standalone\n                        // Components and NgModules only.\n                        if (isStandaloneComponent(dependency) || hasNgModuleDef(dependency)) {\n                            queueTypesFromModulesArrayRecur([dependency]);\n                        }\n                        else {\n                            this.queueType(dependency, null);\n                        }\n                    });\n                }\n            }\n        };\n        queueTypesFromModulesArrayRecur(arr);\n    }\n    // When module overrides (via `TestBed.overrideModule`) are present, it might affect all modules\n    // that import (even transitively) an overridden one. For all affected modules we need to\n    // recalculate their scopes for a given test run and restore original scopes at the end. The goal\n    // of this function is to collect all affected modules in a set for further processing. Example:\n    // if we have the following module hierarchy: A -> B -> C (where `->` means `imports`) and module\n    // `C` is overridden, we consider `A` and `B` as affected, since their scopes might become\n    // invalidated with the override.\n    collectModulesAffectedByOverrides(arr) {\n        const seenModules = new Set();\n        const affectedModules = new Set();\n        const calcAffectedModulesRecur = (arr, path) => {\n            for (const value of arr) {\n                if (Array.isArray(value)) {\n                    // If the value is an array, just flatten it (by invoking this function recursively),\n                    // keeping \"path\" the same.\n                    calcAffectedModulesRecur(value, path);\n                }\n                else if (hasNgModuleDef(value)) {\n                    if (seenModules.has(value)) {\n                        // If we've seen this module before and it's included into \"affected modules\" list, mark\n                        // the whole path that leads to that module as affected, but do not descend into its\n                        // imports, since we already examined them before.\n                        if (affectedModules.has(value)) {\n                            path.forEach(item => affectedModules.add(item));\n                        }\n                        continue;\n                    }\n                    seenModules.add(value);\n                    if (this.overriddenModules.has(value)) {\n                        path.forEach(item => affectedModules.add(item));\n                    }\n                    // Examine module imports recursively to look for overridden modules.\n                    const moduleDef = value[ɵNG_MOD_DEF];\n                    calcAffectedModulesRecur(maybeUnwrapFn(moduleDef.imports), path.concat(value));\n                }\n            }\n        };\n        calcAffectedModulesRecur(arr, []);\n        return affectedModules;\n    }\n    /**\n     * Preserve an original def (such as ɵmod, ɵinj, etc) before applying an override.\n     * Note: one class may have multiple defs (for example: ɵmod and ɵinj in case of\n     * an NgModule). If there is a def in a set already, don't override it, since\n     * an original one should be restored at the end of a test.\n     */\n    maybeStoreNgDef(prop, type) {\n        if (!this.initialNgDefs.has(type)) {\n            this.initialNgDefs.set(type, new Map());\n        }\n        const currentDefs = this.initialNgDefs.get(type);\n        if (!currentDefs.has(prop)) {\n            const currentDef = Object.getOwnPropertyDescriptor(type, prop);\n            currentDefs.set(prop, currentDef);\n        }\n    }\n    storeFieldOfDefOnType(type, defField, fieldName) {\n        const def = type[defField];\n        const originalValue = def[fieldName];\n        this.defCleanupOps.push({ object: def, fieldName, originalValue });\n    }\n    /**\n     * Clears current components resolution queue, but stores the state of the queue, so we can\n     * restore it later. Clearing the queue is required before we try to compile components (via\n     * `TestBed.compileComponents`), so that component defs are in sync with the resolution queue.\n     */\n    clearComponentResolutionQueue() {\n        if (this.originalComponentResolutionQueue === null) {\n            this.originalComponentResolutionQueue = new Map();\n        }\n        clearResolutionOfComponentResourcesQueue().forEach((value, key) => this.originalComponentResolutionQueue.set(key, value));\n    }\n    /*\n     * Restores component resolution queue to the previously saved state. This operation is performed\n     * as a part of restoring the state after completion of the current set of tests (that might\n     * potentially mutate the state).\n     */\n    restoreComponentResolutionQueue() {\n        if (this.originalComponentResolutionQueue !== null) {\n            restoreComponentResolutionQueue(this.originalComponentResolutionQueue);\n            this.originalComponentResolutionQueue = null;\n        }\n    }\n    restoreOriginalState() {\n        // Process cleanup ops in reverse order so the field's original value is restored correctly (in\n        // case there were multiple overrides for the same field).\n        forEachRight(this.defCleanupOps, (op) => {\n            op.object[op.fieldName] = op.originalValue;\n        });\n        // Restore initial component/directive/pipe defs\n        this.initialNgDefs.forEach((defs, type) => {\n            defs.forEach((descriptor, prop) => {\n                if (!descriptor) {\n                    // Delete operations are generally undesirable since they have performance\n                    // implications on objects they were applied to. In this particular case, situations\n                    // where this code is invoked should be quite rare to cause any noticeable impact,\n                    // since it's applied only to some test cases (for example when class with no\n                    // annotations extends some @Component) when we need to clear 'ɵcmp' field on a given\n                    // class to restore its original state (before applying overrides and running tests).\n                    delete type[prop];\n                }\n                else {\n                    Object.defineProperty(type, prop, descriptor);\n                }\n            });\n        });\n        this.initialNgDefs.clear();\n        this.scopesWithOverriddenProviders.clear();\n        this.restoreComponentResolutionQueue();\n        // Restore the locale ID to the default value, this shouldn't be necessary but we never know\n        ɵsetLocaleId(ɵDEFAULT_LOCALE_ID);\n    }\n    compileTestModule() {\n        class RootScopeModule {\n        }\n        ɵcompileNgModuleDefs(RootScopeModule, {\n            providers: [...this.rootProviderOverrides],\n        });\n        const ngZone = new NgZone({ enableLongStackTrace: true });\n        const providers = [\n            { provide: NgZone, useValue: ngZone },\n            { provide: Compiler, useFactory: () => new R3TestCompiler(this) },\n            ...this.providers,\n            ...this.providerOverrides,\n        ];\n        const imports = [RootScopeModule, this.additionalModuleTypes, this.imports || []];\n        // clang-format off\n        ɵcompileNgModuleDefs(this.testModuleType, {\n            declarations: this.declarations,\n            imports,\n            schemas: this.schemas,\n            providers,\n        }, /* allowDuplicateDeclarationsInRoot */ true);\n        // clang-format on\n        this.applyProviderOverridesInScope(this.testModuleType);\n    }\n    get injector() {\n        if (this._injector !== null) {\n            return this._injector;\n        }\n        const providers = [];\n        const compilerOptions = this.platform.injector.get(COMPILER_OPTIONS);\n        compilerOptions.forEach(opts => {\n            if (opts.providers) {\n                providers.push(opts.providers);\n            }\n        });\n        if (this.compilerProviders !== null) {\n            providers.push(...this.compilerProviders);\n        }\n        // TODO(ocombe): make this work with an Injector directly instead of creating a module for it\n        class CompilerModule {\n        }\n        ɵcompileNgModuleDefs(CompilerModule, { providers });\n        const CompilerModuleFactory = new ɵNgModuleFactory(CompilerModule);\n        this._injector = CompilerModuleFactory.create(this.platform.injector).injector;\n        return this._injector;\n    }\n    // get overrides for a specific provider (if any)\n    getSingleProviderOverrides(provider) {\n        const token = getProviderToken(provider);\n        return this.providerOverridesByToken.get(token) || null;\n    }\n    getProviderOverrides(providers) {\n        if (!providers || !providers.length || this.providerOverridesByToken.size === 0)\n            return [];\n        // There are two flattening operations here. The inner flatten() operates on the metadata's\n        // providers and applies a mapping function which retrieves overrides for each incoming\n        // provider. The outer flatten() then flattens the produced overrides array. If this is not\n        // done, the array can contain other empty arrays (e.g. `[[], []]`) which leak into the\n        // providers array and contaminate any error messages that might be generated.\n        return flatten(flatten(providers, (provider) => this.getSingleProviderOverrides(provider) || []));\n    }\n    getOverriddenProviders(providers) {\n        if (!providers || !providers.length || this.providerOverridesByToken.size === 0)\n            return [];\n        const flattenedProviders = flatten(providers);\n        const overrides = this.getProviderOverrides(flattenedProviders);\n        const overriddenProviders = [...flattenedProviders, ...overrides];\n        const final = [];\n        const seenOverriddenProviders = new Set();\n        // We iterate through the list of providers in reverse order to make sure provider overrides\n        // take precedence over the values defined in provider list. We also filter out all providers\n        // that have overrides, keeping overridden values only. This is needed, since presence of a\n        // provider with `ngOnDestroy` hook will cause this hook to be registered and invoked later.\n        forEachRight(overriddenProviders, (provider) => {\n            const token = getProviderToken(provider);\n            if (this.providerOverridesByToken.has(token)) {\n                if (!seenOverriddenProviders.has(token)) {\n                    seenOverriddenProviders.add(token);\n                    // Treat all overridden providers as `{multi: false}` (even if it's a multi-provider) to\n                    // make sure that provided override takes highest precedence and is not combined with\n                    // other instances of the same multi provider.\n                    final.unshift(Object.assign(Object.assign({}, provider), { multi: false }));\n                }\n            }\n            else {\n                final.unshift(provider);\n            }\n        });\n        return final;\n    }\n    hasProviderOverrides(providers) {\n        return this.getProviderOverrides(providers).length > 0;\n    }\n    patchDefWithProviderOverrides(declaration, field) {\n        const def = declaration[field];\n        if (def && def.providersResolver) {\n            this.maybeStoreNgDef(field, declaration);\n            const resolver = def.providersResolver;\n            const processProvidersFn = (providers) => this.getOverriddenProviders(providers);\n            this.storeFieldOfDefOnType(declaration, field, 'providersResolver');\n            def.providersResolver = (ngDef) => resolver(ngDef, processProvidersFn);\n        }\n    }\n}\nfunction initResolvers() {\n    return {\n        module: new NgModuleResolver(),\n        component: new ComponentResolver(),\n        directive: new DirectiveResolver(),\n        pipe: new PipeResolver()\n    };\n}\nfunction isStandaloneComponent(value) {\n    const def = getComponentDef(value);\n    return !!(def === null || def === void 0 ? void 0 : def.standalone);\n}\nfunction getComponentDef(value) {\n    var _a;\n    return (_a = value.ɵcmp) !== null && _a !== void 0 ? _a : null;\n}\nfunction hasNgModuleDef(value) {\n    return value.hasOwnProperty('ɵmod');\n}\nfunction isNgModule(value) {\n    return hasNgModuleDef(value);\n}\nfunction maybeUnwrapFn(maybeFn) {\n    return maybeFn instanceof Function ? maybeFn() : maybeFn;\n}\nfunction flatten(values, mapFn) {\n    const out = [];\n    values.forEach(value => {\n        if (Array.isArray(value)) {\n            out.push(...flatten(value, mapFn));\n        }\n        else {\n            out.push(mapFn ? mapFn(value) : value);\n        }\n    });\n    return out;\n}\nfunction getProviderField(provider, field) {\n    return provider && typeof provider === 'object' && provider[field];\n}\nfunction getProviderToken(provider) {\n    return getProviderField(provider, 'provide') || provider;\n}\nfunction isModuleWithProviders(value) {\n    return value.hasOwnProperty('ngModule');\n}\nfunction forEachRight(values, fn) {\n    for (let idx = values.length - 1; idx >= 0; idx--) {\n        fn(values[idx], idx);\n    }\n}\nfunction invalidTypeError(name, expectedType) {\n    return new Error(`${name} class doesn't have @${expectedType} decorator or is missing metadata.`);\n}\nclass R3TestCompiler {\n    constructor(testBed) {\n        this.testBed = testBed;\n    }\n    compileModuleSync(moduleType) {\n        this.testBed._compileNgModuleSync(moduleType);\n        return new ɵNgModuleFactory(moduleType);\n    }\n    compileModuleAsync(moduleType) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.testBed._compileNgModuleAsync(moduleType);\n            return new ɵNgModuleFactory(moduleType);\n        });\n    }\n    compileModuleAndAllComponentsSync(moduleType) {\n        const ngModuleFactory = this.compileModuleSync(moduleType);\n        const componentFactories = this.testBed._getComponentFactories(moduleType);\n        return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n    }\n    compileModuleAndAllComponentsAsync(moduleType) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const ngModuleFactory = yield this.compileModuleAsync(moduleType);\n            const componentFactories = this.testBed._getComponentFactories(moduleType);\n            return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n        });\n    }\n    clearCache() { }\n    clearCacheFor(type) { }\n    getModuleId(moduleType) {\n        const meta = this.testBed._getModuleResolver().resolve(moduleType);\n        return meta && meta.id || undefined;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Whether test modules should be torn down by default. */\nconst TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT = true;\n/** Whether unknown elements in templates should throw by default. */\nconst THROW_ON_UNKNOWN_ELEMENTS_DEFAULT = false;\n/** Whether unknown properties in templates should throw by default. */\nconst THROW_ON_UNKNOWN_PROPERTIES_DEFAULT = false;\n/**\n * An abstract class for inserting the root test component element in a platform independent way.\n *\n * @publicApi\n */\nclass TestComponentRenderer {\n    insertRootElement(rootElementId) { }\n    removeAllRootElements() { }\n}\n/**\n * @publicApi\n */\nconst ComponentFixtureAutoDetect = new InjectionToken$1('ComponentFixtureAutoDetect');\n/**\n * @publicApi\n */\nconst ComponentFixtureNoNgZone = new InjectionToken$1('ComponentFixtureNoNgZone');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nlet _nextRootElementId = 0;\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * TestBed is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n */\nclass TestBedRender3 {\n    constructor() {\n        // Properties\n        this.platform = null;\n        this.ngModule = null;\n        this._compiler = null;\n        this._testModuleRef = null;\n        this._activeFixtures = [];\n        this._globalCompilationChecked = false;\n    }\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     *\n     * @publicApi\n     */\n    static initTestEnvironment(ngModule, platform, options) {\n        const testBed = _getTestBedRender3();\n        testBed.initTestEnvironment(ngModule, platform, options);\n        return testBed;\n    }\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @publicApi\n     */\n    static resetTestEnvironment() {\n        _getTestBedRender3().resetTestEnvironment();\n    }\n    static configureCompiler(config) {\n        _getTestBedRender3().configureCompiler(config);\n        return TestBedRender3;\n    }\n    /**\n     * Allows overriding default providers, directives, pipes, modules of the test injector,\n     * which are defined in test_injector.js\n     */\n    static configureTestingModule(moduleDef) {\n        _getTestBedRender3().configureTestingModule(moduleDef);\n        return TestBedRender3;\n    }\n    /**\n     * Compile components with a `templateUrl` for the test's NgModule.\n     * It is necessary to call this function\n     * as fetching urls is asynchronous.\n     */\n    static compileComponents() {\n        return _getTestBedRender3().compileComponents();\n    }\n    static overrideModule(ngModule, override) {\n        _getTestBedRender3().overrideModule(ngModule, override);\n        return TestBedRender3;\n    }\n    static overrideComponent(component, override) {\n        _getTestBedRender3().overrideComponent(component, override);\n        return TestBedRender3;\n    }\n    static overrideDirective(directive, override) {\n        _getTestBedRender3().overrideDirective(directive, override);\n        return TestBedRender3;\n    }\n    static overridePipe(pipe, override) {\n        _getTestBedRender3().overridePipe(pipe, override);\n        return TestBedRender3;\n    }\n    static overrideTemplate(component, template) {\n        _getTestBedRender3().overrideComponent(component, { set: { template, templateUrl: null } });\n        return TestBedRender3;\n    }\n    /**\n     * Overrides the template of the given component, compiling the template\n     * in the context of the TestingModule.\n     *\n     * Note: This works for JIT and AOTed components as well.\n     */\n    static overrideTemplateUsingTestingModule(component, template) {\n        _getTestBedRender3().overrideTemplateUsingTestingModule(component, template);\n        return TestBedRender3;\n    }\n    static overrideProvider(token, provider) {\n        _getTestBedRender3().overrideProvider(token, provider);\n        return TestBedRender3;\n    }\n    static inject(token, notFoundValue, flags) {\n        return _getTestBedRender3().inject(token, notFoundValue, flags);\n    }\n    /** @deprecated from v9.0.0 use TestBed.inject */\n    static get(token, notFoundValue = Injector$1.THROW_IF_NOT_FOUND, flags = InjectFlags$1.Default) {\n        return _getTestBedRender3().inject(token, notFoundValue, flags);\n    }\n    static createComponent(component) {\n        return _getTestBedRender3().createComponent(component);\n    }\n    static resetTestingModule() {\n        _getTestBedRender3().resetTestingModule();\n        return TestBedRender3;\n    }\n    static shouldTearDownTestingModule() {\n        return _getTestBedRender3().shouldTearDownTestingModule();\n    }\n    static tearDownTestingModule() {\n        _getTestBedRender3().tearDownTestingModule();\n    }\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     *\n     * @publicApi\n     */\n    initTestEnvironment(ngModule, platform, options) {\n        if (this.platform || this.ngModule) {\n            throw new Error('Cannot set base providers because it has already been called');\n        }\n        TestBedRender3._environmentTeardownOptions = options === null || options === void 0 ? void 0 : options.teardown;\n        TestBedRender3._environmentErrorOnUnknownElementsOption = options === null || options === void 0 ? void 0 : options.errorOnUnknownElements;\n        TestBedRender3._environmentErrorOnUnknownPropertiesOption = options === null || options === void 0 ? void 0 : options.errorOnUnknownProperties;\n        this.platform = platform;\n        this.ngModule = ngModule;\n        this._compiler = new R3TestBedCompiler(this.platform, this.ngModule);\n        // TestBed does not have an API which can reliably detect the start of a test, and thus could be\n        // used to track the state of the NgModule registry and reset it correctly. Instead, when we\n        // know we're in a testing scenario, we disable the check for duplicate NgModule registration\n        // completely.\n        ɵsetAllowDuplicateNgModuleIdsForTest(true);\n    }\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @publicApi\n     */\n    resetTestEnvironment() {\n        this.resetTestingModule();\n        this._compiler = null;\n        this.platform = null;\n        this.ngModule = null;\n        TestBedRender3._environmentTeardownOptions = undefined;\n        ɵsetAllowDuplicateNgModuleIdsForTest(false);\n    }\n    resetTestingModule() {\n        var _a, _b;\n        this.checkGlobalCompilationFinished();\n        ɵresetCompiledComponents();\n        if (this._compiler !== null) {\n            this.compiler.restoreOriginalState();\n        }\n        this._compiler = new R3TestBedCompiler(this.platform, this.ngModule);\n        // Restore the previous value of the \"error on unknown elements\" option\n        ɵsetUnknownElementStrictMode$1((_a = this._previousErrorOnUnknownElementsOption) !== null && _a !== void 0 ? _a : THROW_ON_UNKNOWN_ELEMENTS_DEFAULT);\n        // Restore the previous value of the \"error on unknown properties\" option\n        ɵsetUnknownPropertyStrictMode$1((_b = this._previousErrorOnUnknownPropertiesOption) !== null && _b !== void 0 ? _b : THROW_ON_UNKNOWN_PROPERTIES_DEFAULT);\n        // We have to chain a couple of try/finally blocks, because each step can\n        // throw errors and we don't want it to interrupt the next step and we also\n        // want an error to be thrown at the end.\n        try {\n            this.destroyActiveFixtures();\n        }\n        finally {\n            try {\n                if (this.shouldTearDownTestingModule()) {\n                    this.tearDownTestingModule();\n                }\n            }\n            finally {\n                this._testModuleRef = null;\n                this._instanceTeardownOptions = undefined;\n                this._instanceErrorOnUnknownElementsOption = undefined;\n                this._instanceErrorOnUnknownPropertiesOption = undefined;\n            }\n        }\n    }\n    configureCompiler(config) {\n        if (config.useJit != null) {\n            throw new Error('the Render3 compiler JiT mode is not configurable !');\n        }\n        if (config.providers !== undefined) {\n            this.compiler.setCompilerProviders(config.providers);\n        }\n    }\n    configureTestingModule(moduleDef) {\n        this.assertNotInstantiated('R3TestBed.configureTestingModule', 'configure the test module');\n        // Trigger module scoping queue flush before executing other TestBed operations in a test.\n        // This is needed for the first test invocation to ensure that globally declared modules have\n        // their components scoped properly. See the `checkGlobalCompilationFinished` function\n        // description for additional info.\n        this.checkGlobalCompilationFinished();\n        // Always re-assign the options, even if they're undefined.\n        // This ensures that we don't carry them between tests.\n        this._instanceTeardownOptions = moduleDef.teardown;\n        this._instanceErrorOnUnknownElementsOption = moduleDef.errorOnUnknownElements;\n        this._instanceErrorOnUnknownPropertiesOption = moduleDef.errorOnUnknownProperties;\n        // Store the current value of the strict mode option,\n        // so we can restore it later\n        this._previousErrorOnUnknownElementsOption = ɵgetUnknownElementStrictMode$1();\n        ɵsetUnknownElementStrictMode$1(this.shouldThrowErrorOnUnknownElements());\n        this._previousErrorOnUnknownPropertiesOption = ɵgetUnknownPropertyStrictMode$1();\n        ɵsetUnknownPropertyStrictMode$1(this.shouldThrowErrorOnUnknownProperties());\n        this.compiler.configureTestingModule(moduleDef);\n    }\n    compileComponents() {\n        return this.compiler.compileComponents();\n    }\n    inject(token, notFoundValue, flags) {\n        if (token === TestBedRender3) {\n            return this;\n        }\n        const UNDEFINED = {};\n        const result = this.testModuleRef.injector.get(token, UNDEFINED, flags);\n        return result === UNDEFINED ? this.compiler.injector.get(token, notFoundValue, flags) :\n            result;\n    }\n    /** @deprecated from v9.0.0 use TestBed.inject */\n    get(token, notFoundValue = Injector$1.THROW_IF_NOT_FOUND, flags = InjectFlags$1.Default) {\n        return this.inject(token, notFoundValue, flags);\n    }\n    execute(tokens, fn, context) {\n        const params = tokens.map(t => this.inject(t));\n        return fn.apply(context, params);\n    }\n    overrideModule(ngModule, override) {\n        this.assertNotInstantiated('overrideModule', 'override module metadata');\n        this.compiler.overrideModule(ngModule, override);\n    }\n    overrideComponent(component, override) {\n        this.assertNotInstantiated('overrideComponent', 'override component metadata');\n        this.compiler.overrideComponent(component, override);\n    }\n    overrideTemplateUsingTestingModule(component, template) {\n        this.assertNotInstantiated('R3TestBed.overrideTemplateUsingTestingModule', 'Cannot override template when the test module has already been instantiated');\n        this.compiler.overrideTemplateUsingTestingModule(component, template);\n    }\n    overrideDirective(directive, override) {\n        this.assertNotInstantiated('overrideDirective', 'override directive metadata');\n        this.compiler.overrideDirective(directive, override);\n    }\n    overridePipe(pipe, override) {\n        this.assertNotInstantiated('overridePipe', 'override pipe metadata');\n        this.compiler.overridePipe(pipe, override);\n    }\n    /**\n     * Overwrites all providers for the given token with the given provider definition.\n     */\n    overrideProvider(token, provider) {\n        this.assertNotInstantiated('overrideProvider', 'override provider');\n        this.compiler.overrideProvider(token, provider);\n    }\n    createComponent(type) {\n        const testComponentRenderer = this.inject(TestComponentRenderer);\n        const rootElId = `root${_nextRootElementId++}`;\n        testComponentRenderer.insertRootElement(rootElId);\n        const componentDef = type.ɵcmp;\n        if (!componentDef) {\n            throw new Error(`It looks like '${ɵstringify(type)}' has not been compiled.`);\n        }\n        // TODO: Don't cast as `InjectionToken<boolean>`, proper type is boolean[]\n        const noNgZone = this.inject(ComponentFixtureNoNgZone, false);\n        // TODO: Don't cast as `InjectionToken<boolean>`, proper type is boolean[]\n        const autoDetect = this.inject(ComponentFixtureAutoDetect, false);\n        const ngZone = noNgZone ? null : this.inject(NgZone, null);\n        const componentFactory = new ɵRender3ComponentFactory(componentDef);\n        const initComponent = () => {\n            const componentRef = componentFactory.create(Injector$1.NULL, [], `#${rootElId}`, this.testModuleRef);\n            return new ComponentFixture(componentRef, ngZone, autoDetect);\n        };\n        const fixture = ngZone ? ngZone.run(initComponent) : initComponent();\n        this._activeFixtures.push(fixture);\n        return fixture;\n    }\n    /**\n     * @internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     */\n    get compiler() {\n        if (this._compiler === null) {\n            throw new Error(`Need to call TestBed.initTestEnvironment() first`);\n        }\n        return this._compiler;\n    }\n    /**\n     * @internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     */\n    get testModuleRef() {\n        if (this._testModuleRef === null) {\n            this._testModuleRef = this.compiler.finalize();\n        }\n        return this._testModuleRef;\n    }\n    assertNotInstantiated(methodName, methodDescription) {\n        if (this._testModuleRef !== null) {\n            throw new Error(`Cannot ${methodDescription} when the test module has already been instantiated. ` +\n                `Make sure you are not using \\`inject\\` before \\`${methodName}\\`.`);\n        }\n    }\n    /**\n     * Check whether the module scoping queue should be flushed, and flush it if needed.\n     *\n     * When the TestBed is reset, it clears the JIT module compilation queue, cancelling any\n     * in-progress module compilation. This creates a potential hazard - the very first time the\n     * TestBed is initialized (or if it's reset without being initialized), there may be pending\n     * compilations of modules declared in global scope. These compilations should be finished.\n     *\n     * To ensure that globally declared modules have their components scoped properly, this function\n     * is called whenever TestBed is initialized or reset. The _first_ time that this happens, prior\n     * to any other operations, the scoping queue is flushed.\n     */\n    checkGlobalCompilationFinished() {\n        // Checking _testNgModuleRef is null should not be necessary, but is left in as an additional\n        // guard that compilations queued in tests (after instantiation) are never flushed accidentally.\n        if (!this._globalCompilationChecked && this._testModuleRef === null) {\n            ɵflushModuleScopingQueueAsMuchAsPossible();\n        }\n        this._globalCompilationChecked = true;\n    }\n    destroyActiveFixtures() {\n        let errorCount = 0;\n        this._activeFixtures.forEach((fixture) => {\n            try {\n                fixture.destroy();\n            }\n            catch (e) {\n                errorCount++;\n                console.error('Error during cleanup of component', {\n                    component: fixture.componentInstance,\n                    stacktrace: e,\n                });\n            }\n        });\n        this._activeFixtures = [];\n        if (errorCount > 0 && this.shouldRethrowTeardownErrors()) {\n            throw Error(`${errorCount} ${(errorCount === 1 ? 'component' : 'components')} ` +\n                `threw errors during cleanup`);\n        }\n    }\n    shouldRethrowTeardownErrors() {\n        var _a, _b;\n        const instanceOptions = this._instanceTeardownOptions;\n        const environmentOptions = TestBedRender3._environmentTeardownOptions;\n        // If the new teardown behavior hasn't been configured, preserve the old behavior.\n        if (!instanceOptions && !environmentOptions) {\n            return TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n        }\n        // Otherwise use the configured behavior or default to rethrowing.\n        return (_b = (_a = instanceOptions === null || instanceOptions === void 0 ? void 0 : instanceOptions.rethrowErrors) !== null && _a !== void 0 ? _a : environmentOptions === null || environmentOptions === void 0 ? void 0 : environmentOptions.rethrowErrors) !== null && _b !== void 0 ? _b : this.shouldTearDownTestingModule();\n    }\n    shouldThrowErrorOnUnknownElements() {\n        var _a, _b;\n        // Check if a configuration has been provided to throw when an unknown element is found\n        return (_b = (_a = this._instanceErrorOnUnknownElementsOption) !== null && _a !== void 0 ? _a : TestBedRender3._environmentErrorOnUnknownElementsOption) !== null && _b !== void 0 ? _b : THROW_ON_UNKNOWN_ELEMENTS_DEFAULT;\n    }\n    shouldThrowErrorOnUnknownProperties() {\n        var _a, _b;\n        // Check if a configuration has been provided to throw when an unknown property is found\n        return (_b = (_a = this._instanceErrorOnUnknownPropertiesOption) !== null && _a !== void 0 ? _a : TestBedRender3._environmentErrorOnUnknownPropertiesOption) !== null && _b !== void 0 ? _b : THROW_ON_UNKNOWN_PROPERTIES_DEFAULT;\n    }\n    shouldTearDownTestingModule() {\n        var _a, _b, _c, _d;\n        return (_d = (_b = (_a = this._instanceTeardownOptions) === null || _a === void 0 ? void 0 : _a.destroyAfterEach) !== null && _b !== void 0 ? _b : (_c = TestBedRender3._environmentTeardownOptions) === null || _c === void 0 ? void 0 : _c.destroyAfterEach) !== null && _d !== void 0 ? _d : TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n    }\n    tearDownTestingModule() {\n        var _a;\n        // If the module ref has already been destroyed, we won't be able to get a test renderer.\n        if (this._testModuleRef === null) {\n            return;\n        }\n        // Resolve the renderer ahead of time, because we want to remove the root elements as the very\n        // last step, but the injector will be destroyed as a part of the module ref destruction.\n        const testRenderer = this.inject(TestComponentRenderer);\n        try {\n            this._testModuleRef.destroy();\n        }\n        catch (e) {\n            if (this.shouldRethrowTeardownErrors()) {\n                throw e;\n            }\n            else {\n                console.error('Error during cleanup of a testing module', {\n                    component: this._testModuleRef.instance,\n                    stacktrace: e,\n                });\n            }\n        }\n        finally {\n            (_a = testRenderer.removeAllRootElements) === null || _a === void 0 ? void 0 : _a.call(testRenderer);\n        }\n    }\n}\nlet testBed;\nfunction _getTestBedRender3() {\n    return testBed = testBed || new TestBedRender3();\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n *\n * @publicApi\n */\nconst TestBed = TestBedRender3;\n/**\n * Returns a singleton of the applicable `TestBed`.\n *\n * It will be either an instance of `TestBedViewEngine` or `TestBedRender3`.\n *\n * @publicApi\n */\nconst getTestBed = _getTestBedRender3;\n/**\n * Allows injecting dependencies in `beforeEach()` and `it()`. Note: this function\n * (imported from the `@angular/core/testing` package) can **only** be used to inject dependencies\n * in tests. To inject dependencies in your application code, use the [`inject`](api/core/inject)\n * function from the `@angular/core` package instead.\n *\n * Example:\n *\n * ```\n * beforeEach(inject([Dependency, AClass], (dep, object) => {\n *   // some code that uses `dep` and `object`\n *   // ...\n * }));\n *\n * it('...', inject([AClass], (object) => {\n *   object.doSomething();\n *   expect(...);\n * })\n * ```\n *\n * @publicApi\n */\nfunction inject(tokens, fn) {\n    const testBed = getTestBed();\n    // Not using an arrow function to preserve context passed from call site\n    return function () {\n        return testBed.execute(tokens, fn, this);\n    };\n}\n/**\n * @publicApi\n */\nclass InjectSetupWrapper {\n    constructor(_moduleDef) {\n        this._moduleDef = _moduleDef;\n    }\n    _addModule() {\n        const moduleDef = this._moduleDef();\n        if (moduleDef) {\n            getTestBed().configureTestingModule(moduleDef);\n        }\n    }\n    inject(tokens, fn) {\n        const self = this;\n        // Not using an arrow function to preserve context passed from call site\n        return function () {\n            self._addModule();\n            return inject(tokens, fn).call(this);\n        };\n    }\n}\nfunction withModule(moduleDef, fn) {\n    if (fn) {\n        // Not using an arrow function to preserve context passed from call site\n        return function () {\n            const testBed = getTestBed();\n            if (moduleDef) {\n                testBed.configureTestingModule(moduleDef);\n            }\n            return fn.apply(this);\n        };\n    }\n    return new InjectSetupWrapper(() => moduleDef);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst _global = (typeof window === 'undefined' ? global : window);\n// Reset the test providers and the fake async zone before each test.\nif (_global.beforeEach) {\n    _global.beforeEach(getCleanupHook(false));\n}\n// We provide both a `beforeEach` and `afterEach`, because the updated behavior for\n// tearing down the module is supposed to run after the test so that we can associate\n// teardown errors with the correct test.\nif (_global.afterEach) {\n    _global.afterEach(getCleanupHook(true));\n}\nfunction getCleanupHook(expectedTeardownValue) {\n    return () => {\n        // TODO(alxhub): find a better type here\n        if (TestBed.shouldTearDownTestingModule() === expectedTeardownValue) {\n            TestBed.resetTestingModule();\n            resetFakeAsyncZone();\n        }\n    };\n}\n/**\n * This API should be removed. But doing so seems to break `google3` and so it requires a bit of\n * investigation.\n *\n * A work around is to mark it as `@codeGenApi` for now and investigate later.\n *\n * @codeGenApi\n */\n// TODO(iminar): Remove this code in a safe way.\nconst __core_private_testing_placeholder__ = '';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ComponentFixture, ComponentFixtureAutoDetect, ComponentFixtureNoNgZone, InjectSetupWrapper, TestBed, TestComponentRenderer, __core_private_testing_placeholder__, async, discardPeriodicTasks, fakeAsync, flush, flushMicrotasks, getTestBed, inject, resetFakeAsyncZone, tick$1 as tick, waitForAsync, withModule, MetadataOverrider as ɵMetadataOverrider };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA,SAASA,YAAY,IAAIC,cAAzB,EAAyCC,gBAAgB,IAAIC,kBAA7D,EAAiFC,UAAjF,EAA6FC,uBAA7F,EAAsHC,SAAtH,EAAiIC,SAAjI,EAA4IC,IAA5I,EAAkJC,QAAlJ,EAA4JC,iBAA5J,EAA+KC,iBAAiB,IAAIC,mBAApM,EAAyNC,YAAzN,EAAuOC,mBAAvO,EAA4PC,qBAA5P,EAAmRC,SAAS,IAAIC,WAAhS,EAA6SC,kBAA7S,EAAiUC,YAAjU,EAA+UC,wBAA/U,EAAyWC,iBAAzW,EAA4XC,WAA5X,EAAyYC,iBAAzY,EAA4ZC,YAA5Z,EAA0aC,YAA1a,EAAwbC,WAAxb,EAAqcC,oBAArc,EAA2dC,2BAA3d,EAAwfC,WAAxf,EAAqgBC,oBAArgB,EAA2hBC,MAA3hB,EAAmiBC,QAAniB,EAA6iBC,gBAA7iB,EAA+jBC,gBAA/jB,EAAilBC,4BAAjlB,EAA+mBC,cAAc,IAAIC,gBAAjoB,EAAmpBC,QAAQ,IAAIC,UAA/pB,EAA2qBC,WAAW,IAAIC,aAA1rB,EAAysBC,oCAAzsB,EAA+uBC,wBAA/uB,EAAywBC,4BAA4B,IAAIC,8BAAzyB,EAAy0BC,6BAA6B,IAAIC,+BAA12B,EAA24BC,4BAA4B,IAAIC,8BAA36B,EAA28BC,6BAA6B,IAAIC,+BAA5+B,EAA6gCC,wCAA7gC,QAA6jC,eAA7jC;AACA,SAASC,SAAT,QAA0B,OAA1B;AACA,SAASC,cAAT,QAA+B,mBAA/B;AACA,SAASC,OAAT,EAAkBC,YAAlB,QAAsC,MAAtC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,YAAT,CAAsBC,EAAtB,EAA0B;EACtB,MAAMC,KAAK,GAAG,OAAOC,IAAP,KAAgB,WAAhB,GAA8BA,IAA9B,GAAqC,IAAnD;;EACA,IAAI,CAACD,KAAL,EAAY;IACR,OAAO,YAAY;MACf,OAAOE,OAAO,CAACC,MAAR,CAAe,+EAClB,yDADG,CAAP;IAEH,CAHD;EAIH;;EACD,MAAMC,SAAS,GAAGJ,KAAK,IAAIA,KAAK,CAACA,KAAK,CAACK,UAAN,CAAiB,WAAjB,CAAD,CAAhC;;EACA,IAAI,OAAOD,SAAP,KAAqB,UAAzB,EAAqC;IACjC,OAAOA,SAAS,CAACL,EAAD,CAAhB;EACH;;EACD,OAAO,YAAY;IACf,OAAOG,OAAO,CAACC,MAAR,CAAe,mFAClB,iEADG,CAAP;EAEH,CAHD;AAIH;AACD;AACA;AACA;AACA;AACA;;;AACA,SAASG,KAAT,CAAeP,EAAf,EAAmB;EACf,OAAOD,YAAY,CAACC,EAAD,CAAnB;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMQ,gBAAN,CAAuB;EACnBC,WAAW,CAACC,YAAD,EAAeC,MAAf,EAAuBC,WAAvB,EAAoC;IAC3C,KAAKF,YAAL,GAAoBA,YAApB;IACA,KAAKC,MAAL,GAAcA,MAAd;IACA,KAAKC,WAAL,GAAmBA,WAAnB;IACA,KAAKC,SAAL,GAAiB,IAAjB;IACA,KAAKC,YAAL,GAAoB,KAApB;IACA,KAAKC,QAAL,GAAgB,IAAhB;IACA,KAAKC,QAAL,GAAgB,IAAhB;IACA,KAAKC,uBAAL,GAA+B,IAA/B;IACA,KAAKC,qBAAL,GAA6B,IAA7B;IACA,KAAKC,6BAAL,GAAqC,IAArC;IACA,KAAKC,oBAAL,GAA4B,IAA5B;IACA,KAAKC,iBAAL,GAAyBX,YAAY,CAACW,iBAAtC;IACA,KAAKC,UAAL,GAAkBZ,YAAY,CAACa,QAA/B;IACA,KAAKC,YAAL,GAAoBjF,cAAc,CAAC,KAAK+E,UAAL,CAAgBG,aAAjB,CAAlC;IACA,KAAKC,iBAAL,GAAyBhB,YAAY,CAACiB,QAAtC;IACA,KAAKF,aAAL,GAAqB,KAAKH,UAAL,CAAgBG,aAArC;IACA,KAAKf,YAAL,GAAoBA,YAApB;IACA,KAAKC,MAAL,GAAcA,MAAd;;IACA,IAAIA,MAAJ,EAAY;MACR;MACA;MACAA,MAAM,CAACiB,iBAAP,CAAyB,MAAM;QAC3B,KAAKX,uBAAL,GAA+BN,MAAM,CAACkB,UAAP,CAAkBC,SAAlB,CAA4B;UACvDC,IAAI,EAAE,MAAM;YACR,KAAKlB,SAAL,GAAiB,KAAjB;UACH;QAHsD,CAA5B,CAA/B;QAKA,KAAKM,6BAAL,GAAqCR,MAAM,CAACqB,gBAAP,CAAwBF,SAAxB,CAAkC;UACnEC,IAAI,EAAE,MAAM;YACR,IAAI,KAAKnB,WAAT,EAAsB;cAClB;cACA;cACA,KAAKqB,aAAL,CAAmB,IAAnB;YACH;UACJ;QAPkE,CAAlC,CAArC;QASA,KAAKf,qBAAL,GAA6BP,MAAM,CAACuB,QAAP,CAAgBJ,SAAhB,CAA0B;UACnDC,IAAI,EAAE,MAAM;YACR,KAAKlB,SAAL,GAAiB,IAAjB,CADQ,CAER;;YACA,IAAI,KAAKG,QAAL,KAAkB,IAAtB,EAA4B;cACxB;cACA;cACA;cACAmB,iBAAiB,CAAC,MAAM;gBACpB,IAAI,CAACxB,MAAM,CAACyB,oBAAZ,EAAkC;kBAC9B,IAAI,KAAKpB,QAAL,KAAkB,IAAtB,EAA4B;oBACxB,KAAKD,QAAL,CAAc,IAAd;;oBACA,KAAKA,QAAL,GAAgB,IAAhB;oBACA,KAAKC,QAAL,GAAgB,IAAhB;kBACH;gBACJ;cACJ,CARgB,CAAjB;YASH;UACJ;QAlBkD,CAA1B,CAA7B;QAoBA,KAAKI,oBAAL,GAA4BT,MAAM,CAAC0B,OAAP,CAAeP,SAAf,CAAyB;UACjDC,IAAI,EAAGO,KAAD,IAAW;YACb,MAAMA,KAAN;UACH;QAHgD,CAAzB,CAA5B;MAKH,CAxCD;IAyCH;EACJ;;EACDC,KAAK,CAACC,cAAD,EAAiB;IAClB,KAAKnB,iBAAL,CAAuBY,aAAvB;;IACA,IAAIO,cAAJ,EAAoB;MAChB,KAAKA,cAAL;IACH;EACJ;EACD;AACJ;AACA;;;EACIP,aAAa,CAACO,cAAc,GAAG,IAAlB,EAAwB;IACjC,IAAI,KAAK7B,MAAL,IAAe,IAAnB,EAAyB;MACrB;MACA;MACA,KAAKA,MAAL,CAAY8B,GAAZ,CAAgB,MAAM;QAClB,KAAKF,KAAL,CAAWC,cAAX;MACH,CAFD;IAGH,CAND,MAOK;MACD;MACA,KAAKD,KAAL,CAAWC,cAAX;IACH;EACJ;EACD;AACJ;AACA;;;EACIA,cAAc,GAAG;IACb,KAAKnB,iBAAL,CAAuBmB,cAAvB;EACH;EACD;AACJ;AACA;AACA;AACA;;;EACIE,iBAAiB,CAACC,UAAU,GAAG,IAAd,EAAoB;IACjC,IAAI,KAAKhC,MAAL,IAAe,IAAnB,EAAyB;MACrB,MAAM,IAAIiC,KAAJ,CAAU,oEAAV,CAAN;IACH;;IACD,KAAKhC,WAAL,GAAmB+B,UAAnB;IACA,KAAKV,aAAL;EACH;EACD;AACJ;AACA;AACA;;;EACIY,QAAQ,GAAG;IACP,OAAO,KAAKhC,SAAL,IAAkB,CAAC,KAAKF,MAAL,CAAYyB,oBAAtC;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;;;EACIU,UAAU,GAAG;IACT,IAAI,KAAKD,QAAL,EAAJ,EAAqB;MACjB,OAAO1C,OAAO,CAAC4C,OAAR,CAAgB,KAAhB,CAAP;IACH,CAFD,MAGK,IAAI,KAAK/B,QAAL,KAAkB,IAAtB,EAA4B;MAC7B,OAAO,KAAKA,QAAZ;IACH,CAFI,MAGA;MACD,KAAKA,QAAL,GAAgB,IAAIb,OAAJ,CAAY6C,GAAG,IAAI;QAC/B,KAAKjC,QAAL,GAAgBiC,GAAhB;MACH,CAFe,CAAhB;MAGA,OAAO,KAAKhC,QAAZ;IACH;EACJ;;EACDiC,YAAY,GAAG;IACX,IAAI,KAAKC,SAAL,KAAmBC,SAAvB,EAAkC;MAC9B,KAAKD,SAAL,GAAiB,KAAKxC,YAAL,CAAkB0C,QAAlB,CAA2BC,GAA3B,CAA+B5G,kBAA/B,EAAmD,IAAnD,CAAjB;IACH;;IACD,OAAO,KAAKyG,SAAZ;EACH;EACD;AACJ;AACA;;;EACII,iBAAiB,GAAG;IAChB,MAAMC,QAAQ,GAAG,KAAKN,YAAL,EAAjB;;IACA,IAAIM,QAAQ,IAAIA,QAAQ,CAACD,iBAAzB,EAA4C;MACxC,OAAOC,QAAQ,CAACD,iBAAT,EAAP;IACH;;IACD,OAAO,KAAKR,UAAL,EAAP;EACH;EACD;AACJ;AACA;;;EACIU,OAAO,GAAG;IACN,IAAI,CAAC,KAAK1C,YAAV,EAAwB;MACpB,KAAKJ,YAAL,CAAkB8C,OAAlB;;MACA,IAAI,KAAKvC,uBAAL,IAAgC,IAApC,EAA0C;QACtC,KAAKA,uBAAL,CAA6BwC,WAA7B;;QACA,KAAKxC,uBAAL,GAA+B,IAA/B;MACH;;MACD,IAAI,KAAKC,qBAAL,IAA8B,IAAlC,EAAwC;QACpC,KAAKA,qBAAL,CAA2BuC,WAA3B;;QACA,KAAKvC,qBAAL,GAA6B,IAA7B;MACH;;MACD,IAAI,KAAKC,6BAAL,IAAsC,IAA1C,EAAgD;QAC5C,KAAKA,6BAAL,CAAmCsC,WAAnC;;QACA,KAAKtC,6BAAL,GAAqC,IAArC;MACH;;MACD,IAAI,KAAKC,oBAAL,IAA6B,IAAjC,EAAuC;QACnC,KAAKA,oBAAL,CAA0BqC,WAA1B;;QACA,KAAKrC,oBAAL,GAA4B,IAA5B;MACH;;MACD,KAAKN,YAAL,GAAoB,IAApB;IACH;EACJ;;AA7KkB;;AA+KvB,SAASqB,iBAAT,CAA2BnC,EAA3B,EAA+B;EAC3BE,IAAI,CAACwD,OAAL,CAAavB,iBAAb,CAA+B,mBAA/B,EAAoDnC,EAApD;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,KAAK,GAAG,OAAOC,IAAP,KAAgB,WAAhB,GAA8BA,IAA9B,GAAqC,IAAnD;;AACA,MAAMyD,mBAAmB,GAAG1D,KAAK,IAAIA,KAAK,CAACA,KAAK,CAACK,UAAN,CAAiB,eAAjB,CAAD,CAA1C;;AACA,MAAMsD,wCAAwC,GAAI;AAClD,wEADA;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,kBAAT,GAA8B;EAC1B,IAAIF,mBAAJ,EAAyB;IACrB,OAAOA,mBAAmB,CAACE,kBAApB,EAAP;EACH;;EACD,MAAM,IAAIjB,KAAJ,CAAUgB,wCAAV,CAAN;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,SAAT,CAAmB9D,EAAnB,EAAuB;EACnB,IAAI2D,mBAAJ,EAAyB;IACrB,OAAOA,mBAAmB,CAACG,SAApB,CAA8B9D,EAA9B,CAAP;EACH;;EACD,MAAM,IAAI4C,KAAJ,CAAUgB,wCAAV,CAAN;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASG,MAAT,CAAgBC,MAAM,GAAG,CAAzB,EAA4BC,WAAW,GAAG;EACtCC,iCAAiC,EAAE;AADG,CAA1C,EAEG;EACC,IAAIP,mBAAJ,EAAyB;IACrB,OAAOA,mBAAmB,CAACQ,IAApB,CAAyBH,MAAzB,EAAiCC,WAAjC,CAAP;EACH;;EACD,MAAM,IAAIrB,KAAJ,CAAUgB,wCAAV,CAAN;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASQ,KAAT,CAAeC,QAAf,EAAyB;EACrB,IAAIV,mBAAJ,EAAyB;IACrB,OAAOA,mBAAmB,CAACS,KAApB,CAA0BC,QAA1B,CAAP;EACH;;EACD,MAAM,IAAIzB,KAAJ,CAAUgB,wCAAV,CAAN;AACH;AACD;AACA;AACA;AACA;AACA;;;AACA,SAASU,oBAAT,GAAgC;EAC5B,IAAIX,mBAAJ,EAAyB;IACrB,OAAOA,mBAAmB,CAACW,oBAApB,EAAP;EACH;;EACD,MAAM,IAAI1B,KAAJ,CAAUgB,wCAAV,CAAN;AACH;AACD;AACA;AACA;AACA;AACA;;;AACA,SAASW,eAAT,GAA2B;EACvB,IAAIZ,mBAAJ,EAAyB;IACrB,OAAOA,mBAAmB,CAACY,eAApB,EAAP;EACH;;EACD,MAAM,IAAI3B,KAAJ,CAAUgB,wCAAV,CAAN;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;A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CA;AACA;AACA;AACA;AACA;;AACA,SAASC,+BAAT,GAA2C;EACvC,OAAOL,gBAAgB,CAACC,MAAjB,CAAwB3F,MAAxB,KAAmC,IAA1C;AACH;;AACD,SAASgG,oBAAT,GAAgC;EAC5B,OAAON,gBAAgB,CAACC,MAAjB,CAAwBM,iBAA/B;AACH;;AACD,SAASC,yBAAT,GAAqC;EACjCR,gBAAgB,CAACC,MAAjB,CAAwBM,iBAAxB;AACH;;AACD,SAASE,yBAAT,GAAqC;EACjCT,gBAAgB,CAACC,MAAjB,CAAwBM,iBAAxB;AACH;;AACD,SAASG,kBAAT,GAA8B;EAC1B,OAAOV,gBAAgB,CAACG,eAAxB;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASQ,gBAAT,GAA4B;EACxBX,gBAAgB,CAACG,eAAjB,GAAmC,IAAnC;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASS,iBAAT,GAA6B;EACzBZ,gBAAgB,CAACG,eAAjB,GAAmC,KAAnC;AACH;AACD;AACA;AACA;;;AACA,SAASU,QAAT,GAAoB;EAChB,OAAOb,gBAAgB,CAACC,MAAjB,CAAwBvG,KAA/B;AACH;AACD;AACA;AACA;;;AACA,SAASoH,QAAT,GAAoB;EAChB,OAAOd,gBAAgB,CAACC,MAAjB,CAAwBrU,KAA/B;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASmV,aAAT,CAAuBC,aAAvB,EAAsC;EAClChB,gBAAgB,CAACC,MAAjB,CAAwBgB,YAAxB,GAAuCD,aAAvC;EACA,OAAOA,aAAa,CAAC/I,OAAD,CAApB;AACH;AACD;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASiJ,WAAT,CAAqBnhB,KAArB,EAA4B;EACxBigB,gBAAgB,CAACC,MAAjB,CAAwBgB,YAAxB,GAAuC,IAAv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AIsnB,aAAa,YAAY5lC,IAAzB,IAAiC4lC,aAAa,YAAY3lC,QAA9D,EAAwE;MACzE+jC,UAAU,GAAG4B,aAAb;IACH,CAFI,MAGA,IAAIA,aAAa,YAAYxjD,cAA7B,EAA6C;MAC9C6K,KAAK,GAAG24C,aAAR;IACH;EACJ;;EACD34C,KAAK,GAAGtM,iBAAiB,CAACsM,KAAD,CAAzB;;EACA,IAAIA,KAAK,IAAI,IAAb,EAAmB;IACf,OAAO04C,iBAAiB,CAAC14C,KAAD,EAAQqxB,QAAR,EAAkB0lB,UAAlB,CAAxB;EACH,CAFD,MAGK;IACD,MAAMjB,iBAAiB,CAACrqC,UAAD,EAAasqC,MAAb,CAAvB;EACH;AACJ;;AACD,SAAS2C,iBAAT,CAA2B14C,KAA3B,EAAkCqxB,QAAlC,EAA4C0lB,UAA5C,EAAwD;EACpD,OAAO,IAAID,oBAAJ,CAAyBP,aAAa,CAACz8C,GAAd,CAAkBkG,KAAlB,CAAzB,EAAmDqxB,QAAnD,EAA6D0lB,UAA7D,CAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAM6B,SAAS,GAAG,EAAlB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,kBAAN,CAAyB;EACrB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACkB,OAAPr/C,OAAO,CAACgI,SAAD,EAAY;IACtB,OAAOs2C,0BAA0B,CAACt2C,SAAD,CAAjC;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAC2B,OAAhBs3C,gBAAgB,CAACt3C,SAAD,EAAYma,MAAZ,EAAoB;IACvC,MAAMo9B,2BAA2B,GAAGF,kBAAkB,CAACr/C,OAAnB,CAA2BgI,SAA3B,CAApC;IACA,OAAOq3C,kBAAkB,CAACG,qBAAnB,CAAyCD,2BAAzC,EAAsEp9B,MAAtE,CAAP;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACgC,OAArBq9B,qBAAqB,CAACx3C,SAAD,EAAYma,MAAZ,EAAoB;IAC5C,OAAO,IAAIs9B,mBAAJ,CAAwBz3C,SAAxB,EAAmCma,MAAnC,CAAP;EACH;;AAzFoB;;AA2FzB,MAAMs9B,mBAAN,CAA0B;EACtB;AACJ;AACA;EACI/hD,WAAW,CAACgiD,UAAD,EAAaC,OAAb,EAAsB;IAC7B;IACA,KAAKC,oBAAL,GAA4B,CAA5B;IACA,KAAKF,UAAL,GAAkBA,UAAlB;IACA,KAAKv9B,MAAL,GAAcw9B,OAAO,IAAI,IAAzB;IACA,MAAME,GAAG,GAAGH,UAAU,CAAC18C,MAAvB;IACA,KAAK88C,MAAL,GAAc,EAAd;IACA,KAAKC,IAAL,GAAY,EAAZ;;IACA,KAAK,IAAIv0C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGq0C,GAApB,EAAyBr0C,CAAC,EAA1B,EAA8B;MAC1B,KAAKs0C,MAAL,CAAYt0C,CAAZ,IAAiBk0C,UAAU,CAACl0C,CAAD,CAAV,CAAcrF,GAAd,CAAkBwW,EAAnC;MACA,KAAKojC,IAAL,CAAUv0C,CAAV,IAAe4zC,SAAf;IACH;EACJ;;EACD9+C,GAAG,CAACkG,KAAD,EAAQuQ,aAAa,GAAGM,kBAAxB,EAA4C;IAC3C,OAAO,KAAK2oC,SAAL,CAAejD,aAAa,CAACz8C,GAAd,CAAkBkG,KAAlB,CAAf,EAAyC,IAAzC,EAA+CuQ,aAA/C,CAAP;EACH;;EACDkpC,qBAAqB,CAACj4C,SAAD,EAAY;IAC7B,MAAMu3C,2BAA2B,GAAGF,kBAAkB,CAACr/C,OAAnB,CAA2BgI,SAA3B,CAApC;IACA,OAAO,KAAKk4C,uBAAL,CAA6BX,2BAA7B,CAAP;EACH;;EACDW,uBAAuB,CAACl4C,SAAD,EAAY;IAC/B,MAAMm4C,GAAG,GAAG,IAAIV,mBAAJ,CAAwBz3C,SAAxB,CAAZ;IACAm4C,GAAG,CAACh+B,MAAJ,GAAa,IAAb;IACA,OAAOg+B,GAAP;EACH;;EACDC,qBAAqB,CAACjqC,QAAD,EAAW;IAC5B,OAAO,KAAKkqC,mBAAL,CAAyBhB,kBAAkB,CAACr/C,OAAnB,CAA2B,CAACmW,QAAD,CAA3B,EAAuC,CAAvC,CAAzB,CAAP;EACH;;EACDkqC,mBAAmB,CAAClqC,QAAD,EAAW;IAC1B,OAAO,KAAKmqC,oBAAL,CAA0BnqC,QAA1B,CAAP;EACH;;EACDoqC,kBAAkB,CAACr9C,KAAD,EAAQ;IACtB,IAAIA,KAAK,GAAG,CAAR,IAAaA,KAAK,IAAI,KAAKw8C,UAAL,CAAgB18C,MAA1C,EAAkD;MAC9C,MAAM25C,gBAAgB,CAACz5C,KAAD,CAAtB;IACH;;IACD,OAAO,KAAKw8C,UAAL,CAAgBx8C,KAAhB,CAAP;EACH;EACD;;;EACAs9C,IAAI,CAACrqC,QAAD,EAAW;IACX,IAAI,KAAKypC,oBAAL,KAA8B,KAAKa,sBAAL,EAAlC,EAAiE;MAC7D,MAAMxE,qBAAqB,CAAC,IAAD,EAAO9lC,QAAQ,CAAChQ,GAAhB,CAA3B;IACH;;IACD,OAAO,KAAKm6C,oBAAL,CAA0BnqC,QAA1B,CAAP;EACH;;EACDsqC,sBAAsB,GAAG;IACrB,OAAO,KAAKV,IAAL,CAAU/8C,MAAjB;EACH;;EACDs9C,oBAAoB,CAACnqC,QAAD,EAAW;IAC3B,IAAIA,QAAQ,CAACynC,aAAb,EAA4B;MACxB,MAAM39C,GAAG,GAAG,EAAZ;;MACA,KAAK,IAAIuL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2K,QAAQ,CAACwnC,iBAAT,CAA2B36C,MAA/C,EAAuD,EAAEwI,CAAzD,EAA4D;QACxDvL,GAAG,CAACuL,CAAD,CAAH,GAAS,KAAKk1C,YAAL,CAAkBvqC,QAAlB,EAA4BA,QAAQ,CAACwnC,iBAAT,CAA2BnyC,CAA3B,CAA5B,CAAT;MACH;;MACD,OAAOvL,GAAP;IACH,CAND,MAOK;MACD,OAAO,KAAKygD,YAAL,CAAkBvqC,QAAlB,EAA4BA,QAAQ,CAACwnC,iBAAT,CAA2B,CAA3B,CAA5B,CAAP;IACH;EACJ;;EACD+C,YAAY,CAACvqC,QAAD,EAAW2nC,yBAAX,EAAsC;IAC9C,MAAMn2C,OAAO,GAAGm2C,yBAAyB,CAACn2C,OAA1C;IACA,IAAI6vB,IAAJ;;IACA,IAAI;MACAA,IAAI,GACAsmB,yBAAyB,CAAC3hC,YAA1B,CAAuCxV,GAAvC,CAA2C8wB,GAAG,IAAI,KAAKkpB,0BAAL,CAAgClpB,GAAhC,CAAlD,CADJ;IAEH,CAHD,CAIA,OAAO5e,CAAP,EAAU;MACN,IAAIA,CAAC,CAACijC,MAAN,EAAc;QACVjjC,CAAC,CAACijC,MAAF,CAAS,IAAT,EAAe3lC,QAAQ,CAAChQ,GAAxB;MACH;;MACD,MAAM0S,CAAN;IACH;;IACD,IAAII,GAAJ;;IACA,IAAI;MACAA,GAAG,GAAGtR,OAAO,CAAC,GAAG6vB,IAAJ,CAAb;IACH,CAFD,CAGA,OAAO3e,CAAP,EAAU;MACN,MAAMqjC,kBAAkB,CAAC,IAAD,EAAOrjC,CAAP,EAAUA,CAAC,CAAC+nC,KAAZ,EAAmBzqC,QAAQ,CAAChQ,GAA5B,CAAxB;IACH;;IACD,OAAO8S,GAAP;EACH;;EACD0nC,0BAA0B,CAAClpB,GAAD,EAAM;IAC5B,OAAO,KAAKuoB,SAAL,CAAevoB,GAAG,CAACtxB,GAAnB,EAAwBsxB,GAAG,CAAC8lB,UAA5B,EAAwC9lB,GAAG,CAACI,QAAJ,GAAe,IAAf,GAAsBxgB,kBAA9D,CAAP;EACH;;EACD2oC,SAAS,CAAC75C,GAAD,EAAMo3C,UAAN,EAAkBxmC,aAAlB,EAAiC;IACtC,IAAI5Q,GAAG,KAAKs5C,mBAAmB,CAACoB,YAAhC,EAA8C;MAC1C,OAAO,IAAP;IACH;;IACD,IAAItD,UAAU,YAAYhkC,IAA1B,EAAgC;MAC5B,OAAO,KAAKunC,aAAL,CAAmB36C,GAAnB,EAAwB4Q,aAAxB,CAAP;IACH,CAFD,MAGK;MACD,OAAO,KAAKgqC,gBAAL,CAAsB56C,GAAtB,EAA2B4Q,aAA3B,EAA0CwmC,UAA1C,CAAP;IACH;EACJ;;EACDyD,cAAc,CAACC,KAAD,EAAQ;IAClB,KAAK,IAAIz1C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKs0C,MAAL,CAAY98C,MAAhC,EAAwCwI,CAAC,EAAzC,EAA6C;MACzC,IAAI,KAAKs0C,MAAL,CAAYt0C,CAAZ,MAAmBy1C,KAAvB,EAA8B;QAC1B,IAAI,KAAKlB,IAAL,CAAUv0C,CAAV,MAAiB4zC,SAArB,EAAgC;UAC5B,KAAKW,IAAL,CAAUv0C,CAAV,IAAe,KAAKg1C,IAAL,CAAU,KAAKd,UAAL,CAAgBl0C,CAAhB,CAAV,CAAf;QACH;;QACD,OAAO,KAAKu0C,IAAL,CAAUv0C,CAAV,CAAP;MACH;IACJ;;IACD,OAAO4zC,SAAP;EACH;EACD;;;EACA8B,YAAY,CAAC/6C,GAAD,EAAM4Q,aAAN,EAAqB;IAC7B,IAAIA,aAAa,KAAKM,kBAAtB,EAA0C;MACtC,OAAON,aAAP;IACH,CAFD,MAGK;MACD,MAAMilC,eAAe,CAAC,IAAD,EAAO71C,GAAP,CAArB;IACH;EACJ;EACD;;;EACA26C,aAAa,CAAC36C,GAAD,EAAM4Q,aAAN,EAAqB;IAC9B,MAAMkC,GAAG,GAAG,KAAK+nC,cAAL,CAAoB76C,GAAG,CAACwW,EAAxB,CAAZ;;IACA,OAAQ1D,GAAG,KAAKmmC,SAAT,GAAsBnmC,GAAtB,GAA4B,KAAKioC,YAAL,CAAkB/6C,GAAlB,EAAuB4Q,aAAvB,CAAnC;EACH;EACD;;;EACAgqC,gBAAgB,CAAC56C,GAAD,EAAM4Q,aAAN,EAAqBwmC,UAArB,EAAiC;IAC7C,IAAI4C,GAAJ;;IACA,IAAI5C,UAAU,YAAY/jC,QAA1B,EAAoC;MAChC2mC,GAAG,GAAG,KAAKh+B,MAAX;IACH,CAFD,MAGK;MACDg+B,GAAG,GAAG,IAAN;IACH;;IACD,OAAOA,GAAG,YAAYV,mBAAtB,EAA2C;MACvC,MAAM0B,IAAI,GAAGhB,GAAb;;MACA,MAAMlnC,GAAG,GAAGkoC,IAAI,CAACH,cAAL,CAAoB76C,GAAG,CAACwW,EAAxB,CAAZ;;MACA,IAAI1D,GAAG,KAAKmmC,SAAZ,EACI,OAAOnmC,GAAP;MACJknC,GAAG,GAAGgB,IAAI,CAACh/B,MAAX;IACH;;IACD,IAAIg+B,GAAG,KAAK,IAAZ,EAAkB;MACd,OAAOA,GAAG,CAAC7/C,GAAJ,CAAQ6F,GAAG,CAACK,KAAZ,EAAmBuQ,aAAnB,CAAP;IACH,CAFD,MAGK;MACD,OAAO,KAAKmqC,YAAL,CAAkB/6C,GAAlB,EAAuB4Q,aAAvB,CAAP;IACH;EACJ;;EACc,IAAXimC,WAAW,GAAG;IACd,MAAMh1C,SAAS,GAAGo5C,aAAa,CAAC,IAAD,EAAQz1C,CAAD,IAAO,OAAOA,CAAC,CAACxF,GAAF,CAAM62C,WAAb,GAA2B,IAAzC,CAAb,CACbp2C,IADa,CACR,IADQ,CAAlB;;IAEA,OAAQ,kCAAiCoB,SAAU,IAAnD;EACH;;EACDlB,QAAQ,GAAG;IACP,OAAO,KAAKk2C,WAAZ;EACH;;AA1JqB;;AA4J1ByC,mBAAmB,CAACoB,YAApB,GAAqC,eAAe9D,aAAa,CAACz8C,GAAd,CAAkBzE,QAAlB,CAApD;;AACA,SAASulD,aAAT,CAAuB/gD,QAAvB,EAAiCpD,EAAjC,EAAqC;EACjC,MAAMgD,GAAG,GAAG,EAAZ;;EACA,KAAK,IAAIuL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGnL,QAAQ,CAACq/C,UAAT,CAAoB18C,MAAxC,EAAgD,EAAEwI,CAAlD,EAAqD;IACjDvL,GAAG,CAACuL,CAAD,CAAH,GAASvO,EAAE,CAACoD,QAAQ,CAACkgD,kBAAT,CAA4B/0C,CAA5B,CAAD,CAAX;EACH;;EACD,OAAOvL,GAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASohD,iBAAT,CAA2B76C,KAA3B,EAAkCwQ,KAAK,GAAGjb,WAAW,CAACic,OAAtD,EAA+D;EAC3D,MAAMuJ,KAAK,GAAGmH,QAAQ,EAAtB,CAD2D,CAE3D;EACA;;EACA,IAAInH,KAAK,KAAK,IAAd,EAAoB;IAChB;IACA5b,SAAS,IAAIwR,kCAAkC,CAACkqC,iBAAD,CAA/C;IACA,OAAOppC,QAAQ,CAACzR,KAAD,EAAQwQ,KAAR,CAAf;EACH;;EACD,MAAMxD,KAAK,GAAGwV,eAAe,EAA7B;EACA,OAAOqL,qBAAqB,CAAC7gB,KAAD,EAAQ+N,KAAR,EAAernB,iBAAiB,CAACsM,KAAD,CAAhC,EAAyCwQ,KAAzC,CAA5B;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASsqC,gBAAT,GAA4B;EACxB,MAAM53C,GAAG,GAAG/D,SAAS,GAAI,gEAAJ,GAAsE,SAA3F;EACA,MAAM,IAAI9F,KAAJ,CAAU6J,GAAV,CAAN;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAM63C,sBAAsB,GAAG;EAC3Bx7C,IAAI,EAAE;AADqB,CAA/B;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMy7C,gBAAgB,GAAG;EACrBz7C,IAAI,EAAE;AADe,CAAzB;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAI07C,gCAAgC,GAAG,KAAvC;AACA;AACA;AACA;AACA;AACA;;AACA,SAAStlD,4BAAT,CAAsCulD,WAAtC,EAAmD;EAC/CD,gCAAgC,GAAGC,WAAnC;AACH;AACD;AACA;AACA;;;AACA,SAASnlD,4BAAT,GAAwC;EACpC,OAAOklD,gCAAP;AACH;;AACD,IAAIE,iCAAiC,GAAG,KAAxC;AACA;AACA;AACA;AACA;AACA;;AACA,SAAStlD,6BAAT,CAAuCqlD,WAAvC,EAAoD;EAChDC,iCAAiC,GAAGD,WAApC;AACH;AACD;AACA;AACA;;;AACA,SAASjlD,6BAAT,GAAyC;EACrC,OAAOklD,iCAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,sBAAT,CAAgC5oB,OAAhC,EAAyCzX,KAAzC,EAAgD+e,OAAhD,EAAyDzjB,OAAzD,EAAkEglC,aAAlE,EAAiF;EAC7E;EACA;EACA;EACA;EACA,IAAIhlC,OAAO,KAAK,IAAhB,EACI,OANyE,CAO7E;;EACA,IAAI,CAACglC,aAAD,IAAkBvhB,OAAO,KAAK,IAAlC,EAAwC;IACpC;IACA;IACA;IACA,MAAMwhB,SAAS,GACf;IACA;IACC,OAAOC,kBAAP,KAA8B,WAA9B,IAA6CA,kBAA7C,IACG/oB,OAAO,YAAY+oB,kBADvB,IAEK,OAAOC,cAAP,KAA0B,WAA1B,IAAyC1hB,OAAO,CAACj9B,OAAR,CAAgB,GAAhB,IAAuB,CAAC,CAAjE,IACG,CAAC2+C,cAAc,CAAC1hD,GAAf,CAAmBggC,OAAnB,CANT;;IAOA,IAAIwhB,SAAS,IAAI,CAACG,eAAe,CAACplC,OAAD,EAAUyjB,OAAV,CAAjC,EAAqD;MACjD,MAAM4hB,gBAAgB,GAAGC,yBAAyB,CAAC5gC,KAAD,CAAlD;MACA,MAAM6gC,gBAAgB,GAAGC,0BAA0B,CAAC9gC,KAAD,CAAnD;MACA,MAAM1E,OAAO,GAAI,IAAGqlC,gBAAgB,GAAG,YAAH,GAAkB,WAAY,WAAlE;MACA,IAAIp8C,OAAO,GAAI,IAAGw6B,OAAQ,2BAA0B8hB,gBAAiB,KAArE;MACAt8C,OAAO,IAAK,UAASw6B,OAAQ,qDAAoD4hB,gBAAgB,GAAG,0DAAH,GAC7F,yDAA0D,KAD9D;;MAEA,IAAI5hB,OAAO,IAAIA,OAAO,CAACj9B,OAAR,CAAgB,GAAhB,IAAuB,CAAC,CAAvC,EAA0C;QACtCyC,OAAO,IACF,UAASw6B,OAAQ,iEAAgEzjB,OAAQ,8CAD9F;MAEH,CAHD,MAIK;QACD/W,OAAO,IACF,yDAAwD+W,OAAQ,qBADrE;MAEH;;MACD,IAAI4kC,gCAAJ,EAAsC;QAClC,MAAM,IAAIzsC,YAAJ,CAAiB;QAAI;QAArB,EAA6DlP,OAA7D,CAAN;MACH,CAFD,MAGK;QACDF,OAAO,CAACrG,KAAR,CAAc2V,kBAAkB,CAAC;QAAI;QAAL,EAA6CpP,OAA7C,CAAhC;MACH;IACJ;EACJ;AACJ;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASw8C,eAAT,CAAyBtpB,OAAzB,EAAkCvpB,QAAlC,EAA4C6wB,OAA5C,EAAqDzjB,OAArD,EAA8D;EAC1D;EACA;EACA;EACA;EACA,IAAIA,OAAO,KAAK,IAAhB,EACI,OAAO,IAAP,CANsD,CAO1D;EACA;;EACA,IAAIolC,eAAe,CAACplC,OAAD,EAAUyjB,OAAV,CAAf,IAAqC7wB,QAAQ,IAAIupB,OAAjD,IAA4DlI,eAAe,CAACrhB,QAAD,CAA/E,EAA2F;IACvF,OAAO,IAAP;EACH,CAXyD,CAY1D;EACA;;;EACA,OAAO,OAAO1E,IAAP,KAAgB,WAAhB,IAA+BA,IAAI,KAAK,IAAxC,IAAgD,EAAEiuB,OAAO,YAAYjuB,IAArB,CAAvD;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASw3C,0BAAT,CAAoC9yC,QAApC,EAA8C6wB,OAA9C,EAAuDvC,QAAvD,EAAiExc,KAAjE,EAAwE;EACpE;EACA;EACA;EACA;EACA;EACA;EACA,IAAI,CAAC+e,OAAD,IAAYvC,QAAQ,KAAK;EAAE;EAA/B,EAA0D;IACtDuC,OAAO,GAAG,aAAV;EACH;;EACD,MAAM4hB,gBAAgB,GAAGC,yBAAyB,CAAC5gC,KAAD,CAAlD;EACA,MAAM6gC,gBAAgB,GAAGC,0BAA0B,CAAC9gC,KAAD,CAAnD;EACA,IAAIzb,OAAO,GAAI,kBAAiB2J,QAAS,yCAAwC6wB,OAAQ,IAAG8hB,gBAAiB,GAA7G;EACA,MAAMvlC,OAAO,GAAI,IAAGqlC,gBAAgB,GAAG,YAAH,GAAkB,WAAY,WAAlE;EACA,MAAMM,cAAc,GAAGN,gBAAgB,GACnC,0DADmC,GAEnC,yDAFJ;;EAGA,IAAIO,6BAA6B,CAACx+C,GAA9B,CAAkCwL,QAAlC,CAAJ,EAAiD;IAC7C;IACA;IACA3J,OAAO,IAAK,aAAY2J,QAAS,0CAAtB,GACN,+CAA8C+yC,cAAe,GADlE;EAEH,CALD,MAMK;IACD;IACA18C,OAAO,IAAK,YAAWw6B,OAAQ,2CAApB,GACN,IAAG7wB,QAAS,mCAAkC+yC,cAAe,GADlE,CAFC,CAID;;IACA,IAAIliB,OAAO,IAAIA,OAAO,CAACj9B,OAAR,CAAgB,GAAhB,IAAuB,CAAC,CAAvC,EAA0C;MACtCyC,OAAO,IAAK,YAAWw6B,OAAQ,yDAApB,GACN,UAASzjB,OAAQ,8CADtB;MAEA/W,OAAO,IAAK,uDAAD,GACN,OAAM+W,OAAQ,qBADnB;IAEH,CALD,MAMK;MACD;MACA/W,OAAO,IAAK,uDAAD,GACN,OAAM+W,OAAQ,qBADnB;IAEH;EACJ;;EACD,IAAI8kC,iCAAJ,EAAuC;IACnC,MAAM,IAAI3sC,YAAJ,CAAiB;IAAI;IAArB,EAA6DlP,OAA7D,CAAN;EACH,CAFD,MAGK;IACDF,OAAO,CAACrG,KAAR,CAAc2V,kBAAkB,CAAC;IAAI;IAAL,EAA6CpP,OAA7C,CAAhC;EACH;AACJ;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS48C,0BAAT,CAAoCnhC,KAApC,EAA2C;EACvC,CAAC5b,SAAD,IAAcgE,UAAU,CAAC,yCAAD,CAAxB;EACA,MAAMg5C,gBAAgB,GAAGphC,KAAK,CAACjB,0BAAD,CAA9B;EACA,MAAMnH,OAAO,GAAGwpC,gBAAgB,CAAC7iC,OAAD,CAAhC,CAHuC,CAIvC;;EACA,IAAI,CAAC3G,OAAL,EACI,OAAO,IAAP;EACJ,OAAOA,OAAO,CAACzb,WAAR,GAAsB6f,iBAAiB,CAACpE,OAAO,CAACzb,WAAT,CAAvC,GAA+D,IAAtE;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASykD,yBAAT,CAAmC5gC,KAAnC,EAA0C;EACtC,CAAC5b,SAAD,IAAcgE,UAAU,CAAC,yCAAD,CAAxB;EACA,MAAMy9B,YAAY,GAAGsb,0BAA0B,CAACnhC,KAAD,CAA/C,CAFsC,CAGtC;;EACA,OAAO,CAAC,EAAE6lB,YAAY,KAAK,IAAjB,IAAyBA,YAAY,KAAK,KAAK,CAA/C,GAAmD,KAAK,CAAxD,GAA4DA,YAAY,CAACpsB,UAA3E,CAAR;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASqnC,0BAAT,CAAoC9gC,KAApC,EAA2C;EACvC,IAAIyY,EAAJ;;EACA,CAACr0B,SAAD,IAAcgE,UAAU,CAAC,yCAAD,CAAxB;EACA,MAAMi5C,gBAAgB,GAAGF,0BAA0B,CAACnhC,KAAD,CAAnD;EACA,MAAMshC,kBAAkB,GAAG,CAAC7oB,EAAE,GAAG4oB,gBAAgB,KAAK,IAArB,IAA6BA,gBAAgB,KAAK,KAAK,CAAvD,GAA2D,KAAK,CAAhE,GAAoEA,gBAAgB,CAACpgD,IAA3F,MAAqG,IAArG,IAA6Gw3B,EAAE,KAAK,KAAK,CAAzH,GAA6H,KAAK,CAAlI,GAAsIA,EAAE,CAACj0B,IAApK;EACA,OAAO88C,kBAAkB,GAAI,kBAAiBA,kBAAmB,uBAAxC,GAAiE,EAA1F;AACH;AACD;AACA;AACA;AACA;AACA;;;AACA,MAAMJ,6BAA6B,GAAG,IAAI9+C,GAAJ,CAAQ,CAAC,MAAD,EAAS,OAAT,EAAkB,UAAlB,EAA8B,cAA9B,EAA8C,iBAA9C,CAAR,CAAtC;AACA;AACA;AACA;AACA;AACA;;AACA,SAASs+C,eAAT,CAAyBplC,OAAzB,EAAkCyjB,OAAlC,EAA2C;EACvC,IAAIzjB,OAAO,KAAK,IAAhB,EAAsB;IAClB,KAAK,IAAIrR,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqR,OAAO,CAAC7Z,MAA5B,EAAoCwI,CAAC,EAArC,EAAyC;MACrC,MAAMs3C,MAAM,GAAGjmC,OAAO,CAACrR,CAAD,CAAtB;;MACA,IAAIs3C,MAAM,KAAKtB,gBAAX,IACAsB,MAAM,KAAKvB,sBAAX,IAAqCjhB,OAArC,IAAgDA,OAAO,CAACj9B,OAAR,CAAgB,GAAhB,IAAuB,CAAC,CAD5E,EAC+E;QAC3E,OAAO,IAAP;MACH;IACJ;EACJ;;EACD,OAAO,KAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS0/C,oBAAT,CAA8Bh9C,IAA9B,EAAoC;EAChC;EACA,IAAIJ,SAAJ,EAAe;IACX,IAAI;MACA;MACA;MACA;MACA,OAAQ20B,wBAAwB,CAAC,OAAD,EAAW,gBAAev0B,IAAK,kBAA/B,CAAzB,CAA4EU,KAA5E,CAAP;IACH,CALD,CAMA,OAAOoS,CAAP,EAAU;MACN;MACA,OAAOpS,KAAP;IACH;EACJ,CAXD,MAYK;IACD,MAAM,IAAI5G,KAAJ,CAAU,6GAAV,CAAN;EACH;AACJ;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASmjD,eAAT,CAAyBC,IAAzB,EAA+BjkD,IAA/B,EAAqC;EACjC2G,SAAS,IAAIiE,mBAAmB,CAACq5C,IAAD,EAAO,CAAP,EAAU;EAAM;EAAhB,CAAhC;EACAt9C,SAAS,IAAIiE,mBAAmB,CAAC5K,IAAD,EAAO,CAAP,EAAU;EAAM;EAAhB,CAAhC;EACA,OAAQikD,IAAI,IAAI;EAAG;EAAX,EAA2CjkD,IAAI,IAAI;EAAE;EAA7D;AACH;;AACD,SAASkkD,oBAAT,CAA8BC,aAA9B,EAA6C;EACzCx9C,SAAS,IAAI6D,YAAY,CAAC25C,aAAD,EAAgB,iBAAhB,CAAzB;EACA,OAAQA,aAAa,IAAI;EAAG;EAArB,EAAsD;EAAM;EAAnE;AACH;;AACD,SAASC,6BAAT,CAAuCD,aAAvC,EAAsD;EAClDx9C,SAAS,IAAI6D,YAAY,CAAC25C,aAAD,EAAgB,iBAAhB,CAAzB;EACA,OAAO,CAACA,aAAa,GAAG;EAAE;EAAnB,KACH;EAAE;EADN;AAEH;;AACD,SAASE,oBAAT,CAA8BF,aAA9B,EAA6CtsC,QAA7C,EAAuD;EACnDlR,SAAS,IAAI6D,YAAY,CAAC25C,aAAD,EAAgB,iBAAhB,CAAzB;EACAx9C,SAAS,IAAIiE,mBAAmB,CAACiN,QAAD,EAAW,CAAX,EAAc;EAAM;EAApB,CAAhC;EACA,OAASssC,aAAa,GAAG,CAAC;EAAW;EAA7B,EACHtsC,QAAQ,IAAI;EAAG;EADpB;AAEH;;AACD,SAASysC,6BAAT,CAAuCH,aAAvC,EAAsD;EAClDx9C,SAAS,IAAI6D,YAAY,CAAC25C,aAAD,EAAgB,iBAAhB,CAAzB;EACA,OAAQA,aAAa,GAAG;EAAE;EAA1B;AACH;;AACD,SAASI,oBAAT,CAA8BJ,aAA9B,EAA6C;EACzCx9C,SAAS,IAAI6D,YAAY,CAAC25C,aAAD,EAAgB,iBAAhB,CAAzB;EACA,OAAO,CAACA,aAAa,GAAG;EAAO;EAAxB,KAAyD;EAAE;EAAlE;AACH;;AACD,SAASK,oBAAT,CAA8BL,aAA9B,EAA6CnkD,IAA7C,EAAmD;EAC/C2G,SAAS,IAAI6D,YAAY,CAAC25C,aAAD,EAAgB,iBAAhB,CAAzB;EACAx9C,SAAS,IAAIiE,mBAAmB,CAAC5K,IAAD,EAAO,CAAP,EAAU;EAAM;EAAhB,CAAhC;EACA,OAASmkD,aAAa,GAAG,CAAC;EAAO;EAAzB,EAAyD;EAC7DnkD,IAAI,IAAI;EAAE;EADd;AAEH;;AACD,SAASykD,6BAAT,CAAuCN,aAAvC,EAAsD;EAClDx9C,SAAS,IAAI6D,YAAY,CAAC25C,aAAD,EAAgB,iBAAhB,CAAzB;EACA,OAAO,CAACA,aAAa,GAAG;EAAE;EAAnB,MACH;EAAE;EADN;AAEH;;AACD,SAASO,6BAAT,CAAuCP,aAAvC,EAAsD;EAClDx9C,SAAS,IAAI6D,YAAY,CAAC25C,aAAD,EAAgB,iBAAhB,CAAzB;EACA,OAAQA,aAAa,GAAG;EAAE;EAA1B;AACH;;AACD,SAASQ,oBAAT,CAA8BR,aAA9B,EAA6C;EACzCx9C,SAAS,IAAI6D,YAAY,CAAC25C,aAAD,EAAgB,iBAAhB,CAAzB;EACA,MAAMnkD,IAAI,GAAGukD,oBAAoB,CAACJ,aAAD,CAAjC;EACA,OAAOnkD,IAAI,KAAK,CAAT,GAAakkD,oBAAoB,CAACC,aAAD,CAAjC,GAAmDnkD,IAA1D;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS4kD,iBAAT,CAA2B3qC,GAA3B,EAAgC4qC,KAAhC,EAAuC;EACnC,IAAIl+C,SAAJ,EAAe;IACXsJ,MAAM,CAACC,cAAP,CAAsB+J,GAAtB,EAA2B,OAA3B,EAAoC;MAAErR,KAAK,EAAEi8C,KAAT;MAAgBC,UAAU,EAAE;IAA5B,CAApC;EACH,CAFD,MAGK;IACD,MAAM,IAAIjkD,KAAJ,CAAU,6FAAV,CAAN;EACH;AACJ;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASkkD,iBAAT,CAA2B9qC,GAA3B,EAAgC+qC,WAAhC,EAA6C;EACzC,IAAIr+C,SAAJ,EAAe;IACXsJ,MAAM,CAACC,cAAP,CAAsB+J,GAAtB,EAA2B,OAA3B,EAAoC;MAAE3Y,GAAG,EAAE0jD,WAAP;MAAoBF,UAAU,EAAE;IAAhC,CAApC;EACH,CAFD,MAGK;IACD,MAAM,IAAIjkD,KAAJ,CAAU,6FAAV,CAAN;EACH;AACJ;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIokD,qBAAJ;AACA,IAAIC,oBAAJ;AACA,IAAIC,UAAJ;AACA,IAAIC,eAAJ;AACA,IAAIC,cAAJ;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,8BAAT,CAAwC7wC,KAAxC,EAA+C;EAC3C,MAAM8wC,UAAU,GAAG9wC,KAAnB;EACA,MAAM8N,KAAK,GAAGijC,eAAe,CAACD,UAAU,CAAC/hD,IAAZ,EAAkBiR,KAAK,CAAC7Q,QAAN,IAAkB6Q,KAAK,CAAC7Q,QAAN,CAAemD,IAAnD,CAA7B;EACA,OAAOwb,KAAK,CAACjQ,MAAN,CAAamC,KAAK,CAAC0f,SAAnB,CAAP;AACH;;AACD,MAAMsxB,SAAN,SAAwBh+C,KAAxB,CAA8B;;AAE9B,MAAMi+C,cAAN,SAA6Bj+C,KAA7B,CAAmC;;AAEnC,MAAMk+C,aAAN,SAA4Bl+C,KAA5B,CAAkC;;AAElC,SAAS+9C,eAAT,CAAyBhiD,IAAzB,EAA+BuD,IAA/B,EAAqC;EACjC,QAAQvD,IAAR;IACI,KAAK;IAAE;IAAP;MACI,IAAI2hD,UAAU,KAAK/jD,SAAnB,EACI+jD,UAAU,GAAG,IAAIM,SAAJ,EAAb;MACJ,OAAON,UAAP;;IACJ,KAAK;IAAE;IAAP;MACI,IAAI,CAACx+C,SAAD,IAAc,CAACA,SAAS,CAAC2N,iBAA7B,EAAgD;QAC5C,IAAI8wC,eAAe,KAAKhkD,SAAxB,EACIgkD,eAAe,GAAG,IAAIM,cAAJ,EAAlB;QACJ,OAAON,eAAP;MACH;;MACD,IAAIH,qBAAqB,KAAK7jD,SAA9B,EACI6jD,qBAAqB,GAAG,IAAIpiD,GAAJ,EAAxB;MACJ,IAAI+iD,cAAc,GAAGX,qBAAqB,CAAC3jD,GAAtB,CAA0ByF,IAA1B,CAArB;;MACA,IAAI6+C,cAAc,KAAKxkD,SAAvB,EAAkC;QAC9BwkD,cAAc,GAAG,KAAK7B,oBAAoB,CAAC,mBAAmB8B,UAAU,CAAC9+C,IAAD,CAA9B,CAAzB,GAAjB;QACAk+C,qBAAqB,CAAC/hD,GAAtB,CAA0B6D,IAA1B,EAAgC6+C,cAAhC;MACH;;MACD,OAAOA,cAAP;;IACJ,KAAK;IAAE;IAAP;MACI,IAAI,CAACj/C,SAAD,IAAc,CAACA,SAAS,CAAC2N,iBAA7B,EAAgD;QAC5C,IAAI+wC,cAAc,KAAKjkD,SAAvB,EACIikD,cAAc,GAAG,IAAIM,aAAJ,EAAjB;QACJ,OAAON,cAAP;MACH;;MACD,IAAIH,oBAAoB,KAAK9jD,SAA7B,EACI8jD,oBAAoB,GAAG,IAAIriD,GAAJ,EAAvB;MACJ,IAAIijD,aAAa,GAAGZ,oBAAoB,CAAC5jD,GAArB,CAAyByF,IAAzB,CAApB;;MACA,IAAI++C,aAAa,KAAK1kD,SAAtB,EAAiC;QAC7B0kD,aAAa,GAAG,KAAK/B,oBAAoB,CAAC,kBAAkB8B,UAAU,CAAC9+C,IAAD,CAA7B,CAAzB,GAAhB;QACAm+C,oBAAoB,CAAChiD,GAArB,CAAyB6D,IAAzB,EAA+B++C,aAA/B;MACH;;MACD,OAAOA,aAAP;EAhCR;AAkCH;;AACD,SAASD,UAAT,CAAoBlgD,IAApB,EAA0B;EACtB,IAAIA,IAAI,IAAI,IAAZ,EACI,OAAO,EAAP;EACJ,MAAMzB,KAAK,GAAGyB,IAAI,CAACogD,WAAL,CAAiB,WAAjB,CAAd;EACA,OAAO,OAAO7hD,KAAK,KAAK,CAAC,CAAX,GAAeyB,IAAf,GAAsBA,IAAI,CAACwH,KAAL,CAAW,CAAX,EAAcjJ,KAAd,CAA7B,CAAP;AACH;AACD;AACA;AACA;AACA;AACA;;;AACA,MAAM8hD,gBAAgB,GAAG,MAAMC,KAAN,CAAY;EACjCvnD,WAAW,CAAC8E,IAAD,EAAO2wB,SAAP,EAAkBvwB,QAAlB,EAA4BsiD,OAA5B,EAAqC5oC,SAArC,EAAgD0O,SAAhD,EAA2DxO,IAA3D,EAAiEuG,iBAAjE,EAAoFE,iBAApF,EAAuGkiC,kBAAvG,EAA2H5xC,eAA3H,EAA4IoP,eAA5I,EAA6JyiC,iBAA7J,EAAgLC,oBAAhL,EAAsMh4B,aAAtM,EAAqNC,kBAArN,EAAyOS,YAAzO,EAAuPC,iBAAvP,EAA0QC,SAA1Q,EAAqRC,cAArR,EAAqSC,YAArS,EAAmT0e,OAAnT,EAA4TnxB,cAA5T,EAA4U0qB,UAA5U,EAAwVkf,iBAAxV,EAA2WC,YAA3W,EAAyX75B,UAAzX,EAAqY7O,OAArY,EAA8YxB,MAA9Y,EAAsZmqC,mBAAtZ,EAA2aC,MAA3a,EAAmbC,KAAnb,EAA0b;IACjc,KAAKljD,IAAL,GAAYA,IAAZ;IACA,KAAK2wB,SAAL,GAAiBA,SAAjB;IACA,KAAKvwB,QAAL,GAAgBA,QAAhB;IACA,KAAKsiD,OAAL,GAAeA,OAAf;IACA,KAAK5oC,SAAL,GAAiBA,SAAjB;IACA,KAAK0O,SAAL,GAAiBA,SAAjB;IACA,KAAKxO,IAAL,GAAYA,IAAZ;IACA,KAAKuG,iBAAL,GAAyBA,iBAAzB;IACA,KAAKE,iBAAL,GAAyBA,iBAAzB;IACA,KAAKkiC,kBAAL,GAA0BA,kBAA1B;IACA,KAAK5xC,eAAL,GAAuBA,eAAvB;IACA,KAAKoP,eAAL,GAAuBA,eAAvB;IACA,KAAKyiC,iBAAL,GAAyBA,iBAAzB;IACA,KAAKC,oBAAL,GAA4BA,oBAA5B;IACA,KAAKh4B,aAAL,GAAqBA,aAArB;IACA,KAAKC,kBAAL,GAA0BA,kBAA1B;IACA,KAAKS,YAAL,GAAoBA,YAApB;IACA,KAAKC,iBAAL,GAAyBA,iBAAzB;IACA,KAAKC,SAAL,GAAiBA,SAAjB;IACA,KAAKC,cAAL,GAAsBA,cAAtB;IACA,KAAKC,YAAL,GAAoBA,YAApB;IACA,KAAK0e,OAAL,GAAeA,OAAf;IACA,KAAKnxB,cAAL,GAAsBA,cAAtB;IACA,KAAK0qB,UAAL,GAAkBA,UAAlB;IACA,KAAKkf,iBAAL,GAAyBA,iBAAzB;IACA,KAAKC,YAAL,GAAoBA,YAApB;IACA,KAAK75B,UAAL,GAAkBA,UAAlB;IACA,KAAK7O,OAAL,GAAeA,OAAf;IACA,KAAKxB,MAAL,GAAcA,MAAd;IACA,KAAKmqC,mBAAL,GAA2BA,mBAA3B;IACA,KAAKC,MAAL,GAAcA,MAAd;IACA,KAAKC,KAAL,GAAaA,KAAb;EACH;;EACY,IAATC,SAAS,GAAG;IACZ,MAAM/lB,GAAG,GAAG,EAAZ;IACAgmB,oBAAoB,CAAC,KAAKl6B,UAAN,EAAkBkU,GAAlB,CAApB;IACA,OAAOA,GAAG,CAACh5B,IAAJ,CAAS,EAAT,CAAP;EACH;;EACQ,IAALi/C,KAAK,GAAG;IACR,OAAOhlC,iBAAiB,CAAC,KAAKre,IAAN,CAAjB,IAAiC,cAAa,KAAKA,IAAK,GAA/D;EACH;;AA1CgC,CAArC;;AA4CA,MAAMsjD,KAAN,CAAY;EACRpoD,WAAW,CAACgkB,MAAD,EAAS;EACpBlf,IADW,EACL;EACNU,KAFW,EAEJ;EACP6iD,iBAHW,EAGQ;EACnBtiC,aAJW,EAII;EACf+J,cALW,EAKK;EAChBC,YANW,EAMG;EACdu4B,oBAPW,EAOW;EACtBC,gBARW,EAQO;EAClBjvC,KATW,EASJ;EACPse,eAVW,EAUM;EACjB1tB,KAXW,EAWJ;EACP2oB,KAZW,EAYJ;EACP21B,WAbW,EAaE;EACbjf,UAdW,EAcC;EACZkf,aAfW,EAeI;EACfxqC,MAhBW,EAgBH;EACRC,OAjBW,EAiBF;EACTwqC,MAlBW,EAkBH;EACRpnD,IAnBW,EAmBL;EACN+wC,cApBW,EAoBK;EAChBlkB,KArBW,EAqBJ;EACP1J,MAtBW,EAsBH;EACRmB,UAvBW,EAuBC;EACZxgB,MAxBW,EAwBH;EACRujD,iBAzBW,EAyBQ;EACnBC,cA1BW,EA0BK;EAChBvyB,OA3BW,EA2BF;EACTwyB,kBA5BW,EA4BS;EACpBC,eA7BW,EA6BM;EACjBC,aA9BW,EA8BI;EACfC,aA/BW,EA+BI;IACX,KAAKhlC,MAAL,GAAcA,MAAd;IACA,KAAKlf,IAAL,GAAYA,IAAZ;IACA,KAAKU,KAAL,GAAaA,KAAb;IACA,KAAK6iD,iBAAL,GAAyBA,iBAAzB;IACA,KAAKtiC,aAAL,GAAqBA,aAArB;IACA,KAAK+J,cAAL,GAAsBA,cAAtB;IACA,KAAKC,YAAL,GAAoBA,YAApB;IACA,KAAKu4B,oBAAL,GAA4BA,oBAA5B;IACA,KAAKC,gBAAL,GAAwBA,gBAAxB;IACA,KAAKjvC,KAAL,GAAaA,KAAb;IACA,KAAKse,eAAL,GAAuBA,eAAvB;IACA,KAAK1tB,KAAL,GAAaA,KAAb;IACA,KAAK2oB,KAAL,GAAaA,KAAb;IACA,KAAK21B,WAAL,GAAmBA,WAAnB;IACA,KAAKjf,UAAL,GAAkBA,UAAlB;IACA,KAAKkf,aAAL,GAAqBA,aAArB;IACA,KAAKxqC,MAAL,GAAcA,MAAd;IACA,KAAKC,OAAL,GAAeA,OAAf;IACA,KAAKwqC,MAAL,GAAcA,MAAd;IACA,KAAKpnD,IAAL,GAAYA,IAAZ;IACA,KAAK+wC,cAAL,GAAsBA,cAAtB;IACA,KAAKlkB,KAAL,GAAaA,KAAb;IACA,KAAK1J,MAAL,GAAcA,MAAd;IACA,KAAKmB,UAAL,GAAkBA,UAAlB;IACA,KAAKxgB,MAAL,GAAcA,MAAd;IACA,KAAKujD,iBAAL,GAAyBA,iBAAzB;IACA,KAAKC,cAAL,GAAsBA,cAAtB;IACA,KAAKvyB,OAAL,GAAeA,OAAf;IACA,KAAKwyB,kBAAL,GAA0BA,kBAA1B;IACA,KAAKC,eAAL,GAAuBA,eAAvB;IACA,KAAKC,aAAL,GAAqBA,aAArB;IACA,KAAKC,aAAL,GAAqBA,aAArB;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIC,qBAAqB,CAACplC,KAAD,EAAQ;IACzB,MAAMzL,IAAI,GAAG,EAAb;IACA,IAAI2N,aAAa,GAAGwP,gBAAgB,CAAC,IAAD,EAAO1R,KAAP,CAApC;;IACA,IAAIkC,aAAa,KAAK,CAAC,CAAvB,EAA0B;MACtB;MACA;MACA,MAAMmO,cAAc,GAAGyB,yBAAyB,CAAC,IAAD,EAAO9R,KAAP,CAAhD;;MACA,IAAIqQ,cAAc,KAAKxC,kBAAvB,EAA2C;QACvC;QACA3L,aAAa,GAAGoO,sBAAsB,CAACD,cAAD,CAAtC;QACArQ,KAAK,GAAGyQ,qBAAqB,CAACJ,cAAD,EAAiBrQ,KAAjB,CAA7B;MACH,CAJD,MAKK,CACD;MACH;IACJ;;IACD,OAAOkC,aAAa,KAAK,CAAC,CAA1B,EAA6B;MACzB9d,SAAS,IAAI6d,kBAAkB,CAACjC,KAAD,EAAQkC,aAAR,CAA/B;MACA,MAAMjQ,KAAK,GAAG+N,KAAK,CAAChC,KAAD,CAAL,CAAa/C,IAAb,CAAkBiH,aAAa,GAAG;MAAE;MAApC,CAAd;MACA3N,IAAI,CAACnT,IAAL,CAAUikD,cAAc,CAACpzC,KAAD,EAAQ+N,KAAR,CAAxB;MACA,MAAMqQ,cAAc,GAAGrQ,KAAK,CAACkC,aAAa,GAAG;MAAE;MAAnB,CAA5B;;MACA,IAAImO,cAAc,KAAKxC,kBAAvB,EAA2C;QACvC3L,aAAa,GAAG,CAAC,CAAjB;MACH,CAFD,MAGK;QACDA,aAAa,GAAGoO,sBAAsB,CAACD,cAAD,CAAtC;QACArQ,KAAK,GAAGyQ,qBAAqB,CAACJ,cAAD,EAAiBrQ,KAAjB,CAA7B;MACH;IACJ;;IACD,OAAOzL,IAAP;EACH;;EACQ,IAAL+vC,KAAK,GAAG;IACR,OAAOh2B,mBAAmB,CAAC,KAAKrtB,IAAN,CAAnB,IAAmC,cAAa,KAAKA,IAAK,GAAjE;EACH;;EACS,IAANqkD,MAAM,GAAG;IACT,MAAM7vC,KAAK,GAAG,EAAd;IACA,IAAI,KAAKA,KAAL,GAAa;IAAG;IAApB,EACIA,KAAK,CAACrU,IAAN,CAAW,0BAAX;IACJ,IAAI,KAAKqU,KAAL,GAAa;IAAE;IAAnB,EACIA,KAAK,CAACrU,IAAN,CAAW,4BAAX;IACJ,IAAI,KAAKqU,KAAL,GAAa;IAAG;IAApB,EACIA,KAAK,CAACrU,IAAN,CAAW,0BAAX;IACJ,IAAI,KAAKqU,KAAL,GAAa;IAAI;IAArB,EACIA,KAAK,CAACrU,IAAN,CAAW,4BAAX;IACJ,IAAI,KAAKqU,KAAL,GAAa;IAAE;IAAnB,EACIA,KAAK,CAACrU,IAAN,CAAW,4BAAX;IACJ,IAAI,KAAKqU,KAAL,GAAa;IAAE;IAAnB,EACIA,KAAK,CAACrU,IAAN,CAAW,4BAAX;IACJ,IAAI,KAAKqU,KAAL,GAAa;IAAG;IAApB,EACIA,KAAK,CAACrU,IAAN,CAAW,uBAAX;IACJ,IAAI,KAAKqU,KAAL,GAAa;IAAE;IAAnB,EACIA,KAAK,CAACrU,IAAN,CAAW,wBAAX;IACJ,OAAOqU,KAAK,CAACpQ,IAAN,CAAW,GAAX,CAAP;EACH;;EACY,IAAT++C,SAAS,GAAG;IACZ,IAAI,KAAKnjD,IAAL,GAAY;IAAE;IAAlB,EACI,OAAO,KAAKoF,KAAZ;IACJ,MAAMg4B,GAAG,GAAG,EAAZ;IACA,MAAMU,OAAO,GAAG,OAAO,KAAK14B,KAAZ,KAAsB,QAAtB,IAAkC,KAAKA,KAAvC,IAAgD,KAAKi+C,KAArE;IACAjmB,GAAG,CAACj9B,IAAJ,CAAS,GAAT,EAAc29B,OAAd;;IACA,IAAI,KAAKtpB,KAAT,EAAgB;MACZ4oB,GAAG,CAACj9B,IAAJ,CAAS,GAAT,EAAc,KAAKkkD,MAAnB;IACH;;IACD,IAAI,KAAKt2B,KAAT,EAAgB;MACZ,KAAK,IAAI/kB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK+kB,KAAL,CAAWvtB,MAA/B,GAAwC;QACpC,MAAM0tB,QAAQ,GAAG,KAAKH,KAAL,CAAW/kB,CAAC,EAAZ,CAAjB;;QACA,IAAI,OAAOklB,QAAP,IAAmB,QAAvB,EAAiC;UAC7B;QACH;;QACD,MAAMyjB,SAAS,GAAG,KAAK5jB,KAAL,CAAW/kB,CAAC,EAAZ,CAAlB;QACAo0B,GAAG,CAACj9B,IAAJ,CAAS,GAAT,EAAc+tB,QAAd,EAAwB,IAAxB,EAA8ByjB,SAA9B,EAAyC,GAAzC;MACH;IACJ;;IACDvU,GAAG,CAACj9B,IAAJ,CAAS,GAAT;IACAijD,oBAAoB,CAAC,KAAK/5B,KAAN,EAAa+T,GAAb,CAApB;IACAA,GAAG,CAACj9B,IAAJ,CAAS,IAAT,EAAe29B,OAAf,EAAwB,GAAxB;IACA,OAAOV,GAAG,CAACh5B,IAAJ,CAAS,EAAT,CAAP;EACH;;EACiB,IAAdkgD,cAAc,GAAG;IACjB,OAAOC,mBAAmB,CAAC,IAAD,EAAO,KAAP,CAA1B;EACH;;EACiB,IAAdC,cAAc,GAAG;IACjB,OAAOD,mBAAmB,CAAC,IAAD,EAAO,IAAP,CAA1B;EACH;;EACsB,IAAnBE,mBAAmB,GAAG;IACtB,OAAO,KAAK3xB,eAAL,GAAuB;IAAQ;IAAtC;EACH;;EACoB,IAAjB4xB,iBAAiB,GAAG;IACpB,OAAO,KAAKD,mBAAL,IACF,KAAK3xB,eAAL,KAAyB;IAAG;IAD1B,CAAP;EAEH;;AAzKO;;AA2KZ,MAAM6xB,UAAU,GAAGrB,KAAnB;;AACA,SAASiB,mBAAT,CAA6BvzC,KAA7B,EAAoCi9B,YAApC,EAAkD;EAC9C,MAAM9lB,KAAK,GAAGnX,KAAK,CAACkO,MAAN,CAAalF,IAA3B;EACA,MAAM4qC,QAAQ,GAAG,EAAjB;EACA,MAAMC,KAAK,GAAG5W,YAAY,GAAGj9B,KAAK,CAACizC,aAAT,GAAyBjzC,KAAK,CAACkzC,aAAzD;EACA,MAAMzD,IAAI,GAAGC,oBAAoB,CAACmE,KAAD,CAAjC;EACA,MAAMroD,IAAI,GAAGukD,oBAAoB,CAAC8D,KAAD,CAAjC;EACA,IAAIC,UAAU,GAAGtoD,IAAI,KAAK,CAA1B;EACA,IAAIuoD,MAAM,GAAGD,UAAU,GAAGtoD,IAAH,GAAUikD,IAAjC;;EACA,OAAOsE,MAAM,KAAK,CAAlB,EAAqB;IACjB,MAAMC,OAAO,GAAG78B,KAAK,CAAC48B,MAAD,CAArB;IACA,MAAME,SAAS,GAAG98B,KAAK,CAAC48B,MAAM,GAAG,CAAV,CAAvB;IACAH,QAAQ,CAAC92C,OAAT,CAAiB;MACbnK,GAAG,EAAEqhD,OADQ;MAEbtkD,KAAK,EAAEqkD,MAFM;MAGbD,UAAU,EAAEA,UAHC;MAIbI,aAAa,EAAEtE,6BAA6B,CAACqE,SAAD,CAJ/B;MAKbE,aAAa,EAAElE,6BAA6B,CAACgE,SAAD,CAL/B;MAMbG,SAAS,EAAErE,oBAAoB,CAACkE,SAAD,CANlB;MAObI,SAAS,EAAE3E,oBAAoB,CAACuE,SAAD;IAPlB,CAAjB;IASA,IAAIF,MAAM,KAAKtE,IAAf,EACIqE,UAAU,GAAG,KAAb;IACJC,MAAM,GAAGrE,oBAAoB,CAACuE,SAAD,CAA7B;EACH;;EACDL,QAAQ,CAACzkD,IAAT,CAAc,CAAC8tC,YAAY,GAAGj9B,KAAK,CAACgzC,eAAT,GAA2BhzC,KAAK,CAAC8yC,cAA9C,KAAiE,IAA/E;EACA,OAAOc,QAAP;AACH;;AACD,SAASxB,oBAAT,CAA8BpyC,KAA9B,EAAqCosB,GAArC,EAA0C;EACtC,OAAOpsB,KAAP,EAAc;IACVosB,GAAG,CAACj9B,IAAJ,CAAS6Q,KAAK,CAACmyC,SAAf;IACAnyC,KAAK,GAAGA,KAAK,CAACxU,IAAd;EACH;AACJ;;AACD,MAAM8oD,SAAN,SAAwBrhD,KAAxB,CAA8B;;AAE9B,IAAIshD,eAAJ,C,CAAqB;AACrB;;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,gBAAT,CAA0Bh8C,IAA1B,EAAgC;EAC5B,IAAI+7C,eAAe,KAAK3nD,SAAxB,EACI2nD,eAAe,GAAG,IAAID,SAAJ,EAAlB;EACJ,OAAOC,eAAe,CAACz2C,MAAhB,CAAuBtF,IAAvB,CAAP;AACH;;AACD,MAAMi8C,cAAN,SAA6BxhD,KAA7B,CAAmC;;AAEnC,MAAMyhD,YAAN,SAA2BzhD,KAA3B,CAAiC;;AAEjC,MAAM0hD,eAAN,SAA8B1hD,KAA9B,CAAoC;;AAEpC,MAAM2hD,eAAN,SAA8B3hD,KAA9B,CAAoC;;AAEpC,MAAM4hD,kBAAN,SAAiC5hD,KAAjC,CAAuC;;AAEvC,MAAM6hD,QAAN,SAAuB7hD,KAAvB,CAA6B;;AAE7B,MAAM8hD,QAAN,SAAuB9hD,KAAvB,CAA6B;;AAE7B,SAAS+hD,gBAAT,CAA0BjnC,KAA1B,EAAiC;EAC7BqiC,iBAAiB,CAACriC,KAAD,EAAQ,IAAIknC,UAAJ,CAAelnC,KAAf,CAAR,CAAjB;AACH;;AACD,SAASmnC,qBAAT,CAA+BhhC,UAA/B,EAA2C;EACvCk8B,iBAAiB,CAACl8B,UAAD,EAAa,IAAIihC,eAAJ,CAAoBjhC,UAApB,CAAb,CAAjB;AACH;;AACD,SAASkhC,OAAT,CAAiB3vC,GAAjB,EAAsB;EAClB,IAAIA,GAAJ,EAAS;IACL,MAAM4qC,KAAK,GAAG5qC,GAAG,CAAC4qC,KAAlB;IACAl5C,aAAa,CAACk5C,KAAD,EAAQ,8CAAR,CAAb;IACA,OAAOA,KAAP;EACH,CAJD,MAKK;IACD,OAAO5qC,GAAP;EACH;AACJ;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS4vC,MAAT,CAAgBjhD,KAAhB,EAAuBkhD,eAAe,GAAG,KAAzC,EAAgD;EAC5C,MAAMh+C,IAAI,GAAGyb,WAAW,CAAC3e,KAAD,CAAxB;;EACA,IAAIkD,IAAJ,EAAU;IACN,QAAQA,IAAI,CAACizB,QAAb;MACI,KAAKhzB,IAAI,CAACi1B,SAAV;QACI,OAAOl1B,IAAI,CAAC0/B,WAAZ;;MACJ,KAAKz/B,IAAI,CAACg+C,YAAV;QACI,OAAQ,OAAMj+C,IAAI,CAAC0/B,WAAY,KAA/B;;MACJ,KAAKz/B,IAAI,CAACizB,YAAV;QACI,MAAM6C,SAAS,GAAG/1B,IAAI,CAAC+1B,SAAvB;;QACA,IAAIioB,eAAJ,EAAqB;UACjB,OAAOjoB,SAAP;QACH,CAFD,MAGK;UACD,MAAMxD,SAAS,GAAG,MAAMvyB,IAAI,CAACuyB,SAAX,GAAuB,GAAzC;UACA,OAAQwD,SAAS,CAACrC,KAAV,CAAgBnB,SAAhB,EAA2B,CAA3B,CAAD,GAAkC,GAAzC;QACH;;IAbT;EAeH;;EACD,OAAO,IAAP;AACH;;AACD,MAAMorB,UAAN,CAAiB;EACb/qD,WAAW,CAACsrD,UAAD,EAAa;IACpB,KAAKA,UAAL,GAAkBA,UAAlB;EACH;EACD;AACJ;AACA;;;EACa,IAALhyC,KAAK,GAAG;IACR,MAAMA,KAAK,GAAG,KAAKgyC,UAAL,CAAgBxpC,KAAhB,CAAd;IACA,OAAO;MACHypC,cAAc,EAAEjyC,KADb;MAEHkyC,cAAc,EAAElyC,KAAK,GAAG;MAAE;MAFvB;MAGHywB,YAAY,EAAE,CAAC,EAAEzwB,KAAK,GAAG;MAAE;MAAZ,CAHZ;MAIHmyC,aAAa,EAAE,CAAC,EAAEnyC,KAAK,GAAG;MAAE;MAAZ,CAJb;MAKHoyC,WAAW,EAAE,CAAC,EAAEpyC,KAAK,GAAG;MAAG;MAAb,CALX;MAMHqyC,KAAK,EAAE,CAAC,EAAEryC,KAAK,GAAG;MAAG;MAAb,CANL;MAOHsyC,QAAQ,EAAE,CAAC,EAAEtyC,KAAK,GAAG;MAAG;MAAb,CAPR;MAQHyiC,SAAS,EAAE,CAAC,EAAEziC,KAAK,GAAG;MAAI;MAAd,CART;MASHuyC,MAAM,EAAE,CAAC,EAAEvyC,KAAK,GAAG;MAAI;MAAd,CATN;MAUHwyC,oBAAoB,EAAExyC,KAAK,IAAI;MAAG;;IAV/B,CAAP;EAYH;;EACS,IAANmL,MAAM,GAAG;IACT,OAAOymC,OAAO,CAAC,KAAKI,UAAL,CAAgBvpC,MAAhB,CAAD,CAAd;EACH;;EACW,IAARgqC,QAAQ,GAAG;IACX,OAAOZ,MAAM,CAAC,KAAKG,UAAL,CAAgB1pC,IAAhB,CAAD,EAAwB,IAAxB,CAAb;EACH;;EACO,IAAJ4a,IAAI,GAAG;IACP,OAAO,CAAC,KAAKwvB,KAAL,IAAc,EAAf,EAAmB/iD,GAAnB,CAAuBgjD,SAAvB,EAAkC/iD,IAAlC,CAAuC,EAAvC,CAAP;EACH;;EACU,IAAPuS,OAAO,GAAG;IACV,OAAO,KAAK6vC,UAAL,CAAgBlpC,OAAhB,CAAP;EACH;EACD;AACJ;AACA;AACA;;;EACa,IAAL4pC,KAAK,GAAG;IACR,MAAMnoC,KAAK,GAAG,KAAKynC,UAAnB;IACA,MAAMx1C,KAAK,GAAG+N,KAAK,CAAChC,KAAD,CAAL,CAAamM,UAA3B;IACA,OAAOk+B,YAAY,CAACp2C,KAAD,EAAQ+N,KAAR,CAAnB;EACH;;EACW,IAAR3e,QAAQ,GAAG;IACX,OAAO,KAAK6Q,KAAL,CAAWkyC,SAAlB;EACH;;EACQ,IAALlyC,KAAK,GAAG;IACR,OAAO,KAAKu1C,UAAL,CAAgBzpC,KAAhB,CAAP;EACH;;EACU,IAAPstB,OAAO,GAAG;IACV,OAAO,KAAKmc,UAAL,CAAgBnpC,OAAhB,CAAP;EACH;;EACW,IAARxf,QAAQ,GAAG;IACX,OAAO,KAAK2oD,UAAL,CAAgBjpC,UAAhB,CAAP;EACH;;EACkB,IAAf8pC,eAAe,GAAG;IAClB,OAAO,KAAKb,UAAL,CAAgBhpC,gBAAhB,CAAP;EACH;;EACW,IAARxf,QAAQ,GAAG;IACX,OAAO,KAAKwoD,UAAL,CAAgB/oC,QAAhB,CAAP;EACH;;EACY,IAATuhB,SAAS,GAAG;IACZ,OAAO,KAAKwnB,UAAL,CAAgB9oC,SAAhB,CAAP;EACH;;EACY,IAAT4pC,SAAS,GAAG;IACZ,OAAOlB,OAAO,CAAC,KAAKI,UAAL,CAAgB7oC,UAAhB,CAAD,CAAd;EACH;;EACO,IAAJnhB,IAAI,GAAG;IACP,OAAO4pD,OAAO,CAAC,KAAKI,UAAL,CAAgBtpC,IAAhB,CAAD,CAAd;EACH;;EACY,IAATqqC,SAAS,GAAG;IACZ,OAAOnB,OAAO,CAAC,KAAKI,UAAL,CAAgB5oC,UAAhB,CAAD,CAAd;EACH;;EACkB,IAAf4pC,eAAe,GAAG;IAClB,OAAOpB,OAAO,CAAC,KAAKI,UAAL,CAAgB3oC,gBAAhB,CAAD,CAAd;EACH;;EACU,IAAP6kC,OAAO,GAAG;IACV,OAAO,KAAK8D,UAAL,CAAgBvoC,OAAhB,CAAP;EACH;;EACQ,IAALwpC,KAAK,GAAG;IACR,OAAO,KAAKjB,UAAL,CAAgBppC,MAAhB,CAAP;EACH;;EACK,IAAFjD,EAAE,GAAG;IACL,OAAO,KAAKqsC,UAAL,CAAgBtoC,EAAhB,CAAP;EACH;;EACQ,IAALvF,KAAK,GAAG;IACR,OAAO+uC,YAAY,CAAC,KAAKz2C,KAAN,EAAa,KAAKu1C,UAAlB,EAA8BpoC,aAA9B,EAA6C,KAAKnN,KAAL,CAAWsP,iBAAxD,CAAnB;EACH;;EACO,IAAJ3H,IAAI,GAAG;IACP,OAAO8uC,YAAY,CAAC,KAAKz2C,KAAN,EAAa,KAAKu1C,UAAlB,EAA8B,KAAKv1C,KAAL,CAAWsP,iBAAzC,EAA4D,KAAKtP,KAAL,CAAWwP,iBAAvE,CAAnB;EACH;;EACU,IAAPknC,OAAO,GAAG;IACV,OAAOD,YAAY,CAAC,KAAKz2C,KAAN,EAAa,KAAKu1C,UAAlB,EAA8B,KAAKv1C,KAAL,CAAWwP,iBAAzC,EAA4D,KAAK+lC,UAAL,CAAgBhmD,MAA5E,CAAnB;EACH;EACD;AACJ;AACA;;;EACkB,IAAVonD,UAAU,GAAG;IACb,MAAMA,UAAU,GAAG,EAAnB;IACA,IAAIv+B,KAAK,GAAG,KAAKi+B,SAAjB;;IACA,OAAOj+B,KAAP,EAAc;MACVu+B,UAAU,CAACznD,IAAX,CAAgBkpB,KAAhB;MACAA,KAAK,GAAGA,KAAK,CAAC7sB,IAAd;IACH;;IACD,OAAOorD,UAAP;EACH;;AAzGY;;AA2GjB,SAAST,SAAT,CAAmB7+C,IAAnB,EAAyB;EACrB,IAAIA,IAAI,CAACtI,IAAL,KAAc,kBAAlB,EAAsC;IAClC,OAAO,CAACsI,IAAI,CAACu/C,QAAL,IAAiB,EAAlB,EAAsB1jD,GAAtB,CAA0BgjD,SAA1B,EAAqC/iD,IAArC,CAA0C,EAA1C,CAAP;EACH,CAFD,MAGK,IAAIkE,IAAI,CAACtI,IAAL,KAAc,cAAlB,EAAkC;IACnC,MAAM,IAAI3C,KAAJ,CAAU,iBAAV,CAAN;EACH,CAFI,MAGA;IACD,OAAOgpD,MAAM,CAAC/9C,IAAI,CAACwlB,MAAN,EAAc,IAAd,CAAN,IAA6B,EAApC;EACH;AACJ;;AACD,SAAS45B,YAAT,CAAsBz2C,KAAtB,EAA6B8N,KAA7B,EAAoC1T,KAApC,EAA2Cf,GAA3C,EAAgD;EAC5C,IAAI80B,OAAO,GAAG,EAAd;;EACA,KAAK,IAAI1+B,KAAK,GAAG2K,KAAjB,EAAwB3K,KAAK,GAAG4J,GAAhC,EAAqC5J,KAAK,EAA1C,EAA8C;IAC1C0+B,OAAO,CAACj/B,IAAR,CAAa;MAAEO,KAAK,EAAEA,KAAT;MAAgB+N,CAAC,EAAEwC,KAAK,CAAC+I,IAAN,CAAWtZ,KAAX,CAAnB;MAAsConD,CAAC,EAAE/oC,KAAK,CAACre,KAAD;IAA9C,CAAb;EACH;;EACD,OAAO;IAAE2K,KAAK,EAAEA,KAAT;IAAgBf,GAAG,EAAEA,GAArB;IAA0B9J,MAAM,EAAE8J,GAAG,GAAGe,KAAxC;IAA+C+zB,OAAO,EAAEA;EAAxD,CAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASgoB,YAAT,CAAsBp2C,KAAtB,EAA6B+N,KAA7B,EAAoC;EAChC,IAAI/N,KAAJ,EAAW;IACP,MAAM+2C,UAAU,GAAG,EAAnB;IACA,IAAIC,WAAW,GAAGh3C,KAAlB;;IACA,OAAOg3C,WAAP,EAAoB;MAChBD,UAAU,CAAC5nD,IAAX,CAAgBikD,cAAc,CAAC4D,WAAD,EAAcjpC,KAAd,CAA9B;MACAipC,WAAW,GAAGA,WAAW,CAACxrD,IAA1B;IACH;;IACD,OAAOurD,UAAP;EACH,CARD,MASK;IACD,OAAO,EAAP;EACH;AACJ;;AACD,SAAS3D,cAAT,CAAwBpzC,KAAxB,EAA+B+N,KAA/B,EAAsC;EAClC,MAAMkpC,QAAQ,GAAGlpC,KAAK,CAAC/N,KAAK,CAACtQ,KAAP,CAAtB;EACA,MAAMotB,MAAM,GAAG/J,WAAW,CAACkkC,QAAD,CAA1B;EACA,MAAMC,SAAS,GAAG,EAAlB;EACA,MAAMC,SAAS,GAAG,EAAlB;EACA,MAAMl3C,KAAK,GAAG8N,KAAK,CAAChC,KAAD,CAAnB;;EACA,KAAK,IAAI/T,CAAC,GAAGgI,KAAK,CAACga,cAAnB,EAAmChiB,CAAC,GAAGgI,KAAK,CAACia,YAA7C,EAA2DjiB,CAAC,EAA5D,EAAgE;IAC5D,MAAMhD,GAAG,GAAGiL,KAAK,CAAC+I,IAAN,CAAWhR,CAAX,CAAZ;IACAk/C,SAAS,CAAC/nD,IAAV,CAAe6F,GAAG,CAAChG,IAAnB;IACAmoD,SAAS,CAAChoD,IAAV,CAAe4e,KAAK,CAAC/V,CAAD,CAApB;EACH;;EACD,OAAO;IACH0uB,IAAI,EAAE2uB,MAAM,CAACv4B,MAAD,CADT;IAEH9tB,IAAI,EAAEqtB,mBAAmB,CAACrc,KAAK,CAAChR,IAAP,CAFtB;IAGHgR,KAHG;IAIH8c,MAAM,EAAEA,MAJL;IAKH+5B,QAAQ,EAAET,YAAY,CAACp2C,KAAK,CAACqY,KAAP,EAActK,KAAd,CALnB;IAMHmpC,SANG;IAOHC,SAPG;IAQHtqD,QAAQ,EAAEuqD,sBAAsB,CAACp3C,KAAD,EAAQC,KAAR,EAAe8N,KAAf,CAR7B;;IASH,IAAIspC,sBAAJ,GAA6B;MACzB,OAAOr3C,KAAK,CAACmzC,qBAAN,CAA4BplC,KAA5B,CAAP;IACH;;EAXE,CAAP;AAaH;;AACD,SAASqpC,sBAAT,CAAgCp3C,KAAhC,EAAuCC,KAAvC,EAA8C8N,KAA9C,EAAqD;EACjD,MAAMupC,aAAa,GAAG,EAAtB;;EACA,KAAK,IAAIt/C,CAAC,GAAGgI,KAAK,CAACyzC,mBAAnB,EAAwCz7C,CAAC,GAAGgI,KAAK,CAAC0zC,iBAAlD,EAAqE17C,CAAC,EAAtE,EAA0E;IACtEs/C,aAAa,CAACnoD,IAAd,CAAmB8Q,KAAK,CAAC+I,IAAN,CAAWhR,CAAX,CAAnB;EACH;;EACD,MAAMxD,SAAS,GAAG,EAAlB;;EACA,KAAK,IAAIwD,CAAC,GAAGgI,KAAK,CAAC0zC,iBAAnB,EAAsC17C,CAAC,GAAGgI,KAAK,CAACia,YAAhD,EAA8DjiB,CAAC,EAA/D,EAAmE;IAC/DxD,SAAS,CAACrF,IAAV,CAAe8Q,KAAK,CAAC+I,IAAN,CAAWhR,CAAX,CAAf;EACH;;EACD,MAAMu/C,iBAAiB,GAAG;IACtBC,KAAK,EAAEC,OAAO,CAAC1pC,KAAD,EAAQ/N,KAAK,CAACiQ,aAAd,CADQ;IAEtBynC,eAAe,EAAED,OAAO,CAACx3C,KAAK,CAAC+I,IAAP,EAAahJ,KAAK,CAACiQ,aAAnB,CAFF;IAGtBzb,SAHsB;IAItB8iD,aAJsB;IAKtBh5B,mBAAmB,EAAEvQ,KAAK,CAAC/N,KAAK,CAACyzC,mBAAN,GAA4B,CAA7B;EALJ,CAA1B;EAOA,OAAO8D,iBAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASI,MAAT,CAAgBx+C,KAAhB,EAAuBy7B,GAAvB,EAA4B;EACxB,MAAMxgC,KAAK,GAAG+E,KAAK,CAACy7B,GAAD,CAAnB,CADwB,CAExB;EACA;;EACA,IAAI,OAAOxgC,KAAP,KAAiB,QAArB,EACI,OAAO,UAAP,CALoB,CAMxB;;EACA,MAAMjD,IAAI,GAAG,aAAaiD,KAAK,CAACd,QAAN,CAAe,CAAf,CAA1B;EACA,OAAOnC,IAAI,CAACqC,SAAL,CAAerC,IAAI,CAAC3B,MAAL,GAAc,CAA7B,CAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASioD,OAAT,CAAiBt+C,KAAjB,EAAwBy7B,GAAxB,EAA6B;EACzB,IAAIA,GAAG,GAAG,CAAV,EAAa;IACT,OAAO,kBAAP;EACH;;EACD,OAAQ,GAAE+iB,MAAM,CAACx+C,KAAD,EAAQy7B,GAAG,GAAG,CAAd,CAAiB,IAAG+iB,MAAM,CAACx+C,KAAD,EAAQy7B,GAAG,GAAG,CAAd,CAAiB,IAAG+iB,MAAM,CAACx+C,KAAD,EAAQy7B,GAAG,GAAG,CAAd,CAAiB,IAAG+iB,MAAM,CAACx+C,KAAD,EAAQy7B,GAAG,GAAG,CAAd,CAAiB,IAAG+iB,MAAM,CAACx+C,KAAD,EAAQy7B,GAAG,GAAG,CAAd,CAAiB,IAAG+iB,MAAM,CAACx+C,KAAD,EAAQy7B,GAAG,GAAG,CAAd,CAAiB,IAAG+iB,MAAM,CAACx+C,KAAD,EAAQy7B,GAAG,GAAG,CAAd,CAAiB,IAAG+iB,MAAM,CAACx+C,KAAD,EAAQy7B,GAAG,GAAG,CAAd,CAAiB,EAAvN;AACH;;AACD,MAAMugB,eAAN,CAAsB;EAClBjrD,WAAW,CAAC0tD,eAAD,EAAkB;IACzB,KAAKA,eAAL,GAAuBA,eAAvB;EACH;;EACuB,IAApBC,oBAAoB,GAAG;IACvB,OAAO,KAAKD,eAAL,CAAqBpsC,sBAArB,CAAP;EACH;;EACQ,IAALssC,KAAK,GAAG;IACR,OAAO,KAAKF,eAAL,CAAqBj/C,KAArB,CAA2BiT,uBAA3B,EACFzY,GADE,CACEiiD,OADF,CAAP;EAEH;;EACS,IAANzmC,MAAM,GAAG;IACT,OAAOymC,OAAO,CAAC,KAAKwC,eAAL,CAAqB3rC,MAArB,CAAD,CAAd;EACH;;EACa,IAAVqsB,UAAU,GAAG;IACb,OAAO,KAAKsf,eAAL,CAAqBjsC,WAArB,CAAP;EACH;;EACO,IAAJyY,IAAI,GAAG;IACP,OAAO,KAAKwzB,eAAL,CAAqB9rC,IAArB,CAAP;EACH;;EACS,IAANgR,MAAM,GAAG;IACT,OAAO,KAAK86B,eAAL,CAAqBnsC,MAArB,CAAP;EACH;;EACO,IAAJjgB,IAAI,GAAG;IACP,OAAO4pD,OAAO,CAAC,KAAKwC,eAAL,CAAqB1rC,IAArB,CAAD,CAAd;EACH;;AAzBiB;AA4BtB;AACA;AACA;AACA;;;AACA,MAAM6rC,cAAc,GAAG,CAAC,MAAMnuD,OAAO,CAAC4C,OAAR,CAAgB,IAAhB,CAAP,GAAvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASwrD,yBAAT,CAAmC/3C,KAAnC,EAA0C8N,KAA1C,EAAiD;EAC7C,MAAM4jC,kBAAkB,GAAG1xC,KAAK,CAAC0xC,kBAAjC;EACA,IAAIA,kBAAkB,KAAK,IAA3B,EACI;;EACJ,IAAI;IACA,KAAK,IAAI35C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG25C,kBAAkB,CAACniD,MAAvC,EAA+CwI,CAAC,EAAhD,EAAoD;MAChD,MAAMigD,MAAM,GAAGtG,kBAAkB,CAAC35C,CAAD,CAAjC;;MACA,IAAIigD,MAAM,GAAG,CAAb,EAAgB;QACZ;QACAj/B,gBAAgB,CAAC,CAACi/B,MAAF,CAAhB;MACH,CAHD,MAIK;QACD;QACA,MAAMC,YAAY,GAAGD,MAArB;QACA,MAAME,eAAe,GAAGxG,kBAAkB,CAAC,EAAE35C,CAAH,CAA1C;QACA,MAAMogD,aAAa,GAAGzG,kBAAkB,CAAC,EAAE35C,CAAH,CAAxC;QACA8e,6BAA6B,CAACqhC,eAAD,EAAkBD,YAAlB,CAA7B;QACA,MAAMvyC,OAAO,GAAGoI,KAAK,CAACmqC,YAAD,CAArB;QACAE,aAAa,CAAC;QAAE;QAAH,EAA6BzyC,OAA7B,CAAb;MACH;IACJ;EACJ,CAjBD,SAkBQ;IACJqT,gBAAgB,CAAC,CAAC,CAAF,CAAhB;EACH;AACJ;AACD;;;AACA,SAASq/B,qBAAT,CAA+Bp4C,KAA/B,EAAsC8N,KAAtC,EAA6C;EACzC,MAAM7F,cAAc,GAAGjI,KAAK,CAACiI,cAA7B;;EACA,IAAIA,cAAc,KAAK,IAAvB,EAA6B;IACzB,KAAK,IAAIlQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkQ,cAAc,CAAC1Y,MAAnC,EAA2CwI,CAAC,IAAI,CAAhD,EAAmD;MAC/C,MAAMsgD,aAAa,GAAGpwC,cAAc,CAAClQ,CAAD,CAApC;MACA,MAAMugD,eAAe,GAAGrwC,cAAc,CAAClQ,CAAC,GAAG,CAAL,CAAtC;;MACA,IAAIugD,eAAe,KAAK,CAAC,CAAzB,EAA4B;QACxB,MAAM9+B,YAAY,GAAGxZ,KAAK,CAAC+I,IAAN,CAAWuvC,eAAX,CAArB;QACApmD,SAAS,IAAIgF,aAAa,CAACsiB,YAAD,EAAe,yBAAf,CAA1B;QACAtnB,SAAS,IACLgF,aAAa,CAACsiB,YAAY,CAACvR,cAAd,EAA8B,2CAA9B,CADjB;QAEAoP,oBAAoB,CAACghC,aAAD,CAApB;QACA7+B,YAAY,CAACvR,cAAb,CAA4B;QAAE;QAA9B,EAAwD6F,KAAK,CAACwqC,eAAD,CAA7D,EAAgFA,eAAhF;MACH;IACJ;EACJ;AACJ;AACD;;;AACA,SAASC,sBAAT,CAAgCC,SAAhC,EAA2C7lB,UAA3C,EAAuD;EACnD,KAAK,IAAI56B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG46B,UAAU,CAACpjC,MAA/B,EAAuCwI,CAAC,EAAxC,EAA4C;IACxC0gD,gBAAgB,CAACD,SAAD,EAAY7lB,UAAU,CAAC56B,CAAD,CAAtB,CAAhB;EACH;AACJ;AACD;;;AACA,SAAS2gD,qBAAT,CAA+BF,SAA/B,EAA0C7lB,UAA1C,EAAsD;EAClD,KAAK,IAAI56B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG46B,UAAU,CAACpjC,MAA/B,EAAuCwI,CAAC,EAAxC,EAA4C;IACxC4gD,iBAAiB,CAACH,SAAD,EAAY7lB,UAAU,CAAC56B,CAAD,CAAtB,CAAjB;EACH;AACJ;;AACD,SAAS6gD,WAAT,CAAqBlhC,WAArB,EAAkC1X,KAAlC,EAAyC0F,OAAzC,EAAkDnC,KAAlD,EAAyD4gB,IAAzD,EAA+D00B,SAA/D,EAA0EzC,eAA1E,EAA2FrpD,QAA3F,EAAqGghC,SAArG,EAAgHnhC,QAAhH,EAA0H02B,oBAA1H,EAAgJ;EAC5I,MAAMxV,KAAK,GAAG5b,SAAS,GAAG2+C,8BAA8B,CAAC7wC,KAAD,CAAjC,GAA2CA,KAAK,CAAC0f,SAAN,CAAgBhnB,KAAhB,EAAlE;EACAoV,KAAK,CAACjC,IAAD,CAAL,GAAcsY,IAAd;EACArW,KAAK,CAAC/B,KAAD,CAAL,GAAexI,KAAK,GAAG;EAAE;EAAV,EAA0C;EAAG;EAA7C,EAAyE;EAAE;EAA1F;;EACA,IAAI+f,oBAAoB,KAAK,IAAzB,IACC5L,WAAW,IAAKA,WAAW,CAAC3L,KAAD,CAAX,GAAqB;EAAK;EAD/C,EAC2F;IACvF+B,KAAK,CAAC/B,KAAD,CAAL,IAAgB;IAAK;IAArB;EACH;;EACDgI,sBAAsB,CAACjG,KAAD,CAAtB;EACA5b,SAAS,IAAI8N,KAAK,CAACuX,SAAnB,IAAgCG,WAAhC,IAA+C7J,mBAAmB,CAAC7N,KAAK,CAACuX,SAAP,EAAkBG,WAAlB,CAAlE;EACA5J,KAAK,CAAC9B,MAAD,CAAL,GAAgB8B,KAAK,CAAClB,gBAAD,CAAL,GAA0B8K,WAA1C;EACA5J,KAAK,CAACzB,OAAD,CAAL,GAAiB3G,OAAjB;EACAoI,KAAK,CAACvB,gBAAD,CAAL,GAA2B6pC,eAAe,IAAI1+B,WAAW,IAAIA,WAAW,CAACnL,gBAAD,CAAxE;EACAra,SAAS,IAAIgF,aAAa,CAAC4W,KAAK,CAACvB,gBAAD,CAAN,EAA0B,6BAA1B,CAA1B;EACAuB,KAAK,CAACtB,QAAD,CAAL,GAAmBzf,QAAQ,IAAI2qB,WAAW,IAAIA,WAAW,CAAClL,QAAD,CAAzD;EACAta,SAAS,IAAIgF,aAAa,CAAC4W,KAAK,CAACtB,QAAD,CAAN,EAAkB,sBAAlB,CAA1B;EACAsB,KAAK,CAACrB,SAAD,CAAL,GAAmBshB,SAAS,IAAIrW,WAAW,IAAIA,WAAW,CAACjL,SAAD,CAAvC,IAAsD,IAAzE;EACAqB,KAAK,CAACxB,UAAD,CAAL,GAAoB1f,QAAQ,IAAI8qB,WAAW,IAAIA,WAAW,CAACpL,UAAD,CAAtC,IAAsD,IAA1E;EACAwB,KAAK,CAAC3B,MAAD,CAAL,GAAgB0sC,SAAhB;EACA/qC,KAAK,CAACb,EAAD,CAAL,GAAYgkB,gBAAgB,EAA5B;EACAnjB,KAAK,CAACZ,sBAAD,CAAL,GAAgCoW,oBAAhC;EACApxB,SAAS,IACLwE,WAAW,CAACsJ,KAAK,CAACjR,IAAN,IAAc;EAAE;EAAhB,EAA2C2oB,WAAW,KAAK,IAA3D,GAAkE,IAAnE,EAAyE,IAAzE,EAA+E,sCAA/E,CADf;EAEA5J,KAAK,CAACjB,0BAAD,CAAL,GACI7M,KAAK,CAACjR,IAAN,IAAc;EAAE;EAAhB,EAA2C2oB,WAAW,CAAC7K,0BAAD,CAAtD,GAAqFiB,KADzF;EAEA5b,SAAS,IAAI6iD,gBAAgB,CAACjnC,KAAD,CAA7B;EACA,OAAOA,KAAP;AACH;;AACD,SAASgrC,gBAAT,CAA0B94C,KAA1B,EAAiCvQ,KAAjC,EAAwCV,IAAxC,EAA8CuD,IAA9C,EAAoDwqB,KAApD,EAA2D;EACvD5qB,SAAS,IAAIzC,KAAK,KAAK,CAAvB,IAA4B;EACxB;EACA8G,wBAAwB,CAAC9G,KAAD,EAAQ0d,aAAR,EAAuB,uCAAvB,CAF5B,CADuD,CAIvD;;EACAjb,SAAS,IAAIyqB,mBAAmB,CAAC5tB,IAAD,CAAhC;EACA,IAAIgR,KAAK,GAAGC,KAAK,CAAC+I,IAAN,CAAWtZ,KAAX,CAAZ;;EACA,IAAIsQ,KAAK,KAAK,IAAd,EAAoB;IAChBA,KAAK,GAAGg5C,kBAAkB,CAAC/4C,KAAD,EAAQvQ,KAAR,EAAeV,IAAf,EAAqBuD,IAArB,EAA2BwqB,KAA3B,CAA1B;;IACA,IAAIpG,aAAa,EAAjB,EAAqB;MACjB;MACA;MACA;MACA;MACA3W,KAAK,CAACwD,KAAN,IAAe;MAAG;MAAlB;IACH;EACJ,CATD,MAUK,IAAIxD,KAAK,CAAChR,IAAN,GAAa;EAAG;EAApB,EAAiD;IAClDgR,KAAK,CAAChR,IAAN,GAAaA,IAAb;IACAgR,KAAK,CAAC5L,KAAN,GAAc7B,IAAd;IACAyN,KAAK,CAAC+c,KAAN,GAAcA,KAAd;IACA,MAAMpO,MAAM,GAAGgH,qBAAqB,EAApC;IACA3V,KAAK,CAACiQ,aAAN,GAAsBtB,MAAM,KAAK,IAAX,GAAkB,CAAC,CAAnB,GAAuBA,MAAM,CAACsB,aAApD;IACA9d,SAAS,IAAI6b,mBAAmB,CAAChO,KAAD,EAAQC,KAAR,CAAhC;IACA9N,SAAS,IAAIwE,WAAW,CAACjH,KAAD,EAAQsQ,KAAK,CAACtQ,KAAd,EAAqB,sBAArB,CAAxB;EACH;;EACDkmB,eAAe,CAAC5V,KAAD,EAAQ,IAAR,CAAf;EACA,OAAOA,KAAP;AACH;;AACD,SAASg5C,kBAAT,CAA4B/4C,KAA5B,EAAmCvQ,KAAnC,EAA0CV,IAA1C,EAAgDuD,IAAhD,EAAsDwqB,KAAtD,EAA6D;EACzD,MAAMtH,YAAY,GAAGC,4BAA4B,EAAjD;EACA,MAAMjH,QAAQ,GAAGoH,oBAAoB,EAArC;EACA,MAAMlH,MAAM,GAAGF,QAAQ,GAAGgH,YAAH,GAAkBA,YAAY,IAAIA,YAAY,CAAC9G,MAAtE,CAHyD,CAIzD;;EACA,MAAM3O,KAAK,GAAGC,KAAK,CAAC+I,IAAN,CAAWtZ,KAAX,IACVupD,WAAW,CAACh5C,KAAD,EAAQ0O,MAAR,EAAgB3f,IAAhB,EAAsBU,KAAtB,EAA6B6C,IAA7B,EAAmCwqB,KAAnC,CADf,CALyD,CAOzD;EACA;EACA;;EACA,IAAI9c,KAAK,CAACiY,UAAN,KAAqB,IAAzB,EAA+B;IAC3BjY,KAAK,CAACiY,UAAN,GAAmBlY,KAAnB;EACH;;EACD,IAAIyV,YAAY,KAAK,IAArB,EAA2B;IACvB,IAAIhH,QAAJ,EAAc;MACV;MACA,IAAIgH,YAAY,CAAC4C,KAAb,IAAsB,IAAtB,IAA8BrY,KAAK,CAAC2O,MAAN,KAAiB,IAAnD,EAAyD;QACrD;QACA8G,YAAY,CAAC4C,KAAb,GAAqBrY,KAArB;MACH;IACJ,CAND,MAOK;MACD,IAAIyV,YAAY,CAACjqB,IAAb,KAAsB,IAA1B,EAAgC;QAC5B;QACA;QACAiqB,YAAY,CAACjqB,IAAb,GAAoBwU,KAApB;MACH;IACJ;EACJ;;EACD,OAAOA,KAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASk5C,YAAT,CAAsBj5C,KAAtB,EAA6B8N,KAA7B,EAAoCorC,eAApC,EAAqDC,YAArD,EAAmE;EAC/D,IAAID,eAAe,KAAK,CAAxB,EACI,OAAO,CAAC,CAAR;;EACJ,IAAIhnD,SAAJ,EAAe;IACX6c,qBAAqB,CAAC/O,KAAD,CAArB;IACAnJ,UAAU,CAACmJ,KAAD,EAAQ8N,KAAK,CAAChC,KAAD,CAAb,EAAsB,0CAAtB,CAAV;IACApV,WAAW,CAACsJ,KAAK,CAAC+I,IAAN,CAAWxZ,MAAZ,EAAoBue,KAAK,CAACve,MAA1B,EAAkC,0CAAlC,CAAX;IACAmH,WAAW,CAACsJ,KAAK,CAAC+I,IAAN,CAAWxZ,MAAZ,EAAoByQ,KAAK,CAAC0f,SAAN,CAAgBnwB,MAApC,EAA4C,8CAA5C,CAAX;IACA0f,qBAAqB,CAACjP,KAAD,CAArB;EACH;;EACD,MAAMo5C,QAAQ,GAAGtrC,KAAK,CAACve,MAAvB;;EACA,KAAK,IAAIwI,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmhD,eAApB,EAAqCnhD,CAAC,EAAtC,EAA0C;IACtC+V,KAAK,CAAC5e,IAAN,CAAWiqD,YAAX;IACAn5C,KAAK,CAAC0f,SAAN,CAAgBxwB,IAAhB,CAAqBiqD,YAArB;IACAn5C,KAAK,CAAC+I,IAAN,CAAW7Z,IAAX,CAAgB,IAAhB;EACH;;EACD,OAAOkqD,QAAP;AACH,C,CACD;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,UAAT,CAAoBr5C,KAApB,EAA2B8N,KAA3B,EAAkCpI,OAAlC,EAA2C;EACvCxT,SAAS,IAAIwE,WAAW,CAACid,cAAc,CAAC7F,KAAD,CAAf,EAAwB,IAAxB,EAA8B,gCAA9B,CAAxB;EACA8J,SAAS,CAAC9J,KAAD,CAAT;;EACA,IAAI;IACA,MAAMjF,SAAS,GAAG7I,KAAK,CAAC6I,SAAxB;;IACA,IAAIA,SAAS,KAAK,IAAlB,EAAwB;MACpBywC,kBAAkB,CAAC;MAAE;MAAH,EAA6BzwC,SAA7B,EAAwCnD,OAAxC,CAAlB;IACH,CAJD,CAKA;IACA;;;IACA,MAAM6zC,UAAU,GAAGv5C,KAAK,CAAC7Q,QAAzB;;IACA,IAAIoqD,UAAU,KAAK,IAAnB,EAAyB;MACrBC,eAAe,CAACx5C,KAAD,EAAQ8N,KAAR,EAAeyrC,UAAf,EAA2B;MAAE;MAA7B,EAAuD7zC,OAAvD,CAAf;IACH,CAVD,CAWA;IACA;IACA;IACA;IACA;;;IACA,IAAI1F,KAAK,CAACF,eAAV,EAA2B;MACvBE,KAAK,CAACF,eAAN,GAAwB,KAAxB;IACH,CAlBD,CAmBA;IACA;IACA;;;IACA,IAAIE,KAAK,CAAC4xC,oBAAV,EAAgC;MAC5BwG,qBAAqB,CAACp4C,KAAD,EAAQ8N,KAAR,CAArB;IACH,CAxBD,CAyBA;IACA;IACA;;;IACA,IAAI9N,KAAK,CAAC2xC,iBAAV,EAA6B;MACzB2H,kBAAkB,CAAC;MAAE;MAAH,EAA6Bt5C,KAAK,CAAC6I,SAAnC,EAA8CnD,OAA9C,CAAlB;IACH,CA9BD,CA+BA;;;IACA,MAAMitB,UAAU,GAAG3yB,KAAK,CAAC2yB,UAAzB;;IACA,IAAIA,UAAU,KAAK,IAAnB,EAAyB;MACrB+lB,qBAAqB,CAAC5qC,KAAD,EAAQ6kB,UAAR,CAArB;IACH;EACJ,CApCD,CAqCA,OAAO7mC,KAAP,EAAc;IACV;IACA;IACA,IAAIkU,KAAK,CAACF,eAAV,EAA2B;MACvBE,KAAK,CAAC+xC,mBAAN,GAA4B,IAA5B;MACA/xC,KAAK,CAACF,eAAN,GAAwB,KAAxB;IACH;;IACD,MAAMhU,KAAN;EACH,CA7CD,SA8CQ;IACJgiB,KAAK,CAAC/B,KAAD,CAAL,IAAgB,CAAC;IAAE;IAAnB;IACAyM,SAAS;EACZ;AACJ;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASihC,WAAT,CAAqBz5C,KAArB,EAA4B8N,KAA5B,EAAmCyrC,UAAnC,EAA+C7zC,OAA/C,EAAwD;EACpDxT,SAAS,IAAIwE,WAAW,CAACid,cAAc,CAAC7F,KAAD,CAAf,EAAwB,KAAxB,EAA+B,8BAA/B,CAAxB;EACA,MAAMvK,KAAK,GAAGuK,KAAK,CAAC/B,KAAD,CAAnB;EACA,IAAI,CAACxI,KAAK,GAAG;EAAI;EAAb,MAA6C;EAAI;EAArD,EACI;EACJqU,SAAS,CAAC9J,KAAD,CAAT,CALoD,CAMpD;EACA;;EACA,MAAM4rC,sBAAsB,GAAGxnD,SAAS,IAAI8jB,sBAAsB,EAAlE;;EACA,IAAI;IACAjC,sBAAsB,CAACjG,KAAD,CAAtB;IACAyI,eAAe,CAACvW,KAAK,CAACsP,iBAAP,CAAf;;IACA,IAAIiqC,UAAU,KAAK,IAAnB,EAAyB;MACrBC,eAAe,CAACx5C,KAAD,EAAQ8N,KAAR,EAAeyrC,UAAf,EAA2B;MAAE;MAA7B,EAAuD7zC,OAAvD,CAAf;IACH;;IACD,MAAM07B,uBAAuB,GAAG,CAAC79B,KAAK,GAAG;IAAE;IAAX,MAAoD;IAAE;IAAtF,CANA,CAOA;IACA;;IACA,IAAI,CAACm2C,sBAAL,EAA6B;MACzB,IAAItY,uBAAJ,EAA6B;QACzB,MAAMvnB,kBAAkB,GAAG7Z,KAAK,CAAC6Z,kBAAjC;;QACA,IAAIA,kBAAkB,KAAK,IAA3B,EAAiC;UAC7Bc,iBAAiB,CAAC7M,KAAD,EAAQ+L,kBAAR,EAA4B,IAA5B,CAAjB;QACH;MACJ,CALD,MAMK;QACD,MAAMD,aAAa,GAAG5Z,KAAK,CAAC4Z,aAA5B;;QACA,IAAIA,aAAa,KAAK,IAAtB,EAA4B;UACxBkB,wBAAwB,CAAChN,KAAD,EAAQ8L,aAAR,EAAuB;UAAE;UAAzB,EAAkE,IAAlE,CAAxB;QACH;;QACDoB,uBAAuB,CAAClN,KAAD,EAAQ;QAAE;QAAV,CAAvB;MACH;IACJ,CAvBD,CAwBA;IACA;IACA;;;IACA6rC,+BAA+B,CAAC7rC,KAAD,CAA/B;IACA8rC,oBAAoB,CAAC9rC,KAAD,CAApB,CA5BA,CA6BA;;IACA,IAAI9N,KAAK,CAACiI,cAAN,KAAyB,IAA7B,EAAmC;MAC/BmwC,qBAAqB,CAACp4C,KAAD,EAAQ8N,KAAR,CAArB;IACH,CAhCD,CAiCA;IACA;;;IACA,IAAI,CAAC4rC,sBAAL,EAA6B;MACzB,IAAItY,uBAAJ,EAA6B;QACzB,MAAM7mB,iBAAiB,GAAGva,KAAK,CAACua,iBAAhC;;QACA,IAAIA,iBAAiB,KAAK,IAA1B,EAAgC;UAC5BI,iBAAiB,CAAC7M,KAAD,EAAQyM,iBAAR,CAAjB;QACH;MACJ,CALD,MAMK;QACD,MAAMD,YAAY,GAAGta,KAAK,CAACsa,YAA3B;;QACA,IAAIA,YAAY,KAAK,IAArB,EAA2B;UACvBQ,wBAAwB,CAAChN,KAAD,EAAQwM,YAAR,EAAsB;UAAE;UAAxB,CAAxB;QACH;;QACDU,uBAAuB,CAAClN,KAAD,EAAQ;QAAE;QAAV,CAAvB;MACH;IACJ;;IACDiqC,yBAAyB,CAAC/3C,KAAD,EAAQ8N,KAAR,CAAzB,CAlDA,CAmDA;;IACA,MAAM6kB,UAAU,GAAG3yB,KAAK,CAAC2yB,UAAzB;;IACA,IAAIA,UAAU,KAAK,IAAnB,EAAyB;MACrB4lB,sBAAsB,CAACzqC,KAAD,EAAQ6kB,UAAR,CAAtB;IACH,CAvDD,CAwDA;IACA;IACA;;;IACA,MAAM9pB,SAAS,GAAG7I,KAAK,CAAC6I,SAAxB;;IACA,IAAIA,SAAS,KAAK,IAAlB,EAAwB;MACpBywC,kBAAkB,CAAC;MAAE;MAAH,EAA6BzwC,SAA7B,EAAwCnD,OAAxC,CAAlB;IACH,CA9DD,CA+DA;IACA;;;IACA,IAAI,CAACg0C,sBAAL,EAA6B;MACzB,IAAItY,uBAAJ,EAA6B;QACzB,MAAM3mB,cAAc,GAAGza,KAAK,CAACya,cAA7B;;QACA,IAAIA,cAAc,KAAK,IAAvB,EAA6B;UACzBE,iBAAiB,CAAC7M,KAAD,EAAQ2M,cAAR,CAAjB;QACH;MACJ,CALD,MAMK;QACD,MAAMD,SAAS,GAAGxa,KAAK,CAACwa,SAAxB;;QACA,IAAIA,SAAS,KAAK,IAAlB,EAAwB;UACpBM,wBAAwB,CAAChN,KAAD,EAAQ0M,SAAR,EAAmB;UAAE;UAArB,CAAxB;QACH;;QACDQ,uBAAuB,CAAClN,KAAD,EAAQ;QAAE;QAAV,CAAvB;MACH;IACJ;;IACD,IAAI9N,KAAK,CAACkP,eAAN,KAA0B,IAA9B,EAAoC;MAChC;MACA;MACA;MACA;MACA;MACA;MACAlP,KAAK,CAACkP,eAAN,GAAwB,KAAxB;IACH,CAxFD,CAyFA;IACA;IACA;IACA;IACA;IACA;;;IACA,IAAI,CAACwqC,sBAAL,EAA6B;MACzB5rC,KAAK,CAAC/B,KAAD,CAAL,IAAgB,EAAE;MAAG;MAAH,EAA4B;MAAE;MAAhC,CAAhB;IACH;;IACD,IAAI+B,KAAK,CAAC/B,KAAD,CAAL,GAAe;IAAI;IAAvB,EAAiE;MAC7D+B,KAAK,CAAC/B,KAAD,CAAL,IAAgB,CAAC;MAAI;MAArB;MACAiI,2BAA2B,CAAClG,KAAK,CAAC9B,MAAD,CAAN,EAAgB,CAAC,CAAjB,CAA3B;IACH;EACJ,CAtGD,SAuGQ;IACJwM,SAAS;EACZ;AACJ;;AACD,SAASqhC,yBAAT,CAAmC75C,KAAnC,EAA0C8N,KAA1C,EAAiDyrC,UAAjD,EAA6D7zC,OAA7D,EAAsE;EAClE,MAAM0wC,eAAe,GAAGtoC,KAAK,CAACvB,gBAAD,CAA7B,CADkE,CAElE;EACA;EACA;;EACA,MAAM40B,kBAAkB,GAAG,CAAC,CAACjvC,SAAF,IAAe8jB,sBAAsB,EAAhE;EACA,MAAM8jC,oBAAoB,GAAGnmC,cAAc,CAAC7F,KAAD,CAA3C;;EACA,IAAI;IACA,IAAI,CAACqzB,kBAAD,IAAuB,CAAC2Y,oBAAxB,IAAgD1D,eAAe,CAAC2D,KAApE,EAA2E;MACvE3D,eAAe,CAAC2D,KAAhB;IACH;;IACD,IAAID,oBAAJ,EAA0B;MACtBT,UAAU,CAACr5C,KAAD,EAAQ8N,KAAR,EAAepI,OAAf,CAAV;IACH;;IACD+zC,WAAW,CAACz5C,KAAD,EAAQ8N,KAAR,EAAeyrC,UAAf,EAA2B7zC,OAA3B,CAAX;EACH,CARD,SASQ;IACJ,IAAI,CAACy7B,kBAAD,IAAuB,CAAC2Y,oBAAxB,IAAgD1D,eAAe,CAAC/8C,GAApE,EAAyE;MACrE+8C,eAAe,CAAC/8C,GAAhB;IACH;EACJ;AACJ;;AACD,SAASmgD,eAAT,CAAyBx5C,KAAzB,EAAgC8N,KAAhC,EAAuCyrC,UAAvC,EAAmDS,EAAnD,EAAuDt0C,OAAvD,EAAgE;EAC5D,MAAMu0C,iBAAiB,GAAGnhC,gBAAgB,EAA1C;EACA,MAAMohC,aAAa,GAAGF,EAAE,GAAG;EAAE;EAA7B;;EACA,IAAI;IACAjhC,gBAAgB,CAAC,CAAC,CAAF,CAAhB;;IACA,IAAImhC,aAAa,IAAIpsC,KAAK,CAACve,MAAN,GAAe4d,aAApC,EAAmD;MAC/C;MACA;MACA+zB,mBAAmB,CAAClhC,KAAD,EAAQ8N,KAAR,EAAeX,aAAf,EAA8B,CAAC,CAACjb,SAAF,IAAe8jB,sBAAsB,EAAnE,CAAnB;IACH;;IACD,MAAMmkC,WAAW,GAAGD,aAAa,GAAG;IAAE;IAAL,EAA+C;IAAE;IAAlF;IACA1oC,QAAQ,CAAC2oC,WAAD,EAAcz0C,OAAd,CAAR;IACA6zC,UAAU,CAACS,EAAD,EAAKt0C,OAAL,CAAV;EACH,CAVD,SAWQ;IACJqT,gBAAgB,CAACkhC,iBAAD,CAAhB;IACA,MAAMG,YAAY,GAAGF,aAAa,GAAG;IAAE;IAAL,EAA6C;IAAE;IAAjF;IACA1oC,QAAQ,CAAC4oC,YAAD,EAAe10C,OAAf,CAAR;EACH;AACJ,C,CACD;AACA;AACA;;;AACA,SAAS20C,qBAAT,CAA+Br6C,KAA/B,EAAsCD,KAAtC,EAA6C+N,KAA7C,EAAoD;EAChD,IAAIN,kBAAkB,CAACzN,KAAD,CAAtB,EAA+B;IAC3B,MAAM3F,KAAK,GAAG2F,KAAK,CAACga,cAApB;IACA,MAAM1gB,GAAG,GAAG0G,KAAK,CAACia,YAAlB;;IACA,KAAK,IAAIT,cAAc,GAAGnf,KAA1B,EAAiCmf,cAAc,GAAGlgB,GAAlD,EAAuDkgB,cAAc,EAArE,EAAyE;MACrE,MAAMxkB,GAAG,GAAGiL,KAAK,CAAC+I,IAAN,CAAWwQ,cAAX,CAAZ;;MACA,IAAIxkB,GAAG,CAACkT,cAAR,EAAwB;QACpBlT,GAAG,CAACkT,cAAJ,CAAmB;QAAE;QAArB,EAA+C6F,KAAK,CAACyL,cAAD,CAApD,EAAsEA,cAAtE;MACH;IACJ;EACJ;AACJ;AACD;AACA;AACA;;;AACA,SAAS+gC,yBAAT,CAAmCt6C,KAAnC,EAA0C8N,KAA1C,EAAiD/N,KAAjD,EAAwD;EACpD,IAAI,CAAC+U,kBAAkB,EAAvB,EACI;EACJylC,wBAAwB,CAACv6C,KAAD,EAAQ8N,KAAR,EAAe/N,KAAf,EAAsBmT,gBAAgB,CAACnT,KAAD,EAAQ+N,KAAR,CAAtC,CAAxB;;EACA,IAAI,CAAC/N,KAAK,CAACwD,KAAN,GAAc;EAAI;EAAnB,MAAyD;EAAI;EAAjE,EAAmG;IAC/Fi3C,4BAA4B,CAACx6C,KAAD,EAAQ8N,KAAR,EAAe/N,KAAf,CAA5B;EACH;AACJ;AACD;AACA;AACA;AACA;;;AACA,SAAS06C,wBAAT,CAAkCC,QAAlC,EAA4C36C,KAA5C,EAAmD46C,iBAAiB,GAAGznC,gBAAvE,EAAyF;EACrF,MAAMsgB,UAAU,GAAGzzB,KAAK,CAACyzB,UAAzB;;EACA,IAAIA,UAAU,KAAK,IAAnB,EAAyB;IACrB,IAAIC,UAAU,GAAG1zB,KAAK,CAACtQ,KAAN,GAAc,CAA/B;;IACA,KAAK,IAAIsI,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGy7B,UAAU,CAACjkC,MAA/B,EAAuCwI,CAAC,IAAI,CAA5C,EAA+C;MAC3C,MAAMtI,KAAK,GAAG+jC,UAAU,CAACz7B,CAAC,GAAG,CAAL,CAAxB;MACA,MAAM5D,KAAK,GAAG1E,KAAK,KAAK,CAAC,CAAX,GACVkrD,iBAAiB,CAAC56C,KAAD,EAAQ26C,QAAR,CADP,GAEVA,QAAQ,CAACjrD,KAAD,CAFZ;MAGAirD,QAAQ,CAACjnB,UAAU,EAAX,CAAR,GAAyBt/B,KAAzB;IACH;EACJ;AACJ;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASymD,yBAAT,CAAmC7lD,GAAnC,EAAwC;EACpC,MAAMiL,KAAK,GAAGjL,GAAG,CAACiL,KAAlB,CADoC,CAEpC;EACA;;EACA,IAAIA,KAAK,KAAK,IAAV,IAAkBA,KAAK,CAAC+xC,mBAA5B,EAAiD;IAC7C;IACA;IACA,MAAMx6B,SAAS,GAAG,IAAlB;IACA,OAAOxiB,GAAG,CAACiL,KAAJ,GAAY66C,WAAW,CAAC;IAAE;IAAH,EAA8BtjC,SAA9B,EAAyCxiB,GAAG,CAAC5F,QAA7C,EAAuD4F,GAAG,CAAC2S,KAA3D,EAAkE3S,GAAG,CAAC4S,IAAtE,EAA4E5S,GAAG,CAACyT,aAAhF,EAA+FzT,GAAG,CAAC0T,QAAnG,EAA6G1T,GAAG,CAAC8T,SAAjH,EAA4H9T,GAAG,CAACqU,OAAhI,EAAyIrU,GAAG,CAAC6S,MAA7I,CAA9B;EACH;;EACD,OAAO5H,KAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS66C,WAAT,CAAqB9rD,IAArB,EAA2BwoB,SAA3B,EAAsCgiC,UAAtC,EAAkD7xC,KAAlD,EAAyDC,IAAzD,EAA+DiC,UAA/D,EAA2EC,KAA3E,EAAkFhB,SAAlF,EAA6FO,OAA7F,EAAsG0xC,eAAtG,EAAuH;EACnH5oD,SAAS,IAAIA,SAAS,CAAC8N,KAAV,EAAb;EACA,MAAMsP,iBAAiB,GAAGnC,aAAa,GAAGzF,KAA1C,CAFmH,CAGnH;EACA;EACA;;EACA,MAAMqzC,iBAAiB,GAAGzrC,iBAAiB,GAAG3H,IAA9C;EACA,MAAM+X,SAAS,GAAGs7B,mBAAmB,CAAC1rC,iBAAD,EAAoByrC,iBAApB,CAArC;EACA,MAAMnzC,MAAM,GAAG,OAAOkzC,eAAP,KAA2B,UAA3B,GAAwCA,eAAe,EAAvD,GAA4DA,eAA3E;EACA,MAAM96C,KAAK,GAAG0f,SAAS,CAAC5T,KAAD,CAAT,GAAmB5Z,SAAS,GACtC,IAAIq/C,gBAAJ,CAAqBxiD,IAArB,EAA2B;EAC3B2wB,SADA,EACW;EACX65B,UAFA,EAEY;EACZ,IAHA,EAGM;EACN1wC,SAJA,EAIW;EACX0O,SALA,EAKW;EACXg9B,gBAAgB,CAAC70B,SAAD,CAAhB,CAA4Bu7B,IAA5B,CAAiC,IAAjC,EAAuC3rC,iBAAvC,CANA,EAM2D;EAC3DA,iBAPA,EAOmB;EACnByrC,iBARA,EAQmB;EACnB,IATA,EASM;EACN,IAVA,EAUM;EACN,IAXA,EAWM;EACN,KAZA,EAYO;EACP,KAbA,EAaO;EACP,IAdA,EAcM;EACN,IAfA,EAeM;EACN,IAhBA,EAgBM;EACN,IAjBA,EAiBM;EACN,IAlBA,EAkBM;EACN,IAnBA,EAmBM;EACN,IApBA,EAoBM;EACN,IArBA,EAqBM;EACN,IAtBA,EAsBM;EACN,IAvBA,EAuBM;EACN,OAAOnxC,UAAP,KAAsB,UAAtB,GAAmC;EAC/BA,UAAU,EADd,GACmB;EACfA,UA1BJ,EA0BgB;EAChB,OAAOC,KAAP,KAAiB,UAAjB,GAA8BA,KAAK,EAAnC,GAAwCA,KA3BxC,EA2B+C;EAC/C,IA5BA,EA4BM;EACNT,OA7BA,EA6BS;EACTxB,MA9BA,EA8BQ;EACR,KA/BA,EA+BO;EACPF,KAhCA,EAgCO;EACPC,IAjCA,CADsC,GAmCtC;IACI5Y,IAAI,EAAEA,IADV;IAEI2wB,SAAS,EAAEA,SAFf;IAGIvwB,QAAQ,EAAEoqD,UAHd;IAII9H,OAAO,EAAE,IAJb;IAKI5oC,SAAS,EAAEA,SALf;IAMI0O,SAAS,EAAEA,SANf;IAOIxO,IAAI,EAAE2W,SAAS,CAAChnB,KAAV,GAAkBuiD,IAAlB,CAAuB,IAAvB,EAA6B3rC,iBAA7B,CAPV;IAQIA,iBAAiB,EAAEA,iBARvB;IASIE,iBAAiB,EAAEurC,iBATvB;IAUIrJ,kBAAkB,EAAE,IAVxB;IAWI5xC,eAAe,EAAE,IAXrB;IAYIoP,eAAe,EAAE,IAZrB;IAaIyiC,iBAAiB,EAAE,KAbvB;IAcIC,oBAAoB,EAAE,KAd1B;IAeIh4B,aAAa,EAAE,IAfnB;IAgBIC,kBAAkB,EAAE,IAhBxB;IAiBIS,YAAY,EAAE,IAjBlB;IAkBIC,iBAAiB,EAAE,IAlBvB;IAmBIC,SAAS,EAAE,IAnBf;IAoBIC,cAAc,EAAE,IApBpB;IAqBIC,YAAY,EAAE,IArBlB;IAsBI0e,OAAO,EAAE,IAtBb;IAuBInxB,cAAc,EAAE,IAvBpB;IAwBI0qB,UAAU,EAAE,IAxBhB;IAyBIkf,iBAAiB,EAAE,OAAOjoC,UAAP,KAAsB,UAAtB,GAAmCA,UAAU,EAA7C,GAAkDA,UAzBzE;IA0BIkoC,YAAY,EAAE,OAAOjoC,KAAP,KAAiB,UAAjB,GAA8BA,KAAK,EAAnC,GAAwCA,KA1B1D;IA2BIoO,UAAU,EAAE,IA3BhB;IA4BI7O,OAAO,EAAEA,OA5Bb;IA6BIxB,MAAM,EAAEA,MA7BZ;IA8BImqC,mBAAmB,EAAE;EA9BzB,CAnCJ;;EAmEA,IAAI7/C,SAAJ,EAAe;IACX;IACA;IACA;IACAsJ,MAAM,CAAC0/C,IAAP,CAAYl7C,KAAZ;EACH;;EACD,OAAOA,KAAP;AACH;;AACD,SAASg7C,mBAAT,CAA6B1rC,iBAA7B,EAAgDyrC,iBAAhD,EAAmE;EAC/D,MAAMr7B,SAAS,GAAGxtB,SAAS,GAAG,IAAIsiD,cAAJ,EAAH,GAA0B,EAArD;;EACA,KAAK,IAAIz8C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGgjD,iBAApB,EAAuChjD,CAAC,EAAxC,EAA4C;IACxC2nB,SAAS,CAACxwB,IAAV,CAAe6I,CAAC,GAAGuX,iBAAJ,GAAwB,IAAxB,GAA+BwxB,SAA9C;EACH;;EACD,OAAOphB,SAAP;AACH;;AACD,SAASy7B,WAAT,CAAqBjqD,IAArB,EAA2B6B,KAA3B,EAAkC;EAC9B,OAAO,IAAI3G,KAAJ,CAAW,aAAY8E,IAAK,KAAIiR,iBAAiB,CAACpP,KAAD,CAAQ,GAAzD,CAAP;AACH;;AACD,SAASqoD,oBAAT,CAA8BjpB,QAA9B,EAAwCkpB,iBAAxC,EAA2D;EACvD,IAAI,CAAClpB,QAAL,EAAe;IACX,IAAI,OAAOkpB,iBAAP,KAA6B,QAAjC,EAA2C;MACvC,MAAMF,WAAW,CAAC,oCAAD,EAAuCE,iBAAvC,CAAjB;IACH,CAFD,MAGK;MACD,MAAMF,WAAW,CAAC,wBAAD,EAA2BE,iBAA3B,CAAjB;IACH;EACJ;AACJ;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,iBAAT,CAA2BvuD,QAA3B,EAAqCsuD,iBAArC,EAAwDryC,aAAxD,EAAuE;EACnE,IAAIuJ,oBAAoB,CAACxlB,QAAD,CAAxB,EAAoC;IAChC;IACA,MAAMwuD,eAAe,GAAGvyC,aAAa,KAAKnX,iBAAiB,CAAC2pD,SAA5D;IACA,OAAOzuD,QAAQ,CAAC0uD,iBAAT,CAA2BJ,iBAA3B,EAA8CE,eAA9C,CAAP;EACH;;EACD,IAAIppB,QAAQ,GAAG,OAAOkpB,iBAAP,KAA6B,QAA7B,GACXtuD,QAAQ,CAAC2uD,aAAT,CAAuBL,iBAAvB,CADW,GAEXA,iBAFJ;EAGAnpD,SAAS,IAAIkpD,oBAAoB,CAACjpB,QAAD,EAAWkpB,iBAAX,CAAjC,CATmE,CAUnE;EACA;EACA;EACA;;EACAlpB,QAAQ,CAAC4E,WAAT,GAAuB,EAAvB;EACA,OAAO5E,QAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASwpB,uBAAT,CAAiC37C,KAAjC,EAAwC8N,KAAxC,EAA+CpI,OAA/C,EAAwDk2C,SAAxD,EAAmE;EAC/D,MAAMviB,QAAQ,GAAGwiB,uBAAuB,CAAC/tC,KAAD,CAAxC;;EACA,IAAIpI,OAAO,KAAK,IAAhB,EAAsB;IAClB;IACA;IACA,IAAIxT,SAAJ,EAAe;MACXsJ,MAAM,CAAC+K,MAAP,CAAcu1C,uBAAuB,CAAC97C,KAAD,CAArC;IACH;;IACDq5B,QAAQ,CAACnqC,IAAT,CAAc0sD,SAAd;EACH,CAPD,MAQK;IACDviB,QAAQ,CAACnqC,IAAT,CAAcwW,OAAd;;IACA,IAAI1F,KAAK,CAACF,eAAV,EAA2B;MACvBg8C,uBAAuB,CAAC97C,KAAD,CAAvB,CAA+B9Q,IAA/B,CAAoC0sD,SAApC,EAA+CviB,QAAQ,CAAC9pC,MAAT,GAAkB,CAAjE;IACH;EACJ;AACJ;;AACD,SAASypD,WAAT,CAAqBh5C,KAArB,EAA4B+7C,OAA5B,EAAqChtD,IAArC,EAA2CU,KAA3C,EAAkD0E,KAAlD,EAAyD2oB,KAAzD,EAAgE;EAC5D5qB,SAAS,IAAIzC,KAAK,KAAK,CAAvB,IAA4B;EACxB;EACA8G,wBAAwB,CAAC9G,KAAD,EAAQ0d,aAAR,EAAuB,uCAAvB,CAF5B;EAGAjb,SAAS,IAAI4E,aAAa,CAACgmB,KAAD,EAAQnwB,SAAR,EAAmB,gDAAnB,CAA1B;EACAuF,SAAS,IAAIA,SAAS,CAAC6N,KAAV,EAAb;EACA7N,SAAS,IAAI6pD,OAAb,IAAwBhuC,mBAAmB,CAACguC,OAAD,EAAU/7C,KAAV,CAA3C;EACA,IAAIgQ,aAAa,GAAG+rC,OAAO,GAAGA,OAAO,CAAC/rC,aAAX,GAA2B,CAAC,CAAvD;EACA,MAAMjQ,KAAK,GAAG7N,SAAS,GACnB,IAAIwhD,UAAJ,CAAe1zC,KAAf,EAAsB;EACtBjR,IADA,EACM;EACNU,KAFA,EAEO;EACP,IAHA,EAGM;EACNugB,aAJA,EAIe;EACf,CAAC,CALD,EAKI;EACJ,CAAC,CAND,EAMI;EACJ,CAAC,CAPD,EAOI;EACJ,IARA,EAQM;EACN,CATA,EASG;EACH,CAVA,EAUG;EACH7b,KAXA,EAWO;EACP2oB,KAZA,EAYO;EACP,IAbA,EAaM;EACN,IAdA,EAcM;EACNnwB,SAfA,EAeW;EACX,IAhBA,EAgBM;EACN,IAjBA,EAiBM;EACN,IAlBA,EAkBM;EACN,IAnBA,EAmBM;EACN,IApBA,EAoBM;EACN,IArBA,EAqBM;EACNovD,OAtBA,EAsBS;EACT,IAvBA,EAuBM;EACN,IAxBA,EAwBM;EACN,IAzBA,EAyBM;EACNpvD,SA1BA,EA0BW;EACX,IA3BA,EA2BM;EACN,IA5BA,EA4BM;EACNA,SA7BA,EA6BW;EACX,CA9BA,EA8BG;EACH,CA/BA,CADmB,GAiCnB;IACIoC,IADJ;IAEIU,KAFJ;IAGI6iD,iBAAiB,EAAE,IAHvB;IAIItiC,aAJJ;IAKI+J,cAAc,EAAE,CAAC,CALrB;IAMIC,YAAY,EAAE,CAAC,CANnB;IAOIu4B,oBAAoB,EAAE,CAAC,CAP3B;IAQIC,gBAAgB,EAAE,IARtB;IASIjvC,KAAK,EAAE,CATX;IAUIse,eAAe,EAAE,CAVrB;IAWI1tB,KAAK,EAAEA,KAXX;IAYI2oB,KAAK,EAAEA,KAZX;IAaI21B,WAAW,EAAE,IAbjB;IAcIjf,UAAU,EAAE,IAdhB;IAeIkf,aAAa,EAAE/lD,SAfnB;IAgBIub,MAAM,EAAE,IAhBZ;IAiBIC,OAAO,EAAE,IAjBb;IAkBIwqC,MAAM,EAAE,IAlBZ;IAmBIpnD,IAAI,EAAE,IAnBV;IAoBI+wC,cAAc,EAAE,IApBpB;IAqBIlkB,KAAK,EAAE,IArBX;IAsBI1J,MAAM,EAAEqtC,OAtBZ;IAuBIlsC,UAAU,EAAE,IAvBhB;IAwBIxgB,MAAM,EAAE,IAxBZ;IAyBIujD,iBAAiB,EAAE,IAzBvB;IA0BIC,cAAc,EAAElmD,SA1BpB;IA2BI2zB,OAAO,EAAE,IA3Bb;IA4BIwyB,kBAAkB,EAAE,IA5BxB;IA6BIC,eAAe,EAAEpmD,SA7BrB;IA8BIqmD,aAAa,EAAE,CA9BnB;IA+BIC,aAAa,EAAE;EA/BnB,CAjCJ;;EAkEA,IAAI/gD,SAAJ,EAAe;IACX;IACA;IACA;IACAsJ,MAAM,CAAC0/C,IAAP,CAAYn7C,KAAZ;EACH;;EACD,OAAOA,KAAP;AACH;;AACD,SAASi8C,uBAAT,CAAiCC,aAAjC,EAAgD3D,eAAhD,EAAiE4D,SAAjE,EAA4E;EACxE,KAAK,IAAIrxC,UAAT,IAAuBoxC,aAAvB,EAAsC;IAClC,IAAIA,aAAa,CAACxrD,cAAd,CAA6Boa,UAA7B,CAAJ,EAA8C;MAC1CqxC,SAAS,GAAGA,SAAS,KAAK,IAAd,GAAqB,EAArB,GAA0BA,SAAtC;MACA,MAAMC,YAAY,GAAGF,aAAa,CAACpxC,UAAD,CAAlC;;MACA,IAAIqxC,SAAS,CAACzrD,cAAV,CAAyBoa,UAAzB,CAAJ,EAA0C;QACtCqxC,SAAS,CAACrxC,UAAD,CAAT,CAAsB3b,IAAtB,CAA2BopD,eAA3B,EAA4C6D,YAA5C;MACH,CAFD,MAGK;QACAD,SAAS,CAACrxC,UAAD,CAAT,GAAwB,CAACytC,eAAD,EAAkB6D,YAAlB,CAAzB;MACH;IACJ;EACJ;;EACD,OAAOD,SAAP;AACH;AACD;AACA;AACA;AACA;;;AACA,SAASE,+BAAT,CAAyCp8C,KAAzC,EAAgDD,KAAhD,EAAuD;EACnD7N,SAAS,IAAI6c,qBAAqB,CAAC/O,KAAD,CAAlC;EACA,MAAM5F,KAAK,GAAG2F,KAAK,CAACga,cAApB;EACA,MAAM1gB,GAAG,GAAG0G,KAAK,CAACia,YAAlB;EACA,MAAMqiC,SAAS,GAAGr8C,KAAK,CAAC+I,IAAxB;EACA,MAAMuzC,UAAU,GAAGv8C,KAAK,CAAC+c,KAAzB;EACA,MAAMy/B,eAAe,GAAGrqD,SAAS,GAAG,IAAI0iD,kBAAJ,EAAH,GAA8B,EAA/D;EACA,IAAI4H,WAAW,GAAG,IAAlB;EACA,IAAIC,YAAY,GAAG,IAAnB;;EACA,KAAK,IAAI1kD,CAAC,GAAGqC,KAAb,EAAoBrC,CAAC,GAAGsB,GAAxB,EAA6BtB,CAAC,EAA9B,EAAkC;IAC9B,MAAMyhB,YAAY,GAAG6iC,SAAS,CAACtkD,CAAD,CAA9B;IACA,MAAM2kD,eAAe,GAAGljC,YAAY,CAACtR,MAArC,CAF8B,CAG9B;IACA;IACA;IACA;;IACA,MAAMwqC,aAAa,GAAI4J,UAAU,KAAK,IAAf,IAAuB,CAAC7d,gBAAgB,CAAC1+B,KAAD,CAAzC,GAClB48C,qBAAqB,CAACD,eAAD,EAAkBJ,UAAlB,CADH,GAElB,IAFJ;IAGAC,eAAe,CAACrtD,IAAhB,CAAqBwjD,aAArB;IACA8J,WAAW,GAAGR,uBAAuB,CAACU,eAAD,EAAkB3kD,CAAlB,EAAqBykD,WAArB,CAArC;IACAC,YAAY,GAAGT,uBAAuB,CAACxiC,YAAY,CAACrR,OAAd,EAAuBpQ,CAAvB,EAA0B0kD,YAA1B,CAAtC;EACH;;EACD,IAAID,WAAW,KAAK,IAApB,EAA0B;IACtB,IAAIA,WAAW,CAAC/rD,cAAZ,CAA2B,OAA3B,CAAJ,EAAyC;MACrCsP,KAAK,CAACwD,KAAN,IAAe;MAAG;MAAlB;IACH;;IACD,IAAIi5C,WAAW,CAAC/rD,cAAZ,CAA2B,OAA3B,CAAJ,EAAyC;MACrCsP,KAAK,CAACwD,KAAN,IAAe;MAAG;MAAlB;IACH;EACJ;;EACDxD,KAAK,CAAC2yC,aAAN,GAAsB6J,eAAtB;EACAx8C,KAAK,CAACmI,MAAN,GAAes0C,WAAf;EACAz8C,KAAK,CAACoI,OAAN,GAAgBs0C,YAAhB;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASG,WAAT,CAAqBtqD,IAArB,EAA2B;EACvB,IAAIA,IAAI,KAAK,OAAb,EACI,OAAO,WAAP;EACJ,IAAIA,IAAI,KAAK,KAAb,EACI,OAAO,SAAP;EACJ,IAAIA,IAAI,KAAK,YAAb,EACI,OAAO,YAAP;EACJ,IAAIA,IAAI,KAAK,WAAb,EACI,OAAO,WAAP;EACJ,IAAIA,IAAI,KAAK,UAAb,EACI,OAAO,UAAP;EACJ,IAAIA,IAAI,KAAK,UAAb,EACI,OAAO,UAAP;EACJ,OAAOA,IAAP;AACH;;AACD,SAASuqD,uBAAT,CAAiC78C,KAAjC,EAAwCD,KAAxC,EAA+C+N,KAA/C,EAAsD9R,QAAtD,EAAgE7H,KAAhE,EAAuEpH,QAAvE,EAAiFghC,SAAjF,EAA4F+uB,UAA5F,EAAwG;EACpG5qD,SAAS,IAAI4E,aAAa,CAAC3C,KAAD,EAAQ2sC,SAAR,EAAmB,2CAAnB,CAA1B;EACA,MAAMvb,OAAO,GAAGrS,gBAAgB,CAACnT,KAAD,EAAQ+N,KAAR,CAAhC;EACA,IAAIivC,SAAS,GAAGh9C,KAAK,CAACmI,MAAtB;EACA,IAAI80C,SAAJ;;EACA,IAAI,CAACF,UAAD,IAAeC,SAAS,IAAI,IAA5B,KAAqCC,SAAS,GAAGD,SAAS,CAAC/gD,QAAD,CAA1D,CAAJ,EAA2E;IACvEihD,oBAAoB,CAACj9C,KAAD,EAAQ8N,KAAR,EAAekvC,SAAf,EAA0BhhD,QAA1B,EAAoC7H,KAApC,CAApB;IACA,IAAIsZ,eAAe,CAAC1N,KAAD,CAAnB,EACIm9C,iBAAiB,CAACpvC,KAAD,EAAQ/N,KAAK,CAACtQ,KAAd,CAAjB;;IACJ,IAAIyC,SAAJ,EAAe;MACXirD,sBAAsB,CAACrvC,KAAD,EAAQyX,OAAR,EAAiBxlB,KAAK,CAAChR,IAAvB,EAA6BiuD,SAA7B,EAAwC7oD,KAAxC,CAAtB;IACH;EACJ,CAPD,MAQK,IAAI4L,KAAK,CAAChR,IAAN,GAAa;EAAE;EAAnB,EAA6C;IAC9CiN,QAAQ,GAAG4gD,WAAW,CAAC5gD,QAAD,CAAtB;;IACA,IAAI9J,SAAJ,EAAe;MACXy9B,8BAA8B,CAAC3zB,QAAD,CAA9B;;MACA,IAAI,CAAC6yC,eAAe,CAACtpB,OAAD,EAAUvpB,QAAV,EAAoB+D,KAAK,CAAC5L,KAA1B,EAAiC6L,KAAK,CAACoJ,OAAvC,CAApB,EAAqE;QACjE0lC,0BAA0B,CAAC9yC,QAAD,EAAW+D,KAAK,CAAC5L,KAAjB,EAAwB4L,KAAK,CAAChR,IAA9B,EAAoC+e,KAApC,CAA1B;MACH;;MACD5b,SAAS,CAACqO,mBAAV;IACH,CAR6C,CAS9C;IACA;;;IACApM,KAAK,GAAG45B,SAAS,IAAI,IAAb,GAAoBA,SAAS,CAAC55B,KAAD,EAAQ4L,KAAK,CAAC5L,KAAN,IAAe,EAAvB,EAA2B6H,QAA3B,CAA7B,GAAoE7H,KAA5E;;IACA,IAAIoe,oBAAoB,CAACxlB,QAAD,CAAxB,EAAoC;MAChCA,QAAQ,CAACuwB,WAAT,CAAqBiI,OAArB,EAA8BvpB,QAA9B,EAAwC7H,KAAxC;IACH,CAFD,MAGK,IAAI,CAACkpB,eAAe,CAACrhB,QAAD,CAApB,EAAgC;MACjCupB,OAAO,CAACjI,WAAR,GAAsBiI,OAAO,CAACjI,WAAR,CAAoBthB,QAApB,EAA8B7H,KAA9B,CAAtB,GACIoxB,OAAO,CAACvpB,QAAD,CAAP,GAAoB7H,KADxB;IAEH;EACJ,CAnBI,MAoBA,IAAI4L,KAAK,CAAChR,IAAN,GAAa;EAAG;EAApB,EAAkD;IACnD;IACA;IACA,IAAImD,SAAS,IAAI,CAACs8C,eAAe,CAACxuC,KAAK,CAACoJ,OAAP,EAAgBrJ,KAAK,CAAC5L,KAAtB,CAAjC,EAA+D;MAC3D26C,0BAA0B,CAAC9yC,QAAD,EAAW+D,KAAK,CAAC5L,KAAjB,EAAwB4L,KAAK,CAAChR,IAA9B,EAAoC+e,KAApC,CAA1B;IACH;EACJ;AACJ;AACD;;;AACA,SAASovC,iBAAT,CAA2BpvC,KAA3B,EAAkCsvC,SAAlC,EAA6C;EACzClrD,SAAS,IAAI4c,WAAW,CAAChB,KAAD,CAAxB;EACA,MAAMuvC,mBAAmB,GAAG9pC,wBAAwB,CAAC6pC,SAAD,EAAYtvC,KAAZ,CAApD;;EACA,IAAI,EAAEuvC,mBAAmB,CAACtxC,KAAD,CAAnB,GAA6B;EAAG;EAAlC,CAAJ,EAAqE;IACjEsxC,mBAAmB,CAACtxC,KAAD,CAAnB,IAA8B;IAAG;IAAjC;EACH;AACJ;;AACD,SAASuxC,oBAAT,CAA8BxvC,KAA9B,EAAqCyX,OAArC,EAA8Cx2B,IAA9C,EAAoDkuB,QAApD,EAA8D9oB,KAA9D,EAAqE;EACjE,MAAMpH,QAAQ,GAAG+gB,KAAK,CAACtB,QAAD,CAAtB;EACAyQ,QAAQ,GAAGyT,yBAAyB,CAACzT,QAAD,CAApC;EACA,MAAMsgC,UAAU,GAAGzsB,0BAA0B,CAAC38B,KAAD,CAA7C;;EACA,IAAIpF,IAAI,GAAG;EAAE;EAAb,EAAuC;IACnC,IAAIoF,KAAK,IAAI,IAAb,EAAmB;MACfoe,oBAAoB,CAACxlB,QAAD,CAApB,GAAiCA,QAAQ,CAACq9B,eAAT,CAAyB7E,OAAzB,EAAkCtI,QAAlC,CAAjC,GACIsI,OAAO,CAAC6E,eAAR,CAAwBnN,QAAxB,CADJ;IAEH,CAHD,MAIK;MACD1K,oBAAoB,CAACxlB,QAAD,CAApB,GACIA,QAAQ,CAACowB,YAAT,CAAsBoI,OAAtB,EAA+BtI,QAA/B,EAAyCsgC,UAAzC,CADJ,GAEIh4B,OAAO,CAACpI,YAAR,CAAqBF,QAArB,EAA+BsgC,UAA/B,CAFJ;IAGH;EACJ,CAVD,MAWK;IACD,MAAMxmB,WAAW,GAAGtG,iBAAiB,CAAE,YAAW74B,IAAI,CAAC9E,SAAL,CAAe;MAAE,CAACmqB,QAAD,GAAYsgC;IAAd,CAAf,EAA2C,IAA3C,EAAiD,CAAjD,CAAoD,EAAjE,CAArC;;IACA,IAAIhrC,oBAAoB,CAACxlB,QAAD,CAAxB,EAAoC;MAChCA,QAAQ,CAAC+pC,QAAT,CAAkBvR,OAAlB,EAA2BwR,WAA3B;IACH,CAFD,MAGK;MACDxR,OAAO,CAACwR,WAAR,GAAsBA,WAAtB;IACH;EACJ;AACJ;;AACD,SAASomB,sBAAT,CAAgCrvC,KAAhC,EAAuCyX,OAAvC,EAAgDx2B,IAAhD,EAAsDiuD,SAAtD,EAAiE7oD,KAAjE,EAAwE;EACpE,IAAIpF,IAAI,IAAI;EAAE;EAAF,EAA6B;EAAE;EAAnC,CAAR,EAAuE;IACnE;AACR;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,KAAK,IAAIgJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGilD,SAAS,CAACztD,MAA9B,EAAsCwI,CAAC,IAAI,CAA3C,EAA8C;MAC1CulD,oBAAoB,CAACxvC,KAAD,EAAQyX,OAAR,EAAiBx2B,IAAjB,EAAuBiuD,SAAS,CAACjlD,CAAC,GAAG,CAAL,CAAhC,EAAyC5D,KAAzC,CAApB;IACH;EACJ;AACJ;AACD;AACA;AACA;;;AACA,SAASqpD,wBAAT,CAAkCx9C,KAAlC,EAAyC8N,KAAzC,EAAgD/Y,GAAhD,EAAqD;EACjD,MAAM0oD,SAAS,GAAGloC,eAAe,EAAjC;;EACA,IAAIvV,KAAK,CAACF,eAAV,EAA2B;IACvB,IAAI/K,GAAG,CAAC0S,iBAAR,EACI1S,GAAG,CAAC0S,iBAAJ,CAAsB1S,GAAtB;IACJ,MAAMwkB,cAAc,GAAG0/B,YAAY,CAACj5C,KAAD,EAAQ8N,KAAR,EAAe,CAAf,EAAkB,IAAlB,CAAnC;IACA5b,SAAS,IACLwE,WAAW,CAAC6iB,cAAD,EAAiBkkC,SAAS,CAAC1jC,cAA3B,EAA2C,0FAA3C,CADf;IAEA2jC,0BAA0B,CAAC19C,KAAD,EAAQy9C,SAAR,EAAmB3vC,KAAnB,EAA0ByL,cAA1B,EAA0CxkB,GAA1C,CAA1B;EACH;;EACD,MAAM0mB,SAAS,GAAGkG,iBAAiB,CAAC7T,KAAD,EAAQ9N,KAAR,EAAey9C,SAAS,CAAC1jC,cAAzB,EAAyC0jC,SAAzC,CAAnC;EACAvrB,eAAe,CAACzW,SAAD,EAAY3N,KAAZ,CAAf;EACA,MAAM+O,MAAM,GAAG3J,gBAAgB,CAACuqC,SAAD,EAAY3vC,KAAZ,CAA/B;;EACA,IAAI+O,MAAJ,EAAY;IACRqV,eAAe,CAACrV,MAAD,EAAS/O,KAAT,CAAf;EACH;;EACD,OAAO2N,SAAP;AACH;AACD;AACA;AACA;;;AACA,SAASkiC,iBAAT,CAA2B39C,KAA3B,EAAkC8N,KAAlC,EAAyC/N,KAAzC,EAAgD69C,SAAhD,EAA2D;EACvD;EACA;EACA1rD,SAAS,IAAI6c,qBAAqB,CAAC/O,KAAD,CAAlC;EACA,IAAIouC,aAAa,GAAG,KAApB;;EACA,IAAIt5B,kBAAkB,EAAtB,EAA0B;IACtB,MAAMtM,aAAa,GAAGq1C,uBAAuB,CAAC79C,KAAD,EAAQ8N,KAAR,EAAe/N,KAAf,CAA7C;IACA,MAAM+9C,UAAU,GAAGF,SAAS,KAAK,IAAd,GAAqB,IAArB,GAA4B;MAAE,IAAI,CAAC;IAAP,CAA/C;;IACA,IAAIp1C,aAAa,KAAK,IAAtB,EAA4B;MACxB4lC,aAAa,GAAG,IAAhB;MACA2P,cAAc,CAACh+C,KAAD,EAAQC,KAAK,CAAC+I,IAAN,CAAWxZ,MAAnB,EAA2BiZ,aAAa,CAACjZ,MAAzC,CAAd,CAFwB,CAGxB;MACA;MACA;MACA;MACA;MACA;;MACA,KAAK,IAAIwI,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyQ,aAAa,CAACjZ,MAAlC,EAA0CwI,CAAC,EAA3C,EAA+C;QAC3C,MAAMhD,GAAG,GAAGyT,aAAa,CAACzQ,CAAD,CAAzB;QACA,IAAIhD,GAAG,CAAC0S,iBAAR,EACI1S,GAAG,CAAC0S,iBAAJ,CAAsB1S,GAAtB;MACP;;MACD,IAAIipD,kBAAkB,GAAG,KAAzB;MACA,IAAIC,uBAAuB,GAAG,KAA9B;MACA,IAAIhG,YAAY,GAAGgB,YAAY,CAACj5C,KAAD,EAAQ8N,KAAR,EAAetF,aAAa,CAACjZ,MAA7B,EAAqC,IAArC,CAA/B;MACA2C,SAAS,IACL2E,UAAU,CAACohD,YAAD,EAAel4C,KAAK,CAACga,cAArB,EAAqC,2DAArC,CADd;;MAEA,KAAK,IAAIhiB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyQ,aAAa,CAACjZ,MAAlC,EAA0CwI,CAAC,EAA3C,EAA+C;QAC3C,MAAMhD,GAAG,GAAGyT,aAAa,CAACzQ,CAAD,CAAzB,CAD2C,CAE3C;QACA;;QACAgI,KAAK,CAAC0yC,WAAN,GAAoB/0B,cAAc,CAAC3d,KAAK,CAAC0yC,WAAP,EAAoB19C,GAAG,CAACiT,SAAxB,CAAlC;QACA01C,0BAA0B,CAAC19C,KAAD,EAAQD,KAAR,EAAe+N,KAAf,EAAsBmqC,YAAtB,EAAoCljD,GAApC,CAA1B;QACAmpD,mBAAmB,CAACjG,YAAD,EAAeljD,GAAf,EAAoB+oD,UAApB,CAAnB;QACA,IAAI/oD,GAAG,CAACkT,cAAJ,KAAuB,IAA3B,EACIlI,KAAK,CAACwD,KAAN,IAAe;QAAE;QAAjB;QACJ,IAAIxO,GAAG,CAAC+S,YAAJ,KAAqB,IAArB,IAA6B/S,GAAG,CAACiT,SAAJ,KAAkB,IAA/C,IAAuDjT,GAAG,CAACgT,QAAJ,KAAiB,CAA5E,EACIhI,KAAK,CAACwD,KAAN,IAAe;QAAI;QAAnB;QACJ,MAAM46C,cAAc,GAAGppD,GAAG,CAAChG,IAAJ,CAAS2M,SAAhC,CAX2C,CAY3C;QACA;;QACA,IAAI,CAACsiD,kBAAD,KACCG,cAAc,CAACxtC,WAAf,IAA8BwtC,cAAc,CAAC1kC,QAA7C,IAAyD0kC,cAAc,CAACzkC,SADzE,CAAJ,EACyF;UACrF;UACA;UACA;UACA,CAAC1Z,KAAK,CAAC4Z,aAAN,KAAwB5Z,KAAK,CAAC4Z,aAAN,GAAsB,EAA9C,CAAD,EAAoD1qB,IAApD,CAAyD6Q,KAAK,CAACtQ,KAA/D;UACAuuD,kBAAkB,GAAG,IAArB;QACH;;QACD,IAAI,CAACC,uBAAD,KAA6BE,cAAc,CAACxtC,WAAf,IAA8BwtC,cAAc,CAACzkC,SAA1E,CAAJ,EAA0F;UACtF,CAAC1Z,KAAK,CAAC6Z,kBAAN,KAA6B7Z,KAAK,CAAC6Z,kBAAN,GAA2B,EAAxD,CAAD,EAA8D3qB,IAA9D,CAAmE6Q,KAAK,CAACtQ,KAAzE;UACAwuD,uBAAuB,GAAG,IAA1B;QACH;;QACDhG,YAAY;MACf;;MACDmE,+BAA+B,CAACp8C,KAAD,EAAQD,KAAR,CAA/B;IACH;;IACD,IAAI+9C,UAAJ,EACIM,uBAAuB,CAACr+C,KAAD,EAAQ69C,SAAR,EAAmBE,UAAnB,CAAvB;EACP,CA3DsD,CA4DvD;;;EACA/9C,KAAK,CAAC0yC,WAAN,GAAoB/0B,cAAc,CAAC3d,KAAK,CAAC0yC,WAAP,EAAoB1yC,KAAK,CAAC+c,KAA1B,CAAlC;EACA,OAAOsxB,aAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASiQ,0BAAT,CAAoCr+C,KAApC,EAA2CD,KAA3C,EAAkD+N,KAAlD,EAAyDmqC,YAAzD,EAAuEqG,gBAAvE,EAAyFvpD,GAAzF,EAA8F;EAC1F7C,SAAS,IAAI6c,qBAAqB,CAAC/O,KAAD,CAAlC;EACA,MAAM8H,YAAY,GAAG/S,GAAG,CAAC+S,YAAzB;;EACA,IAAIA,YAAJ,EAAkB;IACd,IAAI4pC,kBAAkB,GAAG1xC,KAAK,CAAC0xC,kBAA/B;;IACA,IAAIA,kBAAkB,KAAK,IAA3B,EAAiC;MAC7BA,kBAAkB,GAAG1xC,KAAK,CAAC0xC,kBAAN,GAA2B,EAAhD;IACH;;IACD,MAAM6M,WAAW,GAAG,CAACx+C,KAAK,CAACtQ,KAA3B;;IACA,IAAI+uD,sBAAsB,CAAC9M,kBAAD,CAAtB,IAA8C6M,WAAlD,EAA+D;MAC3D;MACA;MACA;MACA7M,kBAAkB,CAACxiD,IAAnB,CAAwBqvD,WAAxB;IACH;;IACD7M,kBAAkB,CAACxiD,IAAnB,CAAwB+oD,YAAxB,EAAsCqG,gBAAtC,EAAwDx2C,YAAxD;EACH;AACJ;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS02C,sBAAT,CAAgC9M,kBAAhC,EAAoD;EAChD,IAAI35C,CAAC,GAAG25C,kBAAkB,CAACniD,MAA3B;;EACA,OAAOwI,CAAC,GAAG,CAAX,EAAc;IACV,MAAM5D,KAAK,GAAGu9C,kBAAkB,CAAC,EAAE35C,CAAH,CAAhC;;IACA,IAAI,OAAO5D,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,GAAG,CAAzC,EAA4C;MACxC,OAAOA,KAAP;IACH;EACJ;;EACD,OAAO,CAAP;AACH;AACD;AACA;AACA;;;AACA,SAASomD,wBAAT,CAAkCv6C,KAAlC,EAAyC8N,KAAzC,EAAgD/N,KAAhD,EAAuD8c,MAAvD,EAA+D;EAC3D,MAAMziB,KAAK,GAAG2F,KAAK,CAACga,cAApB;EACA,MAAM1gB,GAAG,GAAG0G,KAAK,CAACia,YAAlB;;EACA,IAAI,CAACha,KAAK,CAACF,eAAX,EAA4B;IACxBwf,8BAA8B,CAACvf,KAAD,EAAQ+N,KAAR,CAA9B;EACH;;EACDokB,eAAe,CAACrV,MAAD,EAAS/O,KAAT,CAAf;EACA,MAAM4kC,aAAa,GAAG3yC,KAAK,CAAC2yC,aAA5B;;EACA,KAAK,IAAI36C,CAAC,GAAGqC,KAAb,EAAoBrC,CAAC,GAAGsB,GAAxB,EAA6BtB,CAAC,EAA9B,EAAkC;IAC9B,MAAMhD,GAAG,GAAGiL,KAAK,CAAC+I,IAAN,CAAWhR,CAAX,CAAZ;IACA,MAAMq+B,WAAW,GAAGzoB,cAAc,CAAC5Y,GAAD,CAAlC;;IACA,IAAIqhC,WAAJ,EAAiB;MACblkC,SAAS,IAAIuqB,eAAe,CAAC1c,KAAD,EAAQ;MAAE;MAAV,CAA5B;MACA0+C,iBAAiB,CAAC3wC,KAAD,EAAQ/N,KAAR,EAAehL,GAAf,CAAjB;IACH;;IACD,MAAM0mB,SAAS,GAAGkG,iBAAiB,CAAC7T,KAAD,EAAQ9N,KAAR,EAAejI,CAAf,EAAkBgI,KAAlB,CAAnC;IACAmyB,eAAe,CAACzW,SAAD,EAAY3N,KAAZ,CAAf;;IACA,IAAI4kC,aAAa,KAAK,IAAtB,EAA4B;MACxBgM,kBAAkB,CAAC5wC,KAAD,EAAQ/V,CAAC,GAAGqC,KAAZ,EAAmBqhB,SAAnB,EAA8B1mB,GAA9B,EAAmCgL,KAAnC,EAA0C2yC,aAA1C,CAAlB;IACH;;IACD,IAAItc,WAAJ,EAAiB;MACb,MAAMvD,aAAa,GAAGtf,wBAAwB,CAACxT,KAAK,CAACtQ,KAAP,EAAcqe,KAAd,CAA9C;MACA+kB,aAAa,CAACxmB,OAAD,CAAb,GAAyBoP,SAAzB;IACH;EACJ;AACJ;;AACD,SAAS++B,4BAAT,CAAsCx6C,KAAtC,EAA6C8N,KAA7C,EAAoD/N,KAApD,EAA2D;EACvD,MAAM3F,KAAK,GAAG2F,KAAK,CAACga,cAApB;EACA,MAAM1gB,GAAG,GAAG0G,KAAK,CAACia,YAAlB;EACA,MAAM2kC,YAAY,GAAG5+C,KAAK,CAACtQ,KAA3B;EACA,MAAMqnB,qBAAqB,GAAGE,wBAAwB,EAAtD;;EACA,IAAI;IACA+B,gBAAgB,CAAC4lC,YAAD,CAAhB;;IACA,KAAK,IAAIC,QAAQ,GAAGxkD,KAApB,EAA2BwkD,QAAQ,GAAGvlD,GAAtC,EAA2CulD,QAAQ,EAAnD,EAAuD;MACnD,MAAM7pD,GAAG,GAAGiL,KAAK,CAAC+I,IAAN,CAAW61C,QAAX,CAAZ;MACA,MAAMnjC,SAAS,GAAG3N,KAAK,CAAC8wC,QAAD,CAAvB;MACA7nC,wBAAwB,CAAC6nC,QAAD,CAAxB;;MACA,IAAI7pD,GAAG,CAAC+S,YAAJ,KAAqB,IAArB,IAA6B/S,GAAG,CAACgT,QAAJ,KAAiB,CAA9C,IAAmDhT,GAAG,CAACiT,SAAJ,KAAkB,IAAzE,EAA+E;QAC3E62C,gCAAgC,CAAC9pD,GAAD,EAAM0mB,SAAN,CAAhC;MACH;IACJ;EACJ,CAVD,SAWQ;IACJ1C,gBAAgB,CAAC,CAAC,CAAF,CAAhB;IACAhC,wBAAwB,CAACD,qBAAD,CAAxB;EACH;AACJ;AACD;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS+nC,gCAAT,CAA0C9pD,GAA1C,EAA+C0mB,SAA/C,EAA0D;EACtD,IAAI1mB,GAAG,CAAC+S,YAAJ,KAAqB,IAAzB,EAA+B;IAC3B/S,GAAG,CAAC+S,YAAJ,CAAiB;IAAE;IAAnB,EAA6C2T,SAA7C;EACH;AACJ;AACD;AACA;AACA;AACA;;;AACA,SAASoiC,uBAAT,CAAiC79C,KAAjC,EAAwC06C,QAAxC,EAAkD36C,KAAlD,EAAyD;EACrD7N,SAAS,IAAI6c,qBAAqB,CAAC/O,KAAD,CAAlC;EACA9N,SAAS,IAAIuqB,eAAe,CAAC1c,KAAD,EAAQ;EAAE;EAAF,EAA6B;EAAG;EAAxC,CAA5B;EACA,MAAM++C,QAAQ,GAAG9+C,KAAK,CAAC6xC,iBAAvB;EACA,IAAIjd,OAAO,GAAG,IAAd;;EACA,IAAIkqB,QAAJ,EAAc;IACV,KAAK,IAAI/mD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+mD,QAAQ,CAACvvD,MAA7B,EAAqCwI,CAAC,EAAtC,EAA0C;MACtC,MAAMhD,GAAG,GAAG+pD,QAAQ,CAAC/mD,CAAD,CAApB;;MACA,IAAI6nC,0BAA0B,CAAC7/B,KAAD,EAAQhL,GAAG,CAAC6T,SAAZ;MAAuB;MAAuB,KAA9C,CAA9B,EAAoF;QAChFgsB,OAAO,KAAKA,OAAO,GAAG1iC,SAAS,GAAG,IAAIuiD,YAAJ,EAAH,GAAwB,EAAhD,CAAP;QACAt0B,kBAAkB,CAACb,8BAA8B,CAACvf,KAAD,EAAQ26C,QAAR,CAA/B,EAAkD16C,KAAlD,EAAyDjL,GAAG,CAAChG,IAA7D,CAAlB;;QACA,IAAI4e,cAAc,CAAC5Y,GAAD,CAAlB,EAAyB;UACrB,IAAI7C,SAAJ,EAAe;YACXuqB,eAAe,CAAC1c,KAAD,EAAQ;YAAE;YAAV,EAAoC,IAAGA,KAAK,CAAC5L,KAAM,4CAAhB,GAC7C,8CAA6CrB,SAAS,CAACiC,GAAG,CAAChG,IAAL,CAAW,aADvD,CAAf;;YAEA,IAAIgR,KAAK,CAACwD,KAAN,GAAc;YAAE;YAApB,EAAsD;cAClD;cACA;cACAqwB,2BAA2B,CAAC7zB,KAAD,EAAQ60B,OAAO,CAAC,CAAD,CAAP,CAAW7lC,IAAnB,EAAyBgG,GAAG,CAAChG,IAA7B,CAA3B;YACH;UACJ;;UACDgwD,mBAAmB,CAAC/+C,KAAD,EAAQD,KAAR,CAAnB,CAVqB,CAWrB;;UACA60B,OAAO,CAAC/3B,OAAR,CAAgB9H,GAAhB;QACH,CAbD,MAcK;UACD6/B,OAAO,CAAC1lC,IAAR,CAAa6F,GAAb;QACH;MACJ;IACJ;EACJ;;EACD,OAAO6/B,OAAP;AACH;AACD;AACA;AACA;AACA;AACA;;;AACA,SAASmqB,mBAAT,CAA6B/+C,KAA7B,EAAoCg/C,SAApC,EAA+C;EAC3C9sD,SAAS,IAAI6c,qBAAqB,CAAC/O,KAAD,CAAlC;EACAg/C,SAAS,CAACz7C,KAAV,IAAmB;EAAE;EAArB;EACA,CAACvD,KAAK,CAAC2yB,UAAN,KAAqB3yB,KAAK,CAAC2yB,UAAN,GAAmBzgC,SAAS,GAAG,IAAIwiD,eAAJ,EAAH,GAA2B,EAA5E,CAAD,EACKxlD,IADL,CACU8vD,SAAS,CAACvvD,KADpB;AAEH;AACD;;;AACA,SAAS2uD,uBAAT,CAAiCr+C,KAAjC,EAAwC69C,SAAxC,EAAmDE,UAAnD,EAA+D;EAC3D,IAAIF,SAAJ,EAAe;IACX,MAAMpqB,UAAU,GAAGzzB,KAAK,CAACyzB,UAAN,GAAmBthC,SAAS,GAAG,IAAIyiD,eAAJ,EAAH,GAA2B,EAA1E,CADW,CAEX;IACA;IACA;;IACA,KAAK,IAAI58C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6lD,SAAS,CAACruD,MAA9B,EAAsCwI,CAAC,IAAI,CAA3C,EAA8C;MAC1C,MAAMtI,KAAK,GAAGquD,UAAU,CAACF,SAAS,CAAC7lD,CAAC,GAAG,CAAL,CAAV,CAAxB;MACA,IAAItI,KAAK,IAAI,IAAb,EACI,MAAM,IAAI8R,YAAJ,CAAiB,CAAC;MAAI;MAAtB,EAA+DrP,SAAS,IAAK,mBAAkB0rD,SAAS,CAAC7lD,CAAC,GAAG,CAAL,CAAQ,cAAhH,CAAN;MACJy7B,UAAU,CAACtkC,IAAX,CAAgB0uD,SAAS,CAAC7lD,CAAD,CAAzB,EAA8BtI,KAA9B;IACH;EACJ;AACJ;AACD;AACA;AACA;AACA;;;AACA,SAASyuD,mBAAT,CAA6BjG,YAA7B,EAA2CljD,GAA3C,EAAgD+oD,UAAhD,EAA4D;EACxD,IAAIA,UAAJ,EAAgB;IACZ,IAAI/oD,GAAG,CAACqT,QAAR,EAAkB;MACd,KAAK,IAAIrQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGhD,GAAG,CAACqT,QAAJ,CAAa7Y,MAAjC,EAAyCwI,CAAC,EAA1C,EAA8C;QAC1C+lD,UAAU,CAAC/oD,GAAG,CAACqT,QAAJ,CAAarQ,CAAb,CAAD,CAAV,GAA8BkgD,YAA9B;MACH;IACJ;;IACD,IAAItqC,cAAc,CAAC5Y,GAAD,CAAlB,EACI+oD,UAAU,CAAC,EAAD,CAAV,GAAiB7F,YAAjB;EACP;AACJ;AACD;AACA;AACA;AACA;AACA;;;AACA,SAAS8F,cAAT,CAAwBh+C,KAAxB,EAA+BtQ,KAA/B,EAAsCwvD,kBAAtC,EAA0D;EACtD/sD,SAAS,IACL0E,cAAc,CAACqoD,kBAAD,EAAqBl/C,KAAK,CAACia,YAAN,GAAqBja,KAAK,CAACga,cAAhD,EAAgE,sCAAhE,CADlB;EAEAha,KAAK,CAACwD,KAAN,IAAe;EAAE;EAAjB,CAHsD,CAItD;;EACAxD,KAAK,CAACga,cAAN,GAAuBtqB,KAAvB;EACAsQ,KAAK,CAACia,YAAN,GAAqBvqB,KAAK,GAAGwvD,kBAA7B;EACAl/C,KAAK,CAAC8hB,eAAN,GAAwBpyB,KAAxB;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASiuD,0BAAT,CAAoC19C,KAApC,EAA2CD,KAA3C,EAAkD+N,KAAlD,EAAyDyL,cAAzD,EAAyExkB,GAAzE,EAA8E;EAC1E7C,SAAS,IACLqE,wBAAwB,CAACgjB,cAAD,EAAiBpM,aAAjB,EAAgC,4BAAhC,CAD5B;EAEAnN,KAAK,CAAC+I,IAAN,CAAWwQ,cAAX,IAA6BxkB,GAA7B;EACA,MAAMmqD,gBAAgB,GAAGnqD,GAAG,CAACb,OAAJ,KAAgBa,GAAG,CAACb,OAAJ,GAAc+b,aAAa,CAAClb,GAAG,CAAChG,IAAL,EAAW,IAAX,CAA3C,CAAzB,CAJ0E,CAK1E;EACA;EACA;;EACA,MAAMowD,mBAAmB,GAAG,IAAIvjC,mBAAJ,CAAwBsjC,gBAAxB,EAA0CvxC,cAAc,CAAC5Y,GAAD,CAAxD,EAA+D64C,iBAA/D,CAA5B;EACA5tC,KAAK,CAAC0f,SAAN,CAAgBnG,cAAhB,IAAkC4lC,mBAAlC;EACArxC,KAAK,CAACyL,cAAD,CAAL,GAAwB4lC,mBAAxB;EACAd,0BAA0B,CAACr+C,KAAD,EAAQD,KAAR,EAAe+N,KAAf,EAAsByL,cAAtB,EAAsC0/B,YAAY,CAACj5C,KAAD,EAAQ8N,KAAR,EAAe/Y,GAAG,CAACgT,QAAnB,EAA6B+4B,SAA7B,CAAlD,EAA2F/rC,GAA3F,CAA1B;AACH;;AACD,SAAS0pD,iBAAT,CAA2B3wC,KAA3B,EAAkCkxC,SAAlC,EAA6CjqD,GAA7C,EAAkD;EAC9C,MAAM8nB,MAAM,GAAG3J,gBAAgB,CAAC8rC,SAAD,EAAYlxC,KAAZ,CAA/B;EACA,MAAM9N,KAAK,GAAG46C,yBAAyB,CAAC7lD,GAAD,CAAvC,CAF8C,CAG9C;EACA;;EACA,MAAMqhD,eAAe,GAAGtoC,KAAK,CAACvB,gBAAD,CAA7B;EACA,MAAMsmB,aAAa,GAAGusB,aAAa,CAACtxC,KAAD,EAAQ8qC,WAAW,CAAC9qC,KAAD,EAAQ9N,KAAR,EAAe,IAAf,EAAqBjL,GAAG,CAACsT,MAAJ,GAAa;EAAG;EAAhB,EAAyC;EAAG;EAAjE,EAA+FwU,MAA/F,EAAuGmiC,SAAvG,EAAkH5I,eAAlH,EAAmIA,eAAe,CAAC1jC,cAAhB,CAA+BmK,MAA/B,EAAuC9nB,GAAvC,CAAnI,EAAgL,IAAhL,EAAsL,IAAtL,EAA4L,IAA5L,CAAnB,CAAnC,CAN8C,CAO9C;EACA;;EACA+Y,KAAK,CAACkxC,SAAS,CAACvvD,KAAX,CAAL,GAAyBojC,aAAzB;AACH;;AACD,SAASwsB,wBAAT,CAAkCt/C,KAAlC,EAAyC+N,KAAzC,EAAgDxb,IAAhD,EAAsD6B,KAAtD,EAA6D45B,SAA7D,EAAwE/b,SAAxE,EAAmF;EAC/E,IAAI9f,SAAJ,EAAe;IACX4E,aAAa,CAAC3C,KAAD,EAAQ2sC,SAAR,EAAmB,2CAAnB,CAAb;IACAjR,8BAA8B,CAACv9B,IAAD,CAA9B;IACAmqB,eAAe,CAAC1c,KAAD,EAAQ;IAAE;IAAV,EAAoC,gCAA+BzN,IAAK,0BAArC,GAC7C,6DADU,CAAf;EAEH;;EACD,MAAMizB,OAAO,GAAGrS,gBAAgB,CAACnT,KAAD,EAAQ+N,KAAR,CAAhC;EACAwxC,mBAAmB,CAACxxC,KAAK,CAACtB,QAAD,CAAN,EAAkB+Y,OAAlB,EAA2BvT,SAA3B,EAAsCjS,KAAK,CAAC5L,KAA5C,EAAmD7B,IAAnD,EAAyD6B,KAAzD,EAAgE45B,SAAhE,CAAnB;AACH;;AACD,SAASuxB,mBAAT,CAA6BvyD,QAA7B,EAAuCw4B,OAAvC,EAAgDvT,SAAhD,EAA2D6a,OAA3D,EAAoEv6B,IAApE,EAA0E6B,KAA1E,EAAiF45B,SAAjF,EAA4F;EACxF,IAAI55B,KAAK,IAAI,IAAb,EAAmB;IACfjC,SAAS,IAAIA,SAAS,CAACoO,uBAAV,EAAb;IACAiS,oBAAoB,CAACxlB,QAAD,CAApB,GAAiCA,QAAQ,CAACq9B,eAAT,CAAyB7E,OAAzB,EAAkCjzB,IAAlC,EAAwC0f,SAAxC,CAAjC,GACIuT,OAAO,CAAC6E,eAAR,CAAwB93B,IAAxB,CADJ;EAEH,CAJD,MAKK;IACDJ,SAAS,IAAIA,SAAS,CAACmO,oBAAV,EAAb;IACA,MAAMk/C,QAAQ,GAAGxxB,SAAS,IAAI,IAAb,GAAoB9rB,eAAe,CAAC9N,KAAD,CAAnC,GAA6C45B,SAAS,CAAC55B,KAAD,EAAQ04B,OAAO,IAAI,EAAnB,EAAuBv6B,IAAvB,CAAvE;;IACA,IAAIigB,oBAAoB,CAACxlB,QAAD,CAAxB,EAAoC;MAChCA,QAAQ,CAACowB,YAAT,CAAsBoI,OAAtB,EAA+BjzB,IAA/B,EAAqCitD,QAArC,EAA+CvtC,SAA/C;IACH,CAFD,MAGK;MACDA,SAAS,GAAGuT,OAAO,CAACnI,cAAR,CAAuBpL,SAAvB,EAAkC1f,IAAlC,EAAwCitD,QAAxC,CAAH,GACLh6B,OAAO,CAACpI,YAAR,CAAqB7qB,IAArB,EAA2BitD,QAA3B,CADJ;IAEH;EACJ;AACJ;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASb,kBAAT,CAA4B5wC,KAA5B,EAAmCyL,cAAnC,EAAmDpuB,QAAnD,EAA6D4J,GAA7D,EAAkEgL,KAAlE,EAAyEy/C,gBAAzE,EAA2F;EACvF,MAAM9M,aAAa,GAAG8M,gBAAgB,CAACjmC,cAAD,CAAtC;;EACA,IAAIm5B,aAAa,KAAK,IAAtB,EAA4B;IACxB,MAAMvpC,QAAQ,GAAGpU,GAAG,CAACoU,QAArB;;IACA,KAAK,IAAIpR,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG26C,aAAa,CAACnjD,MAAlC,GAA2C;MACvC,MAAMsb,UAAU,GAAG6nC,aAAa,CAAC36C,CAAC,EAAF,CAAhC;MACA,MAAMkZ,WAAW,GAAGyhC,aAAa,CAAC36C,CAAC,EAAF,CAAjC;MACA,MAAM5D,KAAK,GAAGu+C,aAAa,CAAC36C,CAAC,EAAF,CAA3B;;MACA,IAAIoR,QAAQ,KAAK,IAAjB,EAAuB;QACnBpU,GAAG,CAACoU,QAAJ,CAAahe,QAAb,EAAuBgJ,KAAvB,EAA8B0W,UAA9B,EAA0CoG,WAA1C;MACH,CAFD,MAGK;QACD9lB,QAAQ,CAAC8lB,WAAD,CAAR,GAAwB9c,KAAxB;MACH;;MACD,IAAIjC,SAAJ,EAAe;QACX,MAAMjH,aAAa,GAAGioB,gBAAgB,CAACnT,KAAD,EAAQ+N,KAAR,CAAtC;QACAwvC,oBAAoB,CAACxvC,KAAD,EAAQ7iB,aAAR,EAAuB8U,KAAK,CAAChR,IAA7B,EAAmCkiB,WAAnC,EAAgD9c,KAAhD,CAApB;MACH;IACJ;EACJ;AACJ;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASwoD,qBAAT,CAA+Bz0C,MAA/B,EAAuC4U,KAAvC,EAA8C;EAC1C,IAAI2iC,aAAa,GAAG,IAApB;EACA,IAAI1nD,CAAC,GAAG,CAAR;;EACA,OAAOA,CAAC,GAAG+kB,KAAK,CAACvtB,MAAjB,EAAyB;IACrB,MAAM0tB,QAAQ,GAAGH,KAAK,CAAC/kB,CAAD,CAAtB;;IACA,IAAIklB,QAAQ,KAAK;IAAE;IAAnB,EAAuD;MACnD;MACAllB,CAAC,IAAI,CAAL;MACA;IACH,CAJD,MAKK,IAAIklB,QAAQ,KAAK;IAAE;IAAnB,EAAoD;MACrD;MACAllB,CAAC,IAAI,CAAL;MACA;IACH,CAXoB,CAYrB;;;IACA,IAAI,OAAOklB,QAAP,KAAoB,QAAxB,EACI;;IACJ,IAAI/U,MAAM,CAACzX,cAAP,CAAsBwsB,QAAtB,CAAJ,EAAqC;MACjC,IAAIwiC,aAAa,KAAK,IAAtB,EACIA,aAAa,GAAG,EAAhB;MACJA,aAAa,CAACvwD,IAAd,CAAmB+tB,QAAnB,EAA6B/U,MAAM,CAAC+U,QAAD,CAAnC,EAA+CH,KAAK,CAAC/kB,CAAC,GAAG,CAAL,CAApD;IACH;;IACDA,CAAC,IAAI,CAAL;EACH;;EACD,OAAO0nD,aAAP;AACH,C,CACD;AACA;AACA;AACA;;;AACA,MAAMC,eAAe,GAAG,MAAMC,UAAN,SAAyB3sD,KAAzB,CAA+B,EAAvD;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAAS4sD,gBAAT,CAA0BC,UAA1B,EAAsChnC,WAAtC,EAAmDgE,MAAnD,EAA2D9c,KAA3D,EAAkE;EAC9D7N,SAAS,IAAI4c,WAAW,CAAC+J,WAAD,CAAxB;EACA3mB,SAAS,IAAI,CAACqgB,oBAAoB,CAACsG,WAAW,CAACrM,QAAD,CAAZ,CAAlC,IAA6DpV,aAAa,CAACylB,MAAD,CAA1E,CAF8D,CAG9D;;EACA,MAAM5I,UAAU,GAAG,KAAK/hB,SAAS,GAAGwtD,eAAH,GAAqB1sD,KAAnC,EAA0C6sD,UAA1C,EAAsD;EACzE,IADmB,EACb;EACN,KAFmB,EAEZ;EACPhnC,WAHmB,EAGN;EACb,IAJmB,EAIb;EACN,CALmB,EAKhB;EACH9Y,KANmB,EAMZ;EACP8c,MAPmB,EAOX;EACR,IARmB,EAQb;EACN,IATmB,CAAnB;EAUA3qB,SAAS,IACLwE,WAAW,CAACud,UAAU,CAAC1kB,MAAZ,EAAoBoc,uBAApB,EAA6C,gEAA7C,CADf;EAEAzZ,SAAS,IAAI+iD,qBAAqB,CAAChhC,UAAD,CAAlC;EACA,OAAOA,UAAP;AACH;AACD;AACA;AACA;AACA;;;AACA,SAAS2lC,oBAAT,CAA8B9rC,KAA9B,EAAqC;EACjC,KAAK,IAAImG,UAAU,GAAG0hB,kBAAkB,CAAC7nB,KAAD,CAAxC,EAAiDmG,UAAU,KAAK,IAAhE,EAAsEA,UAAU,GAAG4hB,iBAAiB,CAAC5hB,UAAD,CAApG,EAAkH;IAC9G,KAAK,IAAIlc,CAAC,GAAG4T,uBAAb,EAAsC5T,CAAC,GAAGkc,UAAU,CAAC1kB,MAArD,EAA6DwI,CAAC,EAA9D,EAAkE;MAC9D,MAAM+nD,aAAa,GAAG7rC,UAAU,CAAClc,CAAD,CAAhC;MACA,MAAMgoD,aAAa,GAAGD,aAAa,CAACh0C,KAAD,CAAnC;MACA5Z,SAAS,IAAIgF,aAAa,CAAC6oD,aAAD,EAAgB,yBAAhB,CAA1B;;MACA,IAAInsC,4BAA4B,CAACksC,aAAD,CAAhC,EAAiD;QAC7CrG,WAAW,CAACsG,aAAD,EAAgBD,aAAhB,EAA+BC,aAAa,CAAC5wD,QAA7C,EAAuD2wD,aAAa,CAACzzC,OAAD,CAApE,CAAX;MACH;IACJ;EACJ;AACJ;AACD;AACA;AACA;AACA;AACA;;;AACA,SAASstC,+BAAT,CAAyC7rC,KAAzC,EAAgD;EAC5C,KAAK,IAAImG,UAAU,GAAG0hB,kBAAkB,CAAC7nB,KAAD,CAAxC,EAAiDmG,UAAU,KAAK,IAAhE,EAAsEA,UAAU,GAAG4hB,iBAAiB,CAAC5hB,UAAD,CAApG,EAAkH;IAC9G,IAAI,CAACA,UAAU,CAAC1I,sBAAD,CAAf,EACI;IACJ,MAAM8sB,UAAU,GAAGpkB,UAAU,CAACvI,WAAD,CAA7B;IACAxZ,SAAS,IAAIgF,aAAa,CAACmhC,UAAD,EAAa,qDAAb,CAA1B;;IACA,KAAK,IAAItgC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGsgC,UAAU,CAAC9oC,MAA/B,EAAuCwI,CAAC,EAAxC,EAA4C;MACxC,MAAMioD,UAAU,GAAG3nB,UAAU,CAACtgC,CAAD,CAA7B;MACA,MAAM4gC,mBAAmB,GAAGqnB,UAAU,CAACh0C,MAAD,CAAtC;MACA9Z,SAAS,IAAI0c,gBAAgB,CAAC+pB,mBAAD,CAA7B,CAHwC,CAIxC;MACA;;MACA,IAAI,CAACqnB,UAAU,CAACj0C,KAAD,CAAV,GAAoB;MAAI;MAAzB,MAAuE,CAA3E,EAA8E;QAC1EiI,2BAA2B,CAAC2kB,mBAAD,EAAsB,CAAtB,CAA3B;MACH,CARuC,CASxC;MACA;MACA;MACA;;;MACAqnB,UAAU,CAACj0C,KAAD,CAAV,IAAqB;MAAI;MAAzB;IACH;EACJ;AACJ,C,CACD;;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS0sC,gBAAT,CAA0BD,SAA1B,EAAqCyH,gBAArC,EAAuD;EACnD/tD,SAAS,IAAIwE,WAAW,CAACid,cAAc,CAAC6kC,SAAD,CAAf,EAA4B,KAA5B,EAAmC,8BAAnC,CAAxB;EACA,MAAM3lB,aAAa,GAAGtf,wBAAwB,CAAC0sC,gBAAD,EAAmBzH,SAAnB,CAA9C,CAFmD,CAGnD;;EACA,IAAI5kC,4BAA4B,CAACif,aAAD,CAAhC,EAAiD;IAC7C,MAAM7yB,KAAK,GAAG6yB,aAAa,CAAC/mB,KAAD,CAA3B;;IACA,IAAI+mB,aAAa,CAAC9mB,KAAD,CAAb,IAAwB;IAAG;IAAH,EAAkC;IAAG;IAA7D,CAAJ,EAA0F;MACtF0tC,WAAW,CAACz5C,KAAD,EAAQ6yB,aAAR,EAAuB7yB,KAAK,CAAC7Q,QAA7B,EAAuC0jC,aAAa,CAACxmB,OAAD,CAApD,CAAX;IACH,CAFD,MAGK,IAAIwmB,aAAa,CAAC3mB,6BAAD,CAAb,GAA+C,CAAnD,EAAsD;MACvD;MACAg0C,wBAAwB,CAACrtB,aAAD,CAAxB;IACH;EACJ;AACJ;AACD;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASqtB,wBAAT,CAAkCpyC,KAAlC,EAAyC;EACrC,KAAK,IAAImG,UAAU,GAAG0hB,kBAAkB,CAAC7nB,KAAD,CAAxC,EAAiDmG,UAAU,KAAK,IAAhE,EAAsEA,UAAU,GAAG4hB,iBAAiB,CAAC5hB,UAAD,CAApG,EAAkH;IAC9G,KAAK,IAAIlc,CAAC,GAAG4T,uBAAb,EAAsC5T,CAAC,GAAGkc,UAAU,CAAC1kB,MAArD,EAA6DwI,CAAC,EAA9D,EAAkE;MAC9D,MAAM+nD,aAAa,GAAG7rC,UAAU,CAAClc,CAAD,CAAhC;;MACA,IAAI+nD,aAAa,CAAC/zC,KAAD,CAAb,GAAuB;MAAI;MAA/B,EAAyE;QACrE,MAAMg0C,aAAa,GAAGD,aAAa,CAACh0C,KAAD,CAAnC;QACA5Z,SAAS,IAAIgF,aAAa,CAAC6oD,aAAD,EAAgB,yBAAhB,CAA1B;QACAtG,WAAW,CAACsG,aAAD,EAAgBD,aAAhB,EAA+BC,aAAa,CAAC5wD,QAA7C,EAAuD2wD,aAAa,CAACzzC,OAAD,CAApE,CAAX;MACH,CAJD,MAKK,IAAIyzC,aAAa,CAAC5zC,6BAAD,CAAb,GAA+C,CAAnD,EAAsD;QACvDg0C,wBAAwB,CAACJ,aAAD,CAAxB;MACH;IACJ;EACJ;;EACD,MAAM9/C,KAAK,GAAG8N,KAAK,CAAChC,KAAD,CAAnB,CAdqC,CAerC;;EACA,MAAM6mB,UAAU,GAAG3yB,KAAK,CAAC2yB,UAAzB;;EACA,IAAIA,UAAU,KAAK,IAAnB,EAAyB;IACrB,KAAK,IAAI56B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG46B,UAAU,CAACpjC,MAA/B,EAAuCwI,CAAC,EAAxC,EAA4C;MACxC,MAAM86B,aAAa,GAAGtf,wBAAwB,CAACof,UAAU,CAAC56B,CAAD,CAAX,EAAgB+V,KAAhB,CAA9C,CADwC,CAExC;;MACA,IAAI8F,4BAA4B,CAACif,aAAD,CAA5B,IACAA,aAAa,CAAC3mB,6BAAD,CAAb,GAA+C,CADnD,EACsD;QAClDg0C,wBAAwB,CAACrtB,aAAD,CAAxB;MACH;IACJ;EACJ;AACJ;;AACD,SAAS8lB,iBAAT,CAA2BH,SAA3B,EAAsCyH,gBAAtC,EAAwD;EACpD/tD,SAAS,IAAIwE,WAAW,CAACid,cAAc,CAAC6kC,SAAD,CAAf,EAA4B,IAA5B,EAAkC,gCAAlC,CAAxB;EACA,MAAM3lB,aAAa,GAAGtf,wBAAwB,CAAC0sC,gBAAD,EAAmBzH,SAAnB,CAA9C;EACA,MAAM2H,cAAc,GAAGttB,aAAa,CAAC/mB,KAAD,CAApC;EACAs0C,qBAAqB,CAACD,cAAD,EAAiBttB,aAAjB,CAArB;EACAwmB,UAAU,CAAC8G,cAAD,EAAiBttB,aAAjB,EAAgCA,aAAa,CAACxmB,OAAD,CAA7C,CAAV;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS+zC,qBAAT,CAA+BpgD,KAA/B,EAAsC8N,KAAtC,EAA6C;EACzC,KAAK,IAAI/V,CAAC,GAAG+V,KAAK,CAACve,MAAnB,EAA2BwI,CAAC,GAAGiI,KAAK,CAAC0f,SAAN,CAAgBnwB,MAA/C,EAAuDwI,CAAC,EAAxD,EAA4D;IACxD+V,KAAK,CAAC5e,IAAN,CAAW8Q,KAAK,CAAC0f,SAAN,CAAgB3nB,CAAhB,CAAX;EACH;AACJ;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASqnD,aAAT,CAAuBtxC,KAAvB,EAA8B6pB,iBAA9B,EAAiD;EAC7C;EACA;EACA;EACA;EACA,IAAI7pB,KAAK,CAACpB,UAAD,CAAT,EAAuB;IACnBoB,KAAK,CAACnB,UAAD,CAAL,CAAkBV,IAAlB,IAA0B0rB,iBAA1B;EACH,CAFD,MAGK;IACD7pB,KAAK,CAACpB,UAAD,CAAL,GAAoBirB,iBAApB;EACH;;EACD7pB,KAAK,CAACnB,UAAD,CAAL,GAAoBgrB,iBAApB;EACA,OAAOA,iBAAP;AACH,C,CACD;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS0oB,aAAT,CAAuBvyC,KAAvB,EAA8B;EAC1B,OAAOA,KAAP,EAAc;IACVA,KAAK,CAAC/B,KAAD,CAAL,IAAgB;IAAG;IAAnB;IACA,MAAM2C,MAAM,GAAG2mB,cAAc,CAACvnB,KAAD,CAA7B,CAFU,CAGV;;IACA,IAAIF,UAAU,CAACE,KAAD,CAAV,IAAqB,CAACY,MAA1B,EAAkC;MAC9B,OAAOZ,KAAP;IACH,CANS,CAOV;;;IACAA,KAAK,GAAGY,MAAR;EACH;;EACD,OAAO,IAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS4xC,YAAT,CAAsBC,WAAtB,EAAmCh9C,KAAnC,EAA0C;EACtC,MAAMi9C,gBAAgB,GAAGD,WAAW,CAACh9C,KAAZ,KAAsB;EAAE;EAAjD;;EACA,IAAIi9C,gBAAgB,IAAID,WAAW,CAACE,KAAZ,IAAqB3I,cAA7C,EAA6D;IACzD;IACA;IACAyI,WAAW,CAACh9C,KAAZ,IAAqBA,KAArB;IACA,IAAI/W,GAAJ;IACA+zD,WAAW,CAACE,KAAZ,GAAoB,IAAI92D,OAAJ,CAAa+2D,CAAD,IAAOl0D,GAAG,GAAGk0D,CAAzB,CAApB;IACAH,WAAW,CAACI,SAAZ,CAAsB,MAAM;MACxB,IAAIJ,WAAW,CAACh9C,KAAZ,GAAoB;MAAE;MAA1B,EAAgE;QAC5Dg9C,WAAW,CAACh9C,KAAZ,IAAqB,CAAC;QAAE;QAAxB;QACAq9C,eAAe,CAACL,WAAD,CAAf;MACH;;MACD,IAAIA,WAAW,CAACh9C,KAAZ,GAAoB;MAAE;MAA1B,EAA+D;QAC3Dg9C,WAAW,CAACh9C,KAAZ,IAAqB,CAAC;QAAE;QAAxB;QACA,MAAMs9C,aAAa,GAAGN,WAAW,CAACM,aAAlC;;QACA,IAAIA,aAAJ,EAAmB;UACfA,aAAa,CAACC,YAAd;QACH;MACJ;;MACDP,WAAW,CAACE,KAAZ,GAAoB3I,cAApB;MACAtrD,GAAG,CAAC,IAAD,CAAH;IACH,CAdD;EAeH;AACJ;;AACD,SAASo0D,eAAT,CAAyBL,WAAzB,EAAsC;EAClC,KAAK,IAAIxoD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwoD,WAAW,CAAC5tB,UAAZ,CAAuBpjC,MAA3C,EAAmDwI,CAAC,EAApD,EAAwD;IACpD,MAAMg7B,aAAa,GAAGwtB,WAAW,CAAC5tB,UAAZ,CAAuB56B,CAAvB,CAAtB;IACA,MAAM+V,KAAK,GAAG0kB,gBAAgB,CAACO,aAAD,CAA9B,CAFoD,CAGpD;;IACA,IAAIjlB,KAAK,KAAK,IAAd,EAAoB;MAChB,MAAM9N,KAAK,GAAG8N,KAAK,CAAChC,KAAD,CAAnB;MACA+tC,yBAAyB,CAAC75C,KAAD,EAAQ8N,KAAR,EAAe9N,KAAK,CAAC7Q,QAArB,EAA+B4jC,aAA/B,CAAzB;IACH;EACJ;AACJ;;AACD,SAASguB,qBAAT,CAA+B/gD,KAA/B,EAAsC8N,KAAtC,EAA6CpI,OAA7C,EAAsD;EAClD,MAAM0wC,eAAe,GAAGtoC,KAAK,CAACvB,gBAAD,CAA7B;EACA,IAAI6pC,eAAe,CAAC2D,KAApB,EACI3D,eAAe,CAAC2D,KAAhB;;EACJ,IAAI;IACAN,WAAW,CAACz5C,KAAD,EAAQ8N,KAAR,EAAe9N,KAAK,CAAC7Q,QAArB,EAA+BuW,OAA/B,CAAX;EACH,CAFD,CAGA,OAAO5Z,KAAP,EAAc;IACVskC,WAAW,CAACtiB,KAAD,EAAQhiB,KAAR,CAAX;IACA,MAAMA,KAAN;EACH,CAND,SAOQ;IACJ,IAAIsqD,eAAe,CAAC/8C,GAApB,EACI+8C,eAAe,CAAC/8C,GAAhB;EACP;AACJ;AACD;AACA;AACA;AACA;AACA;;;AACA,SAAS2nD,uBAAT,CAAiClzC,KAAjC,EAAwC;EACpC8yC,eAAe,CAAC9yC,KAAK,CAACzB,OAAD,CAAN,CAAf;AACH;;AACD,SAAS40C,sBAAT,CAAgCjhD,KAAhC,EAAuCsT,IAAvC,EAA6C5N,OAA7C,EAAsD;EAClDuQ,yBAAyB,CAAC,IAAD,CAAzB;;EACA,IAAI;IACA8qC,qBAAqB,CAAC/gD,KAAD,EAAQsT,IAAR,EAAc5N,OAAd,CAArB;EACH,CAFD,SAGQ;IACJuQ,yBAAyB,CAAC,KAAD,CAAzB;EACH;AACJ;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASirC,wBAAT,CAAkCpzC,KAAlC,EAAyC;EACrCmI,yBAAyB,CAAC,IAAD,CAAzB;;EACA,IAAI;IACA+qC,uBAAuB,CAAClzC,KAAD,CAAvB;EACH,CAFD,SAGQ;IACJmI,yBAAyB,CAAC,KAAD,CAAzB;EACH;AACJ;;AACD,SAASqjC,kBAAT,CAA4B/1C,KAA5B,EAAmC49C,WAAnC,EAAgDryD,SAAhD,EAA2D;EACvDoD,SAAS,IAAIgF,aAAa,CAACiqD,WAAD,EAAc,mDAAd,CAA1B;EACA9pC,oBAAoB,CAAC,CAAD,CAApB;EACA8pC,WAAW,CAAC59C,KAAD,EAAQzU,SAAR,CAAX;AACH,C,CACD;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASsyD,4BAAT,CAAsClqC,KAAtC,EAA6CnX,KAA7C,EAAoDshD,YAApD,EAAkE/qC,YAAlE,EAAgF,GAAGgrC,kBAAnF,EAAuG;EACnG;EACA;EACA;EACA,IAAIpqC,KAAK,CAACZ,YAAD,CAAL,KAAwB,IAA5B,EAAkC;IAC9B,IAAIvW,KAAK,CAACmI,MAAN,IAAgB,IAAhB,IAAwB,CAACnI,KAAK,CAACmI,MAAN,CAAam5C,YAAb,CAA7B,EAAyD;MACrD,MAAME,eAAe,GAAGxhD,KAAK,CAACyyC,gBAAN,KAA2BzyC,KAAK,CAACyyC,gBAAN,GAAyB,EAApD,CAAxB;MACA+O,eAAe,CAACryD,IAAhB,CAAqBonB,YAArB;MACA,IAAIkrC,eAAe,GAAGH,YAAtB;;MACA,IAAIC,kBAAkB,CAAC/xD,MAAnB,GAA4B,CAAhC,EAAmC;QAC/BiyD,eAAe,IACX37B,uBAAuB,GAAGy7B,kBAAkB,CAACnuD,IAAnB,CAAwB0yB,uBAAxB,CAD9B;MAEH;;MACD3O,KAAK,CAACZ,YAAD,CAAL,GAAsBkrC,eAAtB;IACH;EACJ;AACJ;;AACD,MAAMC,aAAa,GAAG3J,cAAtB;;AACA,SAAS+D,uBAAT,CAAiCvoC,IAAjC,EAAuC;EACnC;EACA,OAAOA,IAAI,CAAClH,OAAD,CAAJ,KAAkBkH,IAAI,CAAClH,OAAD,CAAJ,GAAgBla,SAAS,GAAG,IAAI2iD,QAAJ,EAAH,GAAoB,EAA/D,CAAP;AACH;;AACD,SAASiH,uBAAT,CAAiC97C,KAAjC,EAAwC;EACpC,OAAOA,KAAK,CAACo5B,OAAN,KAAkBp5B,KAAK,CAACo5B,OAAN,GAAgBlnC,SAAS,GAAG,IAAI4iD,QAAJ,EAAH,GAAoB,EAA/D,CAAP;AACH;AACD;AACA;AACA;AACA;;;AACA,SAAS4M,qBAAT,CAA+BC,UAA/B,EAA2C5hD,KAA3C,EAAkD+N,KAAlD,EAAyD;EACrD;EACA;EACA;EACA;EACA;EACA;EACA,IAAI6zC,UAAU,KAAK,IAAf,IAAuBh0C,cAAc,CAACg0C,UAAD,CAAzC,EAAuD;IACnD7zC,KAAK,GAAGiF,WAAW,CAACjF,KAAK,CAAC/N,KAAK,CAACtQ,KAAP,CAAN,CAAnB;EACH;;EACD,OAAOqe,KAAK,CAACtB,QAAD,CAAZ;AACH;AACD;;;AACA,SAAS4jB,WAAT,CAAqBtiB,KAArB,EAA4BhiB,KAA5B,EAAmC;EAC/B,MAAMc,QAAQ,GAAGkhB,KAAK,CAACxB,UAAD,CAAtB;EACA,MAAMs1C,YAAY,GAAGh1D,QAAQ,GAAGA,QAAQ,CAACC,GAAT,CAAaqjC,YAAb,EAA2B,IAA3B,CAAH,GAAsC,IAAnE;EACA0xB,YAAY,IAAIA,YAAY,CAACxxB,WAAb,CAAyBtkC,KAAzB,CAAhB;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASmxD,oBAAT,CAA8Bj9C,KAA9B,EAAqC8N,KAArC,EAA4C5F,MAA5C,EAAoD2C,UAApD,EAAgE1W,KAAhE,EAAuE;EACnE,KAAK,IAAI4D,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmQ,MAAM,CAAC3Y,MAA3B,GAAoC;IAChC,MAAME,KAAK,GAAGyY,MAAM,CAACnQ,CAAC,EAAF,CAApB;IACA,MAAMkZ,WAAW,GAAG/I,MAAM,CAACnQ,CAAC,EAAF,CAA1B;IACA,MAAM5M,QAAQ,GAAG2iB,KAAK,CAACre,KAAD,CAAtB;IACAyC,SAAS,IAAIqF,kBAAkB,CAACuW,KAAD,EAAQre,KAAR,CAA/B;IACA,MAAMsF,GAAG,GAAGiL,KAAK,CAAC+I,IAAN,CAAWtZ,KAAX,CAAZ;;IACA,IAAIsF,GAAG,CAACoU,QAAJ,KAAiB,IAArB,EAA2B;MACvBpU,GAAG,CAACoU,QAAJ,CAAahe,QAAb,EAAuBgJ,KAAvB,EAA8B0W,UAA9B,EAA0CoG,WAA1C;IACH,CAFD,MAGK;MACD9lB,QAAQ,CAAC8lB,WAAD,CAAR,GAAwB9c,KAAxB;IACH;EACJ;AACJ;AACD;AACA;AACA;;;AACA,SAAS0tD,mBAAT,CAA6B/zC,KAA7B,EAAoCre,KAApC,EAA2C0E,KAA3C,EAAkD;EAC9CjC,SAAS,IAAIsE,YAAY,CAACrC,KAAD,EAAQ,0BAAR,CAAzB;EACAjC,SAAS,IAAI4E,aAAa,CAAC3C,KAAD,EAAQ2sC,SAAR,EAAmB,+BAAnB,CAA1B;EACA5uC,SAAS,IAAIqF,kBAAkB,CAACuW,KAAD,EAAQre,KAAR,CAA/B;EACA,MAAM81B,OAAO,GAAGtS,gBAAgB,CAACxjB,KAAD,EAAQqe,KAAR,CAAhC;EACA5b,SAAS,IAAIgF,aAAa,CAACquB,OAAD,EAAU,6BAAV,CAA1B;EACAsR,cAAc,CAAC/oB,KAAK,CAACtB,QAAD,CAAN,EAAkB+Y,OAAlB,EAA2BpxB,KAA3B,CAAd;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS2tD,oBAAT,CAA8B/hD,KAA9B,EAAqC+c,KAArC,EAA4CilC,WAA5C,EAAyD;EACrD7vD,SAAS,IACL6c,qBAAqB,CAACmG,QAAQ,EAAT,EAAa,oDAAb,CADzB;EAEA,IAAI7lB,MAAM,GAAG0yD,WAAW,GAAGhiD,KAAK,CAAC1Q,MAAT,GAAkB,IAA1C;EACA,IAAIixB,OAAO,GAAGyhC,WAAW,GAAGhiD,KAAK,CAACugB,OAAT,GAAmB,IAA5C;EACA,IAAIpK,IAAI,GAAG,CAAX;;EACA,IAAI4G,KAAK,KAAK,IAAd,EAAoB;IAChB,KAAK,IAAI/kB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+kB,KAAK,CAACvtB,MAA1B,EAAkCwI,CAAC,EAAnC,EAAuC;MACnC,MAAM5D,KAAK,GAAG2oB,KAAK,CAAC/kB,CAAD,CAAnB;;MACA,IAAI,OAAO5D,KAAP,KAAiB,QAArB,EAA+B;QAC3B+hB,IAAI,GAAG/hB,KAAP;MACH,CAFD,MAGK,IAAI+hB,IAAI,IAAI;MAAE;MAAd,EAA6C;QAC9CoK,OAAO,GAAG9sB,sBAAsB,CAAC8sB,OAAD,EAAUnsB,KAAV,CAAhC;MACH,CAFI,MAGA,IAAI+hB,IAAI,IAAI;MAAE;MAAd,EAA4C;QAC7C,MAAMxmB,KAAK,GAAGyE,KAAd;QACA,MAAM6tD,UAAU,GAAGllC,KAAK,CAAC,EAAE/kB,CAAH,CAAxB;QACA1I,MAAM,GAAGmE,sBAAsB,CAACnE,MAAD,EAASK,KAAK,GAAG,IAAR,GAAesyD,UAAf,GAA4B,GAArC,CAA/B;MACH;IACJ;EACJ;;EACDD,WAAW,GAAGhiD,KAAK,CAAC1Q,MAAN,GAAeA,MAAlB,GAA2B0Q,KAAK,CAAC6yC,iBAAN,GAA0BvjD,MAAhE;EACA0yD,WAAW,GAAGhiD,KAAK,CAACugB,OAAN,GAAgBA,OAAnB,GAA6BvgB,KAAK,CAAC+yC,kBAAN,GAA2BxyB,OAAnE;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS70B,aAAT,CAAuBqD,SAAvB,EAAkC;EAC9B,MAAMwkB,IAAI,GAAG+e,0BAA0B,CAACvjC,SAAD,CAAvC;EACAiyD,qBAAqB,CAACztC,IAAI,CAACxH,KAAD,CAAL,EAAcwH,IAAd,EAAoBxkB,SAApB,CAArB;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASmzD,SAAT,CAAmBnzD,SAAnB,EAA8B;EAC1BoD,SAAS,IAAIgF,aAAa,CAACpI,SAAD,EAAY,WAAZ,CAA1B;EACA,MAAM4mC,QAAQ,GAAG2qB,aAAa,CAAChuB,0BAA0B,CAACvjC,SAAD,CAA3B,CAA9B;EACAoD,SAAS,IAAIgF,aAAa,CAACw+B,QAAQ,CAACrpB,OAAD,CAAT,EAAoB,+BAApB,CAA1B;EACAi0C,YAAY,CAAC5qB,QAAQ,CAACrpB,OAAD,CAAT,EAAoB;EAAE;EAAtB,CAAZ;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS1e,IAAT,CAAcmB,SAAd,EAAyB;EACrB,MAAM4mC,QAAQ,GAAGJ,WAAW,CAACxmC,SAAD,CAA5B;EACA,MAAMyxD,WAAW,GAAG7qB,QAAQ,CAACrpB,OAAD,CAA5B;EACAu0C,eAAe,CAACL,WAAD,CAAf;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS2B,cAAT,CAAwB38B,OAAxB,EAAiC;EAC7BrzB,SAAS,IAAIiwD,gBAAgB,CAAC58B,OAAD,CAA7B;EACA,MAAM7f,OAAO,GAAG6rB,WAAW,CAAChM,OAAD,CAA3B;EACA,IAAI7f,OAAO,KAAK,IAAhB,EACI,OAAO,IAAP;;EACJ,IAAIA,OAAO,CAAC5W,SAAR,KAAsBnC,SAA1B,EAAqC;IACjC,MAAMmhB,KAAK,GAAGpI,OAAO,CAACoI,KAAtB;;IACA,IAAIA,KAAK,KAAK,IAAd,EAAoB;MAChB,OAAO,IAAP;IACH;;IACDpI,OAAO,CAAC5W,SAAR,GAAoBwkC,uBAAuB,CAAC5tB,OAAO,CAAC8N,SAAT,EAAoB1F,KAApB,CAA3C;EACH;;EACD,OAAOpI,OAAO,CAAC5W,SAAf;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASszD,UAAT,CAAoB78B,OAApB,EAA6B;EACzB48B,gBAAgB,CAAC58B,OAAD,CAAhB;EACA,MAAM7f,OAAO,GAAG6rB,WAAW,CAAChM,OAAD,CAA3B;EACA,MAAMzX,KAAK,GAAGpI,OAAO,GAAGA,OAAO,CAACoI,KAAX,GAAmB,IAAxC;EACA,OAAOA,KAAK,KAAK,IAAV,GAAiB,IAAjB,GAAwBA,KAAK,CAACzB,OAAD,CAApC;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASg2C,kBAAT,CAA4BC,YAA5B,EAA0C;EACtC,MAAM58C,OAAO,GAAG6rB,WAAW,CAAC+wB,YAAD,CAA3B;EACA,IAAIx0C,KAAK,GAAGpI,OAAO,GAAGA,OAAO,CAACoI,KAAX,GAAmB,IAAtC;EACA,IAAIA,KAAK,KAAK,IAAd,EACI,OAAO,IAAP;EACJ,IAAIY,MAAJ;;EACA,OAAOZ,KAAK,CAAChC,KAAD,CAAL,CAAa/c,IAAb,KAAsB;EAAE;EAAxB,IAAqD2f,MAAM,GAAG2mB,cAAc,CAACvnB,KAAD,CAA5E,CAAP,EAA6F;IACzFA,KAAK,GAAGY,MAAR;EACH;;EACD,OAAOZ,KAAK,CAAC/B,KAAD,CAAL,GAAe;EAAI;EAAnB,EAA6C,IAA7C,GAAoD+B,KAAK,CAACzB,OAAD,CAAhE;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASk2C,iBAAT,CAA2BD,YAA3B,EAAyC;EACrC,MAAMx0C,KAAK,GAAG0kB,gBAAgB,CAAC8vB,YAAD,CAA9B;EACA,OAAOx0C,KAAK,KAAK,IAAV,GAAiB,CAAC,GAAG0nB,cAAc,CAAC1nB,KAAD,CAAd,CAAsB6kB,UAA1B,CAAjB,GAAyD,EAAhE;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS6vB,WAAT,CAAqBF,YAArB,EAAmC;EAC/B,MAAM58C,OAAO,GAAG6rB,WAAW,CAAC+wB,YAAD,CAA3B;EACA,MAAMx0C,KAAK,GAAGpI,OAAO,GAAGA,OAAO,CAACoI,KAAX,GAAmB,IAAxC;EACA,IAAIA,KAAK,KAAK,IAAd,EACI,OAAO1lB,QAAQ,CAACu/C,IAAhB;EACJ,MAAM5nC,KAAK,GAAG+N,KAAK,CAAChC,KAAD,CAAL,CAAa/C,IAAb,CAAkBrD,OAAO,CAAC8N,SAA1B,CAAd;EACA,OAAO,IAAIoP,YAAJ,CAAiB7iB,KAAjB,EAAwB+N,KAAxB,CAAP;AACH;AACD;AACA;AACA;AACA;AACA;;;AACA,SAAS20C,kBAAT,CAA4Bl9B,OAA5B,EAAqC;EACjC,MAAM7f,OAAO,GAAG6rB,WAAW,CAAChM,OAAD,CAA3B;EACA,MAAMzX,KAAK,GAAGpI,OAAO,GAAGA,OAAO,CAACoI,KAAX,GAAmB,IAAxC;EACA,IAAIA,KAAK,KAAK,IAAd,EACI,OAAO,EAAP;EACJ,MAAM9N,KAAK,GAAG8N,KAAK,CAAChC,KAAD,CAAnB;EACA,MAAM/L,KAAK,GAAGC,KAAK,CAAC+I,IAAN,CAAWrD,OAAO,CAAC8N,SAAnB,CAAd;EACA,MAAMkvC,cAAc,GAAG,EAAvB;EACA,MAAMxnC,UAAU,GAAGnb,KAAK,CAAC8hB,eAAN,GAAwB;EAAQ;EAAnD;EACA,MAAMM,QAAQ,GAAGpiB,KAAK,CAACia,YAAvB;;EACA,KAAK,IAAIjiB,CAAC,GAAGmjB,UAAb,EAAyBnjB,CAAC,GAAGoqB,QAA7B,EAAuCpqB,CAAC,EAAxC,EAA4C;IACxC,IAAI5D,KAAK,GAAG6L,KAAK,CAAC+I,IAAN,CAAWhR,CAAX,CAAZ;;IACA,IAAI4qD,kBAAkB,CAACxuD,KAAD,CAAtB,EAA+B;MAC3B;MACA;MACA;MACA;MACAA,KAAK,GAAGA,KAAK,CAACpF,IAAd;IACH;;IACD2zD,cAAc,CAACxzD,IAAf,CAAoBiF,KAApB;EACH;;EACD,OAAOuuD,cAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,aAAT,CAAuBvrD,IAAvB,EAA6B;EACzB;EACA,IAAIA,IAAI,YAAYwrD,IAApB,EAA0B;IACtB,OAAO,EAAP;EACH;;EACD,MAAMn9C,OAAO,GAAG6rB,WAAW,CAACl6B,IAAD,CAA3B;EACA,MAAMyW,KAAK,GAAGpI,OAAO,GAAGA,OAAO,CAACoI,KAAX,GAAmB,IAAxC;;EACA,IAAIA,KAAK,KAAK,IAAd,EAAoB;IAChB,OAAO,EAAP;EACH;;EACD,MAAM9N,KAAK,GAAG8N,KAAK,CAAChC,KAAD,CAAnB;EACA,MAAM0H,SAAS,GAAG9N,OAAO,CAAC8N,SAA1B;;EACA,IAAI,EAAExT,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAK,KAAK,CAAjC,GAAqC,KAAK,CAA1C,GAA8CA,KAAK,CAAC+I,IAAN,CAAWyK,SAAX,CAAhD,CAAJ,EAA4E;IACxE,OAAO,EAAP;EACH;;EACD,IAAI9N,OAAO,CAACkE,UAAR,KAAuBjd,SAA3B,EAAsC;IAClC+Y,OAAO,CAACkE,UAAR,GAAqBkoB,wBAAwB,CAACte,SAAD,EAAY1F,KAAZ,EAAmB,KAAnB,CAA7C;EACH,CAjBwB,CAkBzB;EACA;;;EACA,OAAOpI,OAAO,CAACkE,UAAR,KAAuB,IAAvB,GAA8B,EAA9B,GAAmC,CAAC,GAAGlE,OAAO,CAACkE,UAAZ,CAA1C;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASk5C,oBAAT,CAA8BC,4BAA9B,EAA4D;EACxD,MAAM;IAAE94D;EAAF,IAAkB84D,4BAAxB;;EACA,IAAI,CAAC94D,WAAL,EAAkB;IACd,MAAM,IAAImC,KAAJ,CAAU,yCAAV,CAAN;EACH,CAJuD,CAKxD;EACA;;;EACA,MAAMunC,YAAY,GAAG7pB,iBAAiB,CAAC7f,WAAD,CAAtC;;EACA,IAAI0pC,YAAJ,EAAkB;IACd,OAAO;MACHzrB,MAAM,EAAEyrB,YAAY,CAACzrB,MADlB;MAEHC,OAAO,EAAEwrB,YAAY,CAACxrB,OAFnB;MAGHa,aAAa,EAAE2qB,YAAY,CAAC3qB,aAHzB;MAIHV,eAAe,EAAEqrB,YAAY,CAACtrB,MAAb,GAAsBpC,uBAAuB,CAACsC,MAA9C,GACbtC,uBAAuB,CAAC1B;IALzB,CAAP;EAOH;;EACD,MAAMiV,YAAY,GAAGzP,eAAe,CAAC9f,WAAD,CAApC;;EACA,IAAIuvB,YAAJ,EAAkB;IACd,OAAO;MAAEtR,MAAM,EAAEsR,YAAY,CAACtR,MAAvB;MAA+BC,OAAO,EAAEqR,YAAY,CAACrR;IAArD,CAAP;EACH;;EACD,OAAO,IAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS66C,YAAT,CAAsBpwD,MAAtB,EAA8B;EAC1B,MAAM8S,OAAO,GAAG6rB,WAAW,CAAC3+B,MAAD,CAA3B;EACA,IAAI8S,OAAO,KAAK,IAAhB,EACI,OAAO,EAAP;;EACJ,IAAIA,OAAO,CAACk4C,SAAR,KAAsBjxD,SAA1B,EAAqC;IACjC,MAAMmhB,KAAK,GAAGpI,OAAO,CAACoI,KAAtB;;IACA,IAAIA,KAAK,KAAK,IAAd,EAAoB;MAChB,OAAO,EAAP;IACH;;IACDpI,OAAO,CAACk4C,SAAR,GAAoBrqB,iBAAiB,CAACzlB,KAAD,EAAQpI,OAAO,CAAC8N,SAAhB,CAArC;EACH;;EACD,OAAO9N,OAAO,CAACk4C,SAAR,IAAqB,EAA5B;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASqF,cAAT,CAAwBC,oBAAxB,EAA8C;EAC1C,OAAO3xB,WAAW,CAAC2xB,oBAAD,CAAX,CAAkCrmC,MAAzC;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASsmC,eAAT,CAAyBr0D,SAAzB,EAAoC;EAChC,MAAM6jB,WAAW,GAAGswC,cAAc,CAACn0D,SAAD,CAAlC;EACA,OAAO6jB,WAAW,CAACokB,WAAZ,IAA2B,EAAlC;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASqsB,YAAT,CAAsB79B,OAAtB,EAA+B;EAC3BrzB,SAAS,IAAIiwD,gBAAgB,CAAC58B,OAAD,CAA7B;EACA,MAAM89B,QAAQ,GAAG9xB,WAAW,CAAChM,OAAD,CAA5B;EACA,MAAMzX,KAAK,GAAGu1C,QAAQ,KAAK,IAAb,GAAoB,IAApB,GAA2BA,QAAQ,CAACv1C,KAAlD;EACA,IAAIA,KAAK,KAAK,IAAd,EACI,OAAO,EAAP;EACJ,MAAM9N,KAAK,GAAG8N,KAAK,CAAChC,KAAD,CAAnB;EACA,MAAMutB,QAAQ,GAAGvrB,KAAK,CAAC1B,OAAD,CAAtB;EACA,MAAM+sB,QAAQ,GAAGn5B,KAAK,CAACo5B,OAAvB;EACA,MAAMkqB,SAAS,GAAG,EAAlB;;EACA,IAAInqB,QAAQ,IAAIE,QAAhB,EAA0B;IACtB,KAAK,IAAIthC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGohC,QAAQ,CAAC5pC,MAA7B,GAAsC;MAClC,MAAMg0D,UAAU,GAAGpqB,QAAQ,CAACphC,CAAC,EAAF,CAA3B;MACA,MAAMyrD,WAAW,GAAGrqB,QAAQ,CAACphC,CAAC,EAAF,CAA5B;;MACA,IAAI,OAAOwrD,UAAP,KAAsB,QAA1B,EAAoC;QAChC,MAAMjxD,IAAI,GAAGixD,UAAb;QACA,MAAME,eAAe,GAAG3wC,WAAW,CAAChF,KAAK,CAAC01C,WAAD,CAAN,CAAnC;QACA,MAAMrd,QAAQ,GAAG9M,QAAQ,CAACF,QAAQ,CAACphC,CAAC,EAAF,CAAT,CAAzB;QACA,MAAM2rD,gBAAgB,GAAGvqB,QAAQ,CAACphC,CAAC,EAAF,CAAjC,CAJgC,CAKhC;QACA;QACA;;QACA,MAAMhJ,IAAI,GAAI,OAAO20D,gBAAP,KAA4B,SAA5B,IAAyCA,gBAAgB,IAAI,CAA9D,GAAmE,KAAnE,GAA2E,QAAxF;QACA,MAAMC,UAAU,GAAG,OAAOD,gBAAP,KAA4B,SAA5B,GAAwCA,gBAAxC,GAA2D,KAA9E;;QACA,IAAIn+B,OAAO,IAAIk+B,eAAf,EAAgC;UAC5BH,SAAS,CAACp0D,IAAV,CAAe;YAAEq2B,OAAF;YAAWjzB,IAAX;YAAiB6zC,QAAjB;YAA2Bwd,UAA3B;YAAuC50D;UAAvC,CAAf;QACH;MACJ;IACJ;EACJ;;EACDu0D,SAAS,CAACM,IAAV,CAAeC,aAAf;EACA,OAAOP,SAAP;AACH;;AACD,SAASO,aAAT,CAAuB5rD,CAAvB,EAA0BC,CAA1B,EAA6B;EACzB,IAAID,CAAC,CAAC3F,IAAF,IAAU4F,CAAC,CAAC5F,IAAhB,EACI,OAAO,CAAP;EACJ,OAAO2F,CAAC,CAAC3F,IAAF,GAAS4F,CAAC,CAAC5F,IAAX,GAAkB,CAAC,CAAnB,GAAuB,CAA9B;AACH;AACD;AACA;AACA;AACA;AACA;;;AACA,SAASqwD,kBAAT,CAA4Bn9C,GAA5B,EAAiC;EAC7B,OAAOA,GAAG,CAACzW,IAAJ,KAAapC,SAAb,IAA0B6Y,GAAG,CAACrW,QAAJ,KAAiBxC,SAA3C,IAAwD6Y,GAAG,CAACgC,cAAJ,KAAuB7a,SAAtF;AACH;AACD;AACA;AACA;AACA;AACA;;;AACA,SAAS7G,YAAT,CAAsBy/B,OAAtB,EAA+B;EAC3B,IAAIrzB,SAAS,IAAI,EAAEqzB,OAAO,YAAYjuB,IAArB,CAAjB,EAA6C;IACzC,MAAM,IAAIlL,KAAJ,CAAU,mCAAV,CAAN;EACH;;EACD,MAAMi3D,QAAQ,GAAG9xB,WAAW,CAAChM,OAAD,CAA5B;EACA,MAAMzX,KAAK,GAAGu1C,QAAQ,GAAGA,QAAQ,CAACv1C,KAAZ,GAAoB,IAA1C;;EACA,IAAIA,KAAK,KAAK,IAAd,EAAoB;IAChB,OAAO,IAAP;EACH;;EACD,MAAM0F,SAAS,GAAG6vC,QAAQ,CAAC7vC,SAA3B;;EACA,IAAIA,SAAS,KAAK,CAAC,CAAnB,EAAsB;IAClB,MAAMswC,YAAY,GAAGh2C,KAAK,CAAC0F,SAAD,CAA1B,CADkB,CAElB;IACA;;IACA,MAAMzT,KAAK,GAAGuN,OAAO,CAACw2C,YAAD,CAAP,GAAwBA,YAAY,CAAC33C,MAAD,CAApC,GAA+CiH,QAAQ,CAACtF,KAAK,CAAChC,KAAD,CAAN,EAAe0H,SAAf,CAArE;IACAthB,SAAS,IACLwE,WAAW,CAACqJ,KAAK,CAACtQ,KAAP,EAAc+jB,SAAd,EAAyB,gDAAzB,CADf;IAEA,OAAO2/B,cAAc,CAACpzC,KAAD,EAAQ+N,KAAR,CAArB;EACH;;EACD,OAAO,IAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASi2C,iBAAT,CAA2BnxD,MAA3B,EAAmC;EAC/B,MAAMywD,QAAQ,GAAG9xB,WAAW,CAAC3+B,MAAD,CAA5B;EACA,MAAMoxD,QAAQ,GAAGX,QAAQ,CAAC7vC,SAA1B;EACA,MAAM1F,KAAK,GAAGu1C,QAAQ,CAACv1C,KAAvB;EACA5b,SAAS,IAAI4c,WAAW,CAAChB,KAAD,CAAxB;EACA,MAAM2uB,cAAc,GAAG3uB,KAAK,CAACk2C,QAAD,CAA5B;EACA9xD,SAAS,IAAI4c,WAAW,CAAC2tB,cAAD,CAAxB;EACA,OAAOA,cAAP;AACH;AACD;;;AACA,SAAS0lB,gBAAT,CAA0BhuD,KAA1B,EAAiC;EAC7B,IAAI,OAAO8vD,OAAP,KAAmB,WAAnB,IAAkC,EAAE9vD,KAAK,YAAY8vD,OAAnB,CAAtC,EAAmE;IAC/D,MAAM,IAAI73D,KAAJ,CAAU,mCAAV,CAAN;EACH;AACJ;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS83D,YAAT,CAAsBp1D,SAAtB,EAAiC;EAC7BmzD,SAAS,CAACnzD,SAAD,CAAT;EACAyzD,iBAAiB,CAACzzD,SAAD,CAAjB,CAA6BD,OAA7B,CAAqCkkC,aAAa,IAAItnC,aAAa,CAACsnC,aAAD,CAAnE;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;;AACA,MAAMoxB,0BAA0B,GAAG,IAAnC;AACA,IAAIC,UAAU,GAAG,KAAjB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,yBAAT,GAAqC;EACjC,IAAI,CAACD,UAAL,EAAiB;IACbA,UAAU,GAAG,IAAb;IACA;AACR;AACA;AACA;AACA;;IACQE,iBAAiB,CAAC,cAAD,EAAiB/yC,WAAjB,CAAjB;IACA+yC,iBAAiB,CAAC,sBAAD,EAAyBxB,oBAAzB,CAAjB;IACAwB,iBAAiB,CAAC,cAAD,EAAiBpC,cAAjB,CAAjB;IACAoC,iBAAiB,CAAC,YAAD,EAAelC,UAAf,CAAjB;IACAkC,iBAAiB,CAAC,cAAD,EAAiBlB,YAAjB,CAAjB;IACAkB,iBAAiB,CAAC,oBAAD,EAAuBjC,kBAAvB,CAAjB;IACAiC,iBAAiB,CAAC,gBAAD,EAAmBrB,cAAnB,CAAjB;IACAqB,iBAAiB,CAAC,aAAD,EAAgB9B,WAAhB,CAAjB;IACA8B,iBAAiB,CAAC,mBAAD,EAAsB/B,iBAAtB,CAAjB;IACA+B,iBAAiB,CAAC,eAAD,EAAkB1B,aAAlB,CAAjB;IACA0B,iBAAiB,CAAC,cAAD,EAAiBJ,YAAjB,CAAjB;EACH;AACJ;AACD;AACA;AACA;AACA;;;AACA,SAASI,iBAAT,CAA2BhyD,IAA3B,EAAiC9I,EAAjC,EAAqC;EACjC,IAAI,OAAO+6D,QAAP,KAAoB,WAApB,IAAmC,CAACA,QAAxC,EAAkD;IAC9C;IACA;IACA;IACA;IACA,MAAMC,CAAC,GAAGpzD,SAAV;IACAc,SAAS,IAAIgF,aAAa,CAAC1N,EAAD,EAAK,sBAAL,CAA1B;;IACA,IAAIg7D,CAAJ,EAAO;MACH,IAAI1uB,SAAS,GAAG0uB,CAAC,CAACL,0BAAD,CAAjB;;MACA,IAAI,CAACruB,SAAL,EAAgB;QACZA,SAAS,GAAG0uB,CAAC,CAACL,0BAAD,CAAD,GAAgC,EAA5C;MACH;;MACDruB,SAAS,CAACxjC,IAAD,CAAT,GAAkB9I,EAAlB;IACH;EACJ;AACJ;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMi7D,aAAa,GAAG;EAClB53D,GAAG,EAAE,CAACkG,KAAD,EAAQuQ,aAAR,KAA0B;IAC3BT,0BAA0B,CAAC9P,KAAD,EAAQ,cAAR,CAA1B;EACH;AAHiB,CAAtB;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAAS2xD,eAAT,CAAyBC;AAAc;AAAvC,EAAuG3wD,IAAI,GAAG,EAA9G,EAAkH;EAC9G9B,SAAS,IAAImyD,yBAAyB,EAAtC;EACAnyD,SAAS,IAAImc,mBAAmB,CAACs2C,aAAD,CAAhC;EACA,MAAMvO,eAAe,GAAGpiD,IAAI,CAACoiD,eAAL,IAAwB3jC,mBAAhD;EACA,MAAMsb,SAAS,GAAG/5B,IAAI,CAAC+5B,SAAL,IAAkB,IAApC;EACA,MAAM4F,YAAY,GAAG7pB,iBAAiB,CAAC66C,aAAD,CAAtC;EACA,IAAIhxB,YAAY,CAAC5kC,IAAb,IAAqB41D,aAAzB,EACIhxB,YAAY,CAAC5kC,IAAb,GAAoB41D,aAApB,CAP0G,CAQ9G;;EACA,MAAMC,YAAY,GAAGjxB,YAAY,CAAC/qB,SAAb,CAAuB,CAAvB,EAA0B,CAA1B,CAArB;EACA,MAAMi8C,YAAY,GAAGzO,eAAe,CAAC1jC,cAAhB,CAA+B,IAA/B,EAAqC,IAArC,CAArB;EACA,MAAMoyC,SAAS,GAAGxJ,iBAAiB,CAACuJ,YAAD,EAAe7wD,IAAI,CAACmwB,IAAL,IAAaygC,YAA5B,EAA0CjxB,YAAY,CAAC3qB,aAAvD,CAAnC;EACA,MAAM+7C,SAAS,GAAGpxB,YAAY,CAACtrB,MAAb,GAAsB;EAAG;EAAH,EAA4B;EAAI;EAAtD,EACd;EAAG;EAAH,EAAkC;EAAI;EAD1C;EAEA,MAAMk4C,WAAW,GAAGyE,iBAAiB,CAAChxD,IAAI,CAAC2sD,SAAN,EAAiB3sD,IAAI,CAAC6sD,aAAtB,CAArC;EACA,MAAM9zD,QAAQ,GAAGqpD,eAAe,CAAC1jC,cAAhB,CAA+BoyC,SAA/B,EAA0CnxB,YAA1C,CAAjB;EACA,MAAMsxB,SAAS,GAAGpK,WAAW,CAAC;EAAE;EAAH,EAAyB,IAAzB,EAA+B,IAA/B,EAAqC,CAArC,EAAwC,CAAxC,EAA2C,IAA3C,EAAiD,IAAjD,EAAuD,IAAvD,EAA6D,IAA7D,EAAmE,IAAnE,CAA7B;EACA,MAAMnlB,QAAQ,GAAGkjB,WAAW,CAAC,IAAD,EAAOqM,SAAP,EAAkB1E,WAAlB,EAA+BwE,SAA/B,EAA0C,IAA1C,EAAgD,IAAhD,EAAsD3O,eAAtD,EAAuErpD,QAAvE,EAAiF,IAAjF,EAAuFiH,IAAI,CAACpH,QAAL,IAAiB,IAAxG,EAA8G,IAA9G,CAA5B;EACAgrB,SAAS,CAAC8d,QAAD,CAAT;EACA,IAAI5mC,SAAJ;;EACA,IAAI;IACA,IAAIsnD,eAAe,CAAC2D,KAApB,EACI3D,eAAe,CAAC2D,KAAhB;IACJ,MAAMlnB,aAAa,GAAGqyB,uBAAuB,CAACJ,SAAD,EAAYnxB,YAAZ,EAA0B+B,QAA1B,EAAoC0gB,eAApC,EAAqDrpD,QAArD,EAA+DghC,SAA/D,CAA7C;IACAj/B,SAAS,GAAGq2D,mBAAmB,CAACtyB,aAAD,EAAgBc,YAAhB,EAA8B+B,QAA9B,EAAwC6qB,WAAxC,EAAqDvsD,IAAI,CAACoxD,YAAL,IAAqB,IAA1E,CAA/B,CAJA,CAKA;;IACA/L,UAAU,CAAC4L,SAAD,EAAYvvB,QAAZ,EAAsB,IAAtB,CAAV,CANA,CAOA;;IACA+jB,WAAW,CAACwL,SAAD,EAAYvvB,QAAZ,EAAsB,IAAtB,EAA4B,IAA5B,CAAX;EACH,CATD,SAUQ;IACJld,SAAS;IACT,IAAI49B,eAAe,CAAC/8C,GAApB,EACI+8C,eAAe,CAAC/8C,GAAhB;EACP;;EACD,OAAOvK,SAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASo2D,uBAAT,CAAiC7uB,KAAjC,EAAwCthC,GAAxC,EAA6C2gC,QAA7C,EAAuD0gB,eAAvD,EAAwEyO,YAAxE,EAAsF92B,SAAtF,EAAiG;EAC7F,MAAM/tB,KAAK,GAAG01B,QAAQ,CAAC5pB,KAAD,CAAtB;EACA,MAAMrc,KAAK,GAAG0d,aAAd;EACAjb,SAAS,IAAIqF,kBAAkB,CAACm+B,QAAD,EAAWjmC,KAAX,CAA/B;EACAimC,QAAQ,CAACjmC,KAAD,CAAR,GAAkB4mC,KAAlB,CAJ6F,CAK7F;EACA;EACA;;EACA,MAAMt2B,KAAK,GAAG+4C,gBAAgB,CAAC94C,KAAD,EAAQvQ,KAAR,EAAe;EAAE;EAAjB,EAA0C,OAA1C,EAAmD,IAAnD,CAA9B;EACA,MAAMgjD,WAAW,GAAG1yC,KAAK,CAAC0yC,WAAN,GAAoB19C,GAAG,CAACiT,SAA5C;;EACA,IAAIyqC,WAAW,KAAK,IAApB,EAA0B;IACtBqP,oBAAoB,CAAC/hD,KAAD,EAAQ0yC,WAAR,EAAqB,IAArB,CAApB;;IACA,IAAIpc,KAAK,KAAK,IAAd,EAAoB;MAChBzZ,eAAe,CAACioC,YAAD,EAAexuB,KAAf,EAAsBoc,WAAtB,CAAf;;MACA,IAAI1yC,KAAK,CAACugB,OAAN,KAAkB,IAAtB,EAA4B;QACxByd,gBAAgB,CAAC8mB,YAAD,EAAexuB,KAAf,EAAsBt2B,KAAK,CAACugB,OAA5B,CAAhB;MACH;;MACD,IAAIvgB,KAAK,CAAC1Q,MAAN,KAAiB,IAArB,EAA2B;QACvBwuC,gBAAgB,CAACgnB,YAAD,EAAexuB,KAAf,EAAsBt2B,KAAK,CAAC1Q,MAA5B,CAAhB;MACH;IACJ;EACJ;;EACD,MAAMg2D,YAAY,GAAGjP,eAAe,CAAC1jC,cAAhB,CAA+B2jB,KAA/B,EAAsCthC,GAAtC,CAArB;EACA,MAAM89B,aAAa,GAAG+lB,WAAW,CAACljB,QAAD,EAAWklB,yBAAyB,CAAC7lD,GAAD,CAApC,EAA2C,IAA3C,EAAiDA,GAAG,CAACsT,MAAJ,GAAa;EAAG;EAAhB,EAAyC;EAAG;EAA7F,EAA2HqtB,QAAQ,CAACjmC,KAAD,CAAnI,EAA4IsQ,KAA5I,EAAmJq2C,eAAnJ,EAAoKiP,YAApK,EAAkLt3B,SAAS,IAAI,IAA/L,EAAqM,IAArM,EAA2M,IAA3M,CAAjC;;EACA,IAAI/tB,KAAK,CAACF,eAAV,EAA2B;IACvBqgB,kBAAkB,CAACb,8BAA8B,CAACvf,KAAD,EAAQ21B,QAAR,CAA/B,EAAkD11B,KAAlD,EAAyDjL,GAAG,CAAChG,IAA7D,CAAlB;IACAgwD,mBAAmB,CAAC/+C,KAAD,EAAQD,KAAR,CAAnB;IACAg+C,cAAc,CAACh+C,KAAD,EAAQ21B,QAAQ,CAACnmC,MAAjB,EAAyB,CAAzB,CAAd;EACH;;EACD6vD,aAAa,CAAC1pB,QAAD,EAAW7C,aAAX,CAAb,CA7B6F,CA8B7F;;EACA,OAAO6C,QAAQ,CAACjmC,KAAD,CAAR,GAAkBojC,aAAzB;AACH;AACD;AACA;AACA;AACA;;;AACA,SAASsyB,mBAAT,CAA6BtyB,aAA7B,EAA4Cc,YAA5C,EAA0D2xB,SAA1D,EAAqE/E,WAArE,EAAkF6E,YAAlF,EAAgG;EAC5F,MAAMplD,KAAK,GAAGslD,SAAS,CAACx5C,KAAD,CAAvB,CAD4F,CAE5F;;EACA,MAAMhd,SAAS,GAAG0uD,wBAAwB,CAACx9C,KAAD,EAAQslD,SAAR,EAAmB3xB,YAAnB,CAA1C;EACA4sB,WAAW,CAAC5tB,UAAZ,CAAuBzjC,IAAvB,CAA4BJ,SAA5B;EACA+jC,aAAa,CAACxmB,OAAD,CAAb,GAAyBvd,SAAzB;;EACA,IAAIs2D,YAAY,KAAK,IAArB,EAA2B;IACvB,KAAK,MAAM/7C,OAAX,IAAsB+7C,YAAtB,EAAoC;MAChC/7C,OAAO,CAACva,SAAD,EAAY6kC,YAAZ,CAAP;IACH;EACJ,CAV2F,CAW5F;EACA;;;EACA,IAAIA,YAAY,CAAC1rB,cAAjB,EAAiC;IAC7B,MAAMlI,KAAK,GAAGwV,eAAe,EAA7B;IACArjB,SAAS,IAAIgF,aAAa,CAAC6I,KAAD,EAAQ,gBAAR,CAA1B;IACA4zB,YAAY,CAAC1rB,cAAb,CAA4B;IAAE;IAA9B,EAAwDnZ,SAAxD,EAAmEiR,KAAK,CAACga,cAAzE;EACH;;EACD,MAAM0jC,SAAS,GAAGloC,eAAe,EAAjC;EACArjB,SAAS,IAAIgF,aAAa,CAACumD,SAAD,EAAY,wCAAZ,CAA1B;;EACA,IAAIz9C,KAAK,CAACF,eAAN,KACC6zB,YAAY,CAAC7rB,YAAb,KAA8B,IAA9B,IAAsC6rB,YAAY,CAAC3rB,SAAb,KAA2B,IADlE,CAAJ,EAC6E;IACzE+Q,gBAAgB,CAAC0kC,SAAS,CAAChuD,KAAX,CAAhB;IACA,MAAMw1D,SAAS,GAAGK,SAAS,CAACx5C,KAAD,CAA3B;IACAuyC,0BAA0B,CAAC4G,SAAD,EAAYxH,SAAZ,EAAuB6H,SAAvB,EAAkC7H,SAAS,CAAC1jC,cAA5C,EAA4D0jC,SAAS,CAACzjC,YAAtE,EAAoF2Z,YAApF,CAA1B;IACAkrB,gCAAgC,CAAClrB,YAAD,EAAe7kC,SAAf,CAAhC;EACH;;EACD,OAAOA,SAAP;AACH;;AACD,SAASk2D,iBAAT,CAA2BrE,SAA3B,EAAsCE,aAAtC,EAAqD;EACjD,OAAO;IACHluB,UAAU,EAAE,EADT;IAEHguB,SAAS,EAAEA,SAAS,IAAIz7B,gBAFrB;IAGHu7B,KAAK,EAAEgB,aAHJ;IAIHZ,aAAa,EAAEA,aAAa,IAAI,IAJ7B;IAKHt9C,KAAK,EAAE;IAAE;;EALN,CAAP;AAOH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASgiD,qBAAT,GAAiC;EAC7B,MAAMxlD,KAAK,GAAGwV,eAAe,EAA7B;EACArjB,SAAS,IAAIgF,aAAa,CAAC6I,KAAD,EAAQ,mBAAR,CAA1B;EACA+Z,sBAAsB,CAAC7E,QAAQ,GAAGnJ,KAAH,CAAT,EAAoB/L,KAApB,CAAtB;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASylD,YAAT,CAAsB12D,SAAtB,EAAiC;EAC7B,OAAO0mC,cAAc,CAAC1mC,SAAD,CAAd,CAA0B2xD,KAAjC;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASgF,YAAT,CAAsB12D,IAAtB,EAA4B;EACxB,OAAOyM,MAAM,CAACiE,cAAP,CAAsB1Q,IAAI,CAAC2M,SAA3B,EAAsCzR,WAA7C;AACH;AACD;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASy7D,0BAAT,CAAoCh1C,UAApC,EAAgD;EAC5C,IAAIi1C,SAAS,GAAGF,YAAY,CAAC/0C,UAAU,CAAC3hB,IAAZ,CAA5B;EACA,IAAI62D,mBAAmB,GAAG,IAA1B;EACA,MAAMC,gBAAgB,GAAG,CAACn1C,UAAD,CAAzB;;EACA,OAAOi1C,SAAP,EAAkB;IACd,IAAIG,QAAQ,GAAGn5D,SAAf;;IACA,IAAIghB,cAAc,CAAC+C,UAAD,CAAlB,EAAgC;MAC5B;MACAo1C,QAAQ,GAAGH,SAAS,CAACl/C,IAAV,IAAkBk/C,SAAS,CAACh/C,IAAvC;IACH,CAHD,MAIK;MACD,IAAIg/C,SAAS,CAACl/C,IAAd,EAAoB;QAChB,MAAM,IAAIlF,YAAJ,CAAiB;QAAI;QAArB,EAAiErP,SAAS,IAC3E,mDAAkDiQ,iBAAiB,CAACuO,UAAU,CAAC3hB,IAAZ,CAAkB,sCAAqCoT,iBAAiB,CAACwjD,SAAD,CAAY,EADtJ,CAAN;MAEH,CAJA,CAKD;;;MACAG,QAAQ,GAAGH,SAAS,CAACh/C,IAArB;IACH;;IACD,IAAIm/C,QAAJ,EAAc;MACV,IAAIF,mBAAJ,EAAyB;QACrBC,gBAAgB,CAAC32D,IAAjB,CAAsB42D,QAAtB,EADqB,CAErB;QACA;;QACA,MAAMC,YAAY,GAAGr1C,UAArB;QACAq1C,YAAY,CAAC79C,MAAb,GAAsB89C,gBAAgB,CAACt1C,UAAU,CAACxI,MAAZ,CAAtC;QACA69C,YAAY,CAACv+C,cAAb,GAA8Bw+C,gBAAgB,CAACt1C,UAAU,CAAClJ,cAAZ,CAA9C;QACAu+C,YAAY,CAAC59C,OAAb,GAAuB69C,gBAAgB,CAACt1C,UAAU,CAACvI,OAAZ,CAAvC,CAPqB,CAQrB;;QACA,MAAM89C,iBAAiB,GAAGH,QAAQ,CAACh+C,YAAnC;QACAm+C,iBAAiB,IAAIC,mBAAmB,CAACx1C,UAAD,EAAau1C,iBAAb,CAAxC,CAVqB,CAWrB;;QACA,MAAME,cAAc,GAAGL,QAAQ,CAACj9C,SAAhC;QACA,MAAMu9C,mBAAmB,GAAGN,QAAQ,CAAC79C,cAArC;QACAk+C,cAAc,IAAIE,gBAAgB,CAAC31C,UAAD,EAAay1C,cAAb,CAAlC;QACAC,mBAAmB,IAAIE,qBAAqB,CAAC51C,UAAD,EAAa01C,mBAAb,CAA5C,CAfqB,CAgBrB;;QACAzzD,cAAc,CAAC+d,UAAU,CAACxI,MAAZ,EAAoB49C,QAAQ,CAAC59C,MAA7B,CAAd;QACAvV,cAAc,CAAC+d,UAAU,CAAClJ,cAAZ,EAA4Bs+C,QAAQ,CAACt+C,cAArC,CAAd;QACA7U,cAAc,CAAC+d,UAAU,CAACvI,OAAZ,EAAqB29C,QAAQ,CAAC39C,OAA9B,CAAd,CAnBqB,CAoBrB;QACA;;QACA,IAAIwF,cAAc,CAACm4C,QAAD,CAAd,IAA4BA,QAAQ,CAAC/8C,IAAT,CAAcw9C,SAA9C,EAAyD;UACrD;UACA;UACA,MAAMC,OAAO,GAAG91C,UAAU,CAAC3H,IAA3B;UACAy9C,OAAO,CAACD,SAAR,GAAoB,CAACC,OAAO,CAACD,SAAR,IAAqB,EAAtB,EAA0B1oD,MAA1B,CAAiCioD,QAAQ,CAAC/8C,IAAT,CAAcw9C,SAA/C,CAApB;QACH;MACJ,CA7BS,CA8BV;;;MACA,MAAMz9C,QAAQ,GAAGg9C,QAAQ,CAACh9C,QAA1B;;MACA,IAAIA,QAAJ,EAAc;QACV,KAAK,IAAI/Q,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+Q,QAAQ,CAACvZ,MAA7B,EAAqCwI,CAAC,EAAtC,EAA0C;UACtC,MAAMsR,OAAO,GAAGP,QAAQ,CAAC/Q,CAAD,CAAxB;;UACA,IAAIsR,OAAO,IAAIA,OAAO,CAACyH,SAAvB,EAAkC;YAC9BzH,OAAO,CAACqH,UAAD,CAAP;UACH,CAJqC,CAKtC;UACA;UACA;UACA;UACA;UACA;UACA;;;UACA,IAAIrH,OAAO,KAAKq8C,0BAAhB,EAA4C;YACxCE,mBAAmB,GAAG,KAAtB;UACH;QACJ;MACJ;IACJ;;IACDD,SAAS,GAAGnqD,MAAM,CAACiE,cAAP,CAAsBkmD,SAAtB,CAAZ;EACH;;EACDc,+BAA+B,CAACZ,gBAAD,CAA/B;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASY,+BAAT,CAAyCZ,gBAAzC,EAA2D;EACvD,IAAI99C,QAAQ,GAAG,CAAf;EACA,IAAIC,SAAS,GAAG,IAAhB,CAFuD,CAGvD;;EACA,KAAK,IAAIjQ,CAAC,GAAG8tD,gBAAgB,CAACt2D,MAAjB,GAA0B,CAAvC,EAA0CwI,CAAC,IAAI,CAA/C,EAAkDA,CAAC,EAAnD,EAAuD;IACnD,MAAMhD,GAAG,GAAG8wD,gBAAgB,CAAC9tD,CAAD,CAA5B,CADmD,CAEnD;;IACAhD,GAAG,CAACgT,QAAJ,GAAgBA,QAAQ,IAAIhT,GAAG,CAACgT,QAAhC,CAHmD,CAInD;;IACAhT,GAAG,CAACiT,SAAJ,GACI0V,cAAc,CAAC3oB,GAAG,CAACiT,SAAL,EAAgBA,SAAS,GAAG0V,cAAc,CAAC1V,SAAD,EAAYjT,GAAG,CAACiT,SAAhB,CAA1C,CADlB;EAEH;AACJ;;AACD,SAASg+C,gBAAT,CAA0B7xD,KAA1B,EAAiC;EAC7B,IAAIA,KAAK,KAAKkS,SAAd,EAAyB;IACrB,OAAO,EAAP;EACH,CAFD,MAGK,IAAIlS,KAAK,KAAKmS,WAAd,EAA2B;IAC5B,OAAO,EAAP;EACH,CAFI,MAGA;IACD,OAAOnS,KAAP;EACH;AACJ;;AACD,SAASkyD,gBAAT,CAA0B31C,UAA1B,EAAsCy1C,cAAtC,EAAsD;EAClD,MAAMO,aAAa,GAAGh2C,UAAU,CAAC7H,SAAjC;;EACA,IAAI69C,aAAJ,EAAmB;IACfh2C,UAAU,CAAC7H,SAAX,GAAuB,CAACmxC,EAAD,EAAK2M,GAAL,KAAa;MAChCR,cAAc,CAACnM,EAAD,EAAK2M,GAAL,CAAd;MACAD,aAAa,CAAC1M,EAAD,EAAK2M,GAAL,CAAb;IACH,CAHD;EAIH,CALD,MAMK;IACDj2C,UAAU,CAAC7H,SAAX,GAAuBs9C,cAAvB;EACH;AACJ;;AACD,SAASG,qBAAT,CAA+B51C,UAA/B,EAA2C01C,mBAA3C,EAAgE;EAC5D,MAAMQ,kBAAkB,GAAGl2C,UAAU,CAACzI,cAAtC;;EACA,IAAI2+C,kBAAJ,EAAwB;IACpBl2C,UAAU,CAACzI,cAAX,GAA4B,CAAC+xC,EAAD,EAAK2M,GAAL,EAAUptC,cAAV,KAA6B;MACrD6sC,mBAAmB,CAACpM,EAAD,EAAK2M,GAAL,EAAUptC,cAAV,CAAnB;MACAqtC,kBAAkB,CAAC5M,EAAD,EAAK2M,GAAL,EAAUptC,cAAV,CAAlB;IACH,CAHD;EAIH,CALD,MAMK;IACD7I,UAAU,CAACzI,cAAX,GAA4Bm+C,mBAA5B;EACH;AACJ;;AACD,SAASF,mBAAT,CAA6Bx1C,UAA7B,EAAyCu1C,iBAAzC,EAA4D;EACxD,MAAMY,gBAAgB,GAAGn2C,UAAU,CAAC5I,YAApC;;EACA,IAAI++C,gBAAJ,EAAsB;IAClBn2C,UAAU,CAAC5I,YAAX,GAA0B,CAACkyC,EAAD,EAAK2M,GAAL,KAAa;MACnCV,iBAAiB,CAACjM,EAAD,EAAK2M,GAAL,CAAjB;MACAE,gBAAgB,CAAC7M,EAAD,EAAK2M,GAAL,CAAhB;IACH,CAHD;EAIH,CALD,MAMK;IACDj2C,UAAU,CAAC5I,YAAX,GAA0Bm+C,iBAA1B;EACH;AACJ;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;;AACA,MAAMa,qBAAqB,GAAG,CAC1B;AACA,mBAF0B,CAG1B;AACA;AAJ0B,CAA9B;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,qBAAqB,GAAG,CAC1B;AACA;AACA,UAH0B,EAI1B,OAJ0B,EAK1B,QAL0B,EAM1B,MAN0B,EAO1B,QAP0B,EAQ1B,oBAR0B,EAS1B;AACA,QAV0B,EAW1B,eAX0B,EAY1B;AACA,SAb0B,CAA9B;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,uBAAT,CAAiCt2C,UAAjC,EAA6C;EACzC,IAAIi1C,SAAS,GAAGF,YAAY,CAAC/0C,UAAU,CAAC3hB,IAAZ,CAA5B;EACA,IAAI+2D,QAAQ,GAAGn5D,SAAf;;EACA,IAAIghB,cAAc,CAAC+C,UAAD,CAAlB,EAAgC;IAC5B;IACAo1C,QAAQ,GAAGH,SAAS,CAACl/C,IAArB;EACH,CAHD,MAIK;IACD;IACAq/C,QAAQ,GAAGH,SAAS,CAACh/C,IAArB;EACH,CAVwC,CAWzC;;;EACA,MAAMsgD,MAAM,GAAGv2C,UAAf,CAZyC,CAazC;;EACA,KAAK,MAAM7b,KAAX,IAAoBiyD,qBAApB,EAA2C;IACvCG,MAAM,CAACpyD,KAAD,CAAN,GAAgBixD,QAAQ,CAACjxD,KAAD,CAAxB;EACH;;EACD,IAAI8Y,cAAc,CAACm4C,QAAD,CAAlB,EAA8B;IAC1B;IACA,KAAK,MAAMjxD,KAAX,IAAoBkyD,qBAApB,EAA2C;MACvCE,MAAM,CAACpyD,KAAD,CAAN,GAAgBixD,QAAQ,CAACjxD,KAAD,CAAxB;IACH;EACJ;AACJ;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIqyD,eAAe,GAAG,IAAtB;;AACA,SAASC,iBAAT,GAA6B;EACzB,IAAI,CAACD,eAAL,EAAsB;IAClB,MAAME,MAAM,GAAGh2D,SAAS,CAAC,QAAD,CAAxB;;IACA,IAAIg2D,MAAM,IAAIA,MAAM,CAACC,QAArB,EAA+B;MAC3BH,eAAe,GAAGE,MAAM,CAACC,QAAzB;IACH,CAFD,MAGK;MACD;MACA,MAAMvoD,IAAI,GAAGtD,MAAM,CAAC8rD,mBAAP,CAA2Bl5D,GAAG,CAACsN,SAA/B,CAAb;;MACA,KAAK,IAAI3D,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+G,IAAI,CAACvP,MAAzB,EAAiC,EAAEwI,CAAnC,EAAsC;QAClC,MAAMrF,GAAG,GAAGoM,IAAI,CAAC/G,CAAD,CAAhB;;QACA,IAAIrF,GAAG,KAAK,SAAR,IAAqBA,GAAG,KAAK,MAA7B,IACAtE,GAAG,CAACsN,SAAJ,CAAchJ,GAAd,MAAuBtE,GAAG,CAACsN,SAAJ,CAAc,SAAd,CAD3B,EACqD;UACjDwrD,eAAe,GAAGx0D,GAAlB;QACH;MACJ;IACJ;EACJ;;EACD,OAAOw0D,eAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASK,UAAT,CAAoB/hD,GAApB,EAAyB;EACrB,OAAOA,GAAG,KAAK,IAAR,IAAgB,OAAOA,GAAP,KAAe,QAA/B,IAA2CA,GAAG,CAAC2hD,iBAAiB,EAAlB,CAAH,KAA6Bx6D,SAA/E;AACH;;AACD,SAAS66D,kBAAT,CAA4BhiD,GAA5B,EAAiC;EAC7B,IAAI,CAACiiD,UAAU,CAACjiD,GAAD,CAAf,EACI,OAAO,KAAP;EACJ,OAAOxS,KAAK,CAACC,OAAN,CAAcuS,GAAd,KACF,EAAEA,GAAG,YAAYpX,GAAjB,KAAyB;EACtB+4D,iBAAiB,MAAM3hD,GAF/B,CAH6B,CAKQ;AACxC;;AACD,SAASkiD,iBAAT,CAA2BzvD,CAA3B,EAA8BC,CAA9B,EAAiCyvD,UAAjC,EAA6C;EACzC,MAAMC,SAAS,GAAG3vD,CAAC,CAACkvD,iBAAiB,EAAlB,CAAD,EAAlB;EACA,MAAMU,SAAS,GAAG3vD,CAAC,CAACivD,iBAAiB,EAAlB,CAAD,EAAlB;;EACA,OAAO,IAAP,EAAa;IACT,MAAMW,KAAK,GAAGF,SAAS,CAACr8D,IAAV,EAAd;IACA,MAAMw8D,KAAK,GAAGF,SAAS,CAACt8D,IAAV,EAAd;IACA,IAAIu8D,KAAK,CAACE,IAAN,IAAcD,KAAK,CAACC,IAAxB,EACI,OAAO,IAAP;IACJ,IAAIF,KAAK,CAACE,IAAN,IAAcD,KAAK,CAACC,IAAxB,EACI,OAAO,KAAP;IACJ,IAAI,CAACL,UAAU,CAACG,KAAK,CAAC3zD,KAAP,EAAc4zD,KAAK,CAAC5zD,KAApB,CAAf,EACI,OAAO,KAAP;EACP;AACJ;;AACD,SAAS8zD,eAAT,CAAyBziD,GAAzB,EAA8Bhc,EAA9B,EAAkC;EAC9B,IAAIwJ,KAAK,CAACC,OAAN,CAAcuS,GAAd,CAAJ,EAAwB;IACpB,KAAK,IAAIzN,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyN,GAAG,CAACjW,MAAxB,EAAgCwI,CAAC,EAAjC,EAAqC;MACjCvO,EAAE,CAACgc,GAAG,CAACzN,CAAD,CAAJ,CAAF;IACH;EACJ,CAJD,MAKK;IACD,MAAMsvD,QAAQ,GAAG7hD,GAAG,CAAC2hD,iBAAiB,EAAlB,CAAH,EAAjB;IACA,IAAI1uD,IAAJ;;IACA,OAAO,CAAE,CAACA,IAAI,GAAG4uD,QAAQ,CAAC97D,IAAT,EAAR,EAAyBy8D,IAAlC,EAAyC;MACrCx+D,EAAE,CAACiP,IAAI,CAACtE,KAAN,CAAF;IACH;EACJ;AACJ;;AACD,SAASszD,UAAT,CAAoBS,CAApB,EAAuB;EACnB,OAAOA,CAAC,KAAK,IAAN,KAAe,OAAOA,CAAP,KAAa,UAAb,IAA2B,OAAOA,CAAP,KAAa,QAAvD,CAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,YAAT,CAAsBlwD,CAAtB,EAAyBC,CAAzB,EAA4B;EACxB,MAAMkwD,mBAAmB,GAAGZ,kBAAkB,CAACvvD,CAAD,CAA9C;EACA,MAAMowD,mBAAmB,GAAGb,kBAAkB,CAACtvD,CAAD,CAA9C;;EACA,IAAIkwD,mBAAmB,IAAIC,mBAA3B,EAAgD;IAC5C,OAAOX,iBAAiB,CAACzvD,CAAD,EAAIC,CAAJ,EAAOiwD,YAAP,CAAxB;EACH,CAFD,MAGK;IACD,MAAMG,SAAS,GAAGrwD,CAAC,KAAK,OAAOA,CAAP,KAAa,QAAb,IAAyB,OAAOA,CAAP,KAAa,UAA3C,CAAnB;IACA,MAAMswD,SAAS,GAAGrwD,CAAC,KAAK,OAAOA,CAAP,KAAa,QAAb,IAAyB,OAAOA,CAAP,KAAa,UAA3C,CAAnB;;IACA,IAAI,CAACkwD,mBAAD,IAAwBE,SAAxB,IAAqC,CAACD,mBAAtC,IAA6DE,SAAjE,EAA4E;MACxE,OAAO,IAAP;IACH,CAFD,MAGK;MACD,OAAO/sD,MAAM,CAACgtD,EAAP,CAAUvwD,CAAV,EAAaC,CAAb,CAAP;IACH;EACJ;AACJ;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;;AACA,SAASuwD,aAAT,CAAuB36C,KAAvB,EAA8BwI,YAA9B,EAA4CniB,KAA5C,EAAmD;EAC/C,OAAO2Z,KAAK,CAACwI,YAAD,CAAL,GAAsBniB,KAA7B;AACH;AACD;;;AACA,SAASu0D,UAAT,CAAoB56C,KAApB,EAA2BwI,YAA3B,EAAyC;EACrCpkB,SAAS,IAAIqF,kBAAkB,CAACuW,KAAD,EAAQwI,YAAR,CAA/B;EACApkB,SAAS,IACL4E,aAAa,CAACgX,KAAK,CAACwI,YAAD,CAAN,EAAsBwqB,SAAtB,EAAiC,yCAAjC,CADjB;EAEA,OAAOhzB,KAAK,CAACwI,YAAD,CAAZ;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASqyC,cAAT,CAAwB76C,KAAxB,EAA+BwI,YAA/B,EAA6CniB,KAA7C,EAAoD;EAChDjC,SAAS,IAAI4E,aAAa,CAAC3C,KAAD,EAAQ2sC,SAAR,EAAmB,2CAAnB,CAA1B;EACA5uC,SAAS,IACL6E,cAAc,CAACuf,YAAD,EAAexI,KAAK,CAACve,MAArB,EAA8B,gDAA9B,CADlB;EAEA,MAAMsvB,QAAQ,GAAG/Q,KAAK,CAACwI,YAAD,CAAtB;;EACA,IAAI9a,MAAM,CAACgtD,EAAP,CAAU3pC,QAAV,EAAoB1qB,KAApB,CAAJ,EAAgC;IAC5B,OAAO,KAAP;EACH,CAFD,MAGK;IACD,IAAIjC,SAAS,IAAI8jB,sBAAsB,EAAvC,EAA2C;MACvC;MACA;MACA,MAAM4yC,iBAAiB,GAAG/pC,QAAQ,KAAKiiB,SAAb,GAAyBjiB,QAAzB,GAAoClyB,SAA9D;;MACA,IAAI,CAACw7D,YAAY,CAACS,iBAAD,EAAoBz0D,KAApB,CAAjB,EAA6C;QACzC,MAAM00D,OAAO,GAAGn0B,gCAAgC,CAAC5mB,KAAD,EAAQwI,YAAR,EAAsBsyC,iBAAtB,EAAyCz0D,KAAzC,CAAhD;QACA4/B,yBAAyB,CAAClV,QAAQ,KAAKiiB,SAAd,EAAyB+nB,OAAO,CAAChqC,QAAjC,EAA2CgqC,OAAO,CAACr0B,QAAnD,EAA6Dq0B,OAAO,CAAC7sD,QAArE,CAAzB;MACH,CAPsC,CAQvC;MACA;MACA;MACA;;;MACA,OAAO,KAAP;IACH;;IACD8R,KAAK,CAACwI,YAAD,CAAL,GAAsBniB,KAAtB;IACA,OAAO,IAAP;EACH;AACJ;AACD;;;AACA,SAAS20D,eAAT,CAAyBh7C,KAAzB,EAAgCwI,YAAhC,EAA8CyyC,IAA9C,EAAoDC,IAApD,EAA0D;EACtD,MAAMC,SAAS,GAAGN,cAAc,CAAC76C,KAAD,EAAQwI,YAAR,EAAsByyC,IAAtB,CAAhC;EACA,OAAOJ,cAAc,CAAC76C,KAAD,EAAQwI,YAAY,GAAG,CAAvB,EAA0B0yC,IAA1B,CAAd,IAAiDC,SAAxD;AACH;AACD;;;AACA,SAASC,eAAT,CAAyBp7C,KAAzB,EAAgCwI,YAAhC,EAA8CyyC,IAA9C,EAAoDC,IAApD,EAA0DG,IAA1D,EAAgE;EAC5D,MAAMF,SAAS,GAAGH,eAAe,CAACh7C,KAAD,EAAQwI,YAAR,EAAsByyC,IAAtB,EAA4BC,IAA5B,CAAjC;EACA,OAAOL,cAAc,CAAC76C,KAAD,EAAQwI,YAAY,GAAG,CAAvB,EAA0B6yC,IAA1B,CAAd,IAAiDF,SAAxD;AACH;AACD;;;AACA,SAASG,eAAT,CAAyBt7C,KAAzB,EAAgCwI,YAAhC,EAA8CyyC,IAA9C,EAAoDC,IAApD,EAA0DG,IAA1D,EAAgEE,IAAhE,EAAsE;EAClE,MAAMJ,SAAS,GAAGH,eAAe,CAACh7C,KAAD,EAAQwI,YAAR,EAAsByyC,IAAtB,EAA4BC,IAA5B,CAAjC;EACA,OAAOF,eAAe,CAACh7C,KAAD,EAAQwI,YAAY,GAAG,CAAvB,EAA0B6yC,IAA1B,EAAgCE,IAAhC,CAAf,IAAwDJ,SAA/D;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASK,WAAT,CAAqBh3D,IAArB,EAA2B6B,KAA3B,EAAkC45B,SAAlC,EAA6C/b,SAA7C,EAAwD;EACpD,MAAMlE,KAAK,GAAGmH,QAAQ,EAAtB;EACA,MAAMqB,YAAY,GAAGE,gBAAgB,EAArC;;EACA,IAAImyC,cAAc,CAAC76C,KAAD,EAAQwI,YAAR,EAAsBniB,KAAtB,CAAlB,EAAgD;IAC5C,MAAM6L,KAAK,GAAGkV,QAAQ,EAAtB;IACA,MAAMnV,KAAK,GAAGiZ,gBAAgB,EAA9B;IACAqmC,wBAAwB,CAACt/C,KAAD,EAAQ+N,KAAR,EAAexb,IAAf,EAAqB6B,KAArB,EAA4B45B,SAA5B,EAAuC/b,SAAvC,CAAxB;IACA9f,SAAS,IAAIkvD,4BAA4B,CAACphD,KAAK,CAAC+I,IAAP,EAAahJ,KAAb,EAAoB,UAAUzN,IAA9B,EAAoCgkB,YAApC,CAAzC;EACH;;EACD,OAAOgzC,WAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,cAAT,CAAwBz7C,KAAxB,EAA+B/R,MAA/B,EAAuC;EACnC7J,SAAS,IAAI6E,cAAc,CAAC,CAAD,EAAIgF,MAAM,CAACxM,MAAX,EAAmB,+BAAnB,CAA3B;EACA2C,SAAS,IAAIwE,WAAW,CAACqF,MAAM,CAACxM,MAAP,GAAgB,CAAjB,EAAoB,CAApB,EAAuB,qCAAvB,CAAxB;EACA,IAAIi6D,gBAAgB,GAAG,KAAvB;EACA,IAAIlzC,YAAY,GAAGD,eAAe,EAAlC;;EACA,KAAK,IAAIte,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGgE,MAAM,CAACxM,MAA3B,EAAmCwI,CAAC,IAAI,CAAxC,EAA2C;IACvC;IACAyxD,gBAAgB,GAAGb,cAAc,CAAC76C,KAAD,EAAQwI,YAAY,EAApB,EAAwBva,MAAM,CAAChE,CAAD,CAA9B,CAAd,IAAoDyxD,gBAAvE;EACH;;EACDjzC,eAAe,CAACD,YAAD,CAAf;;EACA,IAAI,CAACkzC,gBAAL,EAAuB;IACnB,OAAO1oB,SAAP;EACH,CAZkC,CAanC;;;EACA,IAAI3S,OAAO,GAAGpyB,MAAM,CAAC,CAAD,CAApB;;EACA,KAAK,IAAIhE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGgE,MAAM,CAACxM,MAA3B,EAAmCwI,CAAC,IAAI,CAAxC,EAA2C;IACvCo2B,OAAO,IAAIlsB,eAAe,CAAClG,MAAM,CAAChE,CAAD,CAAP,CAAf,GAA6BgE,MAAM,CAAChE,CAAC,GAAG,CAAL,CAA9C;EACH;;EACD,OAAOo2B,OAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASs7B,cAAT,CAAwB37C,KAAxB,EAA+BwmB,MAA/B,EAAuCo1B,EAAvC,EAA2CC,MAA3C,EAAmD;EAC/C,MAAMV,SAAS,GAAGN,cAAc,CAAC76C,KAAD,EAAQ0I,gBAAgB,EAAxB,EAA4BkzC,EAA5B,CAAhC;EACA,OAAOT,SAAS,GAAG30B,MAAM,GAAGryB,eAAe,CAACynD,EAAD,CAAxB,GAA+BC,MAAlC,GAA2C7oB,SAA3D;AACH;AACD;AACA;AACA;;;AACA,SAAS8oB,cAAT,CAAwB97C,KAAxB,EAA+BwmB,MAA/B,EAAuCo1B,EAAvC,EAA2CG,EAA3C,EAA+CC,EAA/C,EAAmDH,MAAnD,EAA2D;EACvD,MAAMrzC,YAAY,GAAGD,eAAe,EAApC;EACA,MAAM4yC,SAAS,GAAGH,eAAe,CAACh7C,KAAD,EAAQwI,YAAR,EAAsBozC,EAAtB,EAA0BI,EAA1B,CAAjC;EACArzC,qBAAqB,CAAC,CAAD,CAArB;EACA,OAAOwyC,SAAS,GAAG30B,MAAM,GAAGryB,eAAe,CAACynD,EAAD,CAAxB,GAA+BG,EAA/B,GAAoC5nD,eAAe,CAAC6nD,EAAD,CAAnD,GAA0DH,MAA7D,GAAsE7oB,SAAtF;AACH;AACD;AACA;AACA;;;AACA,SAASipB,cAAT,CAAwBj8C,KAAxB,EAA+BwmB,MAA/B,EAAuCo1B,EAAvC,EAA2CG,EAA3C,EAA+CC,EAA/C,EAAmDE,EAAnD,EAAuDC,EAAvD,EAA2DN,MAA3D,EAAmE;EAC/D,MAAMrzC,YAAY,GAAGD,eAAe,EAApC;EACA,MAAM4yC,SAAS,GAAGC,eAAe,CAACp7C,KAAD,EAAQwI,YAAR,EAAsBozC,EAAtB,EAA0BI,EAA1B,EAA8BG,EAA9B,CAAjC;EACAxzC,qBAAqB,CAAC,CAAD,CAArB;EACA,OAAOwyC,SAAS,GACZ30B,MAAM,GAAGryB,eAAe,CAACynD,EAAD,CAAxB,GAA+BG,EAA/B,GAAoC5nD,eAAe,CAAC6nD,EAAD,CAAnD,GAA0DE,EAA1D,GAA+D/nD,eAAe,CAACgoD,EAAD,CAA9E,GAAqFN,MADzE,GAEZ7oB,SAFJ;AAGH;AACD;AACA;AACA;;;AACA,SAASopB,cAAT,CAAwBp8C,KAAxB,EAA+BwmB,MAA/B,EAAuCo1B,EAAvC,EAA2CG,EAA3C,EAA+CC,EAA/C,EAAmDE,EAAnD,EAAuDC,EAAvD,EAA2DE,EAA3D,EAA+DC,EAA/D,EAAmET,MAAnE,EAA2E;EACvE,MAAMrzC,YAAY,GAAGD,eAAe,EAApC;EACA,MAAM4yC,SAAS,GAAGG,eAAe,CAACt7C,KAAD,EAAQwI,YAAR,EAAsBozC,EAAtB,EAA0BI,EAA1B,EAA8BG,EAA9B,EAAkCG,EAAlC,CAAjC;EACA3zC,qBAAqB,CAAC,CAAD,CAArB;EACA,OAAOwyC,SAAS,GAAG30B,MAAM,GAAGryB,eAAe,CAACynD,EAAD,CAAxB,GAA+BG,EAA/B,GAAoC5nD,eAAe,CAAC6nD,EAAD,CAAnD,GAA0DE,EAA1D,GACf/nD,eAAe,CAACgoD,EAAD,CADA,GACOE,EADP,GACYloD,eAAe,CAACmoD,EAAD,CAD3B,GACkCT,MADrC,GAEZ7oB,SAFJ;AAGH;AACD;AACA;AACA;;;AACA,SAASupB,cAAT,CAAwBv8C,KAAxB,EAA+BwmB,MAA/B,EAAuCo1B,EAAvC,EAA2CG,EAA3C,EAA+CC,EAA/C,EAAmDE,EAAnD,EAAuDC,EAAvD,EAA2DE,EAA3D,EAA+DC,EAA/D,EAAmEE,EAAnE,EAAuEC,EAAvE,EAA2EZ,MAA3E,EAAmF;EAC/E,MAAMrzC,YAAY,GAAGD,eAAe,EAApC;EACA,IAAI4yC,SAAS,GAAGG,eAAe,CAACt7C,KAAD,EAAQwI,YAAR,EAAsBozC,EAAtB,EAA0BI,EAA1B,EAA8BG,EAA9B,EAAkCG,EAAlC,CAA/B;EACAnB,SAAS,GAAGN,cAAc,CAAC76C,KAAD,EAAQwI,YAAY,GAAG,CAAvB,EAA0Bi0C,EAA1B,CAAd,IAA+CtB,SAA3D;EACAxyC,qBAAqB,CAAC,CAAD,CAArB;EACA,OAAOwyC,SAAS,GAAG30B,MAAM,GAAGryB,eAAe,CAACynD,EAAD,CAAxB,GAA+BG,EAA/B,GAAoC5nD,eAAe,CAAC6nD,EAAD,CAAnD,GAA0DE,EAA1D,GACf/nD,eAAe,CAACgoD,EAAD,CADA,GACOE,EADP,GACYloD,eAAe,CAACmoD,EAAD,CAD3B,GACkCE,EADlC,GACuCroD,eAAe,CAACsoD,EAAD,CADtD,GAC6DZ,MADhE,GAEZ7oB,SAFJ;AAGH;AACD;AACA;AACA;;;AACA,SAAS0pB,cAAT,CAAwB18C,KAAxB,EAA+BwmB,MAA/B,EAAuCo1B,EAAvC,EAA2CG,EAA3C,EAA+CC,EAA/C,EAAmDE,EAAnD,EAAuDC,EAAvD,EAA2DE,EAA3D,EAA+DC,EAA/D,EAAmEE,EAAnE,EAAuEC,EAAvE,EAA2EE,EAA3E,EAA+EC,EAA/E,EAAmFf,MAAnF,EAA2F;EACvF,MAAMrzC,YAAY,GAAGD,eAAe,EAApC;EACA,IAAI4yC,SAAS,GAAGG,eAAe,CAACt7C,KAAD,EAAQwI,YAAR,EAAsBozC,EAAtB,EAA0BI,EAA1B,EAA8BG,EAA9B,EAAkCG,EAAlC,CAA/B;EACAnB,SAAS,GAAGH,eAAe,CAACh7C,KAAD,EAAQwI,YAAY,GAAG,CAAvB,EAA0Bi0C,EAA1B,EAA8BG,EAA9B,CAAf,IAAoDzB,SAAhE;EACAxyC,qBAAqB,CAAC,CAAD,CAArB;EACA,OAAOwyC,SAAS,GACZ30B,MAAM,GAAGryB,eAAe,CAACynD,EAAD,CAAxB,GAA+BG,EAA/B,GAAoC5nD,eAAe,CAAC6nD,EAAD,CAAnD,GAA0DE,EAA1D,GAA+D/nD,eAAe,CAACgoD,EAAD,CAA9E,GAAqFE,EAArF,GACIloD,eAAe,CAACmoD,EAAD,CADnB,GAC0BE,EAD1B,GAC+BroD,eAAe,CAACsoD,EAAD,CAD9C,GACqDE,EADrD,GAC0DxoD,eAAe,CAACyoD,EAAD,CADzE,GACgFf,MAFpE,GAGZ7oB,SAHJ;AAIH;AACD;AACA;AACA;;;AACA,SAAS6pB,cAAT,CAAwB78C,KAAxB,EAA+BwmB,MAA/B,EAAuCo1B,EAAvC,EAA2CG,EAA3C,EAA+CC,EAA/C,EAAmDE,EAAnD,EAAuDC,EAAvD,EAA2DE,EAA3D,EAA+DC,EAA/D,EAAmEE,EAAnE,EAAuEC,EAAvE,EAA2EE,EAA3E,EAA+EC,EAA/E,EAAmFE,EAAnF,EAAuFC,EAAvF,EAA2FlB,MAA3F,EAAmG;EAC/F,MAAMrzC,YAAY,GAAGD,eAAe,EAApC;EACA,IAAI4yC,SAAS,GAAGG,eAAe,CAACt7C,KAAD,EAAQwI,YAAR,EAAsBozC,EAAtB,EAA0BI,EAA1B,EAA8BG,EAA9B,EAAkCG,EAAlC,CAA/B;EACAnB,SAAS,GAAGC,eAAe,CAACp7C,KAAD,EAAQwI,YAAY,GAAG,CAAvB,EAA0Bi0C,EAA1B,EAA8BG,EAA9B,EAAkCG,EAAlC,CAAf,IAAwD5B,SAApE;EACAxyC,qBAAqB,CAAC,CAAD,CAArB;EACA,OAAOwyC,SAAS,GAAG30B,MAAM,GAAGryB,eAAe,CAACynD,EAAD,CAAxB,GAA+BG,EAA/B,GAAoC5nD,eAAe,CAAC6nD,EAAD,CAAnD,GAA0DE,EAA1D,GACf/nD,eAAe,CAACgoD,EAAD,CADA,GACOE,EADP,GACYloD,eAAe,CAACmoD,EAAD,CAD3B,GACkCE,EADlC,GACuCroD,eAAe,CAACsoD,EAAD,CADtD,GAC6DE,EAD7D,GAEfxoD,eAAe,CAACyoD,EAAD,CAFA,GAEOE,EAFP,GAEY3oD,eAAe,CAAC4oD,EAAD,CAF3B,GAEkClB,MAFrC,GAGZ7oB,SAHJ;AAIH;AACD;AACA;AACA;;;AACA,SAASgqB,cAAT,CAAwBh9C,KAAxB,EAA+BwmB,MAA/B,EAAuCo1B,EAAvC,EAA2CG,EAA3C,EAA+CC,EAA/C,EAAmDE,EAAnD,EAAuDC,EAAvD,EAA2DE,EAA3D,EAA+DC,EAA/D,EAAmEE,EAAnE,EAAuEC,EAAvE,EAA2EE,EAA3E,EAA+EC,EAA/E,EAAmFE,EAAnF,EAAuFC,EAAvF,EAA2FE,EAA3F,EAA+FC,EAA/F,EAAmGrB,MAAnG,EAA2G;EACvG,MAAMrzC,YAAY,GAAGD,eAAe,EAApC;EACA,IAAI4yC,SAAS,GAAGG,eAAe,CAACt7C,KAAD,EAAQwI,YAAR,EAAsBozC,EAAtB,EAA0BI,EAA1B,EAA8BG,EAA9B,EAAkCG,EAAlC,CAA/B;EACAnB,SAAS,GAAGG,eAAe,CAACt7C,KAAD,EAAQwI,YAAY,GAAG,CAAvB,EAA0Bi0C,EAA1B,EAA8BG,EAA9B,EAAkCG,EAAlC,EAAsCG,EAAtC,CAAf,IAA4D/B,SAAxE;EACAxyC,qBAAqB,CAAC,CAAD,CAArB;EACA,OAAOwyC,SAAS,GAAG30B,MAAM,GAAGryB,eAAe,CAACynD,EAAD,CAAxB,GAA+BG,EAA/B,GAAoC5nD,eAAe,CAAC6nD,EAAD,CAAnD,GAA0DE,EAA1D,GACf/nD,eAAe,CAACgoD,EAAD,CADA,GACOE,EADP,GACYloD,eAAe,CAACmoD,EAAD,CAD3B,GACkCE,EADlC,GACuCroD,eAAe,CAACsoD,EAAD,CADtD,GAC6DE,EAD7D,GAEfxoD,eAAe,CAACyoD,EAAD,CAFA,GAEOE,EAFP,GAEY3oD,eAAe,CAAC4oD,EAAD,CAF3B,GAEkCE,EAFlC,GAEuC9oD,eAAe,CAAC+oD,EAAD,CAFtD,GAE6DrB,MAFhE,GAGZ7oB,SAHJ;AAIH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASmqB,uBAAT,CAAiChuC,QAAjC,EAA2CqX,MAA3C,EAAmDo1B,EAAnD,EAAuDC,MAAvD,EAA+D57B,SAA/D,EAA0E/b,SAA1E,EAAqF;EACjF,MAAMlE,KAAK,GAAGmH,QAAQ,EAAtB;EACA,MAAMi2C,iBAAiB,GAAGzB,cAAc,CAAC37C,KAAD,EAAQwmB,MAAR,EAAgBo1B,EAAhB,EAAoBC,MAApB,CAAxC;;EACA,IAAIuB,iBAAiB,KAAKpqB,SAA1B,EAAqC;IACjC,MAAM/gC,KAAK,GAAGiZ,gBAAgB,EAA9B;IACAqmC,wBAAwB,CAACt/C,KAAD,EAAQ+N,KAAR,EAAemP,QAAf,EAAyBiuC,iBAAzB,EAA4Cn9B,SAA5C,EAAuD/b,SAAvD,CAAxB;IACA9f,SAAS,IACLkvD,4BAA4B,CAAClsC,QAAQ,GAAGnM,IAAZ,EAAkBhJ,KAAlB,EAAyB,UAAUkd,QAAnC,EAA6C5G,eAAe,KAAK,CAAjE,EAAoEie,MAApE,EAA4Eq1B,MAA5E,CADhC;EAEH;;EACD,OAAOsB,uBAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,uBAAT,CAAiCluC,QAAjC,EAA2CqX,MAA3C,EAAmDo1B,EAAnD,EAAuDG,EAAvD,EAA2DC,EAA3D,EAA+DH,MAA/D,EAAuE57B,SAAvE,EAAkF/b,SAAlF,EAA6F;EACzF,MAAMlE,KAAK,GAAGmH,QAAQ,EAAtB;EACA,MAAMi2C,iBAAiB,GAAGtB,cAAc,CAAC97C,KAAD,EAAQwmB,MAAR,EAAgBo1B,EAAhB,EAAoBG,EAApB,EAAwBC,EAAxB,EAA4BH,MAA5B,CAAxC;;EACA,IAAIuB,iBAAiB,KAAKpqB,SAA1B,EAAqC;IACjC,MAAM/gC,KAAK,GAAGiZ,gBAAgB,EAA9B;IACAqmC,wBAAwB,CAACt/C,KAAD,EAAQ+N,KAAR,EAAemP,QAAf,EAAyBiuC,iBAAzB,EAA4Cn9B,SAA5C,EAAuD/b,SAAvD,CAAxB;IACA9f,SAAS,IACLkvD,4BAA4B,CAAClsC,QAAQ,GAAGnM,IAAZ,EAAkBhJ,KAAlB,EAAyB,UAAUkd,QAAnC,EAA6C5G,eAAe,KAAK,CAAjE,EAAoEie,MAApE,EAA4Eu1B,EAA5E,EAAgFF,MAAhF,CADhC;EAEH;;EACD,OAAOwB,uBAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,uBAAT,CAAiCnuC,QAAjC,EAA2CqX,MAA3C,EAAmDo1B,EAAnD,EAAuDG,EAAvD,EAA2DC,EAA3D,EAA+DE,EAA/D,EAAmEC,EAAnE,EAAuEN,MAAvE,EAA+E57B,SAA/E,EAA0F/b,SAA1F,EAAqG;EACjG,MAAMlE,KAAK,GAAGmH,QAAQ,EAAtB;EACA,MAAMi2C,iBAAiB,GAAGnB,cAAc,CAACj8C,KAAD,EAAQwmB,MAAR,EAAgBo1B,EAAhB,EAAoBG,EAApB,EAAwBC,EAAxB,EAA4BE,EAA5B,EAAgCC,EAAhC,EAAoCN,MAApC,CAAxC;;EACA,IAAIuB,iBAAiB,KAAKpqB,SAA1B,EAAqC;IACjC,MAAM/gC,KAAK,GAAGiZ,gBAAgB,EAA9B;IACAqmC,wBAAwB,CAACt/C,KAAD,EAAQ+N,KAAR,EAAemP,QAAf,EAAyBiuC,iBAAzB,EAA4Cn9B,SAA5C,EAAuD/b,SAAvD,CAAxB;IACA9f,SAAS,IACLkvD,4BAA4B,CAAClsC,QAAQ,GAAGnM,IAAZ,EAAkBhJ,KAAlB,EAAyB,UAAUkd,QAAnC,EAA6C5G,eAAe,KAAK,CAAjE,EAAoEie,MAApE,EAA4Eu1B,EAA5E,EAAgFG,EAAhF,EAAoFL,MAApF,CADhC;EAEH;;EACD,OAAOyB,uBAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,uBAAT,CAAiCpuC,QAAjC,EAA2CqX,MAA3C,EAAmDo1B,EAAnD,EAAuDG,EAAvD,EAA2DC,EAA3D,EAA+DE,EAA/D,EAAmEC,EAAnE,EAAuEE,EAAvE,EAA2EC,EAA3E,EAA+ET,MAA/E,EAAuF57B,SAAvF,EAAkG/b,SAAlG,EAA6G;EACzG,MAAMlE,KAAK,GAAGmH,QAAQ,EAAtB;EACA,MAAMi2C,iBAAiB,GAAGhB,cAAc,CAACp8C,KAAD,EAAQwmB,MAAR,EAAgBo1B,EAAhB,EAAoBG,EAApB,EAAwBC,EAAxB,EAA4BE,EAA5B,EAAgCC,EAAhC,EAAoCE,EAApC,EAAwCC,EAAxC,EAA4CT,MAA5C,CAAxC;;EACA,IAAIuB,iBAAiB,KAAKpqB,SAA1B,EAAqC;IACjC,MAAM/gC,KAAK,GAAGiZ,gBAAgB,EAA9B;IACAqmC,wBAAwB,CAACt/C,KAAD,EAAQ+N,KAAR,EAAemP,QAAf,EAAyBiuC,iBAAzB,EAA4Cn9B,SAA5C,EAAuD/b,SAAvD,CAAxB;IACA9f,SAAS,IACLkvD,4BAA4B,CAAClsC,QAAQ,GAAGnM,IAAZ,EAAkBhJ,KAAlB,EAAyB,UAAUkd,QAAnC,EAA6C5G,eAAe,KAAK,CAAjE,EAAoEie,MAApE,EAA4Eu1B,EAA5E,EAAgFG,EAAhF,EAAoFG,EAApF,EAAwFR,MAAxF,CADhC;EAEH;;EACD,OAAO0B,uBAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,uBAAT,CAAiCruC,QAAjC,EAA2CqX,MAA3C,EAAmDo1B,EAAnD,EAAuDG,EAAvD,EAA2DC,EAA3D,EAA+DE,EAA/D,EAAmEC,EAAnE,EAAuEE,EAAvE,EAA2EC,EAA3E,EAA+EE,EAA/E,EAAmFC,EAAnF,EAAuFZ,MAAvF,EAA+F57B,SAA/F,EAA0G/b,SAA1G,EAAqH;EACjH,MAAMlE,KAAK,GAAGmH,QAAQ,EAAtB;EACA,MAAMi2C,iBAAiB,GAAGb,cAAc,CAACv8C,KAAD,EAAQwmB,MAAR,EAAgBo1B,EAAhB,EAAoBG,EAApB,EAAwBC,EAAxB,EAA4BE,EAA5B,EAAgCC,EAAhC,EAAoCE,EAApC,EAAwCC,EAAxC,EAA4CE,EAA5C,EAAgDC,EAAhD,EAAoDZ,MAApD,CAAxC;;EACA,IAAIuB,iBAAiB,KAAKpqB,SAA1B,EAAqC;IACjC,MAAM/gC,KAAK,GAAGiZ,gBAAgB,EAA9B;IACAqmC,wBAAwB,CAACt/C,KAAD,EAAQ+N,KAAR,EAAemP,QAAf,EAAyBiuC,iBAAzB,EAA4Cn9B,SAA5C,EAAuD/b,SAAvD,CAAxB;IACA9f,SAAS,IACLkvD,4BAA4B,CAAClsC,QAAQ,GAAGnM,IAAZ,EAAkBhJ,KAAlB,EAAyB,UAAUkd,QAAnC,EAA6C5G,eAAe,KAAK,CAAjE,EAAoEie,MAApE,EAA4Eu1B,EAA5E,EAAgFG,EAAhF,EAAoFG,EAApF,EAAwFG,EAAxF,EAA4FX,MAA5F,CADhC;EAEH;;EACD,OAAO2B,uBAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,uBAAT,CAAiCtuC,QAAjC,EAA2CqX,MAA3C,EAAmDo1B,EAAnD,EAAuDG,EAAvD,EAA2DC,EAA3D,EAA+DE,EAA/D,EAAmEC,EAAnE,EAAuEE,EAAvE,EAA2EC,EAA3E,EAA+EE,EAA/E,EAAmFC,EAAnF,EAAuFE,EAAvF,EAA2FC,EAA3F,EAA+Ff,MAA/F,EAAuG57B,SAAvG,EAAkH/b,SAAlH,EAA6H;EACzH,MAAMlE,KAAK,GAAGmH,QAAQ,EAAtB;EACA,MAAMi2C,iBAAiB,GAAGV,cAAc,CAAC18C,KAAD,EAAQwmB,MAAR,EAAgBo1B,EAAhB,EAAoBG,EAApB,EAAwBC,EAAxB,EAA4BE,EAA5B,EAAgCC,EAAhC,EAAoCE,EAApC,EAAwCC,EAAxC,EAA4CE,EAA5C,EAAgDC,EAAhD,EAAoDE,EAApD,EAAwDC,EAAxD,EAA4Df,MAA5D,CAAxC;;EACA,IAAIuB,iBAAiB,KAAKpqB,SAA1B,EAAqC;IACjC,MAAM/gC,KAAK,GAAGiZ,gBAAgB,EAA9B;IACAqmC,wBAAwB,CAACt/C,KAAD,EAAQ+N,KAAR,EAAemP,QAAf,EAAyBiuC,iBAAzB,EAA4Cn9B,SAA5C,EAAuD/b,SAAvD,CAAxB;IACA9f,SAAS,IACLkvD,4BAA4B,CAAClsC,QAAQ,GAAGnM,IAAZ,EAAkBhJ,KAAlB,EAAyB,UAAUkd,QAAnC,EAA6C5G,eAAe,KAAK,CAAjE,EAAoEie,MAApE,EAA4Eu1B,EAA5E,EAAgFG,EAAhF,EAAoFG,EAApF,EAAwFG,EAAxF,EAA4FG,EAA5F,EAAgGd,MAAhG,CADhC;EAEH;;EACD,OAAO4B,uBAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,uBAAT,CAAiCvuC,QAAjC,EAA2CqX,MAA3C,EAAmDo1B,EAAnD,EAAuDG,EAAvD,EAA2DC,EAA3D,EAA+DE,EAA/D,EAAmEC,EAAnE,EAAuEE,EAAvE,EAA2EC,EAA3E,EAA+EE,EAA/E,EAAmFC,EAAnF,EAAuFE,EAAvF,EAA2FC,EAA3F,EAA+FE,EAA/F,EAAmGC,EAAnG,EAAuGlB,MAAvG,EAA+G57B,SAA/G,EAA0H/b,SAA1H,EAAqI;EACjI,MAAMlE,KAAK,GAAGmH,QAAQ,EAAtB;EACA,MAAMi2C,iBAAiB,GAAGP,cAAc,CAAC78C,KAAD,EAAQwmB,MAAR,EAAgBo1B,EAAhB,EAAoBG,EAApB,EAAwBC,EAAxB,EAA4BE,EAA5B,EAAgCC,EAAhC,EAAoCE,EAApC,EAAwCC,EAAxC,EAA4CE,EAA5C,EAAgDC,EAAhD,EAAoDE,EAApD,EAAwDC,EAAxD,EAA4DE,EAA5D,EAAgEC,EAAhE,EAAoElB,MAApE,CAAxC;;EACA,IAAIuB,iBAAiB,KAAKpqB,SAA1B,EAAqC;IACjC,MAAM/gC,KAAK,GAAGiZ,gBAAgB,EAA9B;IACAqmC,wBAAwB,CAACt/C,KAAD,EAAQ+N,KAAR,EAAemP,QAAf,EAAyBiuC,iBAAzB,EAA4Cn9B,SAA5C,EAAuD/b,SAAvD,CAAxB;IACA9f,SAAS,IACLkvD,4BAA4B,CAAClsC,QAAQ,GAAGnM,IAAZ,EAAkBhJ,KAAlB,EAAyB,UAAUkd,QAAnC,EAA6C5G,eAAe,KAAK,CAAjE,EAAoEie,MAApE,EAA4Eu1B,EAA5E,EAAgFG,EAAhF,EAAoFG,EAApF,EAAwFG,EAAxF,EAA4FG,EAA5F,EAAgGG,EAAhG,EAAoGjB,MAApG,CADhC;EAEH;;EACD,OAAO6B,uBAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,uBAAT,CAAiCxuC,QAAjC,EAA2CqX,MAA3C,EAAmDo1B,EAAnD,EAAuDG,EAAvD,EAA2DC,EAA3D,EAA+DE,EAA/D,EAAmEC,EAAnE,EAAuEE,EAAvE,EAA2EC,EAA3E,EAA+EE,EAA/E,EAAmFC,EAAnF,EAAuFE,EAAvF,EAA2FC,EAA3F,EAA+FE,EAA/F,EAAmGC,EAAnG,EAAuGE,EAAvG,EAA2GC,EAA3G,EAA+GrB,MAA/G,EAAuH57B,SAAvH,EAAkI/b,SAAlI,EAA6I;EACzI,MAAMlE,KAAK,GAAGmH,QAAQ,EAAtB;EACA,MAAMi2C,iBAAiB,GAAGJ,cAAc,CAACh9C,KAAD,EAAQwmB,MAAR,EAAgBo1B,EAAhB,EAAoBG,EAApB,EAAwBC,EAAxB,EAA4BE,EAA5B,EAAgCC,EAAhC,EAAoCE,EAApC,EAAwCC,EAAxC,EAA4CE,EAA5C,EAAgDC,EAAhD,EAAoDE,EAApD,EAAwDC,EAAxD,EAA4DE,EAA5D,EAAgEC,EAAhE,EAAoEE,EAApE,EAAwEC,EAAxE,EAA4ErB,MAA5E,CAAxC;;EACA,IAAIuB,iBAAiB,KAAKpqB,SAA1B,EAAqC;IACjC,MAAM/gC,KAAK,GAAGiZ,gBAAgB,EAA9B;IACAqmC,wBAAwB,CAACt/C,KAAD,EAAQ+N,KAAR,EAAemP,QAAf,EAAyBiuC,iBAAzB,EAA4Cn9B,SAA5C,EAAuD/b,SAAvD,CAAxB;IACA9f,SAAS,IACLkvD,4BAA4B,CAAClsC,QAAQ,GAAGnM,IAAZ,EAAkBhJ,KAAlB,EAAyB,UAAUkd,QAAnC,EAA6C5G,eAAe,KAAK,CAAjE,EAAoEie,MAApE,EAA4Eu1B,EAA5E,EAAgFG,EAAhF,EAAoFG,EAApF,EAAwFG,EAAxF,EAA4FG,EAA5F,EAAgGG,EAAhG,EAAoGG,EAApG,EAAwGpB,MAAxG,CADhC;EAEH;;EACD,OAAO8B,uBAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,uBAAT,CAAiCzuC,QAAjC,EAA2ClhB,MAA3C,EAAmDgyB,SAAnD,EAA8D/b,SAA9D,EAAyE;EACrE,MAAMlE,KAAK,GAAGmH,QAAQ,EAAtB;EACA,MAAM02C,YAAY,GAAGpC,cAAc,CAACz7C,KAAD,EAAQ/R,MAAR,CAAnC;;EACA,IAAI4vD,YAAY,KAAK7qB,SAArB,EAAgC;IAC5B,MAAM/gC,KAAK,GAAGiZ,gBAAgB,EAA9B;IACAqmC,wBAAwB,CAACt/C,KAAD,EAAQ+N,KAAR,EAAemP,QAAf,EAAyB0uC,YAAzB,EAAuC59B,SAAvC,EAAkD/b,SAAlD,CAAxB;;IACA,IAAI9f,SAAJ,EAAe;MACX,MAAM05D,sBAAsB,GAAG,CAAC7vD,MAAM,CAAC,CAAD,CAAP,CAA/B,CADW,CACiC;;MAC5C,KAAK,IAAIhE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGgE,MAAM,CAACxM,MAA3B,EAAmCwI,CAAC,IAAI,CAAxC,EAA2C;QACvC6zD,sBAAsB,CAAC18D,IAAvB,CAA4B6M,MAAM,CAAChE,CAAD,CAAlC;MACH;;MACDqpD,4BAA4B,CAAClsC,QAAQ,GAAGnM,IAAZ,EAAkBhJ,KAAlB,EAAyB,UAAUkd,QAAnC,EAA6C5G,eAAe,KAAKu1C,sBAAsB,CAACr8D,MAA3C,GAAoD,CAAjG,EAAoG,GAAGq8D,sBAAvG,CAA5B;IACH;EACJ;;EACD,OAAOF,uBAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASG,uBAAT,CAAiCp8D,KAAjC,EAAwCuQ,KAAxC,EAA+C8N,KAA/C,EAAsDyrC,UAAtD,EAAkE7xC,KAAlE,EAAyEC,IAAzE,EAA+EklB,OAA/E,EAAwFi/B,UAAxF,EAAoGC,cAApG,EAAoH;EAChH75D,SAAS,IAAI6c,qBAAqB,CAAC/O,KAAD,CAAlC;EACA9N,SAAS,IAAIA,SAAS,CAAC4N,eAAV,EAAb;EACA,MAAMksD,WAAW,GAAGhsD,KAAK,CAAC4H,MAA1B,CAHgH,CAIhH;;EACA,MAAM7H,KAAK,GAAG+4C,gBAAgB,CAAC94C,KAAD,EAAQvQ,KAAR,EAAe;EAAE;EAAjB,EAA4Co9B,OAAO,IAAI,IAAvD,EAA6D/Y,WAAW,CAACk4C,WAAD,EAAcF,UAAd,CAAxE,CAA9B;EACAnO,iBAAiB,CAAC39C,KAAD,EAAQ8N,KAAR,EAAe/N,KAAf,EAAsB+T,WAAW,CAACk4C,WAAD,EAAcD,cAAd,CAAjC,CAAjB;EACAjyC,sBAAsB,CAAC9Z,KAAD,EAAQD,KAAR,CAAtB;EACA,MAAMggD,aAAa,GAAGhgD,KAAK,CAAC4yC,MAAN,GAAekI,WAAW,CAAC;EAAE;EAAH,EAA6B96C,KAA7B,EAAoCw5C,UAApC,EAAgD7xC,KAAhD,EAAuDC,IAAvD,EAA6D3H,KAAK,CAAC6xC,iBAAnE,EAAsF7xC,KAAK,CAAC8xC,YAA5F,EAA0G,IAA1G,EAAgH9xC,KAAK,CAACoJ,OAAtH,EAA+H4iD,WAA/H,CAAhD;;EACA,IAAIhsD,KAAK,CAACyxC,OAAN,KAAkB,IAAtB,EAA4B;IACxBzxC,KAAK,CAACyxC,OAAN,CAActiD,QAAd,CAAuB6Q,KAAvB,EAA8BD,KAA9B;IACAggD,aAAa,CAACtO,OAAd,GAAwBzxC,KAAK,CAACyxC,OAAN,CAAcsO,aAAd,CAA4BhgD,KAA5B,CAAxB;EACH;;EACD,OAAOA,KAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASksD,UAAT,CAAoBx8D,KAApB,EAA2B8pD,UAA3B,EAAuC7xC,KAAvC,EAA8CC,IAA9C,EAAoDklB,OAApD,EAA6Di/B,UAA7D,EAAyEC,cAAzE,EAAyFpR,iBAAzF,EAA4G;EACxG,MAAM7sC,KAAK,GAAGmH,QAAQ,EAAtB;EACA,MAAMjV,KAAK,GAAGkV,QAAQ,EAAtB;EACA,MAAMg3C,aAAa,GAAGz8D,KAAK,GAAG0d,aAA9B;EACA,MAAMpN,KAAK,GAAGC,KAAK,CAACF,eAAN,GAAwB+rD,uBAAuB,CAACK,aAAD,EAAgBlsD,KAAhB,EAAuB8N,KAAvB,EAA8ByrC,UAA9B,EAA0C7xC,KAA1C,EAAiDC,IAAjD,EAAuDklB,OAAvD,EAAgEi/B,UAAhE,EAA4EC,cAA5E,CAA/C,GACV/rD,KAAK,CAAC+I,IAAN,CAAWmjD,aAAX,CADJ;EAEAv2C,eAAe,CAAC5V,KAAD,EAAQ,KAAR,CAAf;EACA,MAAMosD,OAAO,GAAGr+C,KAAK,CAACtB,QAAD,CAAL,CAAgByqB,aAAhB,CAA8B/kC,SAAS,GAAG,WAAH,GAAiB,EAAxD,CAAhB;EACAu3B,WAAW,CAACzpB,KAAD,EAAQ8N,KAAR,EAAeq+C,OAAf,EAAwBpsD,KAAxB,CAAX;EACAmyB,eAAe,CAACi6B,OAAD,EAAUr+C,KAAV,CAAf;EACAsxC,aAAa,CAACtxC,KAAD,EAAQA,KAAK,CAACo+C,aAAD,CAAL,GAAuBtM,gBAAgB,CAACuM,OAAD,EAAUr+C,KAAV,EAAiBq+C,OAAjB,EAA0BpsD,KAA1B,CAA/C,CAAb;;EACA,IAAI2N,eAAe,CAAC3N,KAAD,CAAnB,EAA4B;IACxBu6C,yBAAyB,CAACt6C,KAAD,EAAQ8N,KAAR,EAAe/N,KAAf,CAAzB;EACH;;EACD,IAAIgsD,cAAc,IAAI,IAAtB,EAA4B;IACxBtR,wBAAwB,CAAC3sC,KAAD,EAAQ/N,KAAR,EAAe46C,iBAAf,CAAxB;EACH;AACJ;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;;AACA,SAAStpC,KAAT,CAAerR,KAAf,EAAsB8N,KAAtB,EAA6Bre,KAA7B,EAAoC0E,KAApC,EAA2C;EACvC;EACA;EACA,IAAI1E,KAAK,IAAIuQ,KAAK,CAAC+I,IAAN,CAAWxZ,MAAxB,EAAgC;IAC5ByQ,KAAK,CAAC+I,IAAN,CAAWtZ,KAAX,IAAoB,IAApB;IACAuQ,KAAK,CAAC0f,SAAN,CAAgBjwB,KAAhB,IAAyB,IAAzB;EACH;;EACDqe,KAAK,CAACre,KAAD,CAAL,GAAe0E,KAAf;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASi4D,WAAT,CAAqB38D,KAArB,EAA4B;EACxB,MAAM4lB,YAAY,GAAGU,eAAe,EAApC;EACA,OAAO1C,IAAI,CAACgC,YAAD,EAAelI,aAAa,GAAG1d,KAA/B,CAAX;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS48D,UAAT,CAAoBrwD,QAApB,EAA8B7H,KAA9B,EAAqC45B,SAArC,EAAgD;EAC5C,MAAMjgB,KAAK,GAAGmH,QAAQ,EAAtB;EACA,MAAMqB,YAAY,GAAGE,gBAAgB,EAArC;;EACA,IAAImyC,cAAc,CAAC76C,KAAD,EAAQwI,YAAR,EAAsBniB,KAAtB,CAAlB,EAAgD;IAC5C,MAAM6L,KAAK,GAAGkV,QAAQ,EAAtB;IACA,MAAMnV,KAAK,GAAGiZ,gBAAgB,EAA9B;IACA6jC,uBAAuB,CAAC78C,KAAD,EAAQD,KAAR,EAAe+N,KAAf,EAAsB9R,QAAtB,EAAgC7H,KAAhC,EAAuC2Z,KAAK,CAACtB,QAAD,CAA5C,EAAwDuhB,SAAxD,EAAmE,KAAnE,CAAvB;IACA77B,SAAS,IAAIkvD,4BAA4B,CAACphD,KAAK,CAAC+I,IAAP,EAAahJ,KAAb,EAAoB/D,QAApB,EAA8Bsa,YAA9B,CAAzC;EACH;;EACD,OAAO+1C,UAAP;AACH;AACD;AACA;AACA;AACA;;;AACA,SAASC,qCAAT,CAA+CtsD,KAA/C,EAAsDD,KAAtD,EAA6D+N,KAA7D,EAAoE3Z,KAApE,EAA2E6oC,YAA3E,EAAyF;EACrF,MAAM90B,MAAM,GAAGnI,KAAK,CAACmI,MAArB;EACA,MAAMqkD,QAAQ,GAAGvvB,YAAY,GAAG,OAAH,GAAa,OAA1C,CAFqF,CAGrF;;EACAigB,oBAAoB,CAACj9C,KAAD,EAAQ8N,KAAR,EAAe5F,MAAM,CAACqkD,QAAD,CAArB,EAAiCA,QAAjC,EAA2Cp4D,KAA3C,CAApB;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASq4D,2BAAT,CAAqC/8D,KAArC,EAA4CuQ,KAA5C,EAAmD8N,KAAnD,EAA0D+O,MAA1D,EAAkEvqB,IAAlE,EAAwEw5D,UAAxE,EAAoFC,cAApF,EAAoG;EAChG75D,SAAS,IAAI6c,qBAAqB,CAAC/O,KAAD,CAAlC;EACA9N,SAAS,IAAIA,SAAS,CAAC4N,eAAV,EAAb;EACA,MAAMksD,WAAW,GAAGhsD,KAAK,CAAC4H,MAA1B;EACA,MAAMkV,KAAK,GAAGhJ,WAAW,CAACk4C,WAAD,EAAcF,UAAd,CAAzB;EACA,MAAM/rD,KAAK,GAAG+4C,gBAAgB,CAAC94C,KAAD,EAAQvQ,KAAR,EAAe;EAAE;EAAjB,EAA0C6C,IAA1C,EAAgDwqB,KAAhD,CAA9B;EACA,MAAMsxB,aAAa,GAAGuP,iBAAiB,CAAC39C,KAAD,EAAQ8N,KAAR,EAAe/N,KAAf,EAAsB+T,WAAW,CAACk4C,WAAD,EAAcD,cAAd,CAAjC,CAAvC;;EACA,IAAI75D,SAAJ,EAAe;IACXi8C,sBAAsB,CAACtxB,MAAD,EAAS/O,KAAT,EAAgB/N,KAAK,CAAC5L,KAAtB,EAA6B6L,KAAK,CAACoJ,OAAnC,EAA4CglC,aAA5C,CAAtB;EACH;;EACD,IAAIruC,KAAK,CAAC+c,KAAN,KAAgB,IAApB,EAA0B;IACtBglC,oBAAoB,CAAC/hD,KAAD,EAAQA,KAAK,CAAC+c,KAAd,EAAqB,KAArB,CAApB;EACH;;EACD,IAAI/c,KAAK,CAAC0yC,WAAN,KAAsB,IAA1B,EAAgC;IAC5BqP,oBAAoB,CAAC/hD,KAAD,EAAQA,KAAK,CAAC0yC,WAAd,EAA2B,IAA3B,CAApB;EACH;;EACD,IAAIzyC,KAAK,CAACyxC,OAAN,KAAkB,IAAtB,EAA4B;IACxBzxC,KAAK,CAACyxC,OAAN,CAAcgb,YAAd,CAA2BzsD,KAA3B,EAAkCD,KAAlC;EACH;;EACD,OAAOA,KAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS2sD,cAAT,CAAwBj9D,KAAxB,EAA+B6C,IAA/B,EAAqCw5D,UAArC,EAAiDC,cAAjD,EAAiE;EAC7D,MAAMj+C,KAAK,GAAGmH,QAAQ,EAAtB;EACA,MAAMjV,KAAK,GAAGkV,QAAQ,EAAtB;EACA,MAAMg3C,aAAa,GAAG/+C,aAAa,GAAG1d,KAAtC;EACAyC,SAAS,IACLwE,WAAW,CAAC2f,eAAe,EAAhB,EAAoBrW,KAAK,CAACsP,iBAA1B,EAA6C,gDAA7C,CADf;EAEApd,SAAS,IAAIqF,kBAAkB,CAACuW,KAAD,EAAQo+C,aAAR,CAA/B;EACA,MAAMn/D,QAAQ,GAAG+gB,KAAK,CAACtB,QAAD,CAAtB;EACA,MAAMqQ,MAAM,GAAG/O,KAAK,CAACo+C,aAAD,CAAL,GAAuBh1B,iBAAiB,CAACnqC,QAAD,EAAWuF,IAAX,EAAiB+mB,cAAc,EAA/B,CAAvD;EACA,MAAMtZ,KAAK,GAAGC,KAAK,CAACF,eAAN,GACV0sD,2BAA2B,CAACN,aAAD,EAAgBlsD,KAAhB,EAAuB8N,KAAvB,EAA8B+O,MAA9B,EAAsCvqB,IAAtC,EAA4Cw5D,UAA5C,EAAwDC,cAAxD,CADjB,GAEV/rD,KAAK,CAAC+I,IAAN,CAAWmjD,aAAX,CAFJ;EAGAv2C,eAAe,CAAC5V,KAAD,EAAQ,IAAR,CAAf;EACA,MAAM0yC,WAAW,GAAG1yC,KAAK,CAAC0yC,WAA1B;;EACA,IAAIA,WAAW,KAAK,IAApB,EAA0B;IACtB71B,eAAe,CAAC7vB,QAAD,EAAW8vB,MAAX,EAAmB41B,WAAnB,CAAf;EACH;;EACD,MAAMnyB,OAAO,GAAGvgB,KAAK,CAACugB,OAAtB;;EACA,IAAIA,OAAO,KAAK,IAAhB,EAAsB;IAClByd,gBAAgB,CAAChxC,QAAD,EAAW8vB,MAAX,EAAmByD,OAAnB,CAAhB;EACH;;EACD,MAAMjxB,MAAM,GAAG0Q,KAAK,CAAC1Q,MAArB;;EACA,IAAIA,MAAM,KAAK,IAAf,EAAqB;IACjBwuC,gBAAgB,CAAC9wC,QAAD,EAAW8vB,MAAX,EAAmBxtB,MAAnB,CAAhB;EACH;;EACD,IAAI,CAAC0Q,KAAK,CAACwD,KAAN,GAAc;EAAG;EAAlB,MAAmD;EAAG;EAA1D,EAAuF;IACnF;IACA;IACAkmB,WAAW,CAACzpB,KAAD,EAAQ8N,KAAR,EAAe+O,MAAf,EAAuB9c,KAAvB,CAAX;EACH,CA7B4D,CA8B7D;EACA;EACA;;;EACA,IAAI2U,oBAAoB,OAAO,CAA/B,EAAkC;IAC9Bwd,eAAe,CAACrV,MAAD,EAAS/O,KAAT,CAAf;EACH;;EACD8G,yBAAyB;;EACzB,IAAIlH,eAAe,CAAC3N,KAAD,CAAnB,EAA4B;IACxBu6C,yBAAyB,CAACt6C,KAAD,EAAQ8N,KAAR,EAAe/N,KAAf,CAAzB;IACAs6C,qBAAqB,CAACr6C,KAAD,EAAQD,KAAR,EAAe+N,KAAf,CAArB;EACH;;EACD,IAAIi+C,cAAc,KAAK,IAAvB,EAA6B;IACzBtR,wBAAwB,CAAC3sC,KAAD,EAAQ/N,KAAR,CAAxB;EACH;;EACD,OAAO2sD,cAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,YAAT,GAAwB;EACpB,IAAIn3C,YAAY,GAAGD,eAAe,EAAlC;EACArjB,SAAS,IAAIgF,aAAa,CAACse,YAAD,EAAe,0BAAf,CAA1B;;EACA,IAAII,oBAAoB,EAAxB,EAA4B;IACxBC,0BAA0B;EAC7B,CAFD,MAGK;IACD3jB,SAAS,IAAIuc,eAAe,CAAC8G,eAAe,EAAhB,CAA5B;IACAC,YAAY,GAAGA,YAAY,CAAC9G,MAA5B;IACAiH,eAAe,CAACH,YAAD,EAAe,KAAf,CAAf;EACH;;EACD,MAAMzV,KAAK,GAAGyV,YAAd;EACAtjB,SAAS,IAAIuqB,eAAe,CAAC1c,KAAD,EAAQ;EAAE;EAAV,CAA5B;EACA8U,yBAAyB;EACzB,MAAM7U,KAAK,GAAGkV,QAAQ,EAAtB;;EACA,IAAIlV,KAAK,CAACF,eAAV,EAA2B;IACvBga,sBAAsB,CAAC9Z,KAAD,EAAQwV,YAAR,CAAtB;;IACA,IAAIhI,kBAAkB,CAACgI,YAAD,CAAtB,EAAsC;MAClCxV,KAAK,CAACyxC,OAAN,CAAcmb,UAAd,CAAyBp3C,YAAzB;IACH;EACJ;;EACD,IAAIzV,KAAK,CAAC+yC,kBAAN,IAA4B,IAA5B,IAAoCv2B,aAAa,CAACxc,KAAD,CAArD,EAA8D;IAC1DusD,qCAAqC,CAACtsD,KAAD,EAAQD,KAAR,EAAekV,QAAQ,EAAvB,EAA2BlV,KAAK,CAAC+yC,kBAAjC,EAAqD,IAArD,CAArC;EACH;;EACD,IAAI/yC,KAAK,CAAC6yC,iBAAN,IAA2B,IAA3B,IAAmCp2B,aAAa,CAACzc,KAAD,CAApD,EAA6D;IACzDusD,qCAAqC,CAACtsD,KAAD,EAAQD,KAAR,EAAekV,QAAQ,EAAvB,EAA2BlV,KAAK,CAAC6yC,iBAAjC,EAAoD,KAApD,CAArC;EACH;;EACD,OAAO+Z,YAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,SAAT,CAAmBp9D,KAAnB,EAA0B6C,IAA1B,EAAgCw5D,UAAhC,EAA4CC,cAA5C,EAA4D;EACxDW,cAAc,CAACj9D,KAAD,EAAQ6C,IAAR,EAAcw5D,UAAd,EAA0BC,cAA1B,CAAd;EACAY,YAAY;EACZ,OAAOE,SAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,oCAAT,CAA8Cr9D,KAA9C,EAAqDuQ,KAArD,EAA4D8N,KAA5D,EAAmEg+C,UAAnE,EAA+EC,cAA/E,EAA+F;EAC3F75D,SAAS,IAAIA,SAAS,CAAC4N,eAAV,EAAb;EACA,MAAMksD,WAAW,GAAGhsD,KAAK,CAAC4H,MAA1B;EACA,MAAMkV,KAAK,GAAGhJ,WAAW,CAACk4C,WAAD,EAAcF,UAAd,CAAzB;EACA,MAAM/rD,KAAK,GAAG+4C,gBAAgB,CAAC94C,KAAD,EAAQvQ,KAAR,EAAe;EAAE;EAAjB,EAAmD,cAAnD,EAAmEqtB,KAAnE,CAA9B,CAJ2F,CAK3F;EACA;;EACA,IAAIA,KAAK,KAAK,IAAd,EAAoB;IAChBglC,oBAAoB,CAAC/hD,KAAD,EAAQ+c,KAAR,EAAe,IAAf,CAApB;EACH;;EACD,MAAM8gC,SAAS,GAAG9pC,WAAW,CAACk4C,WAAD,EAAcD,cAAd,CAA7B;EACApO,iBAAiB,CAAC39C,KAAD,EAAQ8N,KAAR,EAAe/N,KAAf,EAAsB69C,SAAtB,CAAjB;;EACA,IAAI59C,KAAK,CAACyxC,OAAN,KAAkB,IAAtB,EAA4B;IACxBzxC,KAAK,CAACyxC,OAAN,CAAcgb,YAAd,CAA2BzsD,KAA3B,EAAkCD,KAAlC;EACH;;EACD,OAAOA,KAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASgtD,uBAAT,CAAiCt9D,KAAjC,EAAwCq8D,UAAxC,EAAoDC,cAApD,EAAoE;EAChE,MAAMj+C,KAAK,GAAGmH,QAAQ,EAAtB;EACA,MAAMjV,KAAK,GAAGkV,QAAQ,EAAtB;EACA,MAAMg3C,aAAa,GAAGz8D,KAAK,GAAG0d,aAA9B;EACAjb,SAAS,IAAIqF,kBAAkB,CAACuW,KAAD,EAAQo+C,aAAR,CAA/B;EACAh6D,SAAS,IACLwE,WAAW,CAAC2f,eAAe,EAAhB,EAAoBrW,KAAK,CAACsP,iBAA1B,EAA6C,0DAA7C,CADf;EAEA,MAAMvP,KAAK,GAAGC,KAAK,CAACF,eAAN,GACVgtD,oCAAoC,CAACZ,aAAD,EAAgBlsD,KAAhB,EAAuB8N,KAAvB,EAA8Bg+C,UAA9B,EAA0CC,cAA1C,CAD1B,GAEV/rD,KAAK,CAAC+I,IAAN,CAAWmjD,aAAX,CAFJ;EAGAv2C,eAAe,CAAC5V,KAAD,EAAQ,IAAR,CAAf;EACA7N,SAAS,IAAIA,SAAS,CAACiP,qBAAV,EAAb;EACA,MAAM0b,MAAM,GAAG/O,KAAK,CAACo+C,aAAD,CAAL,GACXp+C,KAAK,CAACtB,QAAD,CAAL,CAAgByqB,aAAhB,CAA8B/kC,SAAS,GAAG,cAAH,GAAoB,EAA3D,CADJ;EAEAu3B,WAAW,CAACzpB,KAAD,EAAQ8N,KAAR,EAAe+O,MAAf,EAAuB9c,KAAvB,CAAX;EACAmyB,eAAe,CAACrV,MAAD,EAAS/O,KAAT,CAAf;;EACA,IAAIJ,eAAe,CAAC3N,KAAD,CAAnB,EAA4B;IACxBu6C,yBAAyB,CAACt6C,KAAD,EAAQ8N,KAAR,EAAe/N,KAAf,CAAzB;IACAs6C,qBAAqB,CAACr6C,KAAD,EAAQD,KAAR,EAAe+N,KAAf,CAArB;EACH;;EACD,IAAIi+C,cAAc,IAAI,IAAtB,EAA4B;IACxBtR,wBAAwB,CAAC3sC,KAAD,EAAQ/N,KAAR,CAAxB;EACH;;EACD,OAAOgtD,uBAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,qBAAT,GAAiC;EAC7B,IAAIx3C,YAAY,GAAGD,eAAe,EAAlC;EACA,MAAMvV,KAAK,GAAGkV,QAAQ,EAAtB;;EACA,IAAIU,oBAAoB,EAAxB,EAA4B;IACxBC,0BAA0B;EAC7B,CAFD,MAGK;IACD3jB,SAAS,IAAIuc,eAAe,CAAC+G,YAAD,CAA5B;IACAA,YAAY,GAAGA,YAAY,CAAC9G,MAA5B;IACAiH,eAAe,CAACH,YAAD,EAAe,KAAf,CAAf;EACH;;EACDtjB,SAAS,IAAIuqB,eAAe,CAACjH,YAAD,EAAe;EAAE;EAAjB,CAA5B;;EACA,IAAIxV,KAAK,CAACF,eAAV,EAA2B;IACvBga,sBAAsB,CAAC9Z,KAAD,EAAQwV,YAAR,CAAtB;;IACA,IAAIhI,kBAAkB,CAACgI,YAAD,CAAtB,EAAsC;MAClCxV,KAAK,CAACyxC,OAAN,CAAcmb,UAAd,CAAyBp3C,YAAzB;IACH;EACJ;;EACD,OAAOw3C,qBAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,kBAAT,CAA4Bx9D,KAA5B,EAAmCq8D,UAAnC,EAA+CC,cAA/C,EAA+D;EAC3DgB,uBAAuB,CAACt9D,KAAD,EAAQq8D,UAAR,EAAoBC,cAApB,CAAvB;EACAiB,qBAAqB;EACrB,OAAOC,kBAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,gBAAT,GAA4B;EACxB,OAAOj4C,QAAQ,EAAf;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;;AACA,SAASk4C,SAAT,CAAmB3nD,GAAnB,EAAwB;EACpB;EACA;EACA,OAAO,CAAC,CAACA,GAAF,IAAS,OAAOA,GAAG,CAAC9W,IAAX,KAAoB,UAApC;AACH;AACD;AACA;AACA;;;AACA,SAAS0+D,cAAT,CAAwB5nD,GAAxB,EAA6B;EACzB,OAAO,CAAC,CAACA,GAAF,IAAS,OAAOA,GAAG,CAACla,SAAX,KAAyB,UAAzC;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAM+hE,YAAY,GAAGD,cAArB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASE,UAAT,CAAoBC,SAApB,EAA+BC,UAA/B,EAA2C7J,UAA3C,EAAuD8J,mBAAvD,EAA4E;EACxE,MAAM3/C,KAAK,GAAGmH,QAAQ,EAAtB;EACA,MAAMjV,KAAK,GAAGkV,QAAQ,EAAtB;EACA,MAAMnV,KAAK,GAAGwV,eAAe,EAA7B;EACAm4C,gBAAgB,CAAC1tD,KAAD,EAAQ8N,KAAR,EAAeA,KAAK,CAACtB,QAAD,CAApB,EAAgCzM,KAAhC,EAAuCwtD,SAAvC,EAAkDC,UAAlD,EAA8D,CAAC,CAAC7J,UAAhE,EAA4E8J,mBAA5E,CAAhB;EACA,OAAOH,UAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASK,uBAAT,CAAiCJ,SAAjC,EAA4CC,UAA5C,EAAwD;EACpD,MAAMztD,KAAK,GAAGwV,eAAe,EAA7B;EACA,MAAMzH,KAAK,GAAGmH,QAAQ,EAAtB;EACA,MAAMjV,KAAK,GAAGkV,QAAQ,EAAtB;EACA,MAAMysC,UAAU,GAAG1qC,sBAAsB,CAACjX,KAAK,CAAC+I,IAAP,CAAzC;EACA,MAAMhc,QAAQ,GAAG20D,qBAAqB,CAACC,UAAD,EAAa5hD,KAAb,EAAoB+N,KAApB,CAAtC;EACA4/C,gBAAgB,CAAC1tD,KAAD,EAAQ8N,KAAR,EAAe/gB,QAAf,EAAyBgT,KAAzB,EAAgCwtD,SAAhC,EAA2CC,UAA3C,EAAuD,KAAvD,CAAhB;EACA,OAAOG,uBAAP;AACH;AACD;AACA;AACA;AACA;AACA;;;AACA,SAASC,oBAAT,CAA8B5tD,KAA9B,EAAqC8N,KAArC,EAA4Cy/C,SAA5C,EAAuDM,QAAvD,EAAiE;EAC7D,MAAM10B,QAAQ,GAAGn5B,KAAK,CAACo5B,OAAvB;;EACA,IAAID,QAAQ,IAAI,IAAhB,EAAsB;IAClB,KAAK,IAAIphC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGohC,QAAQ,CAAC5pC,MAAT,GAAkB,CAAtC,EAAyCwI,CAAC,IAAI,CAA9C,EAAiD;MAC7C,MAAM+1D,gBAAgB,GAAG30B,QAAQ,CAACphC,CAAD,CAAjC;;MACA,IAAI+1D,gBAAgB,KAAKP,SAArB,IAAkCp0B,QAAQ,CAACphC,CAAC,GAAG,CAAL,CAAR,KAAoB81D,QAA1D,EAAoE;QAChE;QACA;QACA;QACA,MAAMx0B,QAAQ,GAAGvrB,KAAK,CAAC1B,OAAD,CAAtB;QACA,MAAM2hD,qBAAqB,GAAG50B,QAAQ,CAACphC,CAAC,GAAG,CAAL,CAAtC;QACA,OAAOshC,QAAQ,CAAC9pC,MAAT,GAAkBw+D,qBAAlB,GAA0C10B,QAAQ,CAAC00B,qBAAD,CAAlD,GAA4E,IAAnF;MACH,CAT4C,CAU7C;MACA;MACA;MACA;MACA;;;MACA,IAAI,OAAOD,gBAAP,KAA4B,QAAhC,EAA0C;QACtC/1D,CAAC,IAAI,CAAL;MACH;IACJ;EACJ;;EACD,OAAO,IAAP;AACH;;AACD,SAAS21D,gBAAT,CAA0B1tD,KAA1B,EAAiC8N,KAAjC,EAAwC/gB,QAAxC,EAAkDgT,KAAlD,EAAyDwtD,SAAzD,EAAoEC,UAApE,EAAgF7J,UAAhF,EAA4F8J,mBAA5F,EAAiH;EAC7G,MAAMO,oBAAoB,GAAGtgD,eAAe,CAAC3N,KAAD,CAA5C;EACA,MAAMD,eAAe,GAAGE,KAAK,CAACF,eAA9B;EACA,MAAMq5B,QAAQ,GAAGr5B,eAAe,IAAIg8C,uBAAuB,CAAC97C,KAAD,CAA3D;EACA,MAAM0F,OAAO,GAAGoI,KAAK,CAACzB,OAAD,CAArB,CAJ6G,CAK7G;EACA;EACA;;EACA,MAAMgtB,QAAQ,GAAGwiB,uBAAuB,CAAC/tC,KAAD,CAAxC;EACA5b,SAAS,IAAIuqB,eAAe,CAAC1c,KAAD,EAAQ;EAAE;EAAF,EAA6B;EAAG;EAAxC,CAA5B;EACA,IAAIkuD,cAAc,GAAG,IAArB,CAV6G,CAW7G;EACA;EACA;EACA;;EACA,IAAKluD,KAAK,CAAChR,IAAN,GAAa;EAAE;EAAhB,GAA6C0+D,mBAAjD,EAAsE;IAClE,MAAM5wC,MAAM,GAAG3J,gBAAgB,CAACnT,KAAD,EAAQ+N,KAAR,CAA/B;IACA,MAAMlb,MAAM,GAAG66D,mBAAmB,GAAGA,mBAAmB,CAAC5wC,MAAD,CAAtB,GAAiCA,MAAnE;IACA,MAAMqxC,aAAa,GAAG70B,QAAQ,CAAC9pC,MAA/B;IACA,MAAMgqC,iBAAiB,GAAGk0B,mBAAmB,GACxC3qC,MAAD,IAAY2qC,mBAAmB,CAAC36C,WAAW,CAACgQ,MAAM,CAAC/iB,KAAK,CAACtQ,KAAP,CAAP,CAAZ,CADU,GAEzCsQ,KAAK,CAACtQ,KAFV,CAJkE,CAOlE;IACA;;IACA,IAAI8iB,oBAAoB,CAACxlB,QAAD,CAAxB,EAAoC;MAChC;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,IAAIohE,gBAAgB,GAAG,IAAvB,CAXgC,CAYhC;MACA;MACA;MACA;MACA;MACA;;MACA,IAAI,CAACV,mBAAD,IAAwBO,oBAA5B,EAAkD;QAC9CG,gBAAgB,GAAGP,oBAAoB,CAAC5tD,KAAD,EAAQ8N,KAAR,EAAey/C,SAAf,EAA0BxtD,KAAK,CAACtQ,KAAhC,CAAvC;MACH;;MACD,IAAI0+D,gBAAgB,KAAK,IAAzB,EAA+B;QAC3B;QACA;QACA;QACA;QACA,MAAMC,cAAc,GAAGD,gBAAgB,CAACE,oBAAjB,IAAyCF,gBAAhE;QACAC,cAAc,CAACE,oBAAf,GAAsCd,UAAtC;QACAW,gBAAgB,CAACE,oBAAjB,GAAwCb,UAAxC;QACAS,cAAc,GAAG,KAAjB;MACH,CATD,MAUK;QACDT,UAAU,GAAGe,YAAY,CAACxuD,KAAD,EAAQ+N,KAAR,EAAepI,OAAf,EAAwB8nD,UAAxB,EAAoC;QAAM;QAA1C,CAAzB;QACA,MAAM5R,SAAS,GAAG7uD,QAAQ,CAACylB,MAAT,CAAgB5f,MAAhB,EAAwB26D,SAAxB,EAAmCC,UAAnC,CAAlB;QACAt7D,SAAS,IAAIA,SAAS,CAACkO,wBAAV,EAAb;QACAi5B,QAAQ,CAACnqC,IAAT,CAAcs+D,UAAd,EAA0B5R,SAA1B;QACAziB,QAAQ,IAAIA,QAAQ,CAACjqC,IAAT,CAAcq+D,SAAd,EAAyBh0B,iBAAzB,EAA4C20B,aAA5C,EAA2DA,aAAa,GAAG,CAA3E,CAAZ;MACH;IACJ,CAtCD,MAuCK;MACDV,UAAU,GAAGe,YAAY,CAACxuD,KAAD,EAAQ+N,KAAR,EAAepI,OAAf,EAAwB8nD,UAAxB,EAAoC;MAAK;MAAzC,CAAzB;MACA56D,MAAM,CAAC47D,gBAAP,CAAwBjB,SAAxB,EAAmCC,UAAnC,EAA+C7J,UAA/C;MACAzxD,SAAS,IAAIA,SAAS,CAACkO,wBAAV,EAAb;MACAi5B,QAAQ,CAACnqC,IAAT,CAAcs+D,UAAd;MACAr0B,QAAQ,IAAIA,QAAQ,CAACjqC,IAAT,CAAcq+D,SAAd,EAAyBh0B,iBAAzB,EAA4C20B,aAA5C,EAA2DvK,UAA3D,CAAZ;IACH;EACJ,CAvDD,MAwDK;IACD;IACA;IACA6J,UAAU,GAAGe,YAAY,CAACxuD,KAAD,EAAQ+N,KAAR,EAAepI,OAAf,EAAwB8nD,UAAxB,EAAoC;IAAM;IAA1C,CAAzB;EACH,CA3E4G,CA4E7G;;;EACA,MAAMrlD,OAAO,GAAGpI,KAAK,CAACoI,OAAtB;EACA,IAAIxN,KAAJ;;EACA,IAAIszD,cAAc,IAAI9lD,OAAO,KAAK,IAA9B,KAAuCxN,KAAK,GAAGwN,OAAO,CAAColD,SAAD,CAAtD,CAAJ,EAAwE;IACpE,MAAMkB,WAAW,GAAG9zD,KAAK,CAACpL,MAA1B;;IACA,IAAIk/D,WAAJ,EAAiB;MACb,KAAK,IAAI12D,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG02D,WAApB,EAAiC12D,CAAC,IAAI,CAAtC,EAAyC;QACrC,MAAMtI,KAAK,GAAGkL,KAAK,CAAC5C,CAAD,CAAnB;QACA7F,SAAS,IAAIqF,kBAAkB,CAACuW,KAAD,EAAQre,KAAR,CAA/B;QACA,MAAMi/D,YAAY,GAAG/zD,KAAK,CAAC5C,CAAC,GAAG,CAAL,CAA1B;QACA,MAAMi7B,iBAAiB,GAAGllB,KAAK,CAACre,KAAD,CAA/B;QACA,MAAMk/D,MAAM,GAAG37B,iBAAiB,CAAC07B,YAAD,CAAhC;;QACA,IAAIx8D,SAAS,IAAI,CAACm7D,YAAY,CAACsB,MAAD,CAA9B,EAAwC;UACpC,MAAM,IAAIviE,KAAJ,CAAW,WAAUsiE,YAAa,wBAAuB17B,iBAAiB,CAAC/oC,WAAlB,CAA8BqI,IAAK,IAA5F,CAAN;QACH;;QACD,MAAMs8D,YAAY,GAAGD,MAAM,CAACrjE,SAAP,CAAiBkiE,UAAjB,CAArB;QACA,MAAM74B,GAAG,GAAG0E,QAAQ,CAAC9pC,MAArB;QACA8pC,QAAQ,CAACnqC,IAAT,CAAcs+D,UAAd,EAA0BoB,YAA1B;QACAz1B,QAAQ,IAAIA,QAAQ,CAACjqC,IAAT,CAAcq+D,SAAd,EAAyBxtD,KAAK,CAACtQ,KAA/B,EAAsCklC,GAAtC,EAA2C,EAAEA,GAAG,GAAG,CAAR,CAA3C,CAAZ;MACH;IACJ;EACJ;AACJ;;AACD,SAASk6B,gCAAT,CAA0C/gD,KAA1C,EAAiDpI,OAAjD,EAA0D8nD,UAA1D,EAAsEpoD,CAAtE,EAAyE;EACrE,IAAI;IACAoM,QAAQ,CAAC;IAAE;IAAH,EAAoC9L,OAApC,EAA6C8nD,UAA7C,CAAR,CADA,CAEA;;IACA,OAAOA,UAAU,CAACpoD,CAAD,CAAV,KAAkB,KAAzB;EACH,CAJD,CAKA,OAAOtZ,KAAP,EAAc;IACVskC,WAAW,CAACtiB,KAAD,EAAQhiB,KAAR,CAAX;IACA,OAAO,KAAP;EACH,CARD,SASQ;IACJ0lB,QAAQ,CAAC;IAAE;IAAH,EAAkC9L,OAAlC,EAA2C8nD,UAA3C,CAAR;EACH;AACJ;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASe,YAAT,CAAsBxuD,KAAtB,EAA6B+N,KAA7B,EAAoCpI,OAApC,EAA6C8nD,UAA7C,EAAyDsB,sBAAzD,EAAiF;EAC7E;EACA;EACA,OAAO,SAASC,yCAAT,CAAmD3pD,CAAnD,EAAsD;IACzD;IACA;IACA,IAAIA,CAAC,KAAKxP,QAAV,EAAoB;MAChB,OAAO43D,UAAP;IACH,CALwD,CAMzD;IACA;;;IACA,MAAMhvC,SAAS,GAAGze,KAAK,CAACwD,KAAN,GAAc;IAAE;IAAhB,EACdgQ,wBAAwB,CAACxT,KAAK,CAACtQ,KAAP,EAAcqe,KAAd,CADV,GAEdA,KAFJ;IAGAuyC,aAAa,CAAC7hC,SAAD,CAAb;IACA,IAAI5gB,MAAM,GAAGixD,gCAAgC,CAAC/gD,KAAD,EAAQpI,OAAR,EAAiB8nD,UAAjB,EAA6BpoD,CAA7B,CAA7C,CAZyD,CAazD;IACA;;IACA,IAAI4pD,cAAc,GAAGD,yCAAyC,CAACT,oBAA/D;;IACA,OAAOU,cAAP,EAAuB;MACnB;MACApxD,MAAM,GAAGixD,gCAAgC,CAAC/gD,KAAD,EAAQpI,OAAR,EAAiBspD,cAAjB,EAAiC5pD,CAAjC,CAAhC,IAAuExH,MAAhF;MACAoxD,cAAc,GAAGA,cAAc,CAACV,oBAAhC;IACH;;IACD,IAAIQ,sBAAsB,IAAIlxD,MAAM,KAAK,KAAzC,EAAgD;MAC5CwH,CAAC,CAAC6pD,cAAF,GAD4C,CAE5C;;MACA7pD,CAAC,CAAC8pD,WAAF,GAAgB,KAAhB;IACH;;IACD,OAAOtxD,MAAP;EACH,CA3BD;AA4BH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASuxD,aAAT,CAAuBz2C,KAAK,GAAG,CAA/B,EAAkC;EAC9B,OAAOD,eAAe,CAACC,KAAD,CAAtB;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS02C,2BAAT,CAAqCrvD,KAArC,EAA4CsvD,eAA5C,EAA6D;EACzD,IAAIC,sBAAsB,GAAG,IAA7B;EACA,MAAMC,kBAAkB,GAAG1vB,qBAAqB,CAAC9/B,KAAD,CAAhD;;EACA,KAAK,IAAIhI,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGs3D,eAAe,CAAC9/D,MAApC,EAA4CwI,CAAC,EAA7C,EAAiD;IAC7C,MAAM2b,SAAS,GAAG27C,eAAe,CAACt3D,CAAD,CAAjC,CAD6C,CAE7C;IACA;;IACA,IAAI2b,SAAS,KAAK,GAAlB,EAAuB;MACnB47C,sBAAsB,GAAGv3D,CAAzB;MACA;IACH,CAP4C,CAQ7C;IACA;;;IACA,IAAIw3D,kBAAkB,KAAK,IAAvB,GACA3vB,0BAA0B,CAAC7/B,KAAD,EAAQ2T,SAAR;IAAmB;IAAuB,IAA1C,CAD1B,GAEAusB,wBAAwB,CAACsvB,kBAAD,EAAqB77C,SAArB,CAF5B,EAE6D;MACzD,OAAO3b,CAAP,CADyD,CAC/C;IACb;EACJ;;EACD,OAAOu3D,sBAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,eAAT,CAAyBH,eAAzB,EAA0C;EACtC,MAAM3yB,aAAa,GAAGznB,QAAQ,GAAGpI,0BAAH,CAAR,CAAuCV,MAAvC,CAAtB;;EACA,IAAI,CAACuwB,aAAa,CAAC7sB,UAAnB,EAA+B;IAC3B;IACA;IACA,MAAM4/C,kBAAkB,GAAGJ,eAAe,GAAGA,eAAe,CAAC9/D,MAAnB,GAA4B,CAAtE;IACA,MAAMmgE,eAAe,GAAGhzB,aAAa,CAAC7sB,UAAd,GACpB7W,QAAQ,CAACy2D,kBAAD,EAAqB,IAArB,CADZ;IAEA,MAAME,KAAK,GAAGD,eAAe,CAACh3D,KAAhB,EAAd;IACA,IAAIk3D,cAAc,GAAGlzB,aAAa,CAACtkB,KAAnC;;IACA,OAAOw3C,cAAc,KAAK,IAA1B,EAAgC;MAC5B,MAAMC,SAAS,GAAGR,eAAe,GAAGD,2BAA2B,CAACQ,cAAD,EAAiBP,eAAjB,CAA9B,GAAkE,CAAnG;;MACA,IAAIQ,SAAS,KAAK,IAAlB,EAAwB;QACpB,IAAIF,KAAK,CAACE,SAAD,CAAT,EAAsB;UAClBF,KAAK,CAACE,SAAD,CAAL,CAAiBvzB,cAAjB,GAAkCszB,cAAlC;QACH,CAFD,MAGK;UACDF,eAAe,CAACG,SAAD,CAAf,GAA6BD,cAA7B;QACH;;QACDD,KAAK,CAACE,SAAD,CAAL,GAAmBD,cAAnB;MACH;;MACDA,cAAc,GAAGA,cAAc,CAACrkE,IAAhC;IACH;EACJ;AACJ;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASukE,YAAT,CAAsBt8C,SAAtB,EAAiCu8C,aAAa,GAAG,CAAjD,EAAoDjzC,KAApD,EAA2D;EACvD,MAAMhP,KAAK,GAAGmH,QAAQ,EAAtB;EACA,MAAMjV,KAAK,GAAGkV,QAAQ,EAAtB;EACA,MAAMsnB,eAAe,GAAGsc,gBAAgB,CAAC94C,KAAD,EAAQmN,aAAa,GAAGqG,SAAxB,EAAmC;EAAG;EAAtC,EAAkE,IAAlE,EAAwEsJ,KAAK,IAAI,IAAjF,CAAxC,CAHuD,CAIvD;;EACA,IAAI0f,eAAe,CAAC3sB,UAAhB,KAA+B,IAAnC,EACI2sB,eAAe,CAAC3sB,UAAhB,GAA6BkgD,aAA7B,CANmD,CAOvD;;EACAl6C,0BAA0B;;EAC1B,IAAI,CAAC2mB,eAAe,CAACj5B,KAAhB,GAAwB;EAAG;EAA5B,MAA6D;EAAG;EAApE,EAAiG;IAC7F;IACAg5B,eAAe,CAACv8B,KAAD,EAAQ8N,KAAR,EAAe0uB,eAAf,CAAf;EACH;AACJ;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASwzB,qBAAT,CAA+Bh0D,QAA/B,EAAyC0tD,EAAzC,EAA6C37B,SAA7C,EAAwD;EACpDkiC,sBAAsB,CAACj0D,QAAD,EAAW,EAAX,EAAe0tD,EAAf,EAAmB,EAAnB,EAAuB37B,SAAvB,CAAtB;EACA,OAAOiiC,qBAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,sBAAT,CAAgCj0D,QAAhC,EAA0Cs4B,MAA1C,EAAkDo1B,EAAlD,EAAsDC,MAAtD,EAA8D57B,SAA9D,EAAyE;EACrE,MAAMjgB,KAAK,GAAGmH,QAAQ,EAAtB;EACA,MAAMi2C,iBAAiB,GAAGzB,cAAc,CAAC37C,KAAD,EAAQwmB,MAAR,EAAgBo1B,EAAhB,EAAoBC,MAApB,CAAxC;;EACA,IAAIuB,iBAAiB,KAAKpqB,SAA1B,EAAqC;IACjC,MAAM9gC,KAAK,GAAGkV,QAAQ,EAAtB;IACA,MAAMnV,KAAK,GAAGiZ,gBAAgB,EAA9B;IACA6jC,uBAAuB,CAAC78C,KAAD,EAAQD,KAAR,EAAe+N,KAAf,EAAsB9R,QAAtB,EAAgCkvD,iBAAhC,EAAmDp9C,KAAK,CAACtB,QAAD,CAAxD,EAAoEuhB,SAApE,EAA+E,KAA/E,CAAvB;IACA77B,SAAS,IACLkvD,4BAA4B,CAACphD,KAAK,CAAC+I,IAAP,EAAahJ,KAAb,EAAoB/D,QAApB,EAA8Bqa,eAAe,KAAK,CAAlD,EAAqDie,MAArD,EAA6Dq1B,MAA7D,CADhC;EAEH;;EACD,OAAOsG,sBAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,sBAAT,CAAgCl0D,QAAhC,EAA0Cs4B,MAA1C,EAAkDo1B,EAAlD,EAAsDG,EAAtD,EAA0DC,EAA1D,EAA8DH,MAA9D,EAAsE57B,SAAtE,EAAiF;EAC7E,MAAMjgB,KAAK,GAAGmH,QAAQ,EAAtB;EACA,MAAMi2C,iBAAiB,GAAGtB,cAAc,CAAC97C,KAAD,EAAQwmB,MAAR,EAAgBo1B,EAAhB,EAAoBG,EAApB,EAAwBC,EAAxB,EAA4BH,MAA5B,CAAxC;;EACA,IAAIuB,iBAAiB,KAAKpqB,SAA1B,EAAqC;IACjC,MAAM9gC,KAAK,GAAGkV,QAAQ,EAAtB;IACA,MAAMnV,KAAK,GAAGiZ,gBAAgB,EAA9B;IACA6jC,uBAAuB,CAAC78C,KAAD,EAAQD,KAAR,EAAe+N,KAAf,EAAsB9R,QAAtB,EAAgCkvD,iBAAhC,EAAmDp9C,KAAK,CAACtB,QAAD,CAAxD,EAAoEuhB,SAApE,EAA+E,KAA/E,CAAvB;IACA77B,SAAS,IACLkvD,4BAA4B,CAACphD,KAAK,CAAC+I,IAAP,EAAahJ,KAAb,EAAoB/D,QAApB,EAA8Bqa,eAAe,KAAK,CAAlD,EAAqDie,MAArD,EAA6Du1B,EAA7D,EAAiEF,MAAjE,CADhC;EAEH;;EACD,OAAOuG,sBAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,sBAAT,CAAgCn0D,QAAhC,EAA0Cs4B,MAA1C,EAAkDo1B,EAAlD,EAAsDG,EAAtD,EAA0DC,EAA1D,EAA8DE,EAA9D,EAAkEC,EAAlE,EAAsEN,MAAtE,EAA8E57B,SAA9E,EAAyF;EACrF,MAAMjgB,KAAK,GAAGmH,QAAQ,EAAtB;EACA,MAAMi2C,iBAAiB,GAAGnB,cAAc,CAACj8C,KAAD,EAAQwmB,MAAR,EAAgBo1B,EAAhB,EAAoBG,EAApB,EAAwBC,EAAxB,EAA4BE,EAA5B,EAAgCC,EAAhC,EAAoCN,MAApC,CAAxC;;EACA,IAAIuB,iBAAiB,KAAKpqB,SAA1B,EAAqC;IACjC,MAAM9gC,KAAK,GAAGkV,QAAQ,EAAtB;IACA,MAAMnV,KAAK,GAAGiZ,gBAAgB,EAA9B;IACA6jC,uBAAuB,CAAC78C,KAAD,EAAQD,KAAR,EAAe+N,KAAf,EAAsB9R,QAAtB,EAAgCkvD,iBAAhC,EAAmDp9C,KAAK,CAACtB,QAAD,CAAxD,EAAoEuhB,SAApE,EAA+E,KAA/E,CAAvB;IACA77B,SAAS,IACLkvD,4BAA4B,CAACphD,KAAK,CAAC+I,IAAP,EAAahJ,KAAb,EAAoB/D,QAApB,EAA8Bqa,eAAe,KAAK,CAAlD,EAAqDie,MAArD,EAA6Du1B,EAA7D,EAAiEG,EAAjE,EAAqEL,MAArE,CADhC;EAEH;;EACD,OAAOwG,sBAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,sBAAT,CAAgCp0D,QAAhC,EAA0Cs4B,MAA1C,EAAkDo1B,EAAlD,EAAsDG,EAAtD,EAA0DC,EAA1D,EAA8DE,EAA9D,EAAkEC,EAAlE,EAAsEE,EAAtE,EAA0EC,EAA1E,EAA8ET,MAA9E,EAAsF57B,SAAtF,EAAiG;EAC7F,MAAMjgB,KAAK,GAAGmH,QAAQ,EAAtB;EACA,MAAMi2C,iBAAiB,GAAGhB,cAAc,CAACp8C,KAAD,EAAQwmB,MAAR,EAAgBo1B,EAAhB,EAAoBG,EAApB,EAAwBC,EAAxB,EAA4BE,EAA5B,EAAgCC,EAAhC,EAAoCE,EAApC,EAAwCC,EAAxC,EAA4CT,MAA5C,CAAxC;;EACA,IAAIuB,iBAAiB,KAAKpqB,SAA1B,EAAqC;IACjC,MAAM9gC,KAAK,GAAGkV,QAAQ,EAAtB;IACA,MAAMnV,KAAK,GAAGiZ,gBAAgB,EAA9B;IACA6jC,uBAAuB,CAAC78C,KAAD,EAAQD,KAAR,EAAe+N,KAAf,EAAsB9R,QAAtB,EAAgCkvD,iBAAhC,EAAmDp9C,KAAK,CAACtB,QAAD,CAAxD,EAAoEuhB,SAApE,EAA+E,KAA/E,CAAvB;IACA77B,SAAS,IACLkvD,4BAA4B,CAACphD,KAAK,CAAC+I,IAAP,EAAahJ,KAAb,EAAoB/D,QAApB,EAA8Bqa,eAAe,KAAK,CAAlD,EAAqDie,MAArD,EAA6Du1B,EAA7D,EAAiEG,EAAjE,EAAqEG,EAArE,EAAyER,MAAzE,CADhC;EAEH;;EACD,OAAOyG,sBAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,sBAAT,CAAgCr0D,QAAhC,EAA0Cs4B,MAA1C,EAAkDo1B,EAAlD,EAAsDG,EAAtD,EAA0DC,EAA1D,EAA8DE,EAA9D,EAAkEC,EAAlE,EAAsEE,EAAtE,EAA0EC,EAA1E,EAA8EE,EAA9E,EAAkFC,EAAlF,EAAsFZ,MAAtF,EAA8F57B,SAA9F,EAAyG;EACrG,MAAMjgB,KAAK,GAAGmH,QAAQ,EAAtB;EACA,MAAMi2C,iBAAiB,GAAGb,cAAc,CAACv8C,KAAD,EAAQwmB,MAAR,EAAgBo1B,EAAhB,EAAoBG,EAApB,EAAwBC,EAAxB,EAA4BE,EAA5B,EAAgCC,EAAhC,EAAoCE,EAApC,EAAwCC,EAAxC,EAA4CE,EAA5C,EAAgDC,EAAhD,EAAoDZ,MAApD,CAAxC;;EACA,IAAIuB,iBAAiB,KAAKpqB,SAA1B,EAAqC;IACjC,MAAM9gC,KAAK,GAAGkV,QAAQ,EAAtB;IACA,MAAMnV,KAAK,GAAGiZ,gBAAgB,EAA9B;IACA6jC,uBAAuB,CAAC78C,KAAD,EAAQD,KAAR,EAAe+N,KAAf,EAAsB9R,QAAtB,EAAgCkvD,iBAAhC,EAAmDp9C,KAAK,CAACtB,QAAD,CAAxD,EAAoEuhB,SAApE,EAA+E,KAA/E,CAAvB;IACA77B,SAAS,IACLkvD,4BAA4B,CAACphD,KAAK,CAAC+I,IAAP,EAAahJ,KAAb,EAAoB/D,QAApB,EAA8Bqa,eAAe,KAAK,CAAlD,EAAqDie,MAArD,EAA6Du1B,EAA7D,EAAiEG,EAAjE,EAAqEG,EAArE,EAAyEG,EAAzE,EAA6EX,MAA7E,CADhC;EAEH;;EACD,OAAO0G,sBAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,sBAAT,CAAgCt0D,QAAhC,EAA0Cs4B,MAA1C,EAAkDo1B,EAAlD,EAAsDG,EAAtD,EAA0DC,EAA1D,EAA8DE,EAA9D,EAAkEC,EAAlE,EAAsEE,EAAtE,EAA0EC,EAA1E,EAA8EE,EAA9E,EAAkFC,EAAlF,EAAsFE,EAAtF,EAA0FC,EAA1F,EAA8Ff,MAA9F,EAAsG57B,SAAtG,EAAiH;EAC7G,MAAMjgB,KAAK,GAAGmH,QAAQ,EAAtB;EACA,MAAMi2C,iBAAiB,GAAGV,cAAc,CAAC18C,KAAD,EAAQwmB,MAAR,EAAgBo1B,EAAhB,EAAoBG,EAApB,EAAwBC,EAAxB,EAA4BE,EAA5B,EAAgCC,EAAhC,EAAoCE,EAApC,EAAwCC,EAAxC,EAA4CE,EAA5C,EAAgDC,EAAhD,EAAoDE,EAApD,EAAwDC,EAAxD,EAA4Df,MAA5D,CAAxC;;EACA,IAAIuB,iBAAiB,KAAKpqB,SAA1B,EAAqC;IACjC,MAAM9gC,KAAK,GAAGkV,QAAQ,EAAtB;IACA,MAAMnV,KAAK,GAAGiZ,gBAAgB,EAA9B;IACA6jC,uBAAuB,CAAC78C,KAAD,EAAQD,KAAR,EAAe+N,KAAf,EAAsB9R,QAAtB,EAAgCkvD,iBAAhC,EAAmDp9C,KAAK,CAACtB,QAAD,CAAxD,EAAoEuhB,SAApE,EAA+E,KAA/E,CAAvB;IACA77B,SAAS,IACLkvD,4BAA4B,CAACphD,KAAK,CAAC+I,IAAP,EAAahJ,KAAb,EAAoB/D,QAApB,EAA8Bqa,eAAe,KAAK,CAAlD,EAAqDie,MAArD,EAA6Du1B,EAA7D,EAAiEG,EAAjE,EAAqEG,EAArE,EAAyEG,EAAzE,EAA6EG,EAA7E,EAAiFd,MAAjF,CADhC;EAEH;;EACD,OAAO2G,sBAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,sBAAT,CAAgCv0D,QAAhC,EAA0Cs4B,MAA1C,EAAkDo1B,EAAlD,EAAsDG,EAAtD,EAA0DC,EAA1D,EAA8DE,EAA9D,EAAkEC,EAAlE,EAAsEE,EAAtE,EAA0EC,EAA1E,EAA8EE,EAA9E,EAAkFC,EAAlF,EAAsFE,EAAtF,EAA0FC,EAA1F,EAA8FE,EAA9F,EAAkGC,EAAlG,EAAsGlB,MAAtG,EAA8G57B,SAA9G,EAAyH;EACrH,MAAMjgB,KAAK,GAAGmH,QAAQ,EAAtB;EACA,MAAMi2C,iBAAiB,GAAGP,cAAc,CAAC78C,KAAD,EAAQwmB,MAAR,EAAgBo1B,EAAhB,EAAoBG,EAApB,EAAwBC,EAAxB,EAA4BE,EAA5B,EAAgCC,EAAhC,EAAoCE,EAApC,EAAwCC,EAAxC,EAA4CE,EAA5C,EAAgDC,EAAhD,EAAoDE,EAApD,EAAwDC,EAAxD,EAA4DE,EAA5D,EAAgEC,EAAhE,EAAoElB,MAApE,CAAxC;;EACA,IAAIuB,iBAAiB,KAAKpqB,SAA1B,EAAqC;IACjC,MAAM9gC,KAAK,GAAGkV,QAAQ,EAAtB;IACA,MAAMnV,KAAK,GAAGiZ,gBAAgB,EAA9B;IACA6jC,uBAAuB,CAAC78C,KAAD,EAAQD,KAAR,EAAe+N,KAAf,EAAsB9R,QAAtB,EAAgCkvD,iBAAhC,EAAmDp9C,KAAK,CAACtB,QAAD,CAAxD,EAAoEuhB,SAApE,EAA+E,KAA/E,CAAvB;IACA77B,SAAS,IACLkvD,4BAA4B,CAACphD,KAAK,CAAC+I,IAAP,EAAahJ,KAAb,EAAoB/D,QAApB,EAA8Bqa,eAAe,KAAK,CAAlD,EAAqDie,MAArD,EAA6Du1B,EAA7D,EAAiEG,EAAjE,EAAqEG,EAArE,EAAyEG,EAAzE,EAA6EG,EAA7E,EAAiFG,EAAjF,EAAqFjB,MAArF,CADhC;EAEH;;EACD,OAAO4G,sBAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,sBAAT,CAAgCx0D,QAAhC,EAA0Cs4B,MAA1C,EAAkDo1B,EAAlD,EAAsDG,EAAtD,EAA0DC,EAA1D,EAA8DE,EAA9D,EAAkEC,EAAlE,EAAsEE,EAAtE,EAA0EC,EAA1E,EAA8EE,EAA9E,EAAkFC,EAAlF,EAAsFE,EAAtF,EAA0FC,EAA1F,EAA8FE,EAA9F,EAAkGC,EAAlG,EAAsGE,EAAtG,EAA0GC,EAA1G,EAA8GrB,MAA9G,EAAsH57B,SAAtH,EAAiI;EAC7H,MAAMjgB,KAAK,GAAGmH,QAAQ,EAAtB;EACA,MAAMi2C,iBAAiB,GAAGJ,cAAc,CAACh9C,KAAD,EAAQwmB,MAAR,EAAgBo1B,EAAhB,EAAoBG,EAApB,EAAwBC,EAAxB,EAA4BE,EAA5B,EAAgCC,EAAhC,EAAoCE,EAApC,EAAwCC,EAAxC,EAA4CE,EAA5C,EAAgDC,EAAhD,EAAoDE,EAApD,EAAwDC,EAAxD,EAA4DE,EAA5D,EAAgEC,EAAhE,EAAoEE,EAApE,EAAwEC,EAAxE,EAA4ErB,MAA5E,CAAxC;;EACA,IAAIuB,iBAAiB,KAAKpqB,SAA1B,EAAqC;IACjC,MAAM9gC,KAAK,GAAGkV,QAAQ,EAAtB;IACA,MAAMnV,KAAK,GAAGiZ,gBAAgB,EAA9B;IACA6jC,uBAAuB,CAAC78C,KAAD,EAAQD,KAAR,EAAe+N,KAAf,EAAsB9R,QAAtB,EAAgCkvD,iBAAhC,EAAmDp9C,KAAK,CAACtB,QAAD,CAAxD,EAAoEuhB,SAApE,EAA+E,KAA/E,CAAvB;IACA77B,SAAS,IACLkvD,4BAA4B,CAACphD,KAAK,CAAC+I,IAAP,EAAahJ,KAAb,EAAoB/D,QAApB,EAA8Bqa,eAAe,KAAK,CAAlD,EAAqDie,MAArD,EAA6Du1B,EAA7D,EAAiEG,EAAjE,EAAqEG,EAArE,EAAyEG,EAAzE,EAA6EG,EAA7E,EAAiFG,EAAjF,EAAqFG,EAArF,EAAyFpB,MAAzF,CADhC;EAEH;;EACD,OAAO6G,sBAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,sBAAT,CAAgCz0D,QAAhC,EAA0CD,MAA1C,EAAkDgyB,SAAlD,EAA6D;EACzD,MAAMjgB,KAAK,GAAGmH,QAAQ,EAAtB;EACA,MAAMi2C,iBAAiB,GAAG3B,cAAc,CAACz7C,KAAD,EAAQ/R,MAAR,CAAxC;;EACA,IAAImvD,iBAAiB,KAAKpqB,SAA1B,EAAqC;IACjC,MAAM9gC,KAAK,GAAGkV,QAAQ,EAAtB;IACA,MAAMnV,KAAK,GAAGiZ,gBAAgB,EAA9B;IACA6jC,uBAAuB,CAAC78C,KAAD,EAAQD,KAAR,EAAe+N,KAAf,EAAsB9R,QAAtB,EAAgCkvD,iBAAhC,EAAmDp9C,KAAK,CAACtB,QAAD,CAAxD,EAAoEuhB,SAApE,EAA+E,KAA/E,CAAvB;;IACA,IAAI77B,SAAJ,EAAe;MACX,MAAM05D,sBAAsB,GAAG,CAAC7vD,MAAM,CAAC,CAAD,CAAP,CAA/B,CADW,CACiC;;MAC5C,KAAK,IAAIhE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGgE,MAAM,CAACxM,MAA3B,EAAmCwI,CAAC,IAAI,CAAxC,EAA2C;QACvC6zD,sBAAsB,CAAC18D,IAAvB,CAA4B6M,MAAM,CAAChE,CAAD,CAAlC;MACH;;MACDqpD,4BAA4B,CAACphD,KAAK,CAAC+I,IAAP,EAAahJ,KAAb,EAAoB/D,QAApB,EAA8Bqa,eAAe,KAAKu1C,sBAAsB,CAACr8D,MAA3C,GAAoD,CAAlF,EAAqF,GAAGq8D,sBAAxF,CAA5B;IACH;EACJ;;EACD,OAAO6E,sBAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIC,mEAAJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,qBAAT,CAA+Bz5C,KAA/B,EAAsCnX,KAAtC,EAA6C6wD,qBAA7C,EAAoEnhE,KAApE,EAA2EohE,aAA3E,EAA0FC,cA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SAAjB,EAA4B;IACxBqwC,YAAY,GAAIj9B,KAAK,CAACgzC,eAAN,GAAwB0e,QAA5B,GAAyC1xD,KAAK,CAAC8yC,cAAN,GAAuB4e,QAA5E;EACH;;EACD,OAAOuD,UAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASO,0BAAT,CAAoCr+C,KAApC,EAA2CnX,KAA3C,EAAkDi9B,YAAlD,EAAgE;EAC5D,MAAM2W,QAAQ,GAAG3W,YAAY,GAAGj9B,KAAK,CAACizC,aAAT,GAAyBjzC,KAAK,CAACkzC,aAA5D;;EACA,IAAInD,oBAAoB,CAAC6D,QAAD,CAApB,KAAmC,CAAvC,EAA0C;IACtC;IACA,OAAOhnD,SAAP;EACH;;EACD,OAAOuqB,KAAK,CAACu4B,oBAAoB,CAACkE,QAAD,CAArB,CAAZ;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS6hB,0BAAT,CAAoCt+C,KAApC,EAA2CnX,KAA3C,EAAkDi9B,YAAlD,EAAgEm0B,WAAhE,EAA6E;EACzE,MAAMxd,QAAQ,GAAG3W,YAAY,GAAGj9B,KAAK,CAACizC,aAAT,GAAyBjzC,KAAK,CAACkzC,aAA5D;EACA/gD,SAAS,IACL0E,cAAc,CAACk5C,oBAAoB,CAAC6D,QAAD,CAArB,EAAiC,CAAjC,EAAoC,0DAApC,CADlB;EAEAz8B,KAAK,CAACu4B,oBAAoB,CAACkE,QAAD,CAArB,CAAL,GAAwCwd,WAAxC;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASsE,eAAT,CAAyBv+C,KAAzB,EAAgCnX,KAAhC,EAAuCi9B,YAAv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8E,0BAAN,CAAiC;;AAEjCA,0BAA0B,CAAClkC,IAA3B,GAAoC,eAAe,IAAIgkC,6BAAJ,EAAnD;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMG,aAAN,CAAoB;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,iBAAN,CAAwB;AAGxB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,cAAN,CAAqB;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,kBAAN,CAAyB;AAGzB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,gBAAT,GAA4B;EACxB,OAAOC,gBAAgB,CAAC52D,eAAe,EAAhB,EAAoBN,QAAQ,EAA5B,CAAvB;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASk3D,gBAAT,CAA0BpsE,KAA1B,EAAiC+N,KAAjC,EAAwC;EACpC,OAAO,IAAIs+D,UAAJ,CAAel5D,gBAAgB,CAACnT,KAAD,EAAQ+N,KAAR,CAA/B,CAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMs+D,UAAN,CAAiB;EACbniF,WAAW,CAACgB,aAAD,EAAgB;IACvB,KAAKA,aAAL,GAAqBA,aAArB;EACH;;AAHY;AAKjB;AACA;AACA;AACA;;;AACAmhF,UAAU,CAACjlE,iBAAX,GAA+B+kE,gBAA/B;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASG,gBAAT,CAA0Bl4E,KAA1B,EAAiC;EAC7B,OAAOA,KAAK,YAAYi4E,UAAjB,GAA8Bj4E,KAAK,CAAClJ,aAApC,GAAoDkJ,KAA3D;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMm4E,oBAAoB,GAAG,IA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;MACJ;;MACD,KAAKk+E,wBAAL,GAAgC,KAAhC;IACH;;IACD30C,YAAY,CAAC,KAAKlW,MAAL,CAAYhX,KAAZ,CAAD,EAAqB,KAAKgX,MAA1B,CAAZ;EACH;;EACD3X,SAAS,CAACg7B,QAAD,EAAW;IAChBwV,uBAAuB,CAAC,KAAK74B,MAAL,CAAYhX,KAAZ,CAAD,EAAqB,KAAKgX,MAA1B,EAAkC,IAAlC,EAAwCqjB,QAAxC,CAAvB;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACI2nC,YAAY,GAAG;IACXztB,aAAa,CAAC,KAAKotB,mBAAL,IAA4B,KAAK3qD,MAAlC,CAAb;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIirD,MAAM,GAAG;IACL,KAAKjrD,MAAL,CAAY/W,KAAZ,KAAsB,CAAC;IAAG;IAA1B;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIiiE,QAAQ,GAAG;IACP,KAAKlrD,MAAL,CAAY/W,KAAZ,KAAsB;IAAG;IAAzB;EACH;EACD;AACJ;A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"},"metadata":{},"sourceType":"module"}